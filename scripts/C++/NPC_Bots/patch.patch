diff --git a/src/server/game/Accounts/RBAC.h b/src/server/game/Accounts/RBAC.h
index 9ce1f9b..33e065c 100644
--- a/src/server/game/Accounts/RBAC.h
+++ b/src/server/game/Accounts/RBAC.h
@@ -683,6 +683,19 @@ enum RBACPermissions
     RBAC_PERM_COMMAND_MAILBOX                                = 777,
 
     // custom permissions 1000+
+
+    //NpcBot command permissions
+    RBAC_PERM_COMMAND_NPCBOT                                 = 1000,
+    RBAC_PERM_COMMAND_NPCBOT_ADD                             = 1001,
+    RBAC_PERM_COMMAND_NPCBOT_REMOVE                          = 1002,
+    RBAC_PERM_COMMAND_NPCBOT_RESET                           = 1003,
+    RBAC_PERM_COMMAND_NPCBOT_CMD                             = 1004,
+    RBAC_PERM_COMMAND_NPCBOT_DIST                            = 1005,
+    RBAC_PERM_COMMAND_NPCBOT_INFO                            = 1006,
+    RBAC_PERM_COMMAND_NPCBOT_HELPER                          = 1007,
+    RBAC_PERM_COMMAND_NPCBOT_REVIVE                          = 1008,
+    //end NpcBot
+
     RBAC_PERM_MAX
 };
 
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
index bf46c1f..ad3e4e4 100644
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -130,6 +130,7 @@ include_directories(
   ${CMAKE_CURRENT_SOURCE_DIR}/Addons
   ${CMAKE_CURRENT_SOURCE_DIR}/AI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/CoreAI
+  ${CMAKE_CURRENT_SOURCE_DIR}/AI/NpcBots
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/ScriptedAI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/SmartScripts
   ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse
diff --git a/src/server/game/Entities/Creature/Creature.cpp b/src/server/game/Entities/Creature/Creature.cpp
index 9052791..b4f6dc5 100644
--- a/src/server/game/Entities/Creature/Creature.cpp
+++ b/src/server/game/Entities/Creature/Creature.cpp
@@ -54,6 +54,9 @@
 
 #include "Transport.h"
 
+// npcbot
+#include "bot_ai.h"
+
 TrainerSpell const* TrainerSpellData::Find(uint32 spell_id) const
 {
     TrainerSpellMap::const_iterator itr = spellList.find(spell_id);
@@ -166,6 +169,15 @@ m_originalEntry(0), m_homePosition(), m_transportHomePosition(), m_creatureInfo(
     TriggerJustRespawned = false;
     m_isTempWorldObject = false;
     _focusSpell = NULL;
+
+    //bot
+    m_bot_owner = NULL;
+    m_creature_owner = NULL;
+    m_bots_pet = NULL;
+    m_bot_class = CLASS_NONE;
+    bot_AI = NULL;
+    m_canUpdate = true;
+    //end bot
 }
 
 Creature::~Creature()
@@ -234,6 +246,8 @@ void Creature::RemoveCorpse(bool setSpawnTime)
 {
     if (getDeathState() != CORPSE)
         return;
+    if (bot_AI)
+        return;
 
     m_corpseRemoveTime = time(NULL);
     setDeathState(DEAD);
@@ -441,6 +455,11 @@ bool Creature::UpdateEntry(uint32 entry, CreatureData const* data /*= nullptr*/)
 
 void Creature::Update(uint32 diff)
 {
+    //npcbot: update helper
+    if (!m_canUpdate && bot_AI)
+        return;
+    //end npcbot
+
     if (IsAIEnabled && TriggerJustRespawned)
     {
         TriggerJustRespawned = false;
@@ -1268,6 +1287,11 @@ void Creature::SetCanDualWield(bool value)
 
 void Creature::LoadEquipment(int8 id, bool force /*= true*/)
 {
+    //npcbot: prevent loading equipment for bots
+    if (GetEntry() >= BOT_ENTRY_BEGIN && GetEntry() <= BOT_ENTRY_END) //temp hack
+        return;
+    //end npcbot
+
     if (id == 0)
     {
         if (force)
@@ -2128,6 +2152,9 @@ void Creature::SetInCombatWithZone()
 
 uint32 Creature::GetShieldBlockValue() const                  //dunno mob block value
 {
+    if (bot_AI)
+        return bot_AI->GetShieldBlockValue();
+
     return (getLevel()/2 + uint32(GetStat(STAT_STRENGTH)/20));
 }
 
@@ -2704,3 +2731,169 @@ void Creature::ReleaseFocus(Spell const* focusSpell)
         ClearUnitState(UNIT_STATE_ROTATING);
 }
 
+uint8 Creature::GetBotClass() const
+{
+    switch (m_bot_class)
+    {
+        case DRUID_BEAR_FORM:
+        case DRUID_CAT_FORM:
+        //case TRAVEL:
+        //case FLY:
+            return CLASS_DRUID;
+        default:
+            return m_bot_class;
+    }
+}
+
+void Creature::SetIAmABot(bool bot)
+{
+    if (!bot)
+    {
+        bot_AI->UnsummonAll();
+        IsAIEnabled = false;
+        bot_AI = NULL;
+        SetUInt64Value(UNIT_FIELD_CREATEDBY, 0);
+    }
+}
+
+void Creature::SetBotsPetDied()
+{
+    if (!m_bots_pet)
+        return;
+
+    m_bots_pet->SetCharmerGUID(0);
+    m_bots_pet->SetCreatureOwner(NULL);
+    //m_bots_pet->GetBotPetAI()->SetCreatureOwner(NULL);
+    m_bots_pet->SetIAmABot(false);
+    m_bot_owner->SetMinion((Minion*)m_bots_pet, false);
+    m_bots_pet->CleanupsBeforeDelete();
+    m_bots_pet->AddObjectToRemoveList();
+    m_bots_pet = NULL;
+}
+
+uint8 Creature::GetBotRoles() const
+{
+    return bot_AI ? bot_AI->GetBotRoles() : 0;
+}
+
+void Creature::SetBotCommandState(CommandStates st, bool force)
+{
+    if (bot_AI && IsAIEnabled)
+        bot_AI->SetBotCommandState(st, force);
+}
+CommandStates Creature::GetBotCommandState() const
+{
+    return bot_AI ? bot_AI->GetBotCommandState() : COMMAND_ABANDON;
+}
+//Bot damage mods
+void Creature::ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierMelee(damage, damageinfo);
+}
+void Creature::ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierMelee(damage, damageinfo, spellInfo, attackType, crit);
+}
+void Creature::ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierSpell(damage, damageinfo, spellInfo, attackType, crit);
+}
+
+void Creature::ApplyBotDamageMultiplierEffect(SpellInfo const* spellInfo, uint8 effect_index, float &value) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierEffect(spellInfo, effect_index, value);
+}
+
+bool Creature::GetIAmABot() const
+{
+    return bot_AI && bot_AI->IsMinionAI();
+}
+
+bool Creature::GetIAmABotsPet() const
+{
+    return bot_AI && bot_AI->IsPetAI();
+}
+
+bot_minion_ai* Creature::GetBotMinionAI() const
+{
+    return IsAIEnabled && bot_AI && bot_AI->IsMinionAI() ? const_cast<bot_minion_ai*>(bot_AI->GetMinionAI()) : NULL;
+}
+
+bot_pet_ai* Creature::GetBotPetAI() const
+{
+    return IsAIEnabled && bot_AI && bot_AI->IsPetAI() ? const_cast<bot_pet_ai*>(bot_AI->GetPetAI()) : NULL;
+}
+
+void Creature::InitBotAI(bool asPet)
+{
+    ASSERT(!bot_AI);
+
+    if (asPet)
+        bot_AI = (bot_pet_ai*)AI();
+    else
+        bot_AI = (bot_minion_ai*)AI();
+}
+
+void Creature::SetBotShouldUpdateStats()
+{
+    if (bot_AI)
+        bot_AI->SetShouldUpdateStats();
+}
+
+void Creature::OnBotSummon(Creature* summon)
+{
+    if (bot_AI)
+        bot_AI->OnBotSummon(summon);
+}
+
+void Creature::OnBotDespawn(Creature* summon)
+{
+    if (bot_AI)
+        bot_AI->OnBotDespawn(summon);
+}
+
+void Creature::RemoveBotItemBonuses(uint8 slot)
+{
+    if (bot_AI)
+        bot_AI->RemoveItemBonuses(slot);
+}
+void Creature::ApplyBotItemBonuses(uint8 slot)
+{
+    if (bot_AI)
+        bot_AI->ApplyItemBonuses(slot);
+}
+bool Creature::CanUseOffHand() const
+{
+    return bot_AI && bot_AI->CanUseOffHand();
+}
+bool Creature::CanUseRanged() const
+{
+    return bot_AI && bot_AI->CanUseRanged();
+}
+bool Creature::CanEquip(ItemTemplate const* item, uint8 slot) const
+{
+    return bot_AI && bot_AI->CanEquip(item, slot);
+}
+bool Creature::Unequip(uint8 slot) const
+{
+    return bot_AI && bot_AI->Unequip(slot);
+}
+bool Creature::Equip(uint32 itemId, uint8 slot) const
+{
+    return bot_AI && bot_AI->Equip(itemId, slot);
+}
+bool Creature::ResetEquipment(uint8 slot) const
+{
+    return bot_AI && bot_AI->ResetEquipment(slot);
+}
+
+bool Creature::IsQuestBot() const
+{
+    return
+        m_creatureInfo->Entry >= 71000 && m_creatureInfo->Entry < 72000 &&
+        (m_creatureInfo->unit_flags2 & UNIT_FLAG2_ALLOW_ENEMY_INTERACT);
+}
diff --git a/src/server/game/Entities/Creature/Creature.h b/src/server/game/Entities/Creature/Creature.h
index 9cc08e3..c164283 100644
--- a/src/server/game/Entities/Creature/Creature.h
+++ b/src/server/game/Entities/Creature/Creature.h
@@ -37,6 +37,11 @@ class Player;
 class SpellInfo;
 class WorldSession;
 
+// npcbot
+class bot_ai;
+class bot_minion_ai;
+class bot_pet_ai;
+
 enum CreatureFlagsExtra
 {
     CREATURE_FLAG_EXTRA_INSTANCE_BIND   = 0x00000001,       // creature kill bind instance with killer and killer's group
@@ -677,6 +682,46 @@ class Creature : public Unit, public GridObject<Creature>, public MapObject
         void FocusTarget(Spell const* focusSpell, WorldObject const* target);
         void ReleaseFocus(Spell const* focusSpell);
 
+        //Bot commands
+        Player* GetBotOwner() const { return m_bot_owner; }
+        void SetBotOwner(Player* newowner) { m_bot_owner = newowner; }
+        Creature* GetCreatureOwner() const { return m_creature_owner; }
+        void SetCreatureOwner(Creature* newCreOwner) { m_creature_owner = newCreOwner; }
+        Creature* GetBotsPet() const { return m_bots_pet; }
+        void SetBotsPetDied();
+        void SetBotsPet(Creature* newpet) { /*ASSERT (!m_bots_pet);*/ m_bots_pet = newpet; }
+        void SetIAmABot(bool bot = true);
+        bool GetIAmABot() const;
+        bool GetIAmABotsPet() const;
+        void SetBotClass(uint8 myclass) { m_bot_class = myclass; }
+        uint8 GetBotClass() const;
+        uint8 GetBotRoles() const;
+        bot_ai* GetBotAI() const { return bot_AI; }
+        bot_minion_ai* GetBotMinionAI() const;
+        bot_pet_ai* GetBotPetAI() const;
+        void InitBotAI(bool asPet = false);
+        void SetBotCommandState(CommandStates st, bool force = false);
+        CommandStates GetBotCommandState() const;
+        void ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const;
+        void ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
+        void ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
+        void ApplyBotDamageMultiplierEffect(SpellInfo const* spellInfo, uint8 effect_index, float &value) const;
+        void SetBotShouldUpdateStats();
+        void OnBotSummon(Creature* summon);
+        void OnBotDespawn(Creature* summon);
+        void SetCanUpdate(bool can) { m_canUpdate = can; }
+        void RemoveBotItemBonuses(uint8 slot);
+        void ApplyBotItemBonuses(uint8 slot);
+        bool CanUseOffHand() const;
+        bool CanUseRanged() const;
+        bool CanEquip(ItemTemplate const* item, uint8 slot) const;
+        bool Unequip(uint8 slot) const;
+        bool Equip(uint32 itemId, uint8 slot) const;
+        bool ResetEquipment(uint8 slot) const;
+        //advanced
+        bool IsQuestBot() const;
+        //End Bot commands
+
     protected:
         bool CreateFromProto(uint32 guidlow, uint32 entry, CreatureData const* data = nullptr, uint32 vehId = 0);
         bool InitEntry(uint32 entry, CreatureData const* data = nullptr);
@@ -727,6 +772,15 @@ class Creature : public Unit, public GridObject<Creature>, public MapObject
         bool CanAlwaysSee(WorldObject const* obj) const;
 
     private:
+        //bot system
+        Player* m_bot_owner;
+        Creature* m_creature_owner;
+        Creature* m_bots_pet;
+        bot_ai* bot_AI;
+        uint8 m_bot_class;
+        bool m_canUpdate;
+        //end bot system
+
         void ForcedDespawn(uint32 timeMSToDespawn = 0);
 
         //WaypointMovementGenerator vars
diff --git a/src/server/game/Entities/Creature/TemporarySummon.cpp b/src/server/game/Entities/Creature/TemporarySummon.cpp
index d31117c..fb8ed9c 100644
--- a/src/server/game/Entities/Creature/TemporarySummon.cpp
+++ b/src/server/game/Entities/Creature/TemporarySummon.cpp
@@ -253,6 +253,14 @@ void TempSummon::UnSummon(uint32 msTime)
     if (owner && owner->GetTypeId() == TYPEID_UNIT && owner->ToCreature()->IsAIEnabled)
         owner->ToCreature()->AI()->SummonedCreatureDespawn(this);
 
+    //npcbot
+    if (GetIAmABot() || GetIAmABotsPet())
+    {
+        //TC_LOG_ERROR("TempSummon::UnSummon(): Trying to unsummon Bot %s(owner: %s). Aborted", GetName(), GetBotOwner()->GetName());
+        return;
+    }
+    //end npcbots
+
     AddObjectToRemoveList();
 }
 
diff --git a/src/server/game/Entities/Object/Object.cpp b/src/server/game/Entities/Object/Object.cpp
index f2215fa..8bccaee 100644
--- a/src/server/game/Entities/Object/Object.cpp
+++ b/src/server/game/Entities/Object/Object.cpp
@@ -2187,6 +2187,11 @@ TempSummon* Map::SummonCreature(uint32 entry, Position const& pos, SummonPropert
             summon = new Puppet(properties, summoner);
             break;
         case UNIT_MASK_TOTEM:
+            //npcbot: totem emul step 1
+            if (summoner && summoner->GetTypeId() == TYPEID_UNIT && summoner->ToCreature()->GetIAmABot())
+                summon = new Totem(properties, summoner->ToCreature()->GetBotOwner());
+            else
+            //end npcbot
             summon = new Totem(properties, summoner);
             break;
         case UNIT_MASK_MINION:
@@ -2208,6 +2213,12 @@ TempSummon* Map::SummonCreature(uint32 entry, Position const& pos, SummonPropert
     AddToMap(summon->ToCreature());
     summon->InitSummon();
 
+    //npcbot: totem emul step 2
+    if (mask == UNIT_MASK_TOTEM)
+        if (summoner && summoner->GetTypeId() == TYPEID_UNIT && summoner->ToCreature()->GetIAmABot())
+            summoner->ToCreature()->OnBotSummon(summon);
+    //end npcbot
+
     //ObjectAccessor::UpdateObjectVisibility(summon);
 
     return summon;
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index fdb0b52..f540188 100644
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -79,6 +79,10 @@
 #include "WorldSession.h"
 #include "GameObjectAI.h"
 
+//Bot
+#include "Config.h"
+#include "bothelper.h"
+
 #define ZONE_UPDATE_INTERVAL (1*IN_MILLISECONDS)
 
 #define PLAYER_SKILL_INDEX(x)       (PLAYER_SKILL_INFO_1_1 + ((x)*3))
@@ -529,6 +533,18 @@ inline void KillRewarder::_RewardXP(Player* player, float rate)
         for (Unit::AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
             AddPct(xp, (*i)->GetAmount());
 
+        //npcbot 4.2.2.1. Apply NpcBot XP reduction
+        if (player->HaveBot() && player->GetNpcBotsCount() > 1)
+        {
+            if (uint8 xp_rate = player->GetNpcBotXpReduction())
+            {
+                int32 ratePct = 100 - (player->GetNpcBotsCount() - 1) * xp_rate;
+                ratePct = std::max<int32>(ratePct, 10); // minimum
+                //ratePct = std::min<int32>(ratePct, 100); // maximum // dead code
+                xp = xp * ratePct / 100;
+            }
+        }
+
         // 4.2.3. Give XP to player.
         player->GiveXP(xp, _victim, _groupRate);
         if (Pet* pet = player->GetPet())
@@ -880,6 +896,28 @@ Player::Player(WorldSession* session): Unit(true)
     m_timeSyncClient = 0;
     m_timeSyncServer = 0;
 
+    ///////////////////// Bot System ////////////////////////
+    _botHlpr = NULL;
+    m_botTimer = 500;
+    m_botCreateTimer = 500;
+    m_bot = NULL;
+    m_enableNpcBots = sConfigMgr->GetBoolDefault("Bot.EnableNpcBots", true);
+    m_followdist = sConfigMgr->GetIntDefault("Bot.BaseFollowDistance", 30);
+    m_maxNpcBots = std::min<uint8>(sConfigMgr->GetIntDefault("Bot.MaxNpcBots", 1), MAX_NPCBOTS);
+    uint8 maxcbots = sConfigMgr->GetIntDefault("Bot.MaxNpcBotsPerClass", 1);
+    m_maxClassNpcBots = maxcbots > 0 ? maxcbots : MAX_NPCBOTS;
+    m_xpReductionNpcBots = std::min<uint8>(sConfigMgr->GetIntDefault("Bot.XpReductionPercent", 0), 100);
+    m_enableNpcBotsArenas = sConfigMgr->GetBoolDefault("Bot.EnableInArenas", true);
+    m_enableNpcBotsBGs = sConfigMgr->GetBoolDefault("Bot.EnableInBGs", true);
+    m_enableNpcBotsDungeons = sConfigMgr->GetBoolDefault("Bot.EnableInDungeons", true);
+    m_enableNpcBotsRaids = sConfigMgr->GetBoolDefault("Bot.EnableInRaids", true);
+    m_limitNpcBotsDungeons = sConfigMgr->GetBoolDefault("Bot.InstanceLimit.Dungeons", false);
+    m_limitNpcBotsRaids = sConfigMgr->GetBoolDefault("Bot.InstanceLimit.Raids", false);
+    m_NpcBotsCost = sConfigMgr->GetIntDefault("Bot.Cost", 0);
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        m_botmap[i] = new NpcBotMap();
+    ///////////////////// End Bot System ////////////////////////
+
     for (uint8 i = 0; i < MAX_POWERS; ++i)
         m_powerFraction[i] = 0;
 
@@ -934,6 +972,16 @@ Player::~Player()
     delete m_achievementMgr;
     delete m_reputationMgr;
 
+    if (_botHlpr)
+    {
+        delete _botHlpr;
+        _botHlpr = NULL;
+    }
+
+    //Npcbot mod: delete botmap
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        delete m_botmap[i];
+
     sWorld->DecreasePlayerCount();
 }
 
@@ -1853,6 +1901,17 @@ void Player::Update(uint32 p_time)
     //because we don't want player's ghost teleported from graveyard
     if (IsHasDelayedTeleport() && IsAlive())
         TeleportTo(m_teleport_dest, m_teleport_options);
+
+    //NpcBot mod: Update
+    if (m_botTimer > 0)
+    {
+        if (p_time >= m_botTimer)
+            m_botTimer = 0;
+        else
+            m_botTimer -= p_time;
+    }
+    else
+        RefreshBot(p_time);
 }
 
 void Player::setDeathState(DeathState s)
@@ -2230,6 +2289,13 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
         if (!sMapMgr->CanPlayerEnter(mapid, this, false))
             return false;
 
+        //Npcbot mod: prevent crash on InstanceMap::DestroyInstance()... Unit::RemoveFromWorld()
+        //if last player being kicked out of instance while having npcbots
+        //we must remove creature Before it will be removed in Map::UnloadAll()
+        if (GetMapId() != mapid)
+            for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+                RemoveBot(m_botmap[i]->m_guid);
+
         //I think this always returns true. Correct me if I am wrong.
         // If the map is not created, assume it is possible to enter it.
         // It will be created in the WorldPortAck.
@@ -2463,6 +2529,916 @@ void Player::RemoveFromWorld()
     }
 }
 
+void Player::RefreshBot(uint32 diff)
+{
+    if (m_botTimer > 0)
+        return;
+
+    if (IsInFlight())
+        m_botTimer = 3000;
+
+    if (!HaveBot())
+        return;
+
+    //BOT REVIVE SUPPORT part 2
+    //Revive timer condition (maybe we should check whole party?)
+    bool partyInCombat = IsInCombat();
+    if (!partyInCombat)
+    {
+        for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        {
+            if (Creature* bot = m_botmap[i]->m_creature)
+            {
+                if (bot->IsInCombat())
+                {
+                    partyInCombat = true;
+                    break;
+                }
+                else if (Creature* pet = bot->GetBotsPet())
+                {
+                    if (pet->IsInCombat())
+                    {
+                        partyInCombat = true;
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+    {
+        uint64 guid = m_botmap[i]->m_guid;
+        m_bot = m_botmap[i]->m_creature;
+
+        //BOT REVIVE SUPPORT part 2
+        //Do not allow bot to be revived if master is in battle
+        if (!partyInCombat)
+        {
+            if (m_botmap[i]->m_reviveTimer > diff)
+            {
+                if (!IsInCombat())
+                    m_botmap[i]->m_reviveTimer -= diff;
+            }
+            else if (m_botmap[i]->m_reviveTimer > 0)
+                m_botmap[i]->m_reviveTimer = 0;
+        }
+
+        if (!m_bot || !m_bot->IsInWorld())
+            continue;
+
+        //!!!BOT UPDATE HELPER!!!
+        m_bot->SetCanUpdate(true);
+        m_bot->IsAIEnabled = true;
+
+        //BOT REVIVE SUPPORT part 3
+        //Revive bot if possible
+        if (m_botmap[i]->m_reviveTimer == 0)
+        {
+            if (m_bot->isDead() && IsAlive() && !IsInCombat() && !InArena() && !IsInFlight() &&
+                !HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_FEIGN_DEATH) &&
+                !HasInvisibilityAura() && !HasStealthAura())
+            {
+                CreateBot(0, 0, 0, true); //revive
+                continue;
+            }
+
+            //delay next attempt
+            m_botmap[i]->m_reviveTimer = 500;
+        }
+
+        //BOT MUST DIE SUPPORT
+        if (IsInFlight() || !GetGroup() || !GetGroup()->IsMember(m_bot->GetGUID()))//even if bot is dead
+        {
+            RemoveBot(guid, !IsInFlight());
+            continue;
+        }
+
+        //TELEPORT SUPPORT
+        if (!IsInFlight() && IsAlive() && (m_bot->IsAlive() || m_bot->GetMapId() != GetMapId() || RestrictBots()))
+        {
+            if (m_bot->GetMapId() != GetMapId() || RestrictBots())
+            {
+                RemoveBot(guid);
+                continue;
+            }
+            else if (m_bot->GetBotCommandState() != COMMAND_STAY)
+            {
+                if (GetDistance(m_bot) > SIZE_OF_GRIDS)
+                {
+                    ////This thing is not confirmed to be stable
+                    //m_bot->SetOwnerGUID(0);
+                    //m_bot->RemoveFromWorld();
+                    //m_bot->Relocate(this);
+                    ////Creature::AddToWorld(): Skip AIM_Initialize();
+                    //if (m_bot->GetZoneScript())
+                    //    m_bot->GetZoneScript()->OnCreatureCreate(m_bot);
+                    //sObjectAccessor->AddObject(m_bot);
+                    //m_bot->ToUnit()->AddToWorld();
+                    //m_bot->SetOwnerGUID(GetGUID());
+
+                    //This thing is unsafe
+                    m_bot->SetBotsPetDied();
+                    m_bot->OnBotDespawn(NULL);
+                    m_bot->InterruptNonMeleeSpells(true);
+                    m_bot->AttackStop();
+                    m_bot->RemoveAllAttackers();
+                    m_bot->DeleteThreatList();
+                    m_bot->ClearInCombat();
+
+                    m_bot->RemoveNotOwnSingleTargetAuras();
+                    //m_bot->RemoveAllGameObjects();
+                    //m_bot->RemoveAllDynObjects();
+                    //m_bot->ExitVehicle();
+                    //m_bot->UnsummonAllTotems();
+                    //m_bot->RemoveAllControlled();
+                    m_bot->RemoveAreaAurasDueToLeaveWorld();
+                    m_bot->DestroyForNearbyPlayers();
+                    m_bot->ClearUpdateMask(true);
+                    //sObjectAccessor->RemoveObject(m_bot);
+                    m_bot->Relocate(this);
+                    //sObjectAccessor->AddObject(m_bot);
+                    m_bot->ToUnit()->AddToWorld();
+                }
+            }
+        }
+
+        //Update bots manually and prevent from normal updates
+        //This will update bot's AI
+        m_bot->Update(diff);
+        m_bot->SetCanUpdate(false);
+
+        //Update bot's pet manually and prevent from normal updates
+        //This will update pet's AI
+        if (Creature* pet = m_bot->GetBotsPet())
+        {
+            pet->SetCanUpdate(true);
+            pet->IsAIEnabled = true;
+            pet->Update(diff);
+            pet->SetCanUpdate(false);
+        }
+
+        m_bot = NULL;
+    }//end for botmap
+
+    //BOT CREATION/RECREATION SUPPORT
+    if (m_botCreateTimer > diff)
+        m_botCreateTimer -= diff;
+    else
+    {
+        m_botCreateTimer = 250;
+
+        if (!IsInFlight() && IsAlive() && !IsInCombat() && GetBotMustBeCreated() && !RestrictBots())
+            for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+                if (m_botmap[pos]->m_entry != 0 && m_botmap[pos]->m_guid == 0)
+                    CreateBot(m_botmap[pos]->m_entry, m_botmap[pos]->m_race, m_botmap[pos]->m_class);
+    }
+}
+
+void Player::SetBotMustBeCreated(uint32 m_entry, uint8 m_race, uint8 m_class, uint32 *equips)
+{
+    if (m_enableNpcBots == false)
+    {
+        ChatHandler ch(GetSession());
+        ch.SendSysMessage("NpcBot system currently disabled. Please contact your administration.");
+        ClearBotMustBeCreated(0, 0, true);
+        return;
+    }
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if (m_botmap[pos]->m_entry == 0)
+        {
+            m_botmap[pos]->m_guid = 0;//we need it to make sure Player::CreateBot will find this slot
+            m_botmap[pos]->m_entry = m_entry;
+            m_botmap[pos]->m_race = m_race;
+            m_botmap[pos]->m_class = m_class;
+
+            for (uint8 i = 0; i != 18; ++i)
+                m_botmap[pos]->equips[i] = equips[i];
+
+            break;
+        }
+    }
+}
+
+bool Player::GetBotMustBeCreated()
+{
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if (m_botmap[pos]->m_entry != 0 &&
+            (m_botmap[pos]->m_guid == 0 || !sObjectAccessor->FindUnit(m_botmap[pos]->m_guid)))
+        {
+            m_botmap[pos]->m_guid = 0;
+            return true;
+        }
+    }
+    return false;
+}
+
+void Player::ClearBotMustBeCreated(uint64 guidOrSlot, bool guid, bool fully)
+{
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if ((guid == true && m_botmap[pos]->m_guid == guidOrSlot) ||
+            (guid == false && pos == guidOrSlot) ||
+            fully)
+        {
+            m_botmap[pos]->m_guid = 0;
+            m_botmap[pos]->m_entry = 0;
+            m_botmap[pos]->m_race = 0;
+            m_botmap[pos]->m_class = 0;
+            m_botmap[pos]->m_creature = NULL;
+
+            for (uint8 i = 0; i != 18; ++i)
+                m_botmap[pos]->equips[i] = 0;
+
+            if (!fully)
+                break;
+        }
+    }
+}
+
+void Player::RemoveBot(uint64 guid, bool final, bool eraseFromDB)
+{
+    if (guid == 0) return;
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+    {
+        if (m_botmap[i]->m_guid == guid)
+        {
+            m_bot = m_botmap[i]->m_creature;
+            break;
+        }
+    }
+    if (!m_bot)
+        m_bot = sObjectAccessor->GetObjectInWorld(guid, (Creature*)NULL);
+    if (m_bot)
+    {
+        //do not disband group unless not in dungeon or forced or on logout (Check WorldSession::LogoutPlayer())
+        Group* gr = GetGroup();
+        if (gr && gr->IsMember(guid))
+        {
+            if (gr->GetMembersCount() > 2 || /*!GetMap()->Instanceable() || */(final && eraseFromDB))
+                gr->RemoveMember(guid);
+            else //just cleanup
+            {
+                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GROUP_MEMBER);
+                stmt->setUInt32(0, GUID_LOPART(guid));
+                CharacterDatabase.Execute(stmt);
+            }
+        }
+
+        m_bot->SetBotsPetDied();
+        m_bot->OnBotDespawn(NULL);
+        m_bot->SetCharmerGUID(0);
+        //m_bot->SetBotOwner(NULL);
+        m_bot->SetIAmABot(false);
+        SetMinion((Minion*)m_bot, false);
+        m_bot->CleanupsBeforeDelete();
+        m_bot->AddObjectToRemoveList();
+
+        if (final)//on logout or by command
+        {
+            ClearBotMustBeCreated(guid);
+            if (eraseFromDB)//by command
+            {
+                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_ACTIVE);
+                stmt->setUInt8(0, uint8(0));
+                stmt->setUInt32(1, GetGUIDLow());
+                stmt->setUInt32(2, m_bot->GetEntry());
+                CharacterDatabase.Execute(stmt);
+                //CharacterDatabase.PExecute("DELETE FROM `character_npcbot` WHERE `owner` = '%u' AND `entry` = '%u'", GetGUIDLow(), m_bot->GetEntry());
+            }
+        }
+        else
+        {
+            ModifyMoney(int64(GetNpcBotCost())); //temp restore money before retake
+
+            for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            {
+                if (m_botmap[pos]->m_guid == guid)
+                {
+                    m_botmap[pos]->m_guid = 0;//reset guid so it can be set during recreation
+                    m_botmap[pos]->m_creature = NULL;
+                }
+            }
+        }
+        m_bot = NULL;
+    }
+}
+
+void Player::CreateBot(uint32 botentry, uint8 botrace, uint8 botclass, bool revive)
+{
+    if (IsBeingTeleported() || IsInFlight()) return; //don't create bot yet
+    if (isDead() && !revive) return; //not to revive by command so abort
+    if (IsInCombat()) return;
+
+    if (m_bot != NULL && revive)
+    {
+        m_bot->SetHealth(m_bot->GetCreateHealth() / 6);//~15% of base health
+        if (m_bot->getPowerType() == POWER_MANA)
+            m_bot->SetPower(POWER_MANA, m_bot->GetCreateMana());
+        SetUInt32Value(UNIT_NPC_FLAGS, m_bot->GetCreatureTemplate()->npcflag);
+        ClearUnitState(uint32(UNIT_STATE_ALL_STATE));
+        m_bot->setDeathState(ALIVE);
+        m_bot->SetBotCommandState(COMMAND_FOLLOW, true);
+        return;
+    }
+    if (m_enableNpcBots == false && revive == false)
+    {
+        ChatHandler ch(GetSession());
+        ch.SendSysMessage("NpcBot system currently disabled. Please contact administration.");
+        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            if (m_botmap[pos]->m_entry == botentry)
+                ClearBotMustBeCreated(pos, false);
+        return;
+    }
+    if (!botentry || !botrace || !botclass)
+    {
+        TC_LOG_ERROR("entities.player", "ERROR! CreateBot(): player %s (%u) trying to create bot with entry = %u, race = %u, class = %u, ignored", GetName().c_str(), GetGUIDLow(), botentry, botrace, botclass);
+        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            if (m_botmap[pos]->m_entry == botentry)
+                ClearBotMustBeCreated(pos, false);
+        return;
+    }
+    //npcbot counter is already increased in SetBotMustBeCreated()
+    if (GetNpcBotsCount() > GetMaxNpcBots())
+    {
+        ChatHandler ch(GetSession());
+        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            if (m_botmap[pos]->m_entry == botentry)
+                ClearBotMustBeCreated(pos, false);
+        ch.PSendSysMessage("Youre exceed max npcbots");
+        ch.SetSentErrorMessage(true);
+        return;
+    }
+    //instance limit check
+    if ((m_limitNpcBotsDungeons && GetMap()->IsNonRaidDungeon()) || (m_limitNpcBotsRaids && GetMap()->IsRaid()))
+    {
+        InstanceMap* map = (InstanceMap*)GetMap();
+        uint32 count = 0;
+        Map::PlayerList const& plMap = map->GetPlayers();
+        for (Map::PlayerList::const_iterator itr = plMap.begin(); itr != plMap.end(); ++itr)
+            if (Player* player = itr->GetSource())
+                count += (1 + player->GetNpcBotsCount());
+
+        //check "more" cuz current bot is queued and we are to choose to remove it or not
+        if (count > map->GetMaxPlayers())
+        {
+            ChatHandler ch(GetSession());
+            for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+                if (m_botmap[pos]->m_entry == botentry)
+                    ClearBotMustBeCreated(pos, false);
+            ch.PSendSysMessage("Instance players limit exceed");
+            ch.SetSentErrorMessage(true);
+            return;
+        }
+    }
+    if (GetGroup() && GetGroup()->isRaidGroup() && GetGroup()->IsFull())
+    {
+        ChatHandler ch(GetSession());
+        ch.PSendSysMessage("Your group is Full!");
+        ch.SetSentErrorMessage(true);
+        return;
+    }
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+        if (m_botmap[pos]->m_entry == botentry)
+            if (m_botmap[pos]->m_reviveTimer != 0)
+                return;
+
+    m_bot = SummonCreature(botentry, *this);
+
+    //check if we have free slot
+    bool _set = false;
+    uint8 slot = 0;
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if (m_botmap[pos]->m_entry == botentry && m_botmap[pos]->m_guid == 0)
+        {
+            m_botmap[pos]->m_guid = m_bot->GetGUID();
+            m_botmap[pos]->m_creature = m_bot;//this will save some time but we need guid as well
+            slot = pos;
+            _set = true;
+            break;
+        }
+    }
+    if (!_set)
+    {
+        TC_LOG_ERROR("entities.player", "character %s (%u) is failed to create npcbot! Removing all bots", GetName().c_str(), GetGUIDLow());
+
+        m_bot->CombatStop();
+        m_bot->CleanupsBeforeDelete();
+        m_bot->AddObjectToRemoveList();
+        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            RemoveBot(m_botmap[pos]->m_guid, true);
+        ClearBotMustBeCreated(0, false, true);
+        return;
+    }
+
+    m_bot->SetBotOwner(this);
+
+    m_bot->SetUInt64Value(UNIT_FIELD_CREATEDBY, GetGUID());
+    SetMinion((Minion*)m_bot, true);
+    m_bot->CombatStop();
+    m_bot->DeleteThreatList();
+    m_bot->AddUnitTypeMask(UNIT_MASK_MINION);
+
+    m_bot->SetByteValue(UNIT_FIELD_BYTES_0, 0, botrace);
+    m_bot->setFaction(getFaction());
+    m_bot->SetLevel(getLevel());
+    m_bot->SetBotClass(botclass);
+    m_bot->AIM_Initialize();
+    m_bot->InitBotAI();
+    m_bot->SetBotCommandState(COMMAND_FOLLOW, true);
+
+    InitBotEquips(m_bot);
+
+    //entry is unique for each master's bot so clean it up just in case
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_NPCBOT);
+    uint8 i = 0;
+    stmt->setUInt32(i++, GetGUIDLow());
+    stmt->setUInt32(i++, botentry);
+    stmt->setUInt8(i++, botrace);
+    stmt->setUInt8(i++, botclass);
+    stmt->setUInt8(i++, m_bot->GetBotRoles());
+
+    for (uint8 j = 0; j != 18; ++j)
+        stmt->setUInt32(i++, m_botmap[slot]->equips[j]);
+
+    stmt->setUInt8(i++, uint8(1)); //active
+    CharacterDatabase.Execute(stmt);
+
+    //If we have a group, just add bot
+    if (Group* gr = GetGroup())
+    {
+        if (!gr->IsFull())
+        {
+            if (!gr->AddMember((Player*)m_bot))
+                RemoveBot(m_bot->GetGUID(), true);
+        }
+        else if (!gr->isRaidGroup()) //non-raid group is full
+        {
+            gr->ConvertToRaid();
+            if (!gr->AddMember((Player*)m_bot))
+                RemoveBot(m_bot->GetGUID(), true);
+        }
+        else //raid group is full
+            RemoveBot(m_bot->GetGUID(), true);
+    }
+    else
+    {
+        gr = new Group;
+        if (!gr->Create(this))
+        {
+            delete gr;
+            return;
+        }
+        sGroupMgr->AddGroup(gr);
+        if (!gr->AddMember((Player*)m_bot))
+            RemoveBot(m_bot->GetGUID(), true);
+    }
+
+    if (uint32 cost = GetNpcBotCost())
+        ModifyMoney(-(int32(cost)));
+
+    if (Group* gr = GetGroup())
+    {
+        Group::MemberSlotList const a = gr->GetMemberSlots();
+        //try to remove 'absent' bots
+        for (Group::member_citerator itr = a.begin(); itr != a.end(); ++itr)
+        {
+            if (itr->guid == 0)
+                continue;
+            if (IS_PLAYER_GUID(itr->guid))
+                continue;
+            if (!sObjectAccessor->FindUnit(itr->guid))
+                gr->RemoveMember(itr->guid);
+        }
+    }
+} //end Player::CreateBot
+
+uint8 Player::GetNpcBotsCount() const
+{
+    uint8 bots = 0;
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+        if (m_botmap[pos]->m_entry != 0)
+            ++bots;
+    return bots;
+}
+
+uint8 Player::GetMaxNpcBots() const
+{
+    return (GetSession()->GetSecurity() == SEC_PLAYER) ? m_maxNpcBots : MAX_NPCBOTS;
+}
+
+bool Player::HaveBot() const
+{
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        if (m_botmap[i]->m_entry != 0)
+            return true;
+    return false;
+}
+
+void Player::SendBotCommandState(Creature* cre, CommandStates state)
+{
+    if (!cre) return;
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        if (m_botmap[i]->m_creature == cre)
+            cre->SetBotCommandState(state, true);
+}
+//finds bot's slot into master's botmap
+int8 Player::GetNpcBotSlot(uint64 guid) const
+{
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+        if (m_botmap[pos]->m_guid == guid)
+            return pos;
+
+    return -1;
+}
+
+void Player::SetNpcBotDied(uint64 guid)
+{
+    if (!guid) return;
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+        if (m_botmap[pos]->m_guid == guid)
+        {
+            m_botmap[pos]->m_reviveTimer = 15000;
+            break;
+        }
+}
+
+bool Player::RestrictBots() const
+{
+    return
+        (!m_enableNpcBotsBGs && GetMap()->IsBattleground()) ||
+        (!m_enableNpcBotsArenas && GetMap()->IsBattleArena()) ||
+        (!m_enableNpcBotsDungeons && GetMap()->IsNonRaidDungeon()) ||
+        (!m_enableNpcBotsRaids && GetMap()->IsRaid());
+}
+
+uint32 Player::GetNpcBotCost() const
+{
+    return m_NpcBotsCost ? uint32((m_NpcBotsCost / 80.f) * getLevel()) : 0;
+}
+
+std::string Player::GetNpcBotCostStr() const
+{
+    std::ostringstream money;
+
+    if (uint32 cost = GetNpcBotCost())
+    {
+        uint32 gold = uint32(cost / 10000);
+        cost -= (gold * 10000);
+        uint32 silver = uint32(cost / 100);
+        cost -= (silver * 100);
+
+        if (gold != 0)
+            money << gold << " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
+        if (silver != 0)
+            money << silver << " |TInterface\\Icons\\INV_Misc_Coin_03:8|t";
+        if (cost)
+            money << cost << " |TInterface\\Icons\\INV_Misc_Coin_05:8|t";
+    }
+    return money.str();
+}
+
+//NPCbot base setup
+void Player::CreateNPCBot(uint8 bot_class)
+{
+    //check if we have too many bots of that class
+    if (HaveBot())
+    {
+        uint8 count = 0;
+        for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+            if (m_botmap[i]->m_class == bot_class)
+                ++count;
+        if (count >= m_maxClassNpcBots)
+        {
+            //SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, 0, 0, 0);
+            ChatHandler ch(GetSession());
+            ch.PSendSysMessage("You cannot have more bots of that class! %u of %u", count, m_maxClassNpcBots);
+            ch.SetSentErrorMessage(true);
+            return;
+        }
+    }
+
+    //check if player cannot afford a bot
+    if (GetMoney() < GetNpcBotCost())
+    {
+        ChatHandler ch(GetSession());
+        std::string str = "You don't have enough money (";
+        str += GetNpcBotCostStr();
+        str += ")!";
+        ch.SendSysMessage(str.c_str());
+        ch.SetSentErrorMessage(true);
+        return;
+    }
+
+    PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_NPCBOT_TEMPLATE);
+    std::ostringstream classStr;
+
+    switch (bot_class)
+    {
+        case CLASS_ROGUE:
+            classStr << "rogue_bot";        break;
+        case CLASS_PRIEST:
+            classStr << "priest_bot";       break;
+        case CLASS_DRUID:
+            classStr << "druid_bot";        break;
+        case CLASS_SHAMAN:
+            classStr << "shaman_bot";       break;
+        case CLASS_MAGE:
+            classStr << "mage_bot";         break;
+        case CLASS_WARLOCK:
+            classStr << "warlock_bot";      break;
+        case CLASS_WARRIOR:
+            classStr << "warrior_bot";      break;
+        case CLASS_PALADIN:
+            classStr << "paladin_bot";      break;
+        case CLASS_HUNTER:
+            classStr << "hunter_bot";       break;
+        case CLASS_DEATH_KNIGHT:
+            classStr << "death_knight_bot"; break;
+        default:
+            ChatHandler ch(GetSession());
+            ch.PSendSysMessage("ERROR! unknown bot_class %u", bot_class);
+            ch.SetSentErrorMessage(true);
+            TC_LOG_ERROR("entities.player", "Player::CreateNPCBot() player %u(%s) tried to create bot of unknown/unsupported class %u!", GetGUIDLow(), GetName().c_str(), bot_class);
+            return;
+    }
+
+    uint8 index = 0;
+    stmt->setString(index++, classStr.str());
+    stmt->setUInt8(index++, bot_class);
+
+    //maybe we should remove this check? ;Ü
+    switch (getRace())
+    {
+        case RACE_NONE:
+        case RACE_HUMAN:
+        case RACE_DWARF:
+        case RACE_NIGHTELF:
+        case RACE_GNOME:
+        case RACE_DRAENEI:
+            stmt->setUInt8(index++, uint8(1));
+            stmt->setUInt8(index++, uint8(3));
+            stmt->setUInt8(index++, uint8(4));
+            stmt->setUInt8(index++, uint8(7));
+            stmt->setUInt8(index++, uint8(11));
+            break;
+
+        case RACE_ORC:
+        case RACE_UNDEAD_PLAYER:
+        case RACE_TAUREN:
+        case RACE_TROLL:
+        case RACE_BLOODELF:
+            stmt->setUInt8(index++, uint8(2));
+            stmt->setUInt8(index++, uint8(5));
+            stmt->setUInt8(index++, uint8(6));
+            stmt->setUInt8(index++, uint8(8));
+            stmt->setUInt8(index++, uint8(10));
+            break;
+    }
+
+    PreparedQueryResult result = WorldDatabase.Query(stmt);
+    if (!result)
+    {
+        TC_LOG_FATAL("entities.player", "Player::CreateNPCBot() CANNOT create bot of class %u, not found in DB!", bot_class);
+        return;
+    }
+
+    uint32 entry = 0;
+    uint32 bot_race = 0;
+
+    //find a bot to add
+    //first check randomly selected bot, second check any bot we can add
+    typedef std::list< std::pair<uint32, uint8> > NpcBotsDataTemplate;
+    NpcBotsDataTemplate npcBotsData;
+    do
+    {
+        Field* fields = result->Fetch();
+        uint32 temp_entry = fields[0].GetUInt32();
+        uint8 temp_race = fields[1].GetUInt8();
+        npcBotsData.push_back(std::pair<uint32, uint8>(temp_entry, temp_race));
+    }
+    while (result->NextRow());
+
+    uint32 m_rand = urand(1, uint32(result->GetRowCount()));
+    uint32 tmp_rand = 1;
+    std::list< std::pair<uint32, uint8> >::const_iterator itr = npcBotsData.begin();
+    bool haveSameBot = false;
+    bool moveback = false;
+    bool forcedCheck = false;
+    bool secondCheck = false;
+    while (true)
+    {
+        if (itr == npcBotsData.end()) //end of list is reached (selected bot is checked)
+        {
+            moveback = true;
+            --itr; //tmp_rand is not needed anymore
+            continue;
+        }
+        if (moveback && itr == npcBotsData.begin()) //search is finished, nothing found
+            break;
+        if (tmp_rand == m_rand || haveSameBot)
+        {
+            bool canAdd = true;
+            for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+            {
+                if (m_botmap[i]->m_entry == itr->first)
+                {
+                    haveSameBot = true;
+                    canAdd = false;
+                    if (!secondCheck)
+                        forcedCheck = true;
+                    secondCheck = true;
+                    break;
+                }
+            }
+            if (canAdd)
+            {
+                entry = itr->first;
+                bot_race = itr->second;
+                break;
+            }
+            if (forcedCheck)
+            {
+                itr = npcBotsData.begin(); //reset searcher pos
+                forcedCheck = false;
+                continue;
+            }
+        }
+        //move through
+        if (moveback)
+            --itr;
+        else
+        {
+            ++itr;
+            ++tmp_rand;
+        }
+    }
+
+    if (!entry || !bot_race)
+    {
+        ChatHandler ch(GetSession());
+        ch.SendSysMessage("No more bots of this class available");
+        ch.SetSentErrorMessage(true);
+        return;
+    }
+
+    uint32 equips[18];
+    for (uint8 i = 0; i != 18; ++i)
+        equips[i] = 0;
+
+    //"SELECT equipMhEx, equipOhEx, equipRhEx FROM character_npcbot WHERE owner = ? AND entry = ?", CONNECTION_SYNCH
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOT_EQUIP);
+    stmt->setUInt32(0, GetGUIDLow());
+    stmt->setUInt32(1, entry);
+    result = CharacterDatabase.Query(stmt);
+    if (result)
+    {
+        Field* field = result->Fetch();
+        for (uint8 i = 0; i != 18; ++i)
+            equips[i] = field[i].GetUInt32();
+    }
+
+    SetBotMustBeCreated(entry, bot_race, bot_class, equips);
+}
+
+void Player::InitBotEquips(Creature* bot)
+{
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(bot->GetEntry(), id);
+
+    uint8 slot = 0;
+    //Load stored equipment if any
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if (m_botmap[pos]->m_creature == bot)
+        {
+            slot = pos;
+
+            bot->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 0, m_botmap[pos]->equips[0]);
+            bot->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1, m_botmap[pos]->equips[1]);
+            bot->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2, m_botmap[pos]->equips[2]);
+
+            if (uint32 mh = bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 0))
+            {
+                if (!einfo || einfo->ItemEntry[0] != mh)
+                {
+                    if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(mh))
+                    {
+                        bot->SetAttackTime(BASE_ATTACK, proto->Delay);
+                        bot->ApplyBotItemBonuses(0);
+                    }
+                }
+            }
+            if (uint32 oh = bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1))
+            {
+                if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(oh))
+                {
+                    if (!einfo || einfo->ItemEntry[1] != oh)
+                        bot->ApplyBotItemBonuses(1);
+
+                    if (proto->Class == ITEM_CLASS_WEAPON)
+                    {
+                        bot->SetAttackTime(OFF_ATTACK, proto->Delay);
+                        bot->SetCanDualWield(true);
+                    }
+                    else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+                    {
+                        if (bot->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
+                            const_cast<CreatureTemplate*>(bot->GetCreatureTemplate())->flags_extra &= ~CREATURE_FLAG_EXTRA_NO_BLOCK;
+                    }
+                }
+            }
+            if (uint32 rh = bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2))
+            {
+                if (!einfo || einfo->ItemEntry[2] != rh)
+                {
+                    if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(rh))
+                    {
+                        bot->SetAttackTime(RANGED_ATTACK, proto->Delay);
+                        bot->ApplyBotItemBonuses(2);
+                    }
+                }
+            }
+
+            for (uint8 i = 3; i != 18; ++i)
+                bot->ApplyBotItemBonuses(i);
+
+            break;
+        }
+    }
+
+    //Load remaining items as defaults
+    if (einfo)
+    {
+        for (uint8 i = 0; i != MAX_EQUIPMENT_ITEMS; ++i)
+        {
+            if (bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i) == 0 && einfo->ItemEntry[i] != 0)
+            {
+                bot->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i, einfo->ItemEntry[i]);
+                if (i == 1) //off-hand
+                {
+                    if (einfo->ItemEntry[i] != 0 && bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i) == einfo->ItemEntry[i])
+                    {
+                        if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(einfo->ItemEntry[i]))
+                        {
+                            if (proto->Class == ITEM_CLASS_WEAPON)
+                            {
+                                bot->SetAttackTime(OFF_ATTACK, bot->GetBotClass() == CLASS_ROGUE ? 1400 : 1800);
+                                bot->SetCanDualWield(true);
+                            }
+                            else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+                            {
+                                if (bot->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
+                                    const_cast<CreatureTemplate*>(bot->GetCreatureTemplate())->flags_extra &= ~CREATURE_FLAG_EXTRA_NO_BLOCK;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        //while creating new bot he has no equips but equip template so write these to bot map
+        m_botmap[slot]->equips[0] = bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 0);
+        m_botmap[slot]->equips[1] = bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1);
+        m_botmap[slot]->equips[2] = bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2);
+    }
+}
+
+uint32 Player::GetBotEquip(Creature* bot, uint8 slot) const
+{
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+        if (m_botmap[pos]->m_creature == bot)
+            return m_botmap[pos]->equips[slot];
+
+    return 0;
+}
+
+void Player::UpdateBotEquips(Creature* bot, uint8 slot, uint32 itemId)
+{
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if (m_botmap[pos]->m_creature == bot)
+        {
+            m_botmap[pos]->equips[slot] = itemId;
+
+            //Commit to DB
+            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_EQUIP);
+            uint8 i;
+            for (i = 0; i != 18; ++i)
+                stmt->setUInt32(i, m_botmap[pos]->equips[i]);
+
+            stmt->setUInt32(18, GetGUIDLow());
+            stmt->setUInt32(19, m_botmap[pos]->m_entry);
+            CharacterDatabase.Execute(stmt);
+
+            break;
+        }
+    }
+}
+
 void Player::RegenerateAll()
 {
     //if (m_regenTimer <= 500)
@@ -2740,6 +3716,9 @@ Creature* Player::GetNPCIfCanInteractWith(uint64 guid, uint32 npcflagmask)
 
     // not enemy
     if (creature->IsHostileTo(this))
+    //npcbot
+    if (!creature->IsQuestBot())
+    //end npcbot
         return NULL;
 
     // not unfriendly
@@ -2928,6 +3907,26 @@ void Player::RemoveFromGroup(Group* group, uint64 guid, RemoveMethod method /* =
 {
     if (group)
     {
+        if (Player* player = ObjectAccessor::FindPlayer(guid))
+        {
+            if (player->HaveBot())
+            {
+                uint8 players = 0;
+                Group::MemberSlotList const& members = group->GetMemberSlots();
+                for (Group::member_citerator itr = members.begin(); itr!= members.end(); ++itr)
+                {
+                    if (Player* pl = ObjectAccessor::FindPlayer(itr->guid))
+                        ++players;
+                }
+
+                //remove npcbots so group will be disbanded if only 1 player
+                for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+                    player->RemoveBot(player->GetBotMap(i)->m_guid, players <= 1);
+                group = player->GetGroup();
+                if (!group)
+                    return; //group has been disbanded
+            }
+        }
         group->RemoveMember(guid, method, kicker, reason);
         group = NULL;
     }
@@ -4992,6 +5991,13 @@ void Player::DeleteFromDB(uint64 playerguid, uint32 accountId, bool updateRealmC
             stmt->setUInt32(0, guid);
             trans->Append(stmt);
 
+            //npcbot - erase npcbots
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_NPCBOTS);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+            //CharacterDatabase.PExecute("DELETE FROM `character_npcbot` WHERE `owner` = '%u'", guid);
+            //end npcbot
+
             CharacterDatabase.CommitTransaction(trans);
             break;
         }
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index 5267403..9a6aab2 100644
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -53,6 +53,11 @@ class PlayerSocial;
 class SpellCastTargets;
 class UpdateMask;
 
+// NpcBot mod
+struct NpcBotMap;
+#define MAX_NPCBOTS 39
+class BotHelper;
+
 typedef std::deque<Mail*> PlayerMails;
 
 #define PLAYER_MAX_SKILLS           127
@@ -2303,6 +2308,39 @@ class Player : public Unit, public GridObject<Player>
         std::string GetMapAreaAndZoneString();
         std::string GetCoordsMapAreaAndZoneString();
 
+        /*********************************************************/
+        /***                     BOT SYSTEM                    ***/
+        /*********************************************************/
+        void SetBotHelper(BotHelper* hlpr) { ASSERT (!_botHlpr); _botHlpr = hlpr; }
+        BotHelper* GetBotHelper() const { return _botHlpr; }
+        void RefreshBot(uint32 p_time);
+        void CreateBot(uint32 botentry, uint8 botrace, uint8 botclass, bool revive = false);
+        void CreateNPCBot(uint8 botclass);
+        int8 GetNpcBotSlot(uint64 guid) const;
+        void SendBotCommandState(Creature* cre, CommandStates state);
+        bool HaveBot() const;
+        void RemoveBot(uint64 guid, bool final = false, bool eraseFromDB = true);
+        void SetBot(Creature* cre) { m_bot = cre; }
+        uint8 GetNpcBotsCount() const;
+        void SetBotMustBeCreated(uint32 m_entry, uint8 m_race, uint8 m_class, uint32 *equips);
+        void ClearBotMustBeCreated(uint64 value, bool guid = true, bool fully = false);
+        bool GetBotMustBeCreated();
+        uint8 GetBotFollowDist() const { return m_followdist; }
+        void SetBotFollowDist(int8 dist) { m_followdist = dist; }
+        void SetNpcBotDied(uint64 guid);
+        NpcBotMap const* GetBotMap(uint8 pos) const { return m_botmap[pos]; }
+        uint8 GetMaxNpcBots() const;
+        uint8 GetNpcBotXpReduction() const { return m_xpReductionNpcBots; }
+        bool RestrictBots() const;
+        uint32 GetNpcBotCost() const;
+        std::string GetNpcBotCostStr() const;
+        void InitBotEquips(Creature* bot);
+        void UpdateBotEquips(Creature* bot, uint8 slot, uint32 itemId);
+        uint32 GetBotEquip(Creature* bot, uint8 slot) const;
+        /*********************************************************/
+        /***                 END BOT SYSTEM                    ***/
+        /*********************************************************/
+
     protected:
         // Gamemaster whisper whitelist
         WhisperListContainer WhisperList;
@@ -2566,6 +2604,31 @@ class Player : public Unit, public GridObject<Player>
         bool m_needsZoneUpdate;
 
     private:
+
+         /*********************************************************/
+         /***                     BOT SYSTEM                    ***/
+         /*********************************************************/
+         BotHelper* _botHlpr;
+         Creature* m_bot;
+         int8 m_followdist;
+         uint8 m_maxNpcBots;
+         uint8 m_maxClassNpcBots;
+         uint8 m_xpReductionNpcBots;
+         bool m_enableNpcBots;
+         bool m_enableNpcBotsArenas;
+         bool m_enableNpcBotsBGs;
+         bool m_enableNpcBotsDungeons;
+         bool m_enableNpcBotsRaids;
+         bool m_limitNpcBotsDungeons;
+         bool m_limitNpcBotsRaids;
+         uint32 m_NpcBotsCost;
+         uint32 m_botTimer;
+         uint32 m_botCreateTimer;
+         NpcBotMap* m_botmap[MAX_NPCBOTS];
+         /*********************************************************/
+         /***                END BOT SYSTEM                     ***/
+         /*********************************************************/
+
         // internal common parts for CanStore/StoreItem functions
         InventoryResult CanStoreItem_InSpecificSlot(uint8 bag, uint8 slot, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool swap, Item* pSrcItem) const;
         InventoryResult CanStoreItem_InBag(uint8 bag, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool merge, bool non_specialized, Item* pSrcItem, uint8 skip_bag, uint8 skip_slot) const;
diff --git a/src/server/game/Entities/Totem/Totem.cpp b/src/server/game/Entities/Totem/Totem.cpp
index b8f5fd1..8dcf817 100644
--- a/src/server/game/Entities/Totem/Totem.cpp
+++ b/src/server/game/Entities/Totem/Totem.cpp
@@ -143,6 +143,13 @@ void Totem::UnSummon(uint32 msTime)
         }
     }
 
+    //npcbot: send SummonedCreatureDespawn()
+    if (IS_CREATURE_GUID(GetCreatorGUID()))
+        if (Unit* bot = sObjectAccessor->FindUnit(GetCreatorGUID()))
+            if (bot->ToCreature()->GetIAmABot())
+                bot->ToCreature()->OnBotDespawn(this);
+    //end npcbot
+
     AddObjectToRemoveList();
 }
 
diff --git a/src/server/game/Entities/Unit/StatSystem.cpp b/src/server/game/Entities/Unit/StatSystem.cpp
index 0413622..3170a37 100644
--- a/src/server/game/Entities/Unit/StatSystem.cpp
+++ b/src/server/game/Entities/Unit/StatSystem.cpp
@@ -25,6 +25,7 @@
 #include "SpellAuraEffects.h"
 #include "SpellMgr.h"
 #include "World.h"
+#include "WorldSession.h"
 
 inline bool _ModifyUInt32(bool apply, uint32& baseValue, int32& amount)
 {
@@ -217,6 +218,10 @@ bool Player::UpdateAllStats()
     RecalculateRating(CR_ARMOR_PENETRATION);
     UpdateAllResistances();
 
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        if (Creature* bot = GetBotMap(i)->_Cre())
+            bot->SetBotShouldUpdateStats();
+
     return true;
 }
 
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
index 4efa137..18d41a4 100644
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -337,6 +337,17 @@ void Unit::Update(uint32 p_time)
                 m_CombatTimer -= p_time;
         }
     }
+    // update combat timer also for npcbots
+    if (IsInCombat() && GetTypeId() == TYPEID_UNIT && !GetVictim() && (ToCreature()->GetIAmABot() || ToCreature()->GetIAmABotsPet()))
+    {
+        if (m_HostileRefManager.isEmpty())
+        {
+            if (m_CombatTimer <= p_time)
+                ClearInCombat();
+            else
+                m_CombatTimer -= p_time;
+        }
+    }
 
     // not implemented before 3.0.2
     if (uint32 base_att = getAttackTimer(BASE_ATTACK))
@@ -574,6 +585,12 @@ uint32 Unit::DealDamage(Unit* victim, uint32 damage, CleanDamage const* cleanDam
         if (pet && pet->IsAlive())
             pet->AI()->OwnerAttackedBy(this);
 
+        // NpcBot mod: also signal owned npcbots
+        for (ControlList::const_iterator itr = victim->ToPlayer()->m_Controlled.begin(); itr != victim->ToPlayer()->m_Controlled.end(); ++itr)
+            if (Creature* cre = (*itr)->ToCreature())
+                if (cre->GetIAmABot() && cre->IsAIEnabled)
+                    cre->AI()->OwnerAttackedBy(this);
+
         if (victim->ToPlayer()->GetCommandStatus(CHEAT_GOD))
             return 0;
     }
@@ -992,6 +1009,11 @@ void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 dama
             case SPELL_DAMAGE_CLASS_RANGED:
             case SPELL_DAMAGE_CLASS_MELEE:
             {
+                //Npcbot mod: apply bot damage mods
+                if (Creature* bot = ToCreature())
+                    if (bot->GetIAmABot() || bot->GetIAmABotsPet())
+                        bot->ApplyBotDamageMultiplierMelee(damage, *damageInfo, spellInfo, attackType, crit);
+
                 // Physical Damage
                 if (damageSchoolMask & SPELL_SCHOOL_MASK_NORMAL)
                 {
@@ -1049,6 +1071,11 @@ void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 dama
             case SPELL_DAMAGE_CLASS_NONE:
             case SPELL_DAMAGE_CLASS_MAGIC:
             {
+                //Npcbot mod: apply bot damage mods
+                if (Creature* bot = ToCreature())
+                    if (bot->GetIAmABot() || bot->GetIAmABotsPet())
+                        bot->ApplyBotDamageMultiplierSpell(damage, *damageInfo, spellInfo, attackType, crit);
+
                 // If crit add critical bonus
                 if (crit)
                 {
@@ -1166,6 +1193,11 @@ void Unit::CalculateMeleeDamage(Unit* victim, uint32 damage, CalcDamageInfo* dam
     // Script Hook For CalculateMeleeDamage -- Allow scripts to change the Damage pre class mitigation calculations
     sScriptMgr->ModifyMeleeDamage(damageInfo->target, damageInfo->attacker, damage);
 
+    //Npcbot mod: apply bot damage mods
+    if (Creature* bot = ToCreature())
+        if (bot->GetIAmABot() || bot->GetIAmABotsPet())
+            bot->ApplyBotDamageMultiplierMelee(damage, *damageInfo);
+
     // Calculate armor reduction
     if (IsDamageReducedByArmor((SpellSchoolMask)(damageInfo->damageSchoolMask)))
     {
@@ -10411,6 +10443,7 @@ bool Unit::isSpellCrit(Unit* victim, SpellInfo const* spellProto, SpellSchoolMas
     //! Mobs can't crit with spells. Player Totems can
     //! Fire Elemental (from totem) can too - but this part is a hack and needs more research
     if (IS_CREATURE_GUID(GetGUID()) && !(IsTotem() && IS_PLAYER_GUID(GetOwnerGUID())) && GetEntry() != 15438)
+        if (!ToCreature()->GetIAmABot())
         return false;
 
     // not critting spell
@@ -13125,6 +13158,11 @@ bool Unit::HandleStatModifier(UnitMods unitMod, UnitModifierType modifierType, f
             break;
     }
 
+    if (Player* master = ToPlayer())
+        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+            if (Creature* bot = master->GetBotMap(i)->_Cre())
+                bot->SetBotShouldUpdateStats();
+
     return true;
 }
 
@@ -16562,6 +16600,182 @@ uint32 Unit::GetModelForForm(ShapeshiftForm form) const
                 break;
         }
     }
+    else if (ToCreature() && ToCreature()->GetIAmABot())
+    {
+        Player const *player = ToCreature()->GetBotOwner();
+        //let's make druids alike for each player
+        switch (form)
+        {
+            case FORM_CAT:
+                // Based on master's Hair color
+                if (player->getRace() == RACE_NIGHTELF)
+                {
+                    uint8 hairColor = player->GetByteValue(PLAYER_BYTES, 3);
+                    switch (hairColor)
+                    {
+                        case 7: // Violet
+                        case 8:
+                            return 29405;
+                        case 3: // Light Blue
+                            return 29406;
+                        case 0: // Green
+                        case 1: // Light Green
+                        case 2: // Dark Green
+                            return 29407;
+                        case 4: // White
+                            return 29408;
+                        default: // original - Dark Blue
+                            return 892;
+                    }
+                }
+                // Based on master's Skin color
+                else if (player->getRace() == RACE_TAUREN)
+                {
+                    uint8 skinColor = player->GetByteValue(PLAYER_BYTES, 0);
+                    // Male master
+                    if (player->getGender() == GENDER_MALE)
+                    {
+                        switch (skinColor)
+                        {
+                            case 12: // White
+                            case 13:
+                            case 14:
+                            case 18: // Completly White
+                                return 29409;
+                            case 9: // Light Brown
+                            case 10:
+                            case 11:
+                                return 29410;
+                            case 6: // Brown
+                            case 7:
+                            case 8:
+                                return 29411;
+                            case 0: // Dark
+                            case 1:
+                            case 2:
+                            case 3: // Dark Grey
+                            case 4:
+                            case 5:
+                                return 29412;
+                            default: // original - Grey
+                                return 8571;
+                        }
+                    }
+                    // Female master
+                    else switch (skinColor)
+                    {
+                        case 10: // White
+                            return 29409;
+                        case 6: // Light Brown
+                        case 7:
+                            return 29410;
+                        case 4: // Brown
+                        case 5:
+                            return 29411;
+                        case 0: // Dark
+                        case 1:
+                        case 2:
+                        case 3:
+                            return 29412;
+                        default: // original - Grey
+                            return 8571;
+                    }
+                }
+                else if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                    return 892;
+                else
+                    return 8571;
+            case FORM_DIREBEAR:
+            case FORM_BEAR:
+                // Based on Hair color
+                if (player->getRace() == RACE_NIGHTELF)
+                {
+                    uint8 hairColor = player->GetByteValue(PLAYER_BYTES, 3);
+                    switch (hairColor)
+                    {
+                        case 0: // Green
+                        case 1: // Light Green
+                        case 2: // Dark Green
+                            return 29413; // 29415?
+                        case 6: // Dark Blue
+                            return 29414;
+                        case 4: // White
+                            return 29416;
+                        case 3: // Light Blue
+                            return 29417;
+                        default: // original - Violet
+                            return 2281;
+                    }
+                }
+                // Based on Skin color
+                else if (player->getRace() == RACE_TAUREN)
+                {
+                    uint8 skinColor = player->GetByteValue(PLAYER_BYTES, 0);
+                    // Male
+                    if (player->getGender() == GENDER_MALE)
+                    {
+                        switch (skinColor)
+                        {
+                            case 0: // Dark (Black)
+                            case 1:
+                            case 2:
+                                return 29418;
+                            case 3: // White
+                            case 4:
+                            case 5:
+                            case 12:
+                            case 13:
+                            case 14:
+                                return 29419;
+                            case 9: // Light Brown/Grey
+                            case 10:
+                            case 11:
+                            case 15:
+                            case 16:
+                            case 17:
+                                return 29420;
+                            case 18: // Completly White
+                                return 29421;
+                            default: // original - Brown
+                                return 2289;
+                        }
+                    }
+                    // Female
+                    else switch (skinColor)
+                    {
+                        case 0: // Dark (Black)
+                        case 1:
+                            return 29418;
+                        case 2: // White
+                        case 3:
+                            return 29419;
+                        case 6: // Light Brown/Grey
+                        case 7:
+                        case 8:
+                        case 9:
+                            return 29420;
+                        case 10: // Completly White
+                            return 29421;
+                        default: // original - Brown
+                            return 2289;
+                    }
+                }
+                else if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                    return 2281;
+                else
+                    return 2289;
+            case FORM_FLIGHT:
+                if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                    return 20857;
+                return 20872;
+            case FORM_FLIGHT_EPIC:
+                if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                    return 21243;
+                return 21244;
+            default:
+                break;
+        }
+    }
 
     uint32 modelid = 0;
     SpellShapeshiftEntry const* formEntry = sSpellShapeshiftStore.LookupEntry(form);
diff --git a/src/server/game/Globals/ObjectMgr.cpp b/src/server/game/Globals/ObjectMgr.cpp
index 207f80e..0e3d08f 100644
--- a/src/server/game/Globals/ObjectMgr.cpp
+++ b/src/server/game/Globals/ObjectMgr.cpp
@@ -7840,6 +7840,82 @@ SkillRangeType GetSkillRangeType(SkillLineEntry const* pSkill, bool racial)
     }
 }
 
+void ObjectMgr::LoadCreatureOutfits()
+{
+    uint32 oldMSTime = getMSTime();
+
+    _creatureOutfitStore.clear();                           // for reload case (test only)
+
+    //                                                 0     1      2      3     4     5       6           7
+    QueryResult result = WorldDatabase.Query("SELECT entry, race, gender, skin, face, hair, haircolor, facialhair, "
+        //8       9        10    11     12     13    14     15     16     17     18
+        "head, shoulders, body, chest, waist, legs, feet, wrists, hands, back, tabard FROM creature_template_outfits");
+
+    if (!result)
+    {
+        TC_LOG_ERROR("server.loading", ">> Loaded 0 creature outfits. DB table `creature_template_outfits` is empty!");
+        return;
+    }
+
+    uint32 count = 0;
+
+    do
+    {
+        Field* fields = result->Fetch();
+
+        uint32 i = 0;
+        uint32 entry     = fields[i++].GetUInt32();
+
+        if (!GetCreatureTemplate(entry))
+        {
+            TC_LOG_ERROR("server.loading", ">> Creature entry %u in `creature_template_outfits`, but not in `creature_template`!", entry);
+            continue;
+        }
+
+        CreatureOutfit co; // const, shouldnt be changed after saving
+        co.race          = fields[i++].GetUInt8();
+        ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(co.race);
+        if (!rEntry)
+        {
+            TC_LOG_ERROR("server.loading", ">> Creature entry %u in `creature_template_outfits` has incorrect race (%u).", entry, uint32(co.race));
+            continue;
+        }
+        co.gender        = fields[i++].GetUInt8();
+        // Set correct displayId
+        switch (co.gender)
+        {
+            case GENDER_FEMALE:
+                _creatureTemplateStore[entry].Modelid1 = rEntry->model_f;
+                break;
+            case GENDER_MALE:
+                _creatureTemplateStore[entry].Modelid1 = rEntry->model_m;
+                break;
+            default:
+                TC_LOG_ERROR("server.loading", ">> Creature entry %u in `creature_template_outfits` has invalid gender %u", entry, uint32(co.gender));
+                continue;
+        }
+        _creatureTemplateStore[entry].Modelid2 = 0;
+        _creatureTemplateStore[entry].Modelid3 = 0;
+        _creatureTemplateStore[entry].Modelid4 = 0;
+        _creatureTemplateStore[entry].unit_flags2 |= UNIT_FLAG2_MIRROR_IMAGE; // Needed so client requests mirror packet
+
+        co.skin          = fields[i++].GetUInt8();
+        co.face          = fields[i++].GetUInt8();
+        co.hair          = fields[i++].GetUInt8();
+        co.haircolor     = fields[i++].GetUInt8();
+        co.facialhair    = fields[i++].GetUInt8();
+        for (uint32 j = 0; j != MAX_CREATURE_OUTFIT_DISPLAYS; ++j)
+            co.outfit[j] = fields[i+j].GetUInt32();
+
+        _creatureOutfitStore[entry] = co;
+
+        ++count;
+    }
+    while (result->NextRow());
+
+    TC_LOG_INFO("server.loading", ">> Loaded %u creature outfits in %u ms", count, GetMSTimeDiffToNow(oldMSTime));
+}
+
 void ObjectMgr::LoadGameTele()
 {
     uint32 oldMSTime = getMSTime();
diff --git a/src/server/game/Globals/ObjectMgr.h b/src/server/game/Globals/ObjectMgr.h
index ba5940d..30a4a89 100644
--- a/src/server/game/Globals/ObjectMgr.h
+++ b/src/server/game/Globals/ObjectMgr.h
@@ -144,6 +144,47 @@ struct GameTele
 
 typedef std::unordered_map<uint32, GameTele > GameTeleContainer;
 
+#define MAX_CREATURE_OUTFIT_DISPLAYS 11
+struct CreatureOutfit
+{
+    uint8 race;
+    uint8 gender;
+    uint8 face;
+    uint8 skin;
+    uint8 hair;
+    uint8 facialhair;
+    uint8 haircolor;
+    uint32 outfit[MAX_CREATURE_OUTFIT_DISPLAYS];
+};
+
+
+#ifndef UNORDERED_MAP
+#ifdef _STLPORT_VERSION
+# define UNORDERED_MAP std::hash_map
+#elif COMPILER_HAS_CPP11_SUPPORT
+# define UNORDERED_MAP std::unordered_map
+#elif COMPILER == COMPILER_MICROSOFT && _MSC_VER >= 1600 // VS100
+# define UNORDERED_MAP std::tr1::unordered_map
+# define UNORDERED_MULTIMAP std::tr1::unordered_multimap
+#elif COMPILER == COMPILER_MICROSOFT && _MSC_VER >= 1500 && _HAS_TR1
+# define UNORDERED_MAP std::tr1::unordered_map
+#elif COMPILER == COMPILER_MICROSOFT && _MSC_VER >= 1300
+# define UNORDERED_MAP stdext::hash_map
+#elif COMPILER == COMPILER_INTEL
+# define UNORDERED_MAP std::hash_map
+#elif COMPILER == COMPILER_GNU && defined(__clang__) && defined(_LIBCPP_VERSION)
+# define UNORDERED_MAP std::unordered_map
+#elif COMPILER == COMPILER_GNU && GCC_VERSION > 40200
+# define UNORDERED_MAP std::tr1::unordered_map
+#elif COMPILER == COMPILER_GNU && GCC_VERSION >= 30000
+# define UNORDERED_MAP __gnu_cxx::hash_map
+#else
+# define UNORDERED_MAP std::hash_map
+#endif
+#endif
+
+typedef UNORDERED_MAP<uint32, CreatureOutfit > CreatureOutfitContainer;
+
 enum ScriptsType
 {
     SCRIPTS_FIRST = 1,
@@ -1011,6 +1052,7 @@ class ObjectMgr
 
         void LoadNPCSpellClickSpells();
 
+        void LoadCreatureOutfits();
         void LoadGameTele();
 
         void LoadGossipMenu();
@@ -1219,6 +1261,8 @@ class ObjectMgr
         bool AddGameTele(GameTele& data);
         bool DeleteGameTele(std::string const& name);
 
+        CreatureOutfitContainer const& GetCreatureOutfitMap() const { return _creatureOutfitStore; }
+
         TrainerSpellData const* GetNpcTrainerSpells(uint32 entry) const
         {
             CacheTrainerSpellContainer::const_iterator  iter = _cacheTrainerSpellStore.find(entry);
@@ -1363,6 +1407,8 @@ class ObjectMgr
         PageTextContainer _pageTextStore;
         InstanceTemplateContainer _instanceTemplateStore;
 
+        CreatureOutfitContainer _creatureOutfitStore;
+
     private:
         void LoadScripts(ScriptsType type);
         void CheckScripts(ScriptsType type, std::set<int32>& ids);
diff --git a/src/server/game/Groups/Group.cpp b/src/server/game/Groups/Group.cpp
index 113df99..60045b1 100644
--- a/src/server/game/Groups/Group.cpp
+++ b/src/server/game/Groups/Group.cpp
@@ -107,6 +107,9 @@ bool Group::Create(Player* leader)
     if (m_groupType & GROUPTYPE_RAID)
         _initRaidSubGroupsCounter();
 
+    if (leader->HaveBot()) //player + npcbot so set to free-for-all on create
+        m_lootMethod = FREE_FOR_ALL;
+    else
     if (!isLFGGroup())
         m_lootMethod = GROUP_LOOT;
 
@@ -366,6 +369,8 @@ bool Group::AddMember(Player* player)
 
     SubGroupCounterIncrease(subGroup);
 
+    if (IS_PLAYER_GUID(player->GetGUID()))
+    {
     player->SetGroupInvite(NULL);
     if (player->GetGroup())
     {
@@ -381,6 +386,7 @@ bool Group::AddMember(Player* player)
     InstanceGroupBind* bind = GetBoundInstance(player);
     if (bind && bind->save->GetInstanceId() == player->GetInstanceId())
         player->m_InstanceValid = true;
+    }
 
     if (!isRaidGroup())                                      // reset targetIcons for non-raid-groups
     {
@@ -406,6 +412,8 @@ bool Group::AddMember(Player* player)
     SendUpdate();
     sScriptMgr->OnGroupAddMember(this, player->GetGUID());
 
+    if (IS_PLAYER_GUID(player->GetGUID()))
+    {
     if (!IsLeader(player->GetGUID()) && !isBGGroup() && !isBFGroup())
     {
         // reset the new member's instances, unless he is currently in one of them
@@ -481,6 +489,7 @@ bool Group::AddMember(Player* player)
 
     if (m_maxEnchantingLevel < player->GetSkillValue(SKILL_ENCHANTING))
         m_maxEnchantingLevel = player->GetSkillValue(SKILL_ENCHANTING);
+    }
 
     return true;
 }
@@ -604,6 +613,9 @@ bool Group::RemoveMember(uint64 guid, const RemoveMethod& method /*= GROUP_REMOV
         }
 
         if (m_memberMgr.getSize() < ((isLFGGroup() || isBGGroup()) ? 1u : 2u))
+        //npcbot
+        if (GetMembersCount() < ((isBGGroup() || isLFGGroup()) ? 1u : 2u))
+        //end npcbot
             Disband();
 
         return true;
diff --git a/src/server/game/Groups/Group.h b/src/server/game/Groups/Group.h
index f0061a7..6d28e40 100644
--- a/src/server/game/Groups/Group.h
+++ b/src/server/game/Groups/Group.h
@@ -309,6 +309,9 @@ class Group
         // FG: evil hacks
         void BroadcastGroupUpdate(void);
 
+        //Bot
+        uint64 const *GetTargetIcons() const { return m_targetIcons; }
+
     protected:
         bool _setMembersGroup(uint64 guid, uint8 group);
         void _homebindIfInstance(Player* player);
diff --git a/src/server/game/Handlers/CharacterHandler.cpp b/src/server/game/Handlers/CharacterHandler.cpp
index 7d9d83a..e3f6911 100644
--- a/src/server/game/Handlers/CharacterHandler.cpp
+++ b/src/server/game/Handlers/CharacterHandler.cpp
@@ -48,6 +48,9 @@
 #include "WorldSession.h"
 
 
+//bot
+#include "Config.h"
+
 class LoginQueryHolder : public SQLQueryHolder
 {
     private:
@@ -1023,6 +1026,34 @@ void WorldSession::HandlePlayerLogin(LoginQueryHolder* holder)
 
     m_playerLoading = false;
 
+    //the only place where we check if it has NPC bots
+    if (sConfigMgr->GetBoolDefault("Bot.EnableNpcBots", true))
+    {
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOTS);
+        stmt->setUInt32(0, pCurrChar->GetGUIDLow());
+        PreparedQueryResult result = CharacterDatabase.Query(stmt);
+        if (result)
+        {
+            uint32 m_bot_entry = 0;
+            uint8 m_bot_race = 0;
+            uint8 m_bot_class = 0;
+            uint32 equips[18];
+            do
+            {
+                Field* fields = result->Fetch();
+                m_bot_entry = fields[0].GetUInt32();
+                m_bot_race = fields[1].GetUInt8();
+                m_bot_class = fields[2].GetInt8();
+                for (uint8 i = 0; i != 18; ++i)
+                    equips[i] = fields[i + 4].GetUInt32();
+
+                if (m_bot_entry && m_bot_race && m_bot_class)
+                    pCurrChar->SetBotMustBeCreated(m_bot_entry, m_bot_race, m_bot_class, equips);
+
+            } while (result->NextRow());
+        }
+    }
+
     // Handle Login-Achievements (should be handled after loading)
     _player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_ON_LOGIN, 1);
 
diff --git a/src/server/game/Handlers/MiscHandler.cpp b/src/server/game/Handlers/MiscHandler.cpp
index 11fa89d..2ce2c39 100644
--- a/src/server/game/Handlers/MiscHandler.cpp
+++ b/src/server/game/Handlers/MiscHandler.cpp
@@ -56,6 +56,9 @@
 #include "Battlefield.h"
 #include "BattlefieldMgr.h"
 
+//Bot
+#include "bothelper.h"
+
 void WorldSession::HandleRepopRequestOpcode(WorldPacket& recvData)
 {
     TC_LOG_DEBUG("network", "WORLD: Recvd CMSG_REPOP_REQUEST Message");
@@ -121,6 +124,16 @@ void WorldSession::HandleGossipSelectOptionOpcode(WorldPacket& recvData)
             return;
         }
     }
+    //Bot
+    else if (IS_PLAYER_GUID(guid))
+    {
+        if (guid != _player->GetGUID())
+        {
+            TC_LOG_ERROR("network", "WORLD: HandleGossipSelectOptionOpcode - Player (GUID: %u) not found.", uint32(GUID_LOPART(guid)));
+            return;
+        }
+    }
+    //end Bot
     else if (IS_GAMEOBJECT_GUID(guid))
     {
         go = _player->GetMap()->GetGameObject(guid);
@@ -158,6 +171,17 @@ void WorldSession::HandleGossipSelectOptionOpcode(WorldPacket& recvData)
             if (!sScriptMgr->OnGossipSelectCode(_player, unit, _player->PlayerTalkClass->GetGossipOptionSender(gossipListId), _player->PlayerTalkClass->GetGossipOptionAction(gossipListId), code.c_str()))
                 _player->OnGossipSelect(unit, gossipListId, menuId);
         }
+        //Bot
+        else if (guid == _player->GetGUID())
+        {
+            if (!_player->GetBotHelper())
+            {
+                TC_LOG_ERROR("network", "WORLD: HandleGossipSelectOptionOpcode - Player (GUID: %u) do not have a helper on gossip select.", uint32(GUID_LOPART(guid)));
+                return;
+            }
+            //_player->GetBotHelper()->OnCodedGossipSelect(_player, _player->PlayerTalkClass->GetGossipOptionSender(gossipListId), _player->PlayerTalkClass->GetGossipOptionAction(gossipListId), code.c_str());
+        }
+        //end Bot
         else
         {
             go->AI()->GossipSelectCode(_player, menuId, gossipListId, code.c_str());
@@ -173,6 +197,17 @@ void WorldSession::HandleGossipSelectOptionOpcode(WorldPacket& recvData)
             if (!sScriptMgr->OnGossipSelect(_player, unit, _player->PlayerTalkClass->GetGossipOptionSender(gossipListId), _player->PlayerTalkClass->GetGossipOptionAction(gossipListId)))
                 _player->OnGossipSelect(unit, gossipListId, menuId);
         }
+        //Bot
+        else if (guid == _player->GetGUID())
+        {
+            if (!_player->GetBotHelper())
+            {
+                TC_LOG_ERROR("network", "WORLD: HandleGossipSelectOptionOpcode - Player (GUID: %u) do not have a helper on gossip select.", uint32(GUID_LOPART(guid)));
+                return;
+            }
+            _player->GetBotHelper()->OnGossipSelect(_player, _player->PlayerTalkClass->GetGossipOptionSender(gossipListId), _player->PlayerTalkClass->GetGossipOptionAction(gossipListId));
+        }
+        //end Bot
         else
         {
             go->AI()->GossipSelect(_player, menuId, gossipListId);
diff --git a/src/server/game/Handlers/NPCHandler.cpp b/src/server/game/Handlers/NPCHandler.cpp
index fc14797..5dea4a7 100644
--- a/src/server/game/Handlers/NPCHandler.cpp
+++ b/src/server/game/Handlers/NPCHandler.cpp
@@ -38,6 +38,9 @@
 #include "CreatureAI.h"
 #include "SpellInfo.h"
 
+//Bot
+#include "bothelper.h"
+
 enum StableResultCode
 {
     STABLE_ERR_MONEY        = 0x01,                         // "you don't have enough money"
@@ -302,6 +305,36 @@ void WorldSession::HandleGossipHelloOpcode(WorldPacket& recvData)
     uint64 guid;
     recvData >> guid;
 
+    //Bot
+    if (guid == _player->GetGUID())
+    {
+        if (!_player->GetBotHelper())
+        {
+            TC_LOG_ERROR("network", "WORLD: HandleGossipSelectOptionOpcode - Player (GUID: %u) do not have a helper on gossip hello.", uint32(GUID_LOPART(guid)));
+            return;
+        }
+        _player->GetBotHelper()->OnGossipHello(_player);
+        return;
+    }
+    else if (IS_CREATURE_GUID(guid))
+    {
+        if (Creature* qBot = ObjectAccessor::GetCreatureOrPetOrVehicle(*_player, guid))
+        {
+            if (qBot->IsQuestBot() &&
+                (_player->IsAlive() || qBot->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_GHOST) &&
+                (qBot->IsAlive() || (qBot->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_DEAD_INTERACT)))
+            {
+                if (!sScriptMgr->OnGossipHello(_player, qBot))
+                {
+                    TC_LOG_ERROR("network", "WORLD: HandleGossipHelloOpcode - qBot %s (Entry: %u) returned false on gossip hello.",
+                        qBot->GetName().c_str(), qBot->GetEntry());
+                }
+                return;
+            }
+        }
+    }
+    //end Bot
+
     Creature* unit = GetPlayer()->GetNPCIfCanInteractWith(guid, UNIT_NPC_FLAG_NONE);
     if (!unit)
     {
diff --git a/src/server/game/Handlers/SpellHandler.cpp b/src/server/game/Handlers/SpellHandler.cpp
index ba30803..896c522 100644
--- a/src/server/game/Handlers/SpellHandler.cpp
+++ b/src/server/game/Handlers/SpellHandler.cpp
@@ -568,6 +568,36 @@ void WorldSession::HandleMirrorImageDataRequest(WorldPacket& recvData)
     if (!unit)
         return;
 
+    //bot
+    if (unit->ToCreature())
+    {
+        CreatureOutfitContainer const& outfits = sObjectMgr->GetCreatureOutfitMap();
+        CreatureOutfitContainer::const_iterator it = outfits.find(unit->GetEntry());
+        if (it != outfits.end())
+        {
+            WorldPacket data(SMSG_MIRRORIMAGE_DATA, 68);
+            data << uint64(guid);
+            data << uint32(unit->GetNativeDisplayId()); // displayId
+            data << uint8(it->second.race);             // race
+            data << uint8(it->second.gender);           // gender
+            data << uint8(unit->getClass());            // class
+            data << uint8(it->second.skin);             // skin
+            data << uint8(it->second.face);             // face
+            data << uint8(it->second.hair);             // hair
+            data << uint8(it->second.haircolor);        // haircolor
+            data << uint8(it->second.facialhair);       // facialhair
+            data << uint32(0);                          // guildId
+
+            // item displays
+            for (uint8 i = 0; i != MAX_CREATURE_OUTFIT_DISPLAYS; ++i)
+                data << uint32(it->second.outfit[i]);
+
+            SendPacket(&data);
+            return;
+        }
+    }
+    //end bot
+
     if (!unit->HasAuraType(SPELL_AURA_CLONE_CASTER))
         return;
 
diff --git a/src/server/game/Maps/Map.cpp b/src/server/game/Maps/Map.cpp
index ba27123..f9f77db 100644
--- a/src/server/game/Maps/Map.cpp
+++ b/src/server/game/Maps/Map.cpp
@@ -2679,7 +2679,10 @@ uint32 Map::GetPlayersCountExceptGMs() const
     uint32 count = 0;
     for (MapRefManager::const_iterator itr = m_mapRefManager.begin(); itr != m_mapRefManager.end(); ++itr)
         if (!itr->GetSource()->IsGameMaster())
+        {
             ++count;
+            count += itr->GetSource()->GetNpcBotsCount();
+        }
     return count;
 }
 
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
index 7365d59..06c4316 100644
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -1436,6 +1436,21 @@ void AddBattlegroundScripts()
 
 #ifdef SCRIPTS
 /* This is where custom scripts' loading functions should be declared. */
+//Bots
+void AddSC_death_knight_bot();
+void AddSC_druid_bot();
+void AddSC_hunter_bot();
+void AddSC_mage_bot();
+void AddSC_paladin_bot();
+void AddSC_priest_bot();
+void AddSC_rogue_bot();
+void AddSC_shaman_bot();
+void AddSC_warlock_bot();
+void AddSC_warrior_bot();
+void AddSC_script_bot_commands();
+//advanced
+void AddSC_BotQuests_chapter1();
+//end Bots
 
 #endif
 
@@ -1443,6 +1458,21 @@ void AddCustomScripts()
 {
 #ifdef SCRIPTS
     /* This is where custom scripts should be added. */
+    //Bots
+    AddSC_death_knight_bot();
+    AddSC_druid_bot();
+    AddSC_hunter_bot();
+    AddSC_mage_bot();
+    AddSC_paladin_bot();
+    AddSC_priest_bot();
+    AddSC_rogue_bot();
+    AddSC_shaman_bot();
+    AddSC_warlock_bot();
+    AddSC_warrior_bot();
+    AddSC_script_bot_commands();
+    //advanced
+    AddSC_BotQuests_chapter1();
+    //end Bots
 
 #endif
 }
diff --git a/src/server/game/Server/WorldSession.cpp b/src/server/game/Server/WorldSession.cpp
index 61a2e05..4883b85 100644
--- a/src/server/game/Server/WorldSession.cpp
+++ b/src/server/game/Server/WorldSession.cpp
@@ -439,6 +439,20 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
 /// %Log the player out
 void WorldSession::LogoutPlayer(bool save)
 {
+    uint8 nBotCount = 0;
+    if (_player)
+    {
+        //remove npcbots but do not delete from DB so they can be reacqured on next login
+        for (uint8 i = 0; i != _player->GetMaxNpcBots(); ++i)
+        {
+            if (_player->GetBotMap(i)->_Guid())
+            {
+                _player->RemoveBot(_player->GetBotMap(i)->_Guid(), true, false);
+                ++nBotCount;
+            }
+        }
+    }
+
     // finish pending transfers before starting the logout
     while (_player && _player->IsBeingTeleportedFar())
         HandleMoveWorldportAckOpcode();
@@ -531,6 +545,9 @@ void WorldSession::LogoutPlayer(bool save)
         // remove player from the group if he is:
         // a) in group; b) not in raid group; c) logging out normally (not being kicked or disconnected)
         if (_player->GetGroup() && !_player->GetGroup()->isRaidGroup() && m_Socket)
+            //bot d) if has no NpcBots or not in instance (trying to save instance)
+            if (nBotCount == 0 || !_player->GetMap()->Instanceable())
+            //end bot
             _player->RemoveFromGroup();
 
         //! Send update to group and reset stored max enchanting level
diff --git a/src/server/game/Server/WorldSession.h b/src/server/game/Server/WorldSession.h
index 82125aa..45b48fe 100644
--- a/src/server/game/Server/WorldSession.h
+++ b/src/server/game/Server/WorldSession.h
@@ -198,6 +198,31 @@ class CharacterCreateInfo
         uint8 CharCount;
 };
 
+//npcbot
+struct NpcBotMap
+{
+    friend class Player;
+    protected:
+        NpcBotMap() : m_guid(0), m_entry(0), m_race(0), m_class(0), m_creature(NULL), m_reviveTimer(0)
+        {
+            for (uint8 i = 0; i != 18; ++i)
+                equips[i] = 0;
+        }
+        uint64 m_guid;
+        uint32 m_entry;
+        uint8  m_race;
+        uint8  m_class;
+        Creature* m_creature;
+        uint32 m_reviveTimer;
+        uint32 equips[18];
+
+    public:
+        uint64 _Guid() const { return m_guid; }
+        Creature* _Cre() const { return m_creature; }
+        uint32 const getEquips(uint8 slot) const { return equips[slot]; }
+};
+//end bot mods
+
 struct PacketCounter
 {
     time_t lastReceiveTime;
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index e40e2f7..c97ac37 100644
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -1437,6 +1437,9 @@ void World::SetInitialWorldSettings()
     TC_LOG_INFO("server.loading", "Loading Creature templates...");
     sObjectMgr->LoadCreatureTemplates();
 
+    TC_LOG_INFO("server.loading", "Loading Creature template outfits...");     // must be after LoadCreatureTemplates
+    sObjectMgr->LoadCreatureOutfits();
+
     TC_LOG_INFO("server.loading", "Loading Equipment templates...");           // must be after LoadCreatureTemplates
     sObjectMgr->LoadEquipmentTemplates();
 
diff --git a/src/server/scripts/Spells/spell_priest.cpp b/src/server/scripts/Spells/spell_priest.cpp
index dea67b5..98c03b8 100644
--- a/src/server/scripts/Spells/spell_priest.cpp
+++ b/src/server/scripts/Spells/spell_priest.cpp
@@ -561,6 +561,7 @@ class spell_pri_penance : public SpellScriptLoader
 
             bool Load() override
             {
+                if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->GetIAmABot()) return true;
                 return GetCaster()->GetTypeId() == TYPEID_PLAYER;
             }
 
@@ -603,6 +604,8 @@ class spell_pri_penance : public SpellScriptLoader
             SpellCastResult CheckCast()
             {
                 Player* caster = GetCaster()->ToPlayer();
+                if (!caster && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->GetIAmABot())
+                    caster = (Player*)GetCaster();
                 if (Unit* target = GetExplTargetUnit())
                     if (!caster->IsFriendlyTo(target) && !caster->IsValidAttackTarget(target))
                         return SPELL_FAILED_BAD_TARGETS;
@@ -744,6 +747,7 @@ class spell_pri_renew : public SpellScriptLoader
 
             bool Load() override
             {
+                if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->GetIAmABot()) return true;
                 return GetCaster() && GetCaster()->GetTypeId() == TYPEID_PLAYER;
             }
 
diff --git a/src/server/shared/Database/Implementation/CharacterDatabase.cpp b/src/server/shared/Database/Implementation/CharacterDatabase.cpp
index 24e61e7..8641889 100644
--- a/src/server/shared/Database/Implementation/CharacterDatabase.cpp
+++ b/src/server/shared/Database/Implementation/CharacterDatabase.cpp
@@ -600,4 +600,18 @@ void CharacterDatabaseConnection::DoPrepareStatements()
     PrepareStatement(CHAR_UPD_CHAR_PET_SLOT_BY_ID, "UPDATE character_pet SET slot = ? WHERE owner = ? AND id = ?", CONNECTION_ASYNC);
     PrepareStatement(CHAR_DEL_CHAR_PET_BY_ID, "DELETE FROM character_pet WHERE id = ?", CONNECTION_ASYNC);
     PrepareStatement(CHAR_DEL_CHAR_PET_BY_SLOT, "DELETE FROM character_pet WHERE owner = ? AND (slot = ? OR slot > ?)", CONNECTION_ASYNC);
+
+    // Bot
+    PrepareStatement(CHAR_SEL_NPCBOTS, "SELECT entry, race, class, roles, equipMhEx, equipOhEx, equipRhEx, "
+        "equipHead, equipShoulders, equipChest, equipWaist, equipLegs, equipFeet, equipWrist, equipHands, equipBack, equipBody, equipFinger1, equipFinger2, equipTrinket1, equipTrinket2, equipNeck FROM character_npcbot WHERE owner = ? AND active = 1", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_DEL_NPCBOTS, "DELETE FROM character_npcbot WHERE owner = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_INS_NPCBOT, "REPLACE INTO character_npcbot (owner, entry, race, class, roles, equipMhEx, equipOhEx, equipRhEx, "
+        "equipHead, equipShoulders, equipChest, equipWaist, equipLegs, equipFeet, equipWrist, equipHands, equipBack, equipBody, equipFinger1, equipFinger2, equipTrinket1, equipTrinket2, equipNeck, active) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_NPCBOT_EQUIP, "UPDATE character_npcbot SET equipMhEx = ?, equipOhEx = ?, equipRhEx = ?, "
+        "equipHead = ?, equipShoulders = ?, equipChest = ?, equipWaist = ?, equipLegs = ?, equipFeet = ?, equipWrist = ?, equipHands = ?, equipBack = ?, equipBody = ?, equipFinger1 = ?, equipFinger2 = ?, equipTrinket1 = ?, equipTrinket2 = ?, equipNeck = ? WHERE owner = ? AND entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_NPCBOT_ACTIVE, "UPDATE character_npcbot SET active = ? WHERE owner = ? AND entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_SEL_NPCBOT_EQUIP, "SELECT equipMhEx, equipOhEx, equipRhEx, "
+        "equipHead, equipShoulders, equipChest, equipWaist, equipLegs, equipFeet, equipWrist, equipHands, equipBack, equipBody, equipFinger1, equipFinger2, equipTrinket1, equipTrinket2, equipNeck FROM character_npcbot WHERE owner = ? AND entry = ?", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_SEL_NPCBOT_ROLES, "SELECT roles FROM character_npcbot WHERE owner = ? AND entry = ?", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_UPD_NPCBOT_ROLES, "UPDATE character_npcbot SET roles = ? WHERE owner = ? AND entry = ?", CONNECTION_ASYNC);
 }
diff --git a/src/server/shared/Database/Implementation/CharacterDatabase.h b/src/server/shared/Database/Implementation/CharacterDatabase.h
index 98d7fe2..315bfc7 100644
--- a/src/server/shared/Database/Implementation/CharacterDatabase.h
+++ b/src/server/shared/Database/Implementation/CharacterDatabase.h
@@ -534,6 +534,16 @@ enum CharacterDatabaseStatements
     CHAR_DEL_ITEMCONTAINER_MONEY,
     CHAR_INS_ITEMCONTAINER_MONEY,
 
+    // Bot
+    CHAR_SEL_NPCBOTS,
+    CHAR_DEL_NPCBOTS,
+    CHAR_INS_NPCBOT,
+    CHAR_UPD_NPCBOT_EQUIP,
+    CHAR_UPD_NPCBOT_ACTIVE,
+    CHAR_SEL_NPCBOT_EQUIP,
+    CHAR_SEL_NPCBOT_ROLES,
+    CHAR_UPD_NPCBOT_ROLES,
+
     MAX_CHARACTERDATABASE_STATEMENTS
 };
 
diff --git a/src/server/shared/Database/Implementation/WorldDatabase.cpp b/src/server/shared/Database/Implementation/WorldDatabase.cpp
index d0e9c46..0531136 100644
--- a/src/server/shared/Database/Implementation/WorldDatabase.cpp
+++ b/src/server/shared/Database/Implementation/WorldDatabase.cpp
@@ -91,4 +91,8 @@ void WorldDatabaseConnection::DoPrepareStatements()
     PrepareStatement(WORLD_DEL_DISABLES, "DELETE FROM disables WHERE entry = ? AND sourceType = ?", CONNECTION_ASYNC);
     // 0: uint8
     PrepareStatement(WORLD_SEL_REQ_XP, "SELECT xp_for_next_level FROM player_xp_for_level WHERE lvl = ?", CONNECTION_SYNCH);
+
+    // Bot
+    PrepareStatement(WORLD_SEL_NPCBOT_TEMPLATE, "SELECT entry, trainer_race FROM creature_template WHERE scriptname = ? and trainer_class = ? and trainer_race IN (?, ?, ?, ?, ?)", CONNECTION_SYNCH);
+    PrepareStatement(WORLD_SEL_NPCBOT_PET_LEVELSTATS, "SELECT hp, mana, armor, str, agi, sta, inte, spi FROM pet_levelstats WHERE creature_entry = ? AND level = ?", CONNECTION_SYNCH);
 }
diff --git a/src/server/shared/Database/Implementation/WorldDatabase.h b/src/server/shared/Database/Implementation/WorldDatabase.h
index a815373..ac74483 100644
--- a/src/server/shared/Database/Implementation/WorldDatabase.h
+++ b/src/server/shared/Database/Implementation/WorldDatabase.h
@@ -112,6 +112,10 @@ enum WorldDatabaseStatements
     WORLD_DEL_DISABLES,
     WORLD_SEL_REQ_XP,
 
+    // Bot
+    WORLD_SEL_NPCBOT_TEMPLATE,
+    WORLD_SEL_NPCBOT_PET_LEVELSTATS,
+
     MAX_WORLDDATABASE_STATEMENTS
 };
 
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index f71ef5d..55e45e6 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -2771,3 +2771,107 @@ PacketSpoof.BanDuration = 86400
 
 #
 ###################################################################################################
+
+
+###################################################################################################
+# NPCBOT CONFIGURATION
+#
+#     Bot.EnableNpcBots
+#        Enable NpcBot system
+#        Default: 1 - enable
+#                       0 - disable
+
+Bot.EnableNpcBots = 1
+
+#    Bot.MaxNpcBots
+#        Maximum number of Npc Bots allowed per character (disabled for GM accounts)
+#        Default: 1
+#        Recomended: 4
+#        Max: 9
+#        Absolute Max: 39
+
+Bot.MaxNpcBots = 1
+
+#    Bot.MaxNpcBotsPerClass
+#        Maximum Npc Bots of each class allowed per character
+#        If set to 0, no restriction
+#        Default: 1
+
+Bot.MaxNpcBotsPerClass = 1
+
+#    Bot.BaseFollowDistance
+#        Default follow distance set at login
+#        Default: 30
+
+Bot.BaseFollowDistance = 30
+
+#    Bot.XpReductionPercent
+#        Since bot party can be pretty large, it can become an exploit to farm xp so you can reduce xp gain here
+#        PERCENT of  'XP.KILL'  reward reduction from each Npc Bots used (Starting with second)
+#        Example:
+#            You have 3 bots, xp reduction is 20 then reduction will be ((3-1)*20) = 40%; 60% exp gained only
+#        Note: Minimum xp rate will be 10%
+#        Min: 0
+#        Max: 90
+#        Default: 0
+
+Bot.XpReductionPercent = 0
+
+#    Bot.HealTargetIconsMask
+#        Icon number bitmask which bots are using to search for additional targets to heal (out of party)
+#        1 - Star
+#        2 - Circle
+#        4 - Diamond
+#        8 - Triangle
+#        16 - Moon
+#        32 - Square
+#        64 - Cross
+#        128 - Skull
+#        Example: to check Star, Triangle and Square we need 1+8+32 = 41
+#        Note that many creatures cannot accept heal
+#        Min: 0 (Disable)
+#        Max: 255 (Any Icon)
+#        Default: 8 (Triangle)
+
+Bot.HealTargetIconsMask = 8
+
+#    Bot.DamageMult
+#        Myltiplier for bot's damage dealt. Allows to balance bots' compared to players' damage
+#        Any damage done by bots will be modified
+#        Range: 0.01 - 10.0
+#        Default: 1.0
+
+Bot.DamageMult.Melee = 1.0
+Bot.DamageMult.Spell = 1.0
+
+#    Bot.EnableIn... Arenas/BGs/Dungeons/Raids
+#        Allows to restrict bots usage in PvE and/or PvP
+#        Default: true for all
+
+Bot.EnableInArenas = 1
+Bot.EnableInBGs = 1
+Bot.EnableInDungeons = 1
+Bot.EnableInRaids = 1
+
+#    Bot.InstanceLimit... Dungeons/Raids
+#        If set to 1 will apply instance players limitation to bots
+#        Default: false for all
+
+Bot.InstanceLimit.Dungeons = 0
+Bot.InstanceLimit.Raids = 0
+
+#    Bot.Cost
+#        Bot recruitment cost (in copper)
+#        Note: this value is set for lvl 80 characters. Cost will be reduced for lower levels
+#        Default: 0
+
+Bot.Cost = 0
+
+#    Bot.PvP
+#        If set to 0 bots will not attack  players or other bots
+#        Default: 1
+
+Bot.PvP = 1
+
+#
+###################################################################################################
