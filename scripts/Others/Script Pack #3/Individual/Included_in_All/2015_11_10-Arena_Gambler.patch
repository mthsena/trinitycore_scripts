From 20297993327d7cd208e43e9c6e41a8a9723af753 Mon Sep 17 00:00:00 2001
From: LordPsyan <realmsofwarcraft@gmail.com>
Date: Tue, 10 Nov 2015 07:26:07 -0600
Subject: [PATCH] 2015_11_10-Arena_Gambler

---
 .../ArenaGambler/CharactersDB.sql                  |  59 ++
 sql/TrinityCore-Patches/ArenaGambler/WorldDB.sql   | 318 +++++++++
 src/server/game/Scripting/ScriptLoader.cpp         |   6 +-
 src/server/scripts/Custom/ArenaGambler.cpp         | 308 +++++++++
 src/server/scripts/Custom/ArenaGamblingSystem.cpp  | 723 +++++++++++++++++++++
 src/server/scripts/Custom/ArenaGamblingSystem.h    | 458 +++++++++++++
 6 files changed, 1870 insertions(+), 2 deletions(-)
 create mode 100644 sql/TrinityCore-Patches/ArenaGambler/CharactersDB.sql
 create mode 100644 sql/TrinityCore-Patches/ArenaGambler/WorldDB.sql
 create mode 100644 src/server/scripts/Custom/ArenaGambler.cpp
 create mode 100644 src/server/scripts/Custom/ArenaGamblingSystem.cpp
 create mode 100644 src/server/scripts/Custom/ArenaGamblingSystem.h

diff --git a/sql/TrinityCore-Patches/ArenaGambler/CharactersDB.sql b/sql/TrinityCore-Patches/ArenaGambler/CharactersDB.sql
new file mode 100644
index 0000000..ac486b2
--- /dev/null
+++ b/sql/TrinityCore-Patches/ArenaGambler/CharactersDB.sql
@@ -0,0 +1,59 @@
+/*
+ * Author: Xees
+ * Description: This file is used to apply the database tables needed for the ArenaGambler
+ * Version: 1.2
+*/
+create table `custom_duel_config` (
+    `optionIndex` int (10),
+    `optionName` varchar (60),
+    `optionValue` float
+);
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('0','MAP ID ','1');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('1','X CORDS','-7218.97');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('2','Y CORDS','982.622');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('3','Z CORDS','303.524');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('4','O CORDS','1.40677');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('5','MINIMUM LEVEL','60');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('6','LEVEL DIFF','3');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('7','REWARD ON FLED','1');
+
+create table `custom_duel_statistics` (
+    `playerGUID` int (11),
+    `duelsLost` int (10),
+    `duelsWon` int (10),
+    `duelsRefused` int (10),
+    `duelsTotal` int (10)
+);
+
+INSERT INTO `custom_duel_config`
+            (`optionIndex`,
+             `optionName`,
+             `optionValue`)
+VALUES ('12',
+        'ENABLE ONLY CURRENCY',
+        '0');
+INSERT INTO `custom_duel_config`
+            (`optionIndex`,
+             `optionName`,
+             `optionValue`)
+VALUES ('13',
+        'ENABLE EQUAL BETS',
+        '0');
+
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('11','ENABLE ITEM LIMITS','0');
+
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('8','MAXIMUM BET','1000');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('9','ENABLE GM DUEL','0');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('10','ENABLE SAMEIP DUEL','0');
+
+create table `custom_duel_storage` (
+    `matchId` int (10),
+    `challengerGUID` int (11),
+    `defenderGUID` int (11),
+    `challengerItemId` mediumint (8),
+    `challengerItemCount` int (11),
+    `defenderItemId` mediumint (8),
+    `defenderItemCount` int (11),
+    `matchDate` timestamp ,
+    `matchWinner` int (11)
+);
diff --git a/sql/TrinityCore-Patches/ArenaGambler/WorldDB.sql b/sql/TrinityCore-Patches/ArenaGambler/WorldDB.sql
new file mode 100644
index 0000000..1d314b7
--- /dev/null
+++ b/sql/TrinityCore-Patches/ArenaGambler/WorldDB.sql
@@ -0,0 +1,318 @@
+
+/*Data for the table `creature` */
+
+DELETE FROM `creature` WHERE `guid` IN (1112144, 1112145, 1112146, 1112148, 1112149, 1112150, 1112151, 1112152, 1112153, 1112155, 1112156, 1112157, 1112158, 1112159, 1112160, 1112161, 1112162, 1112163, 1112164, 1112165, 1112166, 1118308);
+
+INSERT INTO `creature`(`guid`,`id`,`map`,`zoneId`,`areaId`,`spawnMask`,`PhaseMask`,`modelid`,`equipment_id`,`position_x`,`position_y`,`position_z`,`orientation`,`spawntimesecs`,`spawndist`,`currentwaypoint`,`curhealth`,`curmana`,`MovementType`,`npcflag`,`unit_flags`,`dynamicflags`,`VerifiedBuild`) VALUES
+(1118308,908001,1,0,0,1,1,0,0,-7207.9,1056.01,327.532,4.59111,300,0,0,108000,0,2,0,0,0,0),
+(1112166,25266,1,0,0,1,1,0,0,-7272.97,986.543,306.361,6.18204,300,0,0,42,0,2,0,0,0,0),
+(1112165,25266,1,0,0,1,1,0,0,-7272,994.955,306.361,6.18204,300,0,0,42,0,2,0,0,0,0),
+(1112163,25266,1,0,0,1,1,0,0,-7162.96,966.158,307.122,3.02317,300,0,0,42,0,2,0,0,0,0),
+(1112164,25266,1,0,0,1,1,0,0,-7273.19,989.977,306.361,6.18204,300,0,0,42,0,2,0,0,0,0),
+(1112162,25266,1,0,0,1,1,0,0,-7160.46,971.542,308.005,3.02317,300,0,0,42,0,2,0,0,0,0),
+(1112160,25266,1,0,0,1,1,0,0,-7166.61,968.537,306.36,3.02317,300,0,0,42,0,2,0,0,0,0),
+(1112161,25266,1,0,0,1,1,0,0,-7165.4,978.728,306.36,3.02317,300,0,0,42,0,2,0,0,0,0),
+(1112159,25266,1,0,0,1,1,0,0,-7166.34,970.852,306.36,3.02317,300,0,0,42,0,2,0,0,0,0),
+(1112158,25266,1,0,0,1,1,0,0,-7165.9,974.529,306.36,3.02317,300,0,0,42,0,2,0,0,0,0),
+(1112157,25266,1,0,0,1,1,0,0,-7162.03,975.112,306.944,3.02317,300,0,0,42,0,2,0,0,0,0),
+(1112145,25266,1,0,0,1,1,0,0,-7277.48,986.356,307.508,6.11808,300,0,0,42,0,2,0,0,0,0),
+(1112146,25266,1,0,0,1,1,0,0,-7277.03,989.028,307.5,6.11808,300,0,0,42,0,2,0,0,0,0),
+(1112156,25266,1,0,0,1,1,0,0,-7161.6,978.72,306.836,3.02317,300,0,0,42,0,2,0,0,0,0),
+(1112155,25266,1,0,0,1,1,0,0,-7159.16,978.43,308.144,3.02317,300,0,0,42,0,2,0,0,0,0),
+(1112152,25266,1,0,0,1,1,0,0,-7160.59,981.296,307.276,3.02317,300,0,0,42,0,2,0,0,0,0),
+(1112153,25266,1,0,0,1,1,0,0,-7158.82,981.086,308.239,3.02317,300,0,0,42,0,2,0,0,0,0),
+(1112150,25266,1,0,0,1,1,0,0,-7276.97,995.476,307.962,6.11808,300,0,0,42,0,2,0,0,0,0),
+(1112151,25266,1,0,0,1,1,0,0,-7275.67,995.258,307.121,6.11808,300,0,0,42,0,2,0,0,0,0),
+(1112149,25266,1,0,0,1,1,0,0,-7277.57,991.893,307.982,6.11808,300,0,0,42,0,2,0,0,0,0),
+(1112148,25266,1,0,0,1,1,0,0,-7275.89,991.613,307.009,6.11808,300,0,0,42,0,2,0,0,0,0),
+(1112144,25266,1,0,0,1,1,0,0,-7277.83,984.264,307.587,6.11808,300,0,0,42,0,2,0,0,0,0);
+
+/*Data for the table `creature_template` */
+
+DELETE FROM `creature_template` WHERE `entry` = 25266;
+
+INSERT INTO `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`trainer_type`,`trainer_class`,`trainer_race`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`) VALUES
+(25266,0,0,0,0,0,24818,3422,24819,24821,'Arena Gambler','','',0,255,255,0,35,0,1,1.14286,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,5,1,1,1,1,0,0,1,0,0,'',1);
+
+/*Data for the table `gameobject` */
+
+DELETE FROM `gameobject` WHERE `guid` IN (60046, 67903, 67906, 67907, 67908, 67909, 67918, 67919, 67920, 67921, 72037, 72043, 72058, 73361, 223623, 239644, 239650, 239651, 239653, 239655, 239656, 239657, 239658, 239659, 239660, 239661, 239669, 239670, 239671, 239672, 239673, 239674, 239675, 239886, 239888, 239889, 239891, 239893, 239894, 239895, 239896, 239897, 239903, 239906, 239913, 239922, 239923, 239933, 239934, 239941, 239944, 239946, 239948, 239949, 239950, 239951, 239952, 239954, 239955, 239957, 239958, 239959, 239960, 239961, 239962, 239966, 239968, 239970, 239971, 239972, 239973, 239974, 239975, 239976, 239977, 239985, 239992, 239994, 239997, 240003, 240004, 240005, 240008, 240010, 240015, 240016, 240017, 240019, 240020, 240021, 240023, 240024, 240026, 240027, 240028, 240063, 240064, 240065, 240066, 240067, 240068, 240069, 240072, 240073, 240074, 240075, 240076, 240077, 240080, 240085, 240086, 240087, 240088, 240089, 240090, 240091, 240092, 240093, 240094, 240095, 240096, 240097, 240098, 240099, 240100, 240109, 240118, 240119, 240120, 240121, 240122, 240123, 240124, 240125, 240126, 240127, 240128, 240133, 240136, 240137, 240141, 240144, 240147, 240149, 240150, 240152, 240153, 240155, 240160, 240164, 240166, 240167, 240168, 240169, 240170, 240171, 240172, 240174, 240175, 240176, 240177, 240178, 240179, 240180, 240181, 240182, 240183, 240184, 240193, 240194, 240195, 240196, 240197, 240198, 240199, 240200, 240202, 240203, 240204, 240205, 240206, 240207, 240208, 240209, 240210, 240211, 240212, 240213, 240214, 240215, 240216, 240217, 240218, 240219, 240220, 240221, 240222, 240223, 240224, 240225, 240226, 240227, 240228, 240229, 240230, 240231, 240232, 9044951, 9044969, 9044974, 9044976, 9044977, 9044978, 9044979, 9044980, 9044981, 9044982, 9045336, 9046953, 9046955, 9051186, 9055707, 9092464, 9092906, 9109862, 9109906, 9119083, 9119088, 9180717, 9180720, 9180728, 9330402, 9330403, 9347465, 9347468, 9365139, 9365229, 9365230, 9365232, 9365244, 9365245, 9365246, 9365247);
+
+INSERT INTO `gameobject`(`guid`,`id`,`map`,`zoneId`,`areaId`,`spawnMask`,`PhaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`,`VerifiedBuild`) VALUES
+(9045336,8021000,1,0,0,1,1,-7217.97,1054.25,331.856,5.24803,0,0,0.494776,-0.86902,300,0,1,0),
+(239650,8010000,1,0,0,1,1,-7218.95,982.451,299.273,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239651,8010001,1,0,0,1,1,-7218.95,982.451,299.273,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239644,8010002,0,0,0,1,1,-8942.42,-4009.48,331.64,0.943155,0,0,0.454292,0.890853,25,0,1,0),
+(239653,8010003,1,0,0,1,1,-7218.95,982.451,299.273,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(9044977,8007862,1,0,0,1,1,-7224.76,1021.03,303.523,1.40272,0,0,0.645258,0.763965,300,0,1,0),
+(9044978,8007862,1,0,0,1,1,-7201.21,1017.04,303.523,1.40272,0,0,0.645258,0.763965,300,0,1,0),
+(9044951,8007658,1,0,0,1,1,-7207.87,1056.14,327.535,4.52314,0,0,0.770754,-0.637133,300,0,1,0),
+(9046955,800342,1,0,0,1,1,-7212.74,1056.6,335.527,4.59111,0,0,0.748659,-0.662955,300,0,1,0),
+(9046953,800342,1,0,0,1,1,-7202.82,1055.39,335.527,4.59111,0,0,0.748659,-0.662955,300,0,1,0),
+(9044976,8008124,1,0,0,1,1,-7207.83,1055.98,342.182,1.41429,0,0,0.649667,0.760219,300,0,1,0),
+(9055707,8008054,1,0,0,1,1,-7137.07,970.488,329.703,1.51134,0,0,0.685777,0.727812,300,0,1,0),
+(9044974,8008054,1,0,0,1,1,-7302.17,994.336,328.471,4.55182,0,0,0.761539,-0.648119,300,0,1,0),
+(9044969,8008054,1,0,0,1,1,-7232.73,900.85,329.059,6.09277,0,0,0.0950627,-0.995471,300,0,1,0),
+(9044979,8004714,1,0,0,1,1,-7280.03,1002.39,303.523,6.13,0,0,0.0765184,-0.997068,300,0,1,0),
+(9044980,8004714,1,0,0,1,1,-7283.71,978.588,303.523,6.13,0,0,0.0765184,-0.997068,300,0,1,0),
+(9044981,8004714,1,0,0,1,1,-7155.47,985.314,303.524,6.13,0,0,0.0765184,-0.997068,300,0,1,0),
+(9044982,8004714,1,0,0,1,1,-7158.91,962.114,303.524,6.13,0,0,0.0765184,-0.997068,300,0,1,0),
+(240164,70264,1,0,0,1,1,-7211.89,921.652,307.653,3.01201,0,0,0.997902,0.0647469,25,0,1,0),
+(240166,70264,1,0,0,1,1,-7211.89,921.652,303.524,3.01201,0,0,0.997902,0.0647469,25,0,1,0),
+(240167,70264,1,0,0,1,1,-7211.64,923.561,304.714,3.01201,0,0,0.997902,0.0647469,25,0,1,0),
+(240168,70264,1,0,0,1,1,-7210.66,920.395,305.123,3.10238,0,0,0.999808,0.0196051,25,0,1,0),
+(240169,70264,1,0,0,1,1,-7210,922.433,304.547,3.52728,0,0,0.981463,-0.191651,25,0,1,0),
+(240170,70264,1,0,0,1,1,-7211.74,925.442,305.599,3.55012,0,0,0.97921,-0.202848,25,0,1,0),
+(240171,70264,1,0,0,1,1,-7211.08,927.887,303.524,2.53696,0,0,0.954649,0.297734,25,0,1,0),
+(240172,70264,1,0,0,1,1,-7210.16,925.499,303.523,0.171338,0,0,0.0855642,0.996333,25,0,1,0),
+(240174,70264,1,0,0,1,1,-7212.64,918.485,307.331,2.88561,0,0,0.99182,0.127644,25,0,1,0),
+(240175,70264,1,0,0,1,1,-7213.07,916.643,307.346,4.4564,0,0,0.791581,-0.611065,25,0,1,0),
+(240176,70264,1,0,0,1,1,-7213.5,915.324,306.69,4.4564,0,0,0.791581,-0.611065,25,0,1,0),
+(240177,70264,1,0,0,1,1,-7213.94,913.631,308.328,2.57459,0,0,0.960082,0.27972,25,0,1,0),
+(240178,70264,1,0,0,1,1,-7210.59,918.498,303.524,2.23965,0,0,0.900025,0.435839,25,0,1,0),
+(240179,70264,1,0,0,1,1,-7211,916.593,304.705,2.5813,0,0,0.961015,0.276496,25,0,1,0),
+(240180,70264,1,0,0,1,1,-7211.58,914.537,304.612,5.18568,0,0,0.521622,-0.853176,25,0,1,0),
+(240181,70264,1,0,0,1,1,-7214.78,911.262,309.84,2.45752,0,0,0.942074,0.335406,25,0,1,0),
+(240182,70264,1,0,0,1,1,-7216.24,912.227,306.76,5.43418,0,0,0.411866,-0.911244,25,0,1,0),
+(240183,70264,1,0,0,1,1,-7212.83,912.539,307.181,2.37505,0,0,0.927447,0.373954,25,0,1,0),
+(240184,70264,1,0,0,1,1,-7213.46,909.984,307.23,0.549789,0,0,0.271445,0.962454,25,0,1,0),
+(240194,70264,1,0,0,1,1,-7209.58,914.14,303.524,3.51295,0,0,0.982811,-0.184616,25,0,1,0),
+(240195,70264,1,0,0,1,1,-7208.91,916.507,303.523,3.29697,0,0,0.996984,-0.0776098,25,0,1,0),
+(240196,70264,1,0,0,1,1,-7208.91,920.253,303.524,3.50117,0,0,0.983881,-0.178823,25,0,1,0),
+(240197,70264,1,0,0,1,1,-7211.93,910.935,303.523,2.14636,0,0,0.878724,0.477331,25,0,1,0),
+(240198,70264,1,0,0,1,1,-7211.66,909.391,304.125,3.06528,0,0,0.999272,0.0381473,25,0,1,0),
+(240199,70264,1,0,0,1,1,-7243.47,918.183,306.827,2.88084,0,0,0.991513,0.130006,25,0,1,0),
+(240200,70264,1,0,0,1,1,-7242.56,920.043,306.432,6.18659,0,0,0.0482802,-0.998834,25,0,1,0),
+(240202,70264,1,0,0,1,1,-7242.34,922.252,307.37,4.61579,0,0,0.740422,-0.672143,25,0,1,0),
+(240203,70264,1,0,0,1,1,-7241.58,918.298,307.496,5.83709,0,0,0.221202,-0.975228,25,0,1,0),
+(240204,70264,1,0,0,1,1,-7242.13,920.107,308.89,6.18659,0,0,0.0482802,-0.998834,25,0,1,0),
+(240205,70264,1,0,0,1,1,-7240.56,920.002,306.682,3.3923,0,0,0.992153,-0.125027,25,0,1,0),
+(240206,70264,1,0,0,1,1,-7243.02,924.059,309.946,6.17654,0,0,0.0532979,-0.998579,25,0,1,0),
+(240207,70264,1,0,0,1,1,-7243.01,924.088,305.274,6.17654,0,0,0.0532979,-0.998579,25,0,1,0),
+(240208,70264,1,0,0,1,1,-7243.04,924.253,303.523,6.17654,0,0,0.0532979,-0.998579,25,0,1,0),
+(240209,70264,1,0,0,1,1,-7241.35,924.009,307.062,1.96681,0,0,0.83239,0.55419,25,0,1,0),
+(240210,70264,1,0,0,1,1,-7241.94,925.8,305.81,5.47362,0,0,0.393821,-0.919187,25,0,1,0),
+(240211,70264,1,0,0,1,1,-7241.6,928.466,303.523,6.04382,0,0,0.119399,-0.992846,25,0,1,0),
+(240212,70264,1,0,0,1,1,-7241.24,930.286,305.206,3.14491,0,0,0.999999,-0.00165872,25,0,1,0),
+(240213,70264,1,0,0,1,1,-7243.68,926.66,303.523,5.75479,0,0,0.261137,-0.965302,25,0,1,0),
+(240214,70264,1,0,0,1,1,-7242.97,929.298,303.523,5.94014,0,0,0.170683,-0.985326,25,0,1,0),
+(240215,70264,1,0,0,1,1,-7242.62,931.894,303.523,0.27742,0,0,0.138265,0.990395,25,0,1,0),
+(240216,70264,1,0,0,1,1,-7240.76,933.186,304.251,4.5225,0,0,0.770957,-0.636887,25,0,1,0),
+(240217,70264,1,0,0,1,1,-7240.6,934.86,303.523,1.03381,0,0,0.494194,0.869352,25,0,1,0),
+(240218,70264,1,0,0,1,1,-7240.63,927.437,308.706,3.04601,0,0,0.998858,0.0477748,25,0,1,0),
+(240219,70264,1,0,0,1,1,-7239.85,928.99,306.613,4.15651,0,0,0.873982,-0.485958,25,0,1,0),
+(240220,70264,1,0,0,1,1,-7239.49,930.882,305.622,0.293923,0,0,0.146433,0.989221,25,0,1,0),
+(240221,70264,1,0,0,1,1,-7243.6,927.232,307.087,2.75142,0,0,0.981031,0.19385,25,0,1,0),
+(240222,70264,1,0,0,1,1,-7243.98,921.131,303.523,0.378774,0,0,0.188257,0.98212,25,0,1,0),
+(240223,70264,1,0,0,1,1,-7245.03,918.867,303.523,5.00398,0,0,0.596875,-0.802334,25,0,1,0),
+(240224,70264,1,0,0,1,1,-7243.15,916.057,303.523,0.849226,0,0,0.411968,0.911198,25,0,1,0),
+(240225,70264,1,0,0,1,1,-7240.85,916.565,303.523,2.12943,0,0,0.87465,0.484755,25,0,1,0),
+(240226,70264,1,0,0,1,1,-7245.19,916.681,303.523,0.8453,0,0,0.410179,0.912005,25,0,1,0),
+(240141,8009248,1,0,0,1,1,-7226.12,929.725,303.755,0.169878,0,0,0.0848367,0.996395,25,0,1,0),
+(9119088,8009248,1,0,0,1,1,-1823.82,-4584.27,-109.975,5.70834,0,0,0.283482,-0.958978,300,0,1,0),
+(240149,8009248,1,0,0,1,1,-7227.33,920.772,306.682,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(240147,8009248,1,0,0,1,1,-7226.91,923.893,305.622,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(240144,8009248,1,0,0,1,1,-7226.49,926.943,304.55,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(9119083,8009248,1,0,0,1,1,-1823.47,-4583.57,-110.052,4.20586,0,0,0.861725,-0.507375,300,0,1,0),
+(9347465,8009248,1,0,0,1,1,6459.17,-4273.97,667.048,3.94114,0,0,0.921148,-0.389212,300,0,1,0),
+(9347468,8009248,1,0,0,1,1,6474.25,-4258.45,665.93,3.94114,0,0,0.921148,-0.389212,300,0,1,0),
+(240150,181640,1,0,0,1,1,-7228.43,912.741,306.682,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(240152,181640,1,0,0,1,1,-7235.39,917.648,306.682,0.438242,0,0,0.217372,0.976089,25,0,1,0),
+(240153,181640,1,0,0,1,1,-7220.81,916.125,306.681,2.44007,0,0,0.939112,0.343611,25,0,1,0),
+(240155,181640,1,0,0,1,1,-7218.34,922.78,306.683,2.96331,0,0,0.99603,0.0890233,25,0,1,0),
+(240160,181640,1,0,0,1,1,-7236.27,924.809,306.682,6.1303,0,0,0.0763687,-0.99708,25,0,1,0),
+(9365229,186393,1,0,0,1,1,-3067.83,2199.85,43.8142,1.85265,0,0,0.799417,0.600776,300,0,1,0),
+(9365139,186393,1,0,0,1,1,-2789.46,2291.79,53.9035,2.34029,0,0,0.920808,0.390016,300,0,1,0),
+(240010,186393,1,0,0,1,1,-7162.65,959.809,303.523,4.58374,0,0,0.751097,-0.660192,25,0,1,0),
+(240008,186393,1,0,0,1,1,-7158.73,989.066,303.524,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(239922,186393,1,0,0,1,1,-7279.56,975.823,303.523,4.57633,0,0,0.753539,-0.657403,25,0,1,0),
+(239997,186393,1,0,0,1,1,-7159.63,980.321,306.361,3.00559,0,0,0.997689,0.0679491,25,0,1,0),
+(239913,186393,1,0,0,1,1,-7275.58,1004.97,303.523,1.43885,0,0,0.658953,0.752184,25,0,1,0),
+(239923,186393,1,0,0,1,1,-7277.64,990.373,306.361,6.1613,0,0,0.0609072,-0.998143,25,0,1,0),
+(239933,186393,1,0,0,1,1,-7278.38,984.389,306.36,6.1613,0,0,0.0609072,-0.998143,25,0,1,0),
+(239934,186393,1,0,0,1,1,-7276.92,996.3,306.36,6.1613,0,0,0.0609072,-0.998143,25,0,1,0),
+(240065,186393,1,0,0,1,1,-7248.77,1032.2,306.361,3.77837,0,0,0.949741,-0.313037,25,0,1,0),
+(240080,186393,1,0,0,1,1,-7174.38,1012.29,303.523,3.79203,0,0,0.94758,-0.319518,25,0,1,0),
+(240064,186393,1,0,0,1,1,-7259.13,1024.25,306.361,0.640679,0,0,0.314889,0.949129,25,0,1,0),
+(240100,186393,1,0,0,1,1,-7262.34,949.284,303.524,0.654239,0,0,0.321317,0.946972,25,0,1,0),
+(240128,186393,1,0,0,1,1,-7187.33,939.703,303.523,2.21718,0,0,0.895071,0.445923,25,0,1,0),
+(240024,186393,1,0,0,1,1,-7252.32,1026.1,303.524,5.3627,0,0,0.444166,-0.895945,25,0,1,0),
+(239992,186393,1,0,0,1,1,-7160.45,974.339,306.361,3.00559,0,0,0.997689,0.0679491,25,0,1,0),
+(239994,186393,1,0,0,1,1,-7161.27,968.374,306.362,3.00559,0,0,0.997689,0.0679491,25,0,1,0),
+(240227,186393,1,0,0,1,1,-7176.13,1019.19,306.361,5.36606,0,0,0.442661,-0.896689,25,0,1,0),
+(240228,186393,1,0,0,1,1,-7168.2,1008.91,306.36,2.24018,0,0,0.900139,0.435603,25,0,1,0),
+(240229,186393,1,0,0,1,1,-7260.57,942.307,306.36,2.22945,0,0,0.89779,0.440424,25,0,1,0),
+(240230,186393,1,0,0,1,1,-7268.58,952.669,306.36,5.36319,0,0,0.443945,-0.896054,25,0,1,0),
+(240231,186393,1,0,0,1,1,-7180.39,941.411,306.36,3.79612,0,0,0.946925,-0.321454,25,0,1,0),
+(240232,186393,1,0,0,1,1,-7190.67,933.47,306.36,0.654529,0,0,0.321454,0.946925,25,0,1,0),
+(9365230,186393,1,0,0,1,1,-3077.56,2197.23,42.7844,1.83087,0,0,0.792826,0.609448,300,0,1,0),
+(9365232,186393,1,0,0,1,1,-3504.66,2071.59,42.6084,1.13352,0,0,0.536904,0.843644,300,0,1,0),
+(9365244,186393,1,0,0,1,1,-4759.7,1584.99,84.6154,0.124395,0,0,0.0621572,0.998066,300,0,1,0),
+(9365245,186393,1,0,0,1,1,-4758.94,1578.86,85.7949,0.124395,0,0,0.0621572,0.998066,300,0,1,0),
+(9365246,186393,1,0,0,1,1,-4758.17,1572.71,87.2961,0.124395,0,0,0.0621572,0.998066,300,0,1,0),
+(9365247,186393,1,0,0,1,1,-4757.39,1566.47,87.6473,0.124395,0,0,0.0621572,0.998066,300,0,1,0),
+(60046,188596,571,0,0,1,1,3404.73,-5394.46,267.362,1.18682,0,0,0,1,300,100,0,0),
+(239948,188596,1,0,0,1,1,-7164.57,975.06,303.523,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(239950,188596,1,0,0,1,1,-7163.66,981.741,303.523,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(240026,188596,1,0,0,1,1,-7257.12,1032.41,303.524,5.3627,0,0,0.444166,-0.895945,25,0,1,0),
+(240090,188596,1,0,0,1,1,-7268.73,944.317,303.523,0.654239,0,0,0.321317,0.946972,25,0,1,0),
+(240015,188596,1,0,0,1,1,-7255.01,1029.64,303.524,5.3627,0,0,0.444165,-0.895945,25,0,1,0),
+(240091,188596,1,0,0,1,1,-7270.72,946.901,303.523,0.654239,0,0,0.321317,0.946972,25,0,1,0),
+(239658,188596,1,0,0,1,1,-7276.42,1000.47,303.523,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239657,188596,1,0,0,1,1,-7276.87,997.127,303.523,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239656,188596,1,0,0,1,1,-7277.33,993.788,303.523,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239655,188596,1,0,0,1,1,-7277.78,990.448,303.523,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239669,188596,1,0,0,1,1,-7273.63,989.883,303.523,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239661,188596,1,0,0,1,1,-7279.1,980.338,303.523,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239670,188596,1,0,0,1,1,-7273.17,993.224,303.523,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239672,188596,1,0,0,1,1,-7272.26,999.903,303.523,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239659,188596,1,0,0,1,1,-7278.22,987.078,303.523,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239660,188596,1,0,0,1,1,-7278.66,983.707,303.523,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239671,188596,1,0,0,1,1,-7272.72,996.564,303.523,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239673,188596,1,0,0,1,1,-7274.08,986.518,303.524,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239674,188596,1,0,0,1,1,-7274.54,983.151,303.524,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239675,188596,1,0,0,1,1,-7275,979.786,303.524,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239949,188596,1,0,0,1,1,-7164.12,978.4,303.523,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(240077,188596,1,0,0,1,1,-7166.01,1014.58,303.523,3.79203,0,0,0.94758,-0.319518,25,0,1,0),
+(239960,188596,1,0,0,1,1,-7160.4,974.416,303.524,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(239951,188596,1,0,0,1,1,-7163.21,985.081,303.523,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(240028,188596,1,0,0,1,1,-7259.67,1030.47,303.523,5.3627,0,0,0.444166,-0.895945,25,0,1,0),
+(239958,188596,1,0,0,1,1,-7161.31,967.734,303.524,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(240068,188596,1,0,0,1,1,-7168.78,1012.46,303.524,3.79203,0,0,0.94758,-0.319518,25,0,1,0),
+(240069,188596,1,0,0,1,1,-7174.66,1020.19,303.524,3.79203,0,0,0.94758,-0.319518,25,0,1,0),
+(240072,188596,1,0,0,1,1,-7166.81,1009.87,303.523,3.79203,0,0,0.94758,-0.319518,25,0,1,0),
+(240067,188596,1,0,0,1,1,-7170.75,1015.05,303.524,3.79203,0,0,0.94758,-0.319518,25,0,1,0),
+(240066,188596,1,0,0,1,1,-7172.72,1017.64,303.524,3.79203,0,0,0.94758,-0.319518,25,0,1,0),
+(239961,188596,1,0,0,1,1,-7159.95,977.758,303.524,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(239955,188596,1,0,0,1,1,-7165.94,964.962,303.524,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(239957,188596,1,0,0,1,1,-7161.76,964.393,303.523,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(240027,188596,1,0,0,1,1,-7254.53,1034.39,303.524,5.3627,0,0,0.444166,-0.895945,25,0,1,0),
+(240075,188596,1,0,0,1,1,-7169.95,1019.76,303.523,3.79203,0,0,0.94758,-0.319518,25,0,1,0),
+(239966,188596,1,0,0,1,1,-7159.03,984.508,303.524,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(239962,188596,1,0,0,1,1,-7159.49,981.1,303.524,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(239952,188596,1,0,0,1,1,-7165.03,971.695,303.524,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(239959,188596,1,0,0,1,1,-7160.85,971.074,303.524,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(239954,188596,1,0,0,1,1,-7165.49,968.329,303.524,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(240124,188596,1,0,0,1,1,-7179.38,939.825,303.523,1.78622,0,0,0.779027,0.626991,25,0,1,0),
+(240125,188596,1,0,0,1,1,-7189.66,932.069,303.523,2.21718,0,0,0.895071,0.445923,25,0,1,0),
+(240092,188596,1,0,0,1,1,-7267.97,949.005,303.523,0.654239,0,0,0.321317,0.946972,25,0,1,0),
+(240098,188596,1,0,0,1,1,-7262.1,941.384,303.524,0.654239,0,0,0.321317,0.946972,25,0,1,0),
+(240099,188596,1,0,0,1,1,-7259.35,943.486,303.524,0.654239,0,0,0.321317,0.946972,25,0,1,0),
+(240096,188596,1,0,0,1,1,-7266.02,946.459,303.524,0.654239,0,0,0.321317,0.946972,25,0,1,0),
+(240097,188596,1,0,0,1,1,-7264.05,943.929,303.524,0.654239,0,0,0.321317,0.946972,25,0,1,0),
+(240095,188596,1,0,0,1,1,-7266.78,941.771,303.524,0.654239,0,0,0.321317,0.946972,25,0,1,0),
+(240094,188596,1,0,0,1,1,-7267.21,953.693,303.523,0.654239,0,0,0.321317,0.946972,25,0,1,0),
+(240121,188596,1,0,0,1,1,-7187.05,934.013,303.523,2.21718,0,0,0.895071,0.445923,25,0,1,0),
+(240093,188596,1,0,0,1,1,-7269.95,951.589,303.523,0.654239,0,0,0.321317,0.946972,25,0,1,0),
+(240127,188596,1,0,0,1,1,-7181.46,942.585,303.523,2.57948,0,0,0.960763,0.27737,25,0,1,0),
+(240120,188596,1,0,0,1,1,-7184.97,931.254,303.523,2.21718,0,0,0.895071,0.445923,25,0,1,0),
+(240119,188596,1,0,0,1,1,-7179.81,935.147,303.524,2.21718,0,0,0.895071,0.445923,25,0,1,0),
+(240123,188596,1,0,0,1,1,-7181.94,937.892,303.523,2.21718,0,0,0.895071,0.445923,25,0,1,0),
+(240126,188596,1,0,0,1,1,-7191.74,934.827,303.523,2.21718,0,0,0.895071,0.445923,25,0,1,0),
+(240118,188596,1,0,0,1,1,-7182.37,933.215,303.524,2.21718,0,0,0.895071,0.445923,25,0,1,0),
+(240122,188596,1,0,0,1,1,-7184.5,935.96,303.523,2.21718,0,0,0.895071,0.445923,25,0,1,0),
+(240076,188596,1,0,0,1,1,-7167.98,1017.17,303.523,3.79203,0,0,0.94758,-0.319518,25,0,1,0),
+(240017,188596,1,0,0,1,1,-7260.11,1025.76,303.524,5.3627,0,0,0.444165,-0.895945,25,0,1,0),
+(240021,188596,1,0,0,1,1,-7247.73,1030.83,303.524,5.3627,0,0,0.444165,-0.895945,25,0,1,0),
+(240020,188596,1,0,0,1,1,-7249.82,1033.58,303.524,5.3627,0,0,0.444165,-0.895945,25,0,1,0),
+(240019,188596,1,0,0,1,1,-7252.42,1031.61,303.524,5.3627,0,0,0.444165,-0.895945,25,0,1,0),
+(240023,188596,1,0,0,1,1,-7258.02,1023.01,303.523,5.3627,0,0,0.444165,-0.895945,25,0,1,0),
+(240016,188596,1,0,0,1,1,-7257.56,1027.7,303.524,5.3627,0,0,0.444165,-0.895945,25,0,1,0),
+(240073,188596,1,0,0,1,1,-7169.55,1007.76,303.523,3.79203,0,0,0.94758,-0.319518,25,0,1,0),
+(240074,188596,1,0,0,1,1,-7177.41,1018.09,303.523,3.79203,0,0,0.94758,-0.319518,25,0,1,0),
+(240193,70264,1,0,0,1,1,-7210.52,912.412,304.893,2.5155,0,0,0.9514,0.307959,25,0,1,0),
+(239891,178764,1,0,0,1,1,-7272.6,985.626,306.361,6.1481,0,0,0.0674923,-0.99772,25,0,1,0),
+(239897,178764,1,0,0,1,1,-7270.77,999.019,306.36,6.1481,0,0,0.0674923,-0.99772,25,0,1,0),
+(239896,178764,1,0,0,1,1,-7271.12,996.481,306.36,6.1481,0,0,0.0674923,-0.99772,25,0,1,0),
+(239893,178764,1,0,0,1,1,-7272.26,988.172,306.361,6.1481,0,0,0.0674923,-0.99772,25,0,1,0),
+(239895,178764,1,0,0,1,1,-7271.48,993.817,306.361,6.1481,0,0,0.0674923,-0.99772,25,0,1,0),
+(239894,178764,1,0,0,1,1,-7271.88,990.953,306.361,6.1481,0,0,0.0674923,-0.99772,25,0,1,0),
+(239888,178764,1,0,0,1,1,-7273.33,980.292,306.361,6.1481,0,0,0.0674923,-0.99772,25,0,1,0),
+(239889,178764,1,0,0,1,1,-7272.95,983.06,306.361,6.1481,0,0,0.0674923,-0.99772,25,0,1,0),
+(239886,178764,1,0,0,1,1,-7273.7,977.636,306.361,6.1481,0,0,0.0674923,-0.99772,25,0,1,0),
+(239906,178764,1,0,0,1,1,-7276.49,978.036,306.361,4.59361,0,0,0.747829,-0.663891,25,0,1,0),
+(239903,178764,1,0,0,1,1,-7270.44,1001.47,306.36,1.43885,0,0,0.658953,0.752184,25,0,1,0),
+(239946,178764,1,0,0,1,1,-7281.08,978.658,306.36,6.14417,0,0,0.0694537,-0.997585,25,0,1,0),
+(239968,178764,1,0,0,1,1,-7164.82,986.986,306.36,3.01043,0,0,0.99785,0.0655325,25,0,1,0),
+(239972,178764,1,0,0,1,1,-7165.9,978.853,306.36,3.01043,0,0,0.99785,0.0655325,25,0,1,0),
+(239977,178764,1,0,0,1,1,-7167.68,965.418,306.36,3.01043,0,0,0.99785,0.0655325,25,0,1,0),
+(239975,178764,1,0,0,1,1,-7166.97,970.755,306.36,3.01043,0,0,0.99785,0.0655325,25,0,1,0),
+(9051186,178764,1,0,0,1,1,-7168,963.017,306.36,4.61838,0,0,0.739552,-0.6731,300,0,1,0),
+(239973,178764,1,0,0,1,1,-7166.25,976.209,306.36,3.01043,0,0,0.99785,0.0655325,25,0,1,0),
+(239971,178764,1,0,0,1,1,-7165.54,981.532,306.36,3.01043,0,0,0.99785,0.0655325,25,0,1,0),
+(239974,178764,1,0,0,1,1,-7166.62,973.406,306.36,3.01043,0,0,0.99785,0.0655325,25,0,1,0),
+(239970,178764,1,0,0,1,1,-7165.18,984.315,306.36,3.01043,0,0,0.99785,0.0655325,25,0,1,0),
+(239985,178764,1,0,0,1,1,-7161.79,986.521,306.361,1.42079,0,0,0.652132,0.758105,25,0,1,0),
+(239976,178764,1,0,0,1,1,-7167.32,968.097,306.36,3.01043,0,0,0.99785,0.0655325,25,0,1,0),
+(67907,194593,571,0,0,1,1,8460.36,927.153,544.916,3.14159,0,0,0,1,180,255,1,0),
+(239944,194593,1,0,0,1,1,-7278.25,996.463,308.409,6.1613,0,0,0.0609072,-0.998143,25,0,1,0),
+(67909,194595,571,0,0,1,1,8459.95,992.174,544.922,-2.94959,0,0,0,1,180,255,1,0),
+(239941,194595,1,0,0,1,1,-7279.28,990.573,308.462,6.1613,0,0,0.0609072,-0.998143,25,0,1,0),
+(67903,194589,571,0,0,1,1,8439.42,1010.37,544.698,-1.50971,0,0,0,1,180,255,1,0),
+(73361,194589,571,0,0,1,1,8439.42,1010.37,544.698,-1.50971,0,0,0,0,0,0,1,0),
+(9180728,194589,1,0,0,1,1,-7279.68,984.602,308.397,6.1613,0,0,0.0609048,-0.998144,300,0,1,0),
+(223623,170592,1,0,0,1,1,-1824.72,-4583.54,-115.128,4.53332,0,0,0.767499,-0.64105,25,0,1,0),
+(240063,170592,1,0,0,1,1,-7256.76,1032,307.052,5.3627,0,0,0.444166,-0.895945,25,0,1,0),
+(240085,170592,1,0,0,1,1,-7168.76,1016.56,306.909,3.79203,0,0,0.94758,-0.319518,25,0,1,0),
+(240109,170592,1,0,0,1,1,-7268.44,944.602,307.092,0.654239,0,0,0.321317,0.946972,25,0,1,0),
+(240133,170592,1,0,0,1,1,-7182.67,933.532,306.979,2.21718,0,0,0.895071,0.445923,25,0,1,0),
+(9092906,170592,1,0,0,1,1,-9781.68,-2860.63,119.206,0.279273,0,0,0.139183,0.990267,300,0,1,0),
+(9092464,170592,1,0,0,1,1,-7310.55,2233.88,72.4531,0.480897,0,0,0.238138,0.971231,300,0,1,0),
+(9109862,170592,1,0,0,1,1,5855.94,-1995.04,689.745,5.42784,0,0,0.414754,-0.909934,300,0,1,0),
+(9109906,170592,1,0,0,1,1,5871.12,-2012.51,689.701,2.28655,0,0,0.909997,0.414615,300,0,1,0),
+(9330403,170592,1,0,0,1,1,-5082.57,-1103.69,87.1186,0.534018,0,0,0.263848,0.964564,300,0,1,0),
+(9330402,170592,1,0,0,1,1,-5060.65,-1089.75,86.936,3.74954,0,0,0.954155,-0.299314,300,0,1,0),
+(67920,194606,571,0,0,1,1,8307.43,705.927,553.644,0.253072,0,0,0,1,180,255,1,0),
+(240136,194606,1,0,0,1,1,-7272.44,946.637,306.36,0.654239,0,0,0.321317,0.946972,25,0,1,0),
+(240137,194606,1,0,0,1,1,-7267.45,940.127,306.361,0.654239,0,0,0.321317,0.946972,25,0,1,0),
+(67908,194594,571,0,0,1,1,8460.08,950.043,545.051,-3.09792,0,0,0,1,180,255,1,0),
+(9180720,194594,1,0,0,1,1,-7184.78,929.577,306.361,2.21718,0,0,0.895071,0.445924,300,0,1,0),
+(9180717,194594,1,0,0,1,1,-7178.15,934.61,306.362,2.24088,0,0,0.900292,0.435286,300,0,1,0),
+(67921,194607,571,0,0,1,1,8338.74,687.096,553.701,1.59698,0,0,0,1,180,255,1,0),
+(240004,194607,1,0,0,1,1,-7159.92,968.19,308.414,3.00559,0,0,0.997689,0.0679491,25,0,1,0),
+(67919,194605,571,0,0,1,1,8319.33,744.352,553.701,-0.98611,0,0,0,1,180,255,1,0),
+(240003,194605,1,0,0,1,1,-7158.89,974.126,308.49,3.00559,0,0,0.997689,0.0679491,25,0,1,0),
+(67918,194604,571,0,0,1,1,8357.72,744.694,553.627,-2.30383,0,0,0,1,180,255,1,0),
+(240005,194604,1,0,0,1,1,-7158.29,979.98,308.413,3.00559,0,0,0.997689,0.0679491,25,0,1,0),
+(72058,194592,571,0,0,1,1,8458.11,905.744,546.489,2.82392,0,0,0.987412,0.158169,30,0,1,0),
+(72043,194592,571,0,0,1,1,8670.57,692.054,547.522,1.89567,0,0,0.812154,0.583443,30,0,1,0),
+(67906,194592,571,0,0,1,1,8459.21,905.564,545.516,2.75761,0,0,0,1,180,255,1,0),
+(240088,194592,1,0,0,1,1,-7164.78,1014.48,306.361,3.79203,0,0,0.94758,-0.319518,25,0,1,0),
+(240089,194592,1,0,0,1,1,-7169.75,1021,306.36,3.79203,0,0,0.94758,-0.319518,25,0,1,0),
+(72037,194608,571,0,0,1,1,8368.94,708.93,553.772,2.93164,0,0,0.994495,0.104784,30,0,1,0),
+(240087,194608,1,0,0,1,1,-7254.69,1036.01,306.361,5.3627,0,0,0.444166,-0.895945,25,0,1,0),
+(240086,194608,1,0,0,1,1,-7261.24,1031,306.36,5.3627,0,0,0.444166,-0.895945,25,0,1,0);
+
+/*Data for the table `gameobject_template` */
+
+DELETE FROM `gameobject_template` WHERE `entry` IN (8021000, 8010000, 8010001, 8010002, 8010003, 8007862, 8007658, 800342, 8008124, 8008054, 8004714, 8009248, 181640, 186393, 188596, 70264, 178764, 194593, 194595, 194589, 170592, 194606, 194594, 194607, 194605, 194604, 194592, 194608);
+
+INSERT INTO `gameobject_template`(`entry`,`type`,`displayId`,`name`,`IconName`,`castBarCaption`,`unk1`,`faction`,`flags`,`size`,`data0`,`data1`,`data2`,`data3`,`data4`,`data5`,`data6`,`data7`,`data8`,`data9`,`data10`,`data11`,`data12`,`data13`,`data14`,`data15`,`data16`,`data17`,`data18`,`data19`,`data20`,`data21`,`data22`,`data23`,`AIName`,`ScriptName`,`VerifiedBuild`) VALUES
+(8021000,10,8520,'Arena Records','','','',0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','duel_records_system',1),
+(8010000,33,9276,'Arena 0','','','',0,0,1.4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(8010001,33,9256,'Arena 1','','','',0,0,1.4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(8010002,33,9257,'Arena 2','','','',0,0,1.4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(8010003,33,9258,'Arena 3','','','',0,0,1.4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(8007862,5,7862,'Arena Bonfire','','','',0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(8007658,5,7658,'Arena Earth Rune','','','',0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(800342,5,342,'Arena Wall Rune','','','',0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(8008124,5,8124,'Arena Eye of Acherus','','','',0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(8008054,5,8054,'Arena Skull of Acherus','','','',0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(8004714,5,4714,'Arena Light Powersource','','','',0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(8009248,5,9248,'Arena Flat Steel','','','',0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(181640,7,6690,'Arena Throne','','','',0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(186393,5,6725,'Arena Bleachers','','','',0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(188596,5,7812,'Arena Pedestal','','','',0,4,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(70264,5,6752,'Arena Ice Block','','','',0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(178764,5,5453,'Arena Rope Line','','','',0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(194593,5,8620,'Ironforge Banner','','','',0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(194595,5,8616,'Darnassus Banner','','','',0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(194589,5,8617,'Exodar Banner','','','',0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(170592,7,2810,'Arena Throne','','','',0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(194606,5,8615,'Horde Banner','','','',0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(194594,5,8623,'Alliance Banner','','','',0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(194607,5,8621,'Orgrimmar Banner','','','',0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(194605,5,8622,'Silvermoon City Banner','','','',0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(194604,5,8624,'Thunder Bluff Banner','','','',0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(194592,5,8619,'Gnomeregan Banner','','','',0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(194608,5,8618,'Undercity Banner','','','',0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1);
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
index 4ea8583..ce51d53 100644
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -1415,7 +1415,8 @@ void AddBattlegroundScripts()
 // start02
 // start03
 // start04
-// start05
+// Arena Gambler
+void AddSC_ArenaGambler();
 // start06
 // start07
 // start08
@@ -1541,7 +1542,8 @@ void AddCustomScripts()
 // end02
 // end03
 // end04
-// end05
+    // Arena Gambler
+    AddSC_ArenaGambler();
 // end06
 // end07
 // end08
diff --git a/src/server/scripts/Custom/ArenaGambler.cpp b/src/server/scripts/Custom/ArenaGambler.cpp
new file mode 100644
index 0000000..366b473
--- /dev/null
+++ b/src/server/scripts/Custom/ArenaGambler.cpp
@@ -0,0 +1,308 @@
+/*
+ * Author: Xees
+ * FileName: ArenaGambler.cpp
+ * Description: This file is used to script the npc for the Arena Gambling System
+ * Version: 1.9
+ * Status: functional
+*/
+
+#include "ArenaGamblingSystem.h"
+#include "ScriptMgr.h"
+#include "Player.h"
+
+class ArenaGambler : public CreatureScript
+{
+    public:
+        ArenaGambler() : CreatureScript(ARENA_GAMBLER_SCRIPT_NAME) {}
+        bool OnGossipHello(Player *pPlayer, Creature *pCreature)
+        {
+            switch (urand(0,6))
+            {
+                case 0: pCreature->Say("|cffbbbbbbWelcome ye great warrior , fight to the last for the Lich King!",LANG_UNIVERSAL,pPlayer); break;
+                case 1: pCreature->Say("|cffbbbbbbOnly great warriors are welcome!",LANG_UNIVERSAL,pPlayer); break;
+                case 2: pCreature->Say("|cffbbbbbbMere mortals cannot be gods!",LANG_UNIVERSAL,pPlayer); break;
+                case 3: pCreature->Say("|cffbbbbbbGreat warrior , you seek to duel!",LANG_UNIVERSAL,pPlayer); break;
+                case 4: pCreature->Say("|cffbbbbbbDeath and glory await!",LANG_UNIVERSAL,pPlayer); break;
+                case 5: pCreature->Say("|cffbbbbbbBegone, weaklings are unwelcome!",LANG_UNIVERSAL,pPlayer); break;
+                case 6: pCreature->Say("|cffbbbbbbDeath and honor!",LANG_UNIVERSAL,pPlayer); break;
+            }
+                pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_ITEM, ARENA_GAMBLER_MENU_MAIN, GOSSIP_ACTION_INFO_DEF + 1, "", false);
+                pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+
+            return true;
+        }
+
+        bool OnGossipSelect(Player *pPlayer, Creature *pCreature, uint32 sender, uint32 action)
+        {
+            pPlayer->PlayerTalkClass->ClearMenus();
+            switch(sender)
+            {
+                case ARENA_GAMBLER_MENU_MAIN:
+                {
+                    if(GamblerMatchData *matchData = sGamblingSystem->GetMatchDataBy(pPlayer))
+                    {
+                            if(matchData->MatchStarted())
+                                return true;
+                            if(matchData->GetItemIdBy(pPlayer) == 0) // if there is match data, but no item was bet
+                                pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM,    ARENA_GAMBLER_TEXT_BET_ITEM,            ARENA_GAMBLER_MENU_BET_ITEM,            GOSSIP_ACTION_INFO_DEF + 1, ARENA_GAMBLER_TEXT_BET_ITEM_CODE_TEXT, 0, true);
+                            if(matchData->GetItemIdBy(pPlayer) != 0 && matchData->GetItemCountBy(pPlayer) == 0) // if there is match data and an item, but no amount was entered
+                            pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM,    ARENA_GAMBLER_TEXT_BET_ITEM_AMOUNT,    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT,    GOSSIP_ACTION_INFO_DEF + 1, "", false);
+                            if(matchData->GetChallengerItemId() && matchData->GetDefenderItemId() && matchData->GetItemCountBy(pPlayer) != 0 &&  matchData->HasSetReady(pPlayer) == false) // if everything checks out, but player is not yet ready.
+                                pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_ACCEPT,    ARENA_GAMBLER_TEXT_ACCEPT_CHALLENGE,    ARENA_GAMBLER_MENU_ACCEPT_CHALLENGE,    GOSSIP_ACTION_INFO_DEF + 1, "", false);
+                            if(matchData->GetChallengerGUID() == pPlayer->GetGUID().GetCounter())
+                                pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_CANCEL,    ARENA_GAMBLER_TEXT_CANCEL_CHALLENGE,    ARENA_GAMBLER_MENU_CANCEL_CHALLENGE,    GOSSIP_ACTION_INFO_DEF + 1, "", false);
+                            else
+                                pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_DECLINE,    ARENA_GAMBLER_TEXT_DECLINE_CHALLENGE,    ARENA_GAMBLER_MENU_DECLINE_CHALLENGE,    GOSSIP_ACTION_INFO_DEF + 1, "", false);
+                        }
+                        else // if no match data was found
+                        {
+                            pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_CHALLENGE, ARENA_GAMBLER_TEXT_CHALLENGE, ARENA_GAMBLER_MENU_CHALLENGE_PLAYER, GOSSIP_ACTION_INFO_DEF + 1, ARENA_GAMBLER_TEXT_CHALLENGE_CODE_TEXT, 0, true);
+                        }
+                        pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_EXIT, ARENA_GAMBLER_TEXT_EXIT, ARENA_GAMBLER_MENU_EXIT, GOSSIP_ACTION_INFO_DEF + 1, "", false);
+                        pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+
+                }break;
+                case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT:
+                {
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_1, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_1, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_10, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_10, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_20, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_20, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_30, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_30, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_40, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_40, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_50, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_50, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_100, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_100, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_200, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_200, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_300, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_300, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_500, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_500, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_1000, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_1000, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_EXIT, ARENA_GAMBLER_TEXT_EXIT, ARENA_GAMBLER_MENU_EXIT, GOSSIP_ACTION_INFO_DEF + 1, "", false);
+                    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+                }break;
+                    case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_1:
+                    {
+                        if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 1) == false)
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                        else
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                        pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+                    case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_10:
+                    {
+                        if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 10) == false)
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                        else
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                        pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+                    case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_20:
+                    {
+                        if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 20) == false)
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                        else
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                        pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+                    case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_30:
+                    {
+                        if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 30) == false)
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                        else
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                        pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+                    case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_40:
+                    {
+                        if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 40) == false)
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                        else
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                        pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+                    case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_50:
+                {
+                    if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 50) == false)
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                }break;
+                case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_100:
+                {
+                    if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 100) == false)
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                }break;
+                case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_200:
+                {
+                    if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 200) == false)
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                }break;
+                case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_300:
+                {
+                    if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 300) == false)
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                }break;
+                case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_500:
+                {
+                    if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 500) == false)
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                }break;
+                case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_1000:
+                {
+                    if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 1000) == false)
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                }break;
+                case ARENA_GAMBLER_MENU_ACCEPT_CHALLENGE:
+                    {
+                        sGamblingSystem->AcceptChallenge(pPlayer);
+                        pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+                case ARENA_GAMBLER_MENU_CANCEL_CHALLENGE:
+                case ARENA_GAMBLER_MENU_DECLINE_CHALLENGE:
+                    {
+                    sGamblingSystem->CancelChallenge(pPlayer);
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+                case ARENA_GAMBLER_MENU_EXIT:{
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+            }
+
+            return true;
+        }
+
+        bool OnGossipSelectCode(Player *pPlayer, Creature *pCreature, uint32 sender, uint32 action, const char *pCode)
+        {
+            switch(sender)
+            {
+                case ARENA_GAMBLER_MENU_CHALLENGE_PLAYER:
+                {
+                    if(Player* pDefender = ObjectAccessor::FindPlayerByName(pCode))
+                    {
+                        if(sGamblingSystem->CanHaveMatch(pPlayer, pDefender) == false)
+                        {
+                            // General Error Message: Match not possible because:
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_MATCH_NOT_POSSIBLE);
+                            // Reason is: no gamemasters
+                            if(pPlayer->GetSession()->GetSecurity() > 0 || pDefender->GetSession()->GetSecurity() > 0)
+                            {
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_NO_GMS_ALLOWED);
+                            }
+                            // Reason is: you cannot duel your self!
+                            if(pPlayer->GetSession()->GetAccountId() == pDefender->GetSession()->GetAccountId())
+                            {
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_SAME_ACC_ID);
+                            }
+                            // Reason is: multiboxing is not allowed, or players have the same ip.
+                            if(pPlayer->GetSession()->GetRemoteAddress().compare(pDefender->GetSession()->GetRemoteAddress()) == 0)
+                            {
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_MULTI_BOX);
+                            }
+                            // Reason is: your level is smaller than the minimum level required
+                            uint32 m_minRequiredLevel = 0;
+                            if(pPlayer->getLevel() <= m_minRequiredLevel || pDefender->getLevel() <= m_minRequiredLevel )
+                            {
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_LOW_LEVEL);
+                            }
+                            // Reason is: you are requesting a duel from someone who already is in a duel.
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_LOW_LEVEL);
+                            // Reason is: level diffrance is too high
+                            uint32 levelDiff = 0;
+                            if(pPlayer->getLevel() > pDefender->getLevel())
+                            {
+                                levelDiff = pPlayer->getLevel() - pDefender->getLevel();
+                            }
+                            else
+                            {
+                                levelDiff = pDefender->getLevel() - pPlayer->getLevel();
+                            }
+                            return true;
+                        }
+                        sGamblingSystem->SetupMatch(pPlayer, pDefender);
+                        pPlayer->GetSession()->SendAreaTriggerMessage(ARENA_GAMBLER_MSG_CHALLENGE_ISSUED, pDefender);
+                        pDefender->GetSession()->SendAreaTriggerMessage(ARENA_GAMBLER_MSG_CHALLENGED, pPlayer);
+                        OnGossipSelect(pPlayer, pCreature, ARENA_GAMBLER_MENU_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
+                    }
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_PLAYER_NOT_FOUND);
+                }break;
+
+                case ARENA_GAMBLER_MENU_BET_ITEM:
+                {
+                    if(sGamblingSystem->AddItemForMatch(pPlayer, pCode) == false)
+                        pPlayer->GetSession()->SendAreaTriggerMessage(ARENA_GAMBLER_MSG_ITEM_ADD_FAILED);
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_ADD_SUCCESS);
+                    OnGossipSelect(pPlayer, pCreature, ARENA_GAMBLER_MENU_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
+                }break;
+            }
+            return true;
+        }
+};
+
+// Arena Records GameObject
+class ArenaRecords : public GameObjectScript
+{ public:
+    ArenaRecords() : GameObjectScript(ARENA_RECORDS_SCRIPT_NAME) { }
+    bool OnGossipHello(Player* pPlayer, GameObject* pGo)
+    {
+        if(QueryResult queryResult = CharacterDatabase.PQuery("SELECT `playerGUID`,`duelsLost`,`duelsWon`,`duelsRefused`,`duelsTotal` FROM `custom_duel_statistics` WHERE `playerGUID` = '%u'", pPlayer->GetGUID().GetCounter()))
+        {
+            uint32 playerGUID = queryResult->Fetch()[0].GetUInt32();
+            uint32 duelsLost = queryResult->Fetch()[1].GetUInt32();
+            uint32 duelsWon = queryResult->Fetch()[2].GetUInt32();
+            uint32 duelsRefused = queryResult->Fetch()[3].GetUInt32();
+            uint32 duelsTotal = queryResult->Fetch()[4].GetUInt32();
+
+            std::ostringstream Lost;
+            std::ostringstream Won;
+            std::ostringstream Refused;
+            std::ostringstream Total;
+
+            Lost << MSG_COLOR_SUBWHITE << "You have Lost : " << MSG_COLOR_LIGHTBLUE <<  duelsLost << " Duel(s)." ;
+            Won << MSG_COLOR_SUBWHITE << "You have Won : " << MSG_COLOR_LIGHTBLUE <<  duelsWon << " Duel(s)." ;
+            Refused << MSG_COLOR_SUBWHITE << "You have Refused : " << MSG_COLOR_LIGHTBLUE <<  duelsRefused << " Duel(s)." ;
+            Total << MSG_COLOR_SUBWHITE << "You have Fought : " << MSG_COLOR_LIGHTBLUE <<  duelsTotal << " Duel(s)." ;
+
+            ChatHandler(pPlayer->GetSession()).SendSysMessage(Lost.str( ).c_str( ));
+            ChatHandler(pPlayer->GetSession()).SendSysMessage(Won.str( ).c_str( ));
+            ChatHandler(pPlayer->GetSession()).SendSysMessage(Refused.str( ).c_str( ));
+            ChatHandler(pPlayer->GetSession()).SendSysMessage(Total.str( ).c_str( ));
+        }
+        else
+        {
+            switch (urand(0,5))
+            {
+            case 0: pPlayer->Say("I never fought once , i should be ashamed.",LANG_UNIVERSAL,pPlayer);break;
+            case 1: pPlayer->Say("This book does not hold any records of me!",LANG_UNIVERSAL,pPlayer);break;
+            case 2: pPlayer->Say("i have never challenged anyone here!",LANG_UNIVERSAL,pPlayer);break;
+            case 3: pPlayer->Say("I should first challenge someone!",LANG_UNIVERSAL,pPlayer);break;
+            case 4: pPlayer->Say("No Wins, No losses",LANG_UNIVERSAL,pPlayer);break;
+            case 5: pPlayer->Say("I should hide in a cave, i don't deserve to be here!",LANG_UNIVERSAL,pPlayer);break;
+            }
+        }
+        return true;
+    }
+};
+
+void AddSC_ArenaGambler()
+{
+    sGamblingSystem->Initalize();
+    new ArenaGambler();
+    new ArenaRecords();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/ArenaGamblingSystem.cpp b/src/server/scripts/Custom/ArenaGamblingSystem.cpp
new file mode 100644
index 0000000..eba6f78
--- /dev/null
+++ b/src/server/scripts/Custom/ArenaGamblingSystem.cpp
@@ -0,0 +1,723 @@
+/*
+ * Author: Xees
+ * FileName: ArenaGamblingSystem.cpp
+ * Description: This file is used to script the Arena Gambling System
+ * Version: 1.9
+ * Status: functional
+*/
+
+#include "ArenaGamblingSystem.h"
+
+using namespace std;
+
+const char *GamblerPlayerStatFields[GAMBLER_PLAYER_STAT_MAX] =
+{
+    "playerGUID",
+    "duelsLost",
+    "duelsWon",
+    "duelsRefused",
+    "duelsTotal"
+};
+
+GamblingSystem::GamblingSystem() : WorldScript(GAMBLER_SYSTEM_SCRIPT_NAME)
+{
+    m_checkMatches.SetInterval(GAMBLER_SYSTEM_INTERVAL_TELE_CHECK);
+}
+
+GamblingSystem::~GamblingSystem()
+{
+    AcquireMatchLock();
+    GamblerMatchMap::iterator Itr;
+    for(Itr = m_matchStorage.begin(); Itr != m_matchStorage.end(); ++Itr)
+        delete Itr->second;
+    m_matchStorage.clear();
+    ReleaseMatchLock();
+}
+
+// Creation
+void GamblingSystem::Initalize()
+{
+    LoadConfigData();
+    _loadPastMatches();
+    new GamblerDuelScript();
+}
+
+// Events
+// Called on every world tick (don't execute too heavy code here).
+void GamblingSystem::OnUpdate(uint32 diff)
+{
+    if(m_checkMatches.GetCurrent() >= 0)
+        m_checkMatches.Update(diff);
+    else
+        m_checkMatches.SetCurrent(0);
+    if(m_checkMatches.Passed())
+        m_checkMatches.Reset();
+
+    AcquireMatchLock();
+    GamblerMatchMap::iterator Itr;
+    for(Itr = m_matchStorage.begin(); Itr != m_matchStorage.end(); ++Itr)
+    {
+        if(Itr->second->GetMatchStatus() != GAMBLER_MATCH_STATUS_TELEPORT)
+            continue;
+
+        Player *pChallenger = ObjectAccessor::FindPlayer(ObjectGuid(HighGuid::Player, Itr->second->GetChallengerGUID()));
+        Player *pDefender    = ObjectAccessor::FindPlayer(ObjectGuid(HighGuid::Player,Itr->second->GetDefenderGUID()));
+
+        if(pChallenger == NULL || pDefender == NULL)
+            continue;
+        if(pChallenger->IsBeingTeleported() || pChallenger->IsLoading() || pDefender->IsBeingTeleported() || pDefender->IsLoading())
+            continue;
+
+        pChallenger->CastSpell(pDefender, 7266, true);
+        Itr->second->SetMatchStatus(GAMBLER_MATCH_STATUS_RUNNING);
+    }
+    ReleaseMatchLock();
+}
+
+// Database Interaction
+void GamblingSystem::LoadConfigData()
+{
+    m_minRequiredLevel = 255;
+    m_maxLevelDiff       = 5;
+    m_maxBet           = 100;
+    m_awardFled           = false;
+    m_enableGM           = false;
+    m_enableSameip       = false;
+    m_enableLimits       = false;
+    m_onlyCurrency       = false;
+    m_equalDuels       = false;
+    if(QueryResult queryResult = CharacterDatabase.Query("SELECT `optionIndex`, `optionValue` FROM `custom_duel_config`"))
+    {
+        do
+        {
+            Field *Fields = queryResult->Fetch();
+            switch(Fields[0].GetUInt32())
+            {
+                case GAMBLER_CONFIG_OPTION_MAPID:                m_arenaCoords.m_mapId        = Fields[1].GetUInt32();    break;
+                case GAMBLER_CONFIG_OPTION_COORDSX:                m_arenaCoords.m_positionX    = Fields[1].GetFloat();        break;
+                case GAMBLER_CONFIG_OPTION_COORDSY:                m_arenaCoords.m_positionY    = Fields[1].GetFloat();        break;
+                case GAMBLER_CONFIG_OPTION_COORDSZ:                m_arenaCoords.m_positionZ    = Fields[1].GetFloat();        break;
+                case GAMBLER_CONFIG_OPTION_COORDSO:                m_arenaCoords.m_orientation    = Fields[1].GetFloat();        break;
+                case GAMBLER_CONFIG_OPTION_MIN_REQUIREDLEVEL:    m_minRequiredLevel            = Fields[1].GetUInt32();    break;
+                case GAMBLER_CONFIG_OPTION_MAX_LEVELDIFF:        m_maxLevelDiff                = Fields[1].GetUInt32();    break;
+                case GAMBLER_CONFIG_OPTION_AWARD_FLED:            m_awardFled                    = Fields[1].GetBool();        break;
+                case GAMBLER_CONFIG_OPTION_MAX_BET:
+                    m_maxBet                    = Fields[1].GetUInt32();
+                    if(m_maxBet > GAMBLER_SYSTEM_TOTAL_MAX_BET){
+                        m_maxBet = GAMBLER_SYSTEM_TOTAL_MAX_BET;
+                    }
+                break;
+                case GAMBLER_CONFIG_OPTION_ENABLE_GM:            m_enableGM                    = Fields[1].GetBool();        break;
+                case GAMBLER_CONFIG_OPTION_ENABLE_SAMEIP:        m_enableSameip                = Fields[1].GetBool();        break;
+                case GAMBLER_CONFIG_OPTION_ENABLE_LIMITS:        m_enableLimits                = Fields[1].GetBool();        break;
+                case GAMBLER_CONFIG_OPTION_ONLY_CURRENCY:        m_onlyCurrency                = Fields[1].GetBool();        break;
+                case GAMBLER_CONFIG_OPTION_EQUAL_DUELS:            m_equalDuels                = Fields[1].GetBool();        break;
+            }
+        }while(queryResult->NextRow());
+    }
+    else
+        TC_LOG_ERROR("Arena", "GamblingSystem: Unable to load duel_config, result was not returned");
+    if(QueryResult queryResult = CharacterDatabase.Query("SELECT MAX(`matchId`) FROM `custom_duel_storage`"))
+        m_highMatchId = queryResult->Fetch()[0].GetUInt32();
+    else
+        m_highMatchId = 0;
+}
+
+void GamblingSystem::_loadPastMatches()
+{
+    if(QueryResult queryResult = CharacterDatabase.Query("SELECT * FROM `custom_duel_storage`"))
+    {
+        do
+        {
+            GamblerMatchData *matchData = new GamblerMatchData(queryResult->Fetch());
+            if(matchData->GetMatchWinner() == 0)
+            {
+                _createItemAndMailToPlayer(NULL, matchData->GetChallengerGUID(), matchData->GetChallengerItemId(), matchData->GetChallengerItemCount(), GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_INCOMPLETE);
+                _createItemAndMailToPlayer(NULL, matchData->GetDefenderGUID(), matchData->GetDefenderItemId(), matchData->GetDefenderItemCount(), GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_INCOMPLETE);
+                continue;
+            }
+            AcquireMatchLock();
+            m_matchStorage.insert(make_pair(matchData->GetMatchId(), matchData));
+            ReleaseMatchLock();
+        }while(queryResult->NextRow());
+    }
+    CharacterDatabase.PExecute("DELETE FROM `custom_duel_storage` WHERE `matchWinner` = '0'");
+}
+
+void GamblingSystem::_saveCurrentMatchProgress(GamblerMatchData *matchData)
+{
+    if(QueryResult queryResult = CharacterDatabase.PQuery("SELECT * FROM `custom_duel_storage` WHERE `matchId` = '%u'", matchData->GetMatchId()))
+        CharacterDatabase.PExecute("UPDATE `custom_duel_storage` SET `matchWinner` = '%u'", matchData->GetMatchWinner());
+    else
+        CharacterDatabase.PExecute("INSERT INTO `custom_duel_storage` VALUES ('%u', '%u', '%u', '%u', '%u', '%u', '%u', NOW(), '%u')", matchData->GetMatchId(), matchData->GetChallengerGUID(), matchData->GetDefenderGUID(), matchData->GetChallengerItemId(),matchData->GetChallengerItemCount(), matchData->GetDefenderItemId(),matchData->GetDefenderItemCount(), matchData->GetMatchWinner());
+}
+
+void GamblingSystem::_updatePlayerStats(uint32 playerGUID, GamblerPlayerStatIndex statIndex, uint32 statIncreaseValue)
+{
+    if(statIndex > GAMBLER_PLAYER_STAT_MAX)
+    {
+        TC_LOG_ERROR("Arena", "GamblingSystem: _updatePlayerStats statIndex out of range");
+        return;
+    }
+    if(QueryResult queryResult = CharacterDatabase.PQuery("SELECT `%s` FROM `custom_duel_statistics` WHERE `%s` = '%u'", GamblerPlayerStatFields[statIndex], GamblerPlayerStatFields[GAMBLER_PLAYER_STAT_GUID], playerGUID))
+        CharacterDatabase.PExecute("UPDATE `custom_duel_statistics` SET `%s` = '%u' WHERE `%s` = '%u'", GamblerPlayerStatFields[statIndex], queryResult->Fetch()[0].GetUInt32()+statIncreaseValue, GamblerPlayerStatFields[GAMBLER_PLAYER_STAT_GUID], playerGUID);
+    else
+        CharacterDatabase.PExecute("INSERT INTO `custom_duel_statistics` (`%s`,`%s`) VALUES('%u', '%u')", GamblerPlayerStatFields[GAMBLER_PLAYER_STAT_GUID], GamblerPlayerStatFields[statIndex], playerGUID, statIncreaseValue);
+}
+
+// Match Data Retrieval
+GamblerMatchData *GamblingSystem::GetMatchDataBy(Player *pPlayer)
+{
+    AcquireMatchLock();
+    GamblerMatchMap::iterator Itr;
+    for(Itr = m_matchStorage.begin(); Itr != m_matchStorage.end(); ++Itr)
+    {
+        if(Itr->second->GetChallengerGUID() == pPlayer->GetGUID().GetCounter() || Itr->second->GetDefenderGUID() == pPlayer->GetGUID().GetCounter())
+        {
+            // Match is over, old data
+            if(Itr->second->GetMatchWinner())
+                continue;
+            ReleaseMatchLock();
+            return Itr->second;
+        }
+    }
+    ReleaseMatchLock();
+    return NULL;
+}
+
+// Match Requirements Checking
+bool GamblingSystem::CanHaveMatch(Player *pChallenger, Player *pDefender)
+{
+    // if same ip dueling is enabled in configuration
+    if(m_enableSameip == 1){
+        // no multibox or dueling with same ip
+        if(pChallenger->GetSession()->GetRemoteAddress().compare(pDefender->GetSession()->GetRemoteAddress()) == 0)
+            return false;
+    }
+
+    // if gm dueling is enabled in configuration
+    if(m_enableGM == 1){
+        // No gamemasters
+         if(pChallenger->GetSession()->GetSecurity() > 0 || pDefender->GetSession()->GetSecurity() > 0)
+            return false;
+    }
+
+    // no dueling on the same account
+    if(pChallenger->GetSession()->GetAccountId() == pDefender->GetSession()->GetAccountId())
+        return false;
+
+    // no dueling if any of the players are logging out!
+    if(pChallenger->GetSession()->isLogingOut() || pDefender->GetSession()->isLogingOut())
+        return false;
+
+    // No dueling if player already has a duel record in progress
+    if(GetMatchDataBy(pChallenger) || GetMatchDataBy(pDefender))
+        return false;
+
+    // No dueling if you don't meet the level requirement in the database
+    uint32 m_minRequiredLevel = 0;
+    if(pChallenger->getLevel() <= m_minRequiredLevel || pDefender->getLevel() <= m_minRequiredLevel)
+        return false;
+
+    // No dueling if your level differance is bigger than specified in the database
+    uint32 levelDiff = 0;
+    if(pChallenger->getLevel() > pDefender->getLevel())
+        levelDiff = pChallenger->getLevel() - pDefender->getLevel();
+    else
+        levelDiff = pDefender->getLevel() - pChallenger->getLevel();
+    if(levelDiff > m_maxLevelDiff)
+        return false;
+
+    return true;
+}
+
+// Match Setup
+void GamblingSystem::SetupMatch(Player *pChallenger, Player *pDefender)
+{
+    GamblerMatchData *matchData = new GamblerMatchData(_generateMatchId(), pChallenger->GetGUID().GetCounter(), pDefender->GetGUID().GetCounter());
+    AcquireMatchLock();
+    m_matchStorage.insert(make_pair(matchData->GetMatchId(), matchData));
+    ReleaseMatchLock();
+}
+
+std::string GamblingSystem::GetQualityColor(int32 qualityType) const
+{
+    switch(qualityType)
+    {
+        case ITEM_QUALITY_NORMAL:
+        {
+            return QUALITY_NORMAL;
+        }break;
+        case ITEM_QUALITY_UNCOMMON:
+        {
+            return QUALITY_UNCOMMON;
+        }break;
+        case ITEM_QUALITY_RARE:
+        {
+            return QUALITY_RARE;
+        }break;
+        case ITEM_QUALITY_EPIC:
+        {
+            return QUALITY_EPIC;
+        }break;
+        case ITEM_QUALITY_LEGENDARY:
+        {
+            return QUALITY_LEGENDARY;
+        }break;
+        case ITEM_QUALITY_ARTIFACT:
+        {
+            return QUALITY_ARTIFACT;
+        }break;
+        case ITEM_QUALITY_HEIRLOOM:
+        {
+            return QUALITY_HEIRLOOM;
+        }break;
+        default :
+        {
+            return QUALITY_POOR;
+        }break;
+    }
+    return 0;
+}
+
+bool GamblingSystem::AddItemForMatch(Player *pPlayer, std::string itemName)
+{
+    GamblerMatchData *matchData = GetMatchDataBy(pPlayer);
+    if(matchData == NULL)
+        return false;
+
+    WorldDatabase.EscapeString(itemName);
+    if(QueryResult queryResult = WorldDatabase.PQuery("SELECT `entry` FROM `item_template` WHERE `name` = '%s'", itemName.c_str()))
+    {
+        uint32 itemId = queryResult->Fetch()[0].GetUInt32();
+
+        ItemTemplate const *itemProto = sObjectMgr->GetItemTemplate(itemId);
+        if(Item *pItem = pPlayer->GetItemByEntry(itemId))
+        {
+            // if its currency
+            if(itemProto->BagFamily & BAG_FAMILY_MASK_CURRENCY_TOKENS)
+            {
+                if(pItem == NULL)
+                    return false;
+            }else{ // if its a normal item, check if its valid.
+                if(_checkItemValidity(pItem) == false)
+                    return false;
+            }
+
+            if(m_enableLimits == 1){ // if item limits are enabled, check them.
+                if(_checkWithinLimits(pItem) == false)
+                    return false;
+            }
+
+            if(m_onlyCurrency == 1){ // if only currency is allowed, check the item proto, temporary.
+                if(itemProto->BagFamily & BAG_FAMILY_MASK_CURRENCY_TOKENS){}else{return false;}
+            }
+
+            if(matchData->IsChallenger(pPlayer)){
+                matchData->SetChallengerItemId(itemId);
+            }
+            else{
+                matchData->SetDefenderItemId(itemId);
+            }
+            return true;
+        }
+    }
+    return false;
+}
+
+bool GamblingSystem::AddItemAmountForMatch(Player *pPlayer, uint32 amount)
+{
+    GamblerMatchData *matchData = GetMatchDataBy(pPlayer);
+    if(matchData == NULL)
+        return false;
+
+    uint32 itemId = matchData->GetItemIdBy(pPlayer);
+    ItemTemplate const *itemProto = sObjectMgr->GetItemTemplate(itemId);
+
+    if(Item *pItem = pPlayer->GetItemByEntry(itemId))
+    {
+        // if duels must be equal, then challenger item count must equal defender item count.
+        if(m_equalDuels == 1){
+            // if the player is challenger and his amount is not equal to the defender's item count, return false.
+            if(matchData->IsChallenger(pPlayer) && matchData->GetDefenderItemCount() != 0 && amount != matchData->GetDefenderItemCount())
+                return false;
+            // if the player is defender and his amount is not equal to challenger's item count, return false.
+            else if(matchData->IsDefender(pPlayer)  && matchData->GetChallengerItemCount() != 0 && amount != matchData->GetChallengerItemCount())
+                return false;
+        }
+
+        if(amount > m_maxBet)
+            return false;
+
+        if(!pPlayer->HasItemCount(itemId,amount))
+            return false;
+
+        if(matchData->IsChallenger(pPlayer)){
+            matchData->SetChallengerItemCount(amount);
+        }
+        else{
+            matchData->SetDefenderItemCount(amount);
+        }
+
+        Player *secondPlayer = NULL;
+        if(matchData->IsChallenger(pPlayer))
+            secondPlayer = ObjectAccessor::FindPlayer(ObjectGuid(HighGuid::Player, matchData->GetDefenderGUID()));
+        else
+            secondPlayer = ObjectAccessor::FindPlayer(ObjectGuid(HighGuid::Player, matchData->GetChallengerGUID()));
+        if(secondPlayer)
+            secondPlayer->GetSession()->SendAreaTriggerMessage("|cffffffffThe player |cff00ccff%s |cffffffffhas bet |cff00ccff%u|cffffffffx of the item |%s|Hitem:%u:0:0:0:0:0:0:0:%u|h[%s]|h|r", pPlayer, amount, GetQualityColor(itemProto->Quality).c_str(),  pItem->GetEntry(), pPlayer->getLevel(),  itemProto->Name1.c_str());
+        return true;
+    }
+    return false;
+}
+
+void GamblingSystem::AcceptChallenge(Player *pPlayer)
+{
+    GamblerMatchData *matchData = GetMatchDataBy(pPlayer);
+    if(matchData == NULL)
+        return;
+    if(matchData->IsChallenger(pPlayer))
+        matchData->SetChallengerReady(true);
+    else
+        matchData->SetDefenderReady(true);
+    if(matchData->GetChallengerReady() && matchData->GetDefenderReady())
+    {
+        Player *secondPlayer = NULL;
+
+        if(matchData->IsChallenger(pPlayer)){
+            secondPlayer = ObjectAccessor::FindPlayer(ObjectGuid(HighGuid::Player,matchData->GetDefenderGUID()));}
+        else{
+            secondPlayer = ObjectAccessor::FindPlayer(ObjectGuid(HighGuid::Player,matchData->GetChallengerGUID()));}
+
+        // Don't start the duel if there is no second player
+        if(secondPlayer == NULL)
+        {
+            ChatHandler(pPlayer->GetSession()).PSendSysMessage(GAMBLER_SYSTEM_MSG_CANT_LOCATE_PLAYER);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+        // Don't start the duel if they are already in a duel
+        if(secondPlayer->duel || pPlayer->duel)
+        {
+            SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_CANT_START_DUEL);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+        // Don't start the duel if they are already InCombat
+        if(secondPlayer->IsInCombat() || pPlayer->IsInCombat())
+        {
+            SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_CANT_START_DUEL);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+        // Don't start the duel if the players are logging out
+        if(secondPlayer->GetSession()->isLogingOut() || pPlayer->GetSession()->isLogingOut())
+        {
+            SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_CANT_START_LOGGING);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+
+        uint32 itemId1 = matchData->IsChallenger(pPlayer) ? matchData->GetChallengerItemId() : matchData->GetDefenderItemId();
+        uint32 itemId2 = matchData->IsChallenger(secondPlayer) ? matchData->GetChallengerItemId() : matchData->GetDefenderItemId();
+
+        uint32 amount1 = matchData->IsChallenger(pPlayer) ? matchData->GetChallengerItemCount() : matchData->GetDefenderItemCount();
+        uint32 amount2 = matchData->IsChallenger(secondPlayer) ? matchData->GetChallengerItemCount() : matchData->GetDefenderItemCount();
+
+        ItemTemplate const *Proto1 = sObjectMgr->GetItemTemplate(itemId1);
+        ItemTemplate const *Proto2 = sObjectMgr->GetItemTemplate(itemId2);
+
+        if(Proto1->BagFamily & BAG_FAMILY_MASK_CURRENCY_TOKENS || Proto2->BagFamily & BAG_FAMILY_MASK_CURRENCY_TOKENS){
+            // Missing data here, not important.
+        }else if(_checkItemValidity(pPlayer->GetItemByEntry(itemId1)) == false || _checkItemValidity(secondPlayer->GetItemByEntry(itemId2)) == false){
+            SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_ITEM_VALIDATE_FAIL);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+
+        // Don't start the duel if the players don't have the item in inventory
+        if(pPlayer->GetItemCount(itemId1) == 0 || secondPlayer->GetItemCount(itemId2) == 0)
+        {
+            SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_ITEM_NO_INV);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+
+        // Don't start the duel if the players don't have the amount of items betted
+        if(!pPlayer->GetItemCount(itemId1, amount1)  || !secondPlayer->GetItemCount(itemId2, amount2))
+        {
+            SendMessageToPlayers(matchData, ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+
+        // Don't start the duel if the players have betted more than the maximum specified in configuration
+        if(pPlayer->GetItemCount(amount1) > m_maxBet || secondPlayer->GetItemCount(amount2) > m_maxBet)
+        {
+            SendMessageToPlayers(matchData, ARENA_GAMBLER_MSG_BET_ADD_FAILED, m_maxBet);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+
+        _saveCurrentMatchProgress(matchData);
+        _updatePlayerStats(pPlayer->GetGUID().GetCounter(), GAMBLER_PLAYER_STAT_DUELS_TOTAL, 1);
+        _updatePlayerStats(secondPlayer->GetGUID().GetCounter(), GAMBLER_PLAYER_STAT_DUELS_TOTAL, 1);
+
+        pPlayer->DestroyItemCount(itemId1, amount1, true, true);
+        secondPlayer->DestroyItemCount(itemId2, amount2, true, true);
+
+        pPlayer->SaveToDB();
+        secondPlayer->SaveToDB();
+
+        SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_MATCH_STARTING);
+
+        pPlayer->SetBattlegroundEntryPoint();
+        secondPlayer->SetBattlegroundEntryPoint();
+        pPlayer->TeleportTo(m_arenaCoords.GetMapId(), m_arenaCoords.GetPositionX(), m_arenaCoords.GetPositionY(), m_arenaCoords.GetPositionZ(), m_arenaCoords.GetOrientation());
+        secondPlayer->TeleportTo(m_arenaCoords.GetMapId(), m_arenaCoords.GetPositionX(), m_arenaCoords.GetPositionY(), m_arenaCoords.GetPositionZ(), m_arenaCoords.GetOrientation());
+        matchData->SetMatchStatus(GAMBLER_MATCH_STATUS_TELEPORT);
+    }
+    else
+        SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_ACCEPTED_CHALLENGE, pPlayer);
+}
+
+void GamblingSystem::CancelChallenge(Player *pPlayer)
+{
+    GamblerMatchData *matchData = GetMatchDataBy(pPlayer);
+    if(matchData == NULL)
+        return;
+    SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_CANCELED, pPlayer, matchData->GetChallengerGUID() == pPlayer->GetGUID().GetCounter() ? GAMBLER_SYSTEM_MSG_CANCELED_1 : GAMBLER_SYSTEM_MSG_CANCELED_2);
+    if(matchData->IsDefender(pPlayer))
+        _updatePlayerStats(pPlayer->GetGUID().GetCounter(), GAMBLER_PLAYER_STAT_DUELS_REFUSED, 1);
+    _deleteMatchData(matchData->GetMatchId());
+}
+
+// Match Completion
+void GamblingSystem::HandleMatchComplete(Player *pWinner, Player *pLoser, GamblerMatchData *matchData, DuelCompleteType completeType)
+{
+    uint32 itemId1 = matchData->IsChallenger(pWinner) ? matchData->GetChallengerItemId() : matchData->GetDefenderItemId();
+    uint32 itemId2 = matchData->IsChallenger(pLoser) ? matchData->GetChallengerItemId() : matchData->GetDefenderItemId();
+    uint32 amount1 = matchData->IsChallenger(pWinner) ? matchData->GetChallengerItemCount() : matchData->GetDefenderItemCount();
+    uint32 amount2 = matchData->IsChallenger(pLoser) ? matchData->GetChallengerItemCount() : matchData->GetDefenderItemCount();
+    switch(completeType)
+    {
+        case DUEL_INTERRUPTED:
+        {
+            _createItemAndMailToPlayer(pWinner, pWinner->GetGUID().GetCounter(), itemId1, amount1, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_INCOMPLETE);
+            _createItemAndMailToPlayer(pLoser, pLoser->GetGUID().GetCounter(), itemId2, amount2, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_INCOMPLETE);
+            SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_DUEL_INTERRUPTED);
+        }break;
+        case DUEL_WON:
+        {
+            _createItemAndMailToPlayer(pWinner, pWinner->GetGUID().GetCounter(), itemId1, amount1, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_WON);
+            _createItemAndMailToPlayer(pWinner, pWinner->GetGUID().GetCounter(), itemId2, amount2, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_WON);
+            SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_DUEL_WON, pWinner);
+        }break;
+        case DUEL_FLED:
+        {
+            if(m_awardFled)
+            {
+                _createItemAndMailToPlayer(pWinner, pWinner->GetGUID().GetCounter(), itemId1, amount1, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_WON);
+                _createItemAndMailToPlayer(pWinner, pWinner->GetGUID().GetCounter(), itemId2, amount2, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_WON);
+                SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_DUEL_WON, pWinner);
+
+            }else{
+                _createItemAndMailToPlayer(pWinner, pWinner->GetGUID().GetCounter(), itemId1, amount1, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_INCOMPLETE);
+                _createItemAndMailToPlayer(pLoser, pLoser->GetGUID().GetCounter(), itemId2, amount2, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_INCOMPLETE);
+                SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_DUEL_FLED_NON_AWARD);
+            }
+        }break;
+    }
+    _updatePlayerStats(pWinner->GetGUID().GetCounter(), GAMBLER_PLAYER_STAT_DUELS_WON, 1);
+    _updatePlayerStats(pLoser->GetGUID().GetCounter(), GAMBLER_PLAYER_STAT_DUELS_LOST, 1);
+    matchData->SetMatchWinner(pWinner->GetGUID().GetCounter());
+    _saveCurrentMatchProgress(matchData);
+    _deleteMatchData(matchData->GetMatchId());
+    pWinner->TeleportToBGEntryPoint();
+    pLoser->TeleportToBGEntryPoint();
+}
+
+// Match Data
+void GamblingSystem::_deleteMatchData(Player *pPlayer)
+{
+    AcquireMatchLock();
+    GamblerMatchMap::iterator Itr;
+    for(Itr = m_matchStorage.begin(); Itr != m_matchStorage.end(); ++Itr)
+    {
+        if(Itr->second->GetChallengerGUID() == pPlayer->GetGUID().GetCounter() || Itr->second->GetDefenderGUID() == pPlayer->GetGUID().GetCounter())
+        {
+            delete Itr->second;
+            m_matchStorage.erase(Itr);
+            break;
+        }
+    }
+    ReleaseMatchLock();
+}
+
+bool GamblingSystem::_checkItemValidity(Item *pItem)
+{
+    if(pItem == NULL || pItem->IsSoulBound() || pItem->IsBoundAccountWide() || pItem->IsBoundByEnchant())
+        return false;
+    return true;
+}
+
+bool GamblingSystem::_checkWithinLimits(Item *pItem)
+{
+    /*
+    * Here you can add your items that you want players to be able to use in the system. this is temporary.
+    * uint32 GAMBLER_SYSTEM_ITEM_LIMITS [] = {ITEMID1,ITEMID2,ITEMID3};
+    */
+    uint32 GAMBLER_SYSTEM_ITEM_LIMITS [] = {20559};
+    for (uint32 i = 0; i < sizeof(GAMBLER_SYSTEM_ITEM_LIMITS)/sizeof(uint32); ++i){
+        if (pItem->GetEntry() == GAMBLER_SYSTEM_ITEM_LIMITS[i])
+            return true;
+    }
+    return false;
+}
+
+void GamblingSystem::_deleteMatchData(uint32 matchId)
+{
+    AcquireMatchLock();
+    GamblerMatchMap::iterator Itr = m_matchStorage.find(matchId);
+    if(Itr != m_matchStorage.end())
+        m_matchStorage.erase(Itr);
+    ReleaseMatchLock();
+}
+
+uint32 GamblingSystem::_generateMatchId()
+{
+    m_highMatchId++;
+    return m_highMatchId;
+}
+
+// Messaging
+void GamblingSystem::SendMessageToPlayers(GamblerMatchData *matchData, const char *msgToSend, ...)
+{
+    Player *pChallenger = ObjectAccessor::FindPlayer(ObjectGuid(HighGuid::Player,matchData->GetChallengerGUID()));
+    Player *pDefender    = ObjectAccessor::FindPlayer(ObjectGuid(HighGuid::Player,matchData->GetDefenderGUID()));
+
+    char Result[1024];
+    va_list List;
+    va_start(List, msgToSend);
+    vsnprintf(Result, 1024, msgToSend, List);
+    va_end(List);
+
+    if(pChallenger)
+        ChatHandler(pChallenger->GetSession()).PSendSysMessage(Result);
+    if(pDefender)
+        ChatHandler(pDefender->GetSession()).PSendSysMessage(Result);
+}
+
+// Mail System
+void GamblingSystem::_createItemAndMailToPlayer(Player *pPlayer, uint32 playerGUID, uint32 itemId, uint32 amount, std::string mailMessage)
+{
+    MailSender toSend(MAIL_NORMAL, playerGUID, GAMBLER_SYSTEM_MAIL_TYPE);
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    MailDraft mailDraft(GAMBLER_SYSTEM_MSG_MAIL_SUBJECT, mailMessage.c_str());
+
+    // extract items
+    typedef std::pair<uint32, uint32> ItemPair;
+    typedef std::list< ItemPair > ItemPairs;
+    ItemPairs items;
+    ItemTemplate const* item_proto = sObjectMgr->GetItemTemplate(itemId);
+    while (amount > item_proto->GetMaxStackSize())
+    {
+        items.push_back(ItemPair(itemId, item_proto->GetMaxStackSize()));
+        amount -= item_proto->GetMaxStackSize();
+    }
+    items.push_back(ItemPair(itemId, amount));
+
+    // TODO: items to be send is higher than the maximum items that a mail can hold!, security measure.
+    if (items.size() > MAX_MAIL_ITEMS){}
+
+    for(ItemPairs::const_iterator itr = items.begin(); itr != items.end(); ++itr)
+    {
+        if (Item* pItem = Item::CreateItem(itr->first, itr->second,pPlayer))
+        {
+           pItem->SaveToDB(trans);   // save for prevent lost at next mail load, if send fail then item will deleted
+           mailDraft.AddItem(pItem);
+        }
+    }
+
+    if(pPlayer){
+        mailDraft.SendMailTo(trans, MailReceiver(pPlayer), toSend);
+    }
+    else{
+        mailDraft.SendMailTo(trans, MailReceiver(playerGUID), toSend);
+    }
+    CharacterDatabase.CommitTransaction(trans);
+}
+
+// Called when a duel begins, check if both players have match data with each other
+void GamblerDuelScript::OnDuelRequest(Player *pDefender, Player *pChallenger)
+{
+    // To make sure we have the players and bug reporting
+    if(pDefender == NULL || pChallenger == NULL){
+        TC_LOG_ERROR("Arena", "GamblerDuelScript: OnDuelEnd pDefender or pChallenger is NULL!");
+        return;}
+
+    GamblerMatchData *ChallengerMatchData = sGamblingSystem->GetMatchDataBy(pChallenger);
+    GamblerMatchData *DefenderMatchData = sGamblingSystem->GetMatchDataBy(pDefender);
+
+    // if challenger or defender has no existing match data, return.
+    if(ChallengerMatchData == NULL || DefenderMatchData == NULL){
+        return;
+    }// if challenger or defender has match data existing
+    else{
+        // if challenger's match id is not the same as the defender, and they both have match data.
+        // then challenger has requested duel from someone else with match data.
+        if(ChallengerMatchData->GetMatchId() != DefenderMatchData->GetMatchId()){
+            ChatHandler(pChallenger->GetSession()).SendSysMessage(ARENA_GAMBLER_MSG_NOT_SAME_PLAYER);
+            sGamblingSystem->CancelChallenge(pChallenger);
+        }
+        // if the challenger has not set ready, or the defender has not set ready!
+        if(ChallengerMatchData->HasSetReady(pChallenger) == false || ChallengerMatchData->HasSetReady(pDefender) == false){
+            ChatHandler(pChallenger->GetSession()).SendSysMessage(ARENA_GAMBLER_MSG_NOT_READY);
+            sGamblingSystem->CancelChallenge(pChallenger);
+        }
+        // if challenger has no item id set, or defender has no item id set!
+        if(ChallengerMatchData->GetChallengerItemId() == 0 || ChallengerMatchData->GetDefenderItemId() == 0){
+            ChatHandler(pChallenger->GetSession()).SendSysMessage(ARENA_GAMBLER_MSG_NO_ITEM);
+            sGamblingSystem->CancelChallenge(pChallenger);
+        }
+        // if challenger has not set item count yet, or defender has not set item count yet!
+        if(ChallengerMatchData->GetChallengerItemCount() == 0 || ChallengerMatchData->GetDefenderItemCount() == 0){
+            ChatHandler(pChallenger->GetSession()).SendSysMessage(ARENA_GAMBLER_MSG_NO_AMOUNT);
+            sGamblingSystem->CancelChallenge(pChallenger);
+        }
+
+    }
+}
+
+// Called when a duel ends, check if there is a match running or not.
+void GamblerDuelScript::OnDuelEnd(Player *pWinner, Player *pLoser, DuelCompleteType type)
+{
+    // To make sure we have the players and bug reporting
+    if(pWinner == NULL || pLoser == NULL){
+        TC_LOG_ERROR("Arena", "GamblerDuelScript: OnDuelEnd pWinner or pLoser is NULL!");
+        return;}
+
+    GamblerMatchData *WinnerData = sGamblingSystem->GetMatchDataBy(pWinner);
+    GamblerMatchData *LoserData = sGamblingSystem->GetMatchDataBy(pLoser);
+
+    if(WinnerData == NULL || LoserData == NULL){
+        return;}
+    else if(WinnerData->GetMatchId() == LoserData->GetMatchId()){
+    sGamblingSystem->HandleMatchComplete(pWinner, pLoser, WinnerData, type);
+    }
+}
+
+// Called when a player logsout, if a player exists, check match data, if it started, if yes then complete the duel
+void GamblerDuelScript::OnLogout(Player *pPlayer)
+{
+    // To make sure we have the player and bug reporting
+    if(pPlayer == NULL){
+        TC_LOG_ERROR("Arena", "GamblerDuelScript: OnLogout pPlayer is NULL!");
+        return;}
+
+    GamblerMatchData *matchData = sGamblingSystem->GetMatchDataBy(pPlayer);
+    if(matchData == NULL){
+        return;}
+    else if(matchData->MatchStarted() && (matchData->GetChallengerGUID() == pPlayer->GetGUID().GetCounter() || matchData->GetDefenderGUID() == pPlayer->GetGUID().GetCounter()))
+            pPlayer->DuelComplete(DUEL_FLED);
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/ArenaGamblingSystem.h b/src/server/scripts/Custom/ArenaGamblingSystem.h
new file mode 100644
index 0000000..c861ea0
--- /dev/null
+++ b/src/server/scripts/Custom/ArenaGamblingSystem.h
@@ -0,0 +1,458 @@
+/*
+ * Author: Xees
+ * FileName: ArenaGamblingSystem.h
+ * Description: This file is used for definitions and requirements of the Arena Gambling System
+ * Version: 1.9
+ * Status: functional
+*/
+#ifndef ArenaGambler_H
+#define ArenaGambler_H
+
+// scriptName
+#define GAMBLER_SYSTEM_SCRIPT_NAME "custom_gambling_system_script"
+#define GAMBLER_SYSTEM_DUEL_SCRIPT_NAME "custom_gambler_duel_script"
+
+#define ARENA_GAMBLER_SCRIPT_NAME "duel_system"
+#define ARENA_RECORDS_SCRIPT_NAME "duel_records_system"
+
+enum ARENA_GAMBLER_MENUS
+{
+    ARENA_GAMBLER_MENU_MAIN    = 1,
+    ARENA_GAMBLER_MENU_CHALLENGE_PLAYER,
+    ARENA_GAMBLER_MENU_BET_ITEM,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_1,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_10,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_20,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_30,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_40,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_50,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_100,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_200,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_300,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_500,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_1000,
+    ARENA_GAMBLER_MENU_ACCEPT_CHALLENGE,
+    ARENA_GAMBLER_MENU_CANCEL_CHALLENGE,
+    ARENA_GAMBLER_MENU_DECLINE_CHALLENGE,
+    ARENA_GAMBLER_MENU_EXIT
+};
+
+enum ARENA_GAMBLER_MENU_ICONS
+{
+    ARENA_GAMBLER_ICON_CHALLENGE    = GOSSIP_ICON_BATTLE,            // ARENA_GAMBLER_MENU_CHALLENGE_PLAYER
+    ARENA_GAMBLER_ICON_BET_ITEM        = GOSSIP_ICON_MONEY_BAG,        // ARENA_GAMBLER_MENU_BET_ITEM
+    ARENA_GAMBLER_ICON_ACCEPT        = GOSSIP_ICON_BATTLE,            // ARENA_GAMBLER_MENU_ACCEPT_CHALLENGE
+    ARENA_GAMBLER_ICON_CANCEL        = GOSSIP_ICON_DOT,                // ARENA_GAMBLER_MENU_CANCEL_CHALLENGE
+    ARENA_GAMBLER_ICON_DECLINE        = GOSSIP_ICON_TAXI,                // ARENA_GAMBLER_MENU_DECLINE_CHALLENGE
+    ARENA_GAMBLER_ICON_EXIT            = GOSSIP_ICON_TABARD,            // ARENA_GAMBLER_MENU_EXIT
+};
+
+// Menu Texts
+#define ARENA_GAMBLER_TEXT_CHALLENGE "I would like to Challenge a player to a duel!"
+#define ARENA_GAMBLER_TEXT_CHALLENGE_CODE_TEXT "Enter the name of a player you wish to challenge. (Case Sensitive)"
+#define ARENA_GAMBLER_TEXT_BET_ITEM "I would like to Bet an item"
+#define ARENA_GAMBLER_TEXT_BET_ITEM_CODE_TEXT "Enter the name of the item you wish to bet"
+#define ARENA_GAMBLER_TEXT_BET_ITEM_AMOUNT "I would like to enter the amount"
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_TEXT "Select the amount of items you wish to bet"
+#define ARENA_GAMBLER_TEXT_ACCEPT_CHALLENGE "I accept the challenge!"
+#define ARENA_GAMBLER_TEXT_CANCEL_CHALLENGE "I do not want to this challenge!"
+#define ARENA_GAMBLER_TEXT_DECLINE_CHALLENGE "I do not accept this challenge!"
+#define ARENA_GAMBLER_TEXT_EXIT "Nevermind"
+
+// Amount of bets Menu text -- TODO: write a more efficient way to override Opcode OnGossipSelectWithCode string restrictions
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_1 "1 item."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_10 "10 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_20 "20 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_30 "30 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_40 "40 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_50 "50 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_100 "100 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_200 "200 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_300 "300 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_500 "500 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_1000 "1000 items."
+
+// Mail System Defines
+#define GAMBLER_SYSTEM_MSG_MAIL_SUBJECT "The Judgment Arena : Rewards !"
+#define GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_INCOMPLETE "Your item is being returned as the result of an incomplete match"
+#define GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_WON "You've won the match!"
+#define GAMBLER_SYSTEM_MAIL_TYPE MAIL_STATIONERY_GM
+
+// Messages
+#define GAMBLER_SYSTEM_MSG_ACCEPTED_CHALLENGE "%s has accepted the challenge!" // %s = accepters name
+#define GAMBLER_SYSTEM_MSG_ITEM_BET_PLACED "%s has placed item %s up for bet!" // %s1 = players name %s2 = items name
+#define GAMBLER_SYSTEM_MSG_CANCELED "%s has %s the match!" // the first %s will utilize one of the below defines considering the player is either, the challenger canceling the match, or the defender canceling the match
+#define GAMBLER_SYSTEM_MSG_CANCELED_1 "Canceled"
+#define GAMBLER_SYSTEM_MSG_CANCELED_2 "Forfeit"
+#define GAMBLER_SYSTEM_MSG_CANT_LOCATE_PLAYER "Could not locate the second player, match aborted!"
+#define GAMBLER_SYSTEM_MSG_CANT_START_DUEL "Cannot start match while currently in a duel, or in combat."
+#define GAMBLER_SYSTEM_MSG_CANT_START_LOGGING "Cannot start the match while one fo the players is logging out!"
+#define GAMBLER_SYSTEM_MSG_MATCH_STARTING "The match is now underway!"
+#define GAMBLER_SYSTEM_MSG_DUEL_INTERRUPTED "The duel has been interrupted, items have been mailed back to their original owners"
+#define GAMBLER_SYSTEM_MSG_DUEL_FLED_NON_AWARD "items have been mailed to their original owners"
+#define GAMBLER_SYSTEM_MSG_DUEL_WON "%s has been mailed his match winnings!" // %s = winnerName
+#define GAMBLER_SYSTEM_MSG_ITEM_VALIDATE_FAIL "An invalid item has caused the match to be stopped!"
+#define GAMBLER_SYSTEM_MSG_ITEM_NO_INV "The amount of items you can bet is invalid!"
+#define ARENA_GAMBLER_MSG_NOT_SAME_PLAYER "That is not the same person i requested the duel with!"
+#define ARENA_GAMBLER_MSG_PLAYER_NOT_FOUND "The player might be offline or away at the moment , i was not able to locate the player."
+#define ARENA_GAMBLER_MSG_MATCH_NOT_POSSIBLE "Duel is not accepted because of the following: "
+#define ARENA_GAMBLER_MSG_NO_GMS_ALLOWED "Game Masters are not allowed to duel!"
+#define ARENA_GAMBLER_MSG_SAME_ACC_ID "You cannot duel your self!"
+#define ARENA_GAMBLER_MSG_NOT_READY "You or your opponent has not set ready for the duel!"
+#define ARENA_GAMBLER_MSG_NO_ITEM "You or your opponent did not specify an item id!"
+#define ARENA_GAMBLER_MSG_NO_AMOUNT "You or your opponent did not specify an item amount!"
+#define ARENA_GAMBLER_MSG_MULTI_BOX "You cannot duel anyone with the same ip address!"
+#define ARENA_GAMBLER_MSG_LOW_LEVEL "Your level is too low to duel"
+#define ARENA_GAMBLER_MSG_MATCH_DATA "You have requested a duel from someone who already is in a duel."
+#define ARENA_GAMBLER_MSG_DIFF_NOT_MET "Your level is too high or too low to duel this player."
+#define ARENA_GAMBLER_MSG_CHALLENGE_ISSUED "You have challenged %s to a duel!"    // %s = defenders name
+#define ARENA_GAMBLER_MSG_CHALLENGED "%s wants to challenge you to a duel!"        // %s = challengers name
+#define ARENA_GAMBLER_MSG_ITEM_ADD_FAILED "You may not have the item, or the item could be soulbound, or you are not allowed to bet that item."
+#define ARENA_GAMBLER_MSG_BET_ADD_FAILED "The maximum amount of items you can bet is %u" // %u = maximum bet
+#define ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED "You may not have the item, or your bet is not the same as your opponent, or you have chosen a higher bet that allowed, your not allowed to duel this item."
+#define ARENA_GAMBLER_MSG_BET_AMOUNT_TOO_HIGH "The maximum number of items the player can recieve is lower than the amount betted."
+#define ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS "Your bet amount was entered successfully, please accept or reject the duel!"
+#define ARENA_GAMBLER_MSG_ITEM_ADD_SUCCESS "Your item was selected successfully, now select the amount you would like to bet!"
+
+// Intervals
+#define GAMBLER_SYSTEM_INTERVAL_TELE_CHECK 10000
+
+// Vars
+#define GAMBLER_SYSTEM_TOTAL_MAX_BET 1000
+
+#define MSG_COLOR_LIGHTRED      "|cffff6060"
+#define MSG_COLOR_LIGHTBLUE     "|cff00ccff"
+#define MSG_COLOR_BLUE          "|cff0000ff"
+#define MSG_COLOR_GREEN         "|cff00ff00"
+#define MSG_COLOR_RED           "|cffff0000"
+#define MSG_COLOR_GOLD          "|cffffcc00"
+#define MSG_COLOR_GREY          "|cff888888"
+#define MSG_COLOR_WHITE         "|cffffffff"
+#define MSG_COLOR_SUBWHITE      "|cffbbbbbb"
+#define MSG_COLOR_MAGENTA       "|cffff00ff"
+#define MSG_COLOR_YELLOW        "|cffffff00"
+#define MSG_COLOR_CYAN          "|cff00ffff"
+#define MSG_COLOR_ORANGE        "|cffff9900"
+
+#define QUALITY_POOR                 "cff9d9d9d"              //GREY
+#define QUALITY_NORMAL               "cffffffff"             //WHITE
+#define QUALITY_UNCOMMON             "cff1eff00"             //GREEN
+#define QUALITY_RARE                 "cff0070dd"             //BLUE
+#define QUALITY_EPIC                 "cffa335ee"             //PURPLE
+#define QUALITY_LEGENDARY            "cffff8000"             //ORANGE
+#define QUALITY_ARTIFACT             "cffe6cc80"             //LIGHT YELLOW
+#define QUALITY_HEIRLOOM             "cffe6cc80"              //LIGHT YELLOW
+
+enum MatchParticipants
+{
+    GAMBLER_CHALLENGER,
+    GAMBLER_DEFENDER,
+    GAMBLER_WINNER,
+    GAMBLER_MAX_MEMBERS,
+};
+
+enum GamberSystemConfigIndex
+{
+    GAMBLER_CONFIG_OPTION_MAPID,
+    GAMBLER_CONFIG_OPTION_COORDSX,
+    GAMBLER_CONFIG_OPTION_COORDSY,
+    GAMBLER_CONFIG_OPTION_COORDSZ,
+    GAMBLER_CONFIG_OPTION_COORDSO,
+    GAMBLER_CONFIG_OPTION_MIN_REQUIREDLEVEL,
+    GAMBLER_CONFIG_OPTION_MAX_LEVELDIFF,
+    GAMBLER_CONFIG_OPTION_AWARD_FLED,
+    GAMBLER_CONFIG_OPTION_MAX_BET,
+    GAMBLER_CONFIG_OPTION_ENABLE_GM,
+    GAMBLER_CONFIG_OPTION_ENABLE_SAMEIP,
+    GAMBLER_CONFIG_OPTION_ENABLE_LIMITS,
+    GAMBLER_CONFIG_OPTION_ONLY_CURRENCY,
+    GAMBLER_CONFIG_OPTION_EQUAL_DUELS
+};
+
+enum GamblerPlayerStatIndex
+{
+    GAMBLER_PLAYER_STAT_GUID,
+    GAMBLER_PLAYER_STAT_DUELS_LOST,
+    GAMBLER_PLAYER_STAT_DUELS_WON,
+    GAMBLER_PLAYER_STAT_DUELS_REFUSED,
+    GAMBLER_PLAYER_STAT_DUELS_TOTAL,
+    GAMBLER_PLAYER_STAT_MAX
+};
+
+enum GamblerMatchStatus
+{
+    GAMBLER_MATCH_STATUS_SETUP,
+    GAMBLER_MATCH_STATUS_TELEPORT,
+    GAMBLER_MATCH_STATUS_RUNNING,
+};
+
+struct GamblerMatchData
+{
+    public:
+        GamblerMatchData(uint32 Id, uint32 challengerGUID, uint32 defenderGUID)
+        {
+            SetMatchStatus(GAMBLER_MATCH_STATUS_SETUP);
+            SetChallengerGUID(challengerGUID);
+            SetDefenderGUID(defenderGUID);
+            SetChallengerReady(false);
+            SetDefenderReady(false);
+            SetMatchWinner(0);
+            matchId = Id;
+
+            for(uint8 i = 0; i < GAMBLER_MAX_MEMBERS-1; i++)
+                itemStorage[i] = 0;
+
+            for(uint8 i = 0; i < GAMBLER_MAX_MEMBERS-1; i++)
+                CountStorage[i] = 0;
+        }
+
+        GamblerMatchData(Field *pFields)
+        {
+            SetMatchStatus(GAMBLER_MATCH_STATUS_SETUP);
+            matchId    = pFields[0].GetUInt32();
+            SetChallengerGUID(pFields[1].GetUInt32());
+            SetDefenderGUID(pFields[2].GetUInt32());
+            SetChallengerItemId(pFields[3].GetUInt32());
+            SetChallengerItemCount(pFields[4].GetUInt32());
+            SetDefenderItemId(pFields[5].GetUInt32());
+            SetDefenderItemCount(pFields[6].GetUInt32());
+            SetMatchDate(pFields[7].GetString());
+            SetMatchWinner(pFields[8].GetUInt32());
+            SetChallengerReady(false);
+            SetDefenderReady(false);
+        }
+
+        // External Assignment Functions
+        void SetChallengerGUID(uint32 challengerGUID)    { _setMemberGUID(GAMBLER_CHALLENGER,    challengerGUID);    }
+        void SetDefenderGUID(uint32 defenderGUID)        { _setMemberGUID(GAMBLER_DEFENDER,        defenderGUID);        }
+        void SetChallengerItemId(uint32 itemId)            { _setMemberItemId(GAMBLER_CHALLENGER,    itemId);            }
+        void SetDefenderItemId(uint32 itemId)            { _setMemberItemId(GAMBLER_DEFENDER,    itemId);            }
+        void SetChallengerItemCount(uint32 amount)        { _setMemberItemCount(GAMBLER_CHALLENGER,    amount);        }
+        void SetDefenderItemCount(uint32 amount)        { _setMemberItemCount(GAMBLER_DEFENDER,    amount);            }
+        void SetChallengerReady(bool isReady)            { _setMemberReady(GAMBLER_CHALLENGER,    isReady);            }
+        void SetDefenderReady(bool isReady)                { _setMemberReady(GAMBLER_DEFENDER,        isReady);            }
+        void SetMatchWinner(uint32 winnerGUID)            { _setMemberGUID(GAMBLER_WINNER,        winnerGUID);        }
+        void SetMatchDate(std::string matchTime)        { matchDate = matchTime;                                    }
+        void SetMatchStatus(GamblerMatchStatus status)    { matchStatus = status;                                        }
+
+        // External Retrieval Functions
+        uint32 GetChallengerGUID()                        { return _getMemberGUID(GAMBLER_CHALLENGER);                }
+        uint32 GetDefenderGUID()                        { return _getMemberGUID(GAMBLER_DEFENDER);                    }
+        uint32 GetChallengerItemId()                    { return _getMemberItemId(GAMBLER_CHALLENGER);                }
+        uint32 GetDefenderItemId()                        { return _getMemberItemId(GAMBLER_DEFENDER);                }
+        uint32 GetChallengerItemCount()                    { return _getMemberItemCount(GAMBLER_CHALLENGER);            }
+        uint32 GetDefenderItemCount()                    { return _getMemberItemCount(GAMBLER_DEFENDER);                }
+        uint32 GetMatchWinner()                            { return _getMemberGUID(GAMBLER_WINNER);                    }
+        uint32 GetMatchId()                                { return matchId;                                            }
+        uint8 GetMatchStatus()                            { return matchStatus;                                        }
+        bool GetChallengerReady()                        { return _getMemberReadyStatus(GAMBLER_CHALLENGER);            }
+        bool GetDefenderReady()                            { return _getMemberReadyStatus(GAMBLER_DEFENDER);            }
+        std::string GetMatchDate()                        { return matchDate;                                            }
+
+        bool MatchStarted()
+        {
+            if(GetMatchStatus() >= GAMBLER_MATCH_STATUS_TELEPORT)
+                return true;
+            return false;
+        }
+
+        bool HasSetReady(Player *pPlayer)
+        {
+            if(IsChallenger(pPlayer))
+                return GetChallengerReady();
+            else
+                return GetDefenderReady();
+        }
+
+        uint32 GetItemIdBy(Player *pPlayer)
+        {
+            if(pPlayer->GetGUID().GetCounter() == GetChallengerGUID())
+                return GetChallengerItemId();
+            else
+                return GetDefenderItemId();
+        }
+
+        uint32 GetItemCountBy(Player *pPlayer)
+        {
+            if(pPlayer->GetGUID().GetCounter() == GetChallengerGUID())
+                return GetChallengerItemCount();
+            else
+                return GetDefenderItemCount();
+        }
+
+        // Misc Functions
+        bool IsChallenger(Player *pPlayer)
+        {
+            if(pPlayer->GetGUID().GetCounter() == GetChallengerGUID())
+                return true;
+            return false;
+        }
+
+        bool IsDefender(Player *pPlayer) { return !IsChallenger(pPlayer); }
+
+    private:
+        // Internal Assignment Functions
+        void _setMemberGUID(MatchParticipants matchMember, uint32 memberGUID) { guidStorage[matchMember] = memberGUID; }
+        void _setMemberItemId(MatchParticipants matchMember, uint32 itemId)
+        {
+            if(matchMember > GAMBLER_DEFENDER)
+                return;
+            itemStorage[matchMember] = itemId;
+        }
+        void _setMemberItemCount(MatchParticipants matchMember, uint32 amount)
+        {
+            if(matchMember > GAMBLER_DEFENDER)
+                return;
+            CountStorage[matchMember] = amount;
+        }
+
+        void _setMemberReady(MatchParticipants matchMember, bool isReady)
+        {
+            if(matchMember > GAMBLER_DEFENDER)
+                return;
+            readyStatus[matchMember] = isReady;
+        }
+
+        // Internal Retrieval Functions
+        uint32 _getMemberGUID(MatchParticipants matchMember) { return guidStorage[matchMember]; }
+        uint32 _getMemberItemId(MatchParticipants matchMember)
+        {
+            if(matchMember > GAMBLER_DEFENDER)
+                return 0;
+            return itemStorage[matchMember];
+        }
+        uint32 _getMemberItemCount(MatchParticipants matchMember)
+        {
+            if(matchMember > GAMBLER_DEFENDER)
+                return 0;
+            return CountStorage[matchMember];
+        }
+
+        bool _getMemberReadyStatus(MatchParticipants matchMember)
+        {
+            if(matchMember > GAMBLER_DEFENDER)
+                return false;
+            return readyStatus[matchMember];
+        }
+
+    protected:
+        uint32 guidStorage[GAMBLER_MAX_MEMBERS];
+        uint32 itemStorage[GAMBLER_MAX_MEMBERS-1];
+        uint32 CountStorage[GAMBLER_MAX_MEMBERS-1];
+        uint32 matchId;
+        GamblerMatchStatus matchStatus;
+        bool readyStatus[GAMBLER_MAX_MEMBERS-1];
+        std::string matchDate;
+};
+
+typedef std::map<uint32, GamblerMatchData*> GamblerMatchMap;
+class GamblingSystem : public WorldScript
+{
+    public:
+    static GamblingSystem* instance()
+    {
+        static GamblingSystem* instance = new GamblingSystem();
+        return instance;
+    }
+        GamblingSystem();
+        ~GamblingSystem();
+
+        // Creation
+        void Initalize();
+
+        // Events
+        // Called on every world tick (don't execute too heavy code here).
+        void OnUpdate(uint32 diff);
+
+        // Database Interaction
+        void LoadConfigData();
+
+        // Match Data Retrieval
+        GamblerMatchData *GetMatchDataBy(Player *pPlayer);
+
+        // Match Requirements Checking
+        bool CanHaveMatch(Player *pChallenger, Player *pDefender);
+
+        // Match Setup
+        void SetupMatch(Player *pChallenger, Player *pDefender);
+        bool AddItemForMatch(Player *pPlayer, std::string itemName);
+        bool AddItemAmountForMatch(Player *pPlayer, uint32 amount);
+        void AcceptChallenge(Player *pPlayer);
+        void CancelChallenge(Player *pPlayer);
+
+        std::string GetQualityColor(int32 qualityType) const;
+
+        // Match Completion
+        void HandleMatchComplete(Player *pWinner, Player *pLoser, GamblerMatchData *matchData, DuelCompleteType completeType);
+
+        // Messaging
+        void SendMessageToPlayers(GamblerMatchData *matchData, const char *msgToSend, ...);
+
+
+    private:
+        // Database Interaction
+        void _loadPastMatches();
+        void _saveCurrentMatchProgress(GamblerMatchData *matchData);
+        void _updatePlayerStats(uint32 playerGUID, GamblerPlayerStatIndex statIndex, uint32 statIncreaseValue);
+
+        // Mail System
+        void _createItemAndMailToPlayer(Player *pPlayer, uint32 playerGUID, uint32 itemId, uint32 amount, std::string mailMessage);
+
+        // Mutex Wrappers
+        void AcquireMatchLock()
+        {
+            std::lock_guard<std::mutex> lock(_matchLock);
+        }
+        void ReleaseMatchLock()
+        {
+            std::lock_guard<std::mutex> unlock(_matchLock);
+        }
+        // Match Data
+        bool _checkItemValidity(Item *pItem);
+        bool _checkItemValidity(uint32 itemId);
+        bool _checkWithinLimits(Item *pItem);
+        void _deleteMatchData(Player *pPlayer);
+        void _deleteMatchData(uint32 matchId);
+        uint32 _generateMatchId();
+    protected:
+
+        // Matches
+        std::mutex _matchLock;
+        GamblerMatchMap m_matchStorage;
+        IntervalTimer m_checkMatches;
+
+        // Config Data
+        WorldLocation m_arenaCoords;
+        uint32 m_minRequiredLevel;
+        uint8 m_maxLevelDiff;
+        uint32 m_highMatchId;
+        bool m_awardFled;
+        uint32 m_maxBet;
+        bool m_enableGM;
+        bool m_enableSameip;
+        bool m_enableLimits;
+        bool m_onlyCurrency;
+        bool m_equalDuels;
+};
+
+class GamblerDuelScript : PlayerScript
+{
+    public:
+    static GamblingSystem* instance()
+    {
+        static GamblingSystem* instance = new GamblingSystem();
+        return instance;
+    }
+    GamblerDuelScript() : PlayerScript(GAMBLER_SYSTEM_DUEL_SCRIPT_NAME) {}
+
+     // Called when a duel is requested
+    void OnDuelRequest(Player *pDefender, Player *pChallenger);
+    // Called when a duel ends
+    void OnDuelEnd(Player *pWinner, Player *pLoser, DuelCompleteType type);
+    // Called when a player logsout
+    void OnLogout(Player *pPlayer);
+};
+
+#define sGamblingSystem GamblingSystem::instance()
+#endif
\ No newline at end of file
-- 
2.1.4

