From 5c4e75777dd15c16d2dbe613e0ec5a05daabe83c Mon Sep 17 00:00:00 2001
From: LordPsyan <realmsofwarcraft@gmail.com>
Date: Tue, 12 Jan 2016 08:35:08 -0600
Subject: [PATCH] 2016_01_12-All-No-Bots

---
 Patch_List.txt                                     |   33 +
 README.NPCTELEPORT                                 |   14 +
 Reforging_README.md                                |   40 +
 TransmogVendor_README.md                           |   49 +
 sql/TrinityCore-Patches/All-In-One/auth_AIO.sql    |   11 +
 .../All-In-One/characters_AIO.sql                  |    1 +
 sql/TrinityCore-Patches/All-In-One/world_AIO.sql   |   31 +
 .../ArenaGambler/CharactersDB.sql                  |   59 +
 sql/TrinityCore-Patches/ArenaGambler/WorldDB.sql   |  318 +++
 .../character.Arena_Template_NPC.sql               | 2476 ++++++++++++++++++++
 .../BloodMoneyDuels/world.bloodmoneyduel.sql       |    1 +
 .../BountyHunter/characters.BountyHunter.sql       |   38 +
 .../BountyHunter/world.BountyHunter.sql            |    5 +
 .../External_Mail/characters.external_mail.sql     |   10 +
 .../Guildhouses/world_guildhouses.sql              |   67 +
 .../LevelNPC/world.levelnpc.sql                    |    5 +
 sql/TrinityCore-Patches/Lotto/world.lottery.sql    |   44 +
 .../Reforging/characters.reforging.sql             |   10 +
 .../Reforging/world.reforging.sql                  |    6 +
 .../SummonNPC/world.summonnpc-item.sql             |    4 +
 .../TeleNPC2/world.npc_teleport.sql                |  119 +
 .../Transmog/Transmog_CHANGELOG.md                 |  126 +
 .../Transmog/Transmog_README.md                    |   53 +
 .../Transmog/characters.Transmog.sql               |   37 +
 .../Transmog/world.Transmog.sql                    |   29 +
 .../TransmogVendor/characters.TransmogVendor.sql   |   37 +
 .../TransmogVendor/world_TransMogVendor.sql        |    6 +
 .../TriniIRC/World_TrinityChat.sql                 |   81 +
 sql/TrinityCore-Patches/TrinityJail/auth.jail.sql  |   13 +
 .../TrinityJail/characters_jail.sql                |   66 +
 .../TrinityJail/world_command_Deutsch.sql          |    7 +
 .../TrinityJail/world_command_English.sql          |    7 +
 .../TrinityJail/world_command_Francais.sql         |    7 +
 .../TrinityJail/world_trinity_string.sql           |   41 +
 .../Vote-Rewarder/world.vote-npc.sql               |    3 +
 .../WoWArmory/characters.armory.sql                |   50 +
 .../WorldChat/auth.worldchat.sql                   |    5 +
 .../arena1v1/character_v2.0.sql                    |    2 +
 sql/TrinityCore-Patches/arena1v1/world_v1.0.sql    |    3 +
 .../beastmaster/world-beastmaster.sql              |   65 +
 sql/TrinityCore-Patches/enchant/world.enchant.sql  |    4 +
 .../npc_buff/world_npc_buff.sql                    |   62 +
 .../profession_npc/world_professionnpc.sql         |    4 +
 src/common/Common.h                                |   15 +-
 .../Database/Implementation/CharacterDatabase.cpp  |    4 +
 .../Database/Implementation/CharacterDatabase.h    |    3 +
 src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp  |  377 +++
 src/server/game/AI/ScriptedAI/sc_npc_teleport.h    |  151 ++
 src/server/game/Accounts/RBAC.h                    |    7 +-
 src/server/game/Achievements/AchievementMgr.cpp    |    6 +
 src/server/game/Battlegrounds/Arena.cpp            |   49 +-
 src/server/game/Battlegrounds/ArenaTeam.cpp        |    4 +-
 src/server/game/Battlegrounds/ArenaTeam.h          |    2 +-
 src/server/game/Battlegrounds/Battleground.cpp     |   68 +-
 src/server/game/Battlegrounds/Battleground.h       |    8 +-
 src/server/game/Battlegrounds/BattlegroundMgr.cpp  |    4 +-
 .../game/Battlegrounds/BattlegroundQueue.cpp       |   84 +-
 src/server/game/Battlegrounds/BattlegroundQueue.h  |   11 +-
 src/server/game/Battlegrounds/BattlegroundScore.h  |   30 +-
 .../game/Battlegrounds/Zones/BattlegroundAB.cpp    |    2 +-
 .../game/Battlegrounds/Zones/BattlegroundAV.cpp    |   19 +-
 .../game/Battlegrounds/Zones/BattlegroundWS.cpp    |    5 +-
 src/server/game/CMakeLists.txt                     |    5 +
 src/server/game/Cfbg/Cfbg.cpp                      |  363 +++
 src/server/game/Cfbg/Cfbg.h                        |   61 +
 src/server/game/Chat/Channels/Channel.cpp          |    4 +
 src/server/game/Chat/Chat.cpp                      |   40 +
 src/server/game/Chat/Chat.h                        |    3 +
 src/server/game/DataStores/DBCEnums.h              |    2 +-
 src/server/game/DataStores/DBCStores.cpp           |    4 +-
 src/server/game/DataStores/DBCStores.h             |    2 +-
 src/server/game/DataStores/DBCStructure.h          |    2 +-
 src/server/game/DataStores/DBCfmt.h                |    2 +-
 src/server/game/Entities/Creature/Creature.cpp     |    4 +-
 src/server/game/Entities/Item/Item.cpp             |   11 +
 src/server/game/Entities/Player/Player.cpp         |  654 +++++-
 src/server/game/Entities/Player/Player.h           |  135 +-
 src/server/game/Entities/Unit/Unit.cpp             |   46 +-
 src/server/game/Entities/Unit/Unit.h               |    4 +-
 src/server/game/Events/GameEventMgr.cpp            |    7 +
 src/server/game/Globals/ObjectMgr.cpp              |  115 +
 src/server/game/Globals/ObjectMgr.h                |   23 +
 src/server/game/Handlers/AuctionHouseHandler.cpp   |    4 +-
 src/server/game/Handlers/BattleGroundHandler.cpp   |    8 +-
 src/server/game/Handlers/CharacterHandler.cpp      |    3 +
 src/server/game/Handlers/ChatHandler.cpp           |    7 +-
 src/server/game/Handlers/MiscHandler.cpp           |   19 +-
 src/server/game/Handlers/PetitionsHandler.cpp      |    4 +-
 src/server/game/Handlers/QueryHandler.cpp          |    1 +
 src/server/game/Handlers/SpellHandler.cpp          |   11 +-
 src/server/game/Mails/Mail.cpp                     |   62 +
 src/server/game/Miscellaneous/Language.h           |   55 +-
 src/server/game/Scripting/ScriptLoader.cpp         |  162 +-
 src/server/game/Scripting/ScriptMgr.cpp            |   63 +
 src/server/game/Scripting/ScriptMgr.h              |   60 +
 src/server/game/Server/WorldSession.h              |    1 +
 src/server/game/Spells/Spell.cpp                   |    4 +-
 src/server/game/Spells/SpellEffects.cpp            |    3 +
 src/server/game/Spells/SpellInfo.cpp               |    6 +-
 src/server/game/TriniChat/IRCClient.cpp            |  135 ++
 src/server/game/TriniChat/IRCClient.h              |  291 +++
 src/server/game/TriniChat/IRCCmd.cpp               |  857 +++++++
 src/server/game/TriniChat/IRCCmd.h                 |  144 ++
 src/server/game/TriniChat/IRCCmde.cpp              | 2353 +++++++++++++++++++
 src/server/game/TriniChat/IRCFunc.h                |  292 +++
 src/server/game/TriniChat/IRCIO.cpp                |  529 +++++
 src/server/game/TriniChat/IRCLog.cpp               |   81 +
 src/server/game/TriniChat/IRCLog.h                 |   40 +
 src/server/game/TriniChat/IRCSock.cpp              |  160 ++
 src/server/game/TriniChat/MCS_OnlinePlayers.cpp    |   94 +
 src/server/game/TriniChat/MCS_OnlinePlayers.h      |   38 +
 src/server/game/World/World.cpp                    |  293 ++-
 src/server/game/World/World.h                      |   77 +-
 src/server/scripts/CMakeLists.txt                  |    4 +
 src/server/scripts/Commands/cs_jail.cpp            |  390 +++
 src/server/scripts/Commands/cs_message.cpp         |   20 +
 src/server/scripts/Custom/ArenaGambler.cpp         |  308 +++
 src/server/scripts/Custom/ArenaGamblingSystem.cpp  |  723 ++++++
 src/server/scripts/Custom/ArenaGamblingSystem.h    |  458 ++++
 src/server/scripts/Custom/Arena_Anti_Draw.cpp      |   51 +
 src/server/scripts/Custom/BloodMoneyDuels.cpp      |  429 ++++
 src/server/scripts/Custom/DoubleXP.cpp             |   39 +
 src/server/scripts/Custom/LearnSpells.cpp          |  147 ++
 src/server/scripts/Custom/Phased_Duels.cpp         |   98 +
 src/server/scripts/Custom/Reforging.cpp            |  644 +++++
 src/server/scripts/Custom/TemplateNPC.cpp          | 1466 ++++++++++++
 src/server/scripts/Custom/TemplateNPC.h            |  257 ++
 .../scripts/Custom/TransmogDisplayVendor.cpp       | 1155 +++++++++
 .../scripts/Custom/TransmogDisplayVendorConf.h     |   93 +
 src/server/scripts/Custom/Transmogrification.cpp   |  872 +++++++
 src/server/scripts/Custom/Transmogrification.h     |  129 +
 src/server/scripts/Custom/Transmogrifier.cpp       |  421 ++++
 src/server/scripts/Custom/VAS_AutoBalance.cpp      |  510 ++++
 src/server/scripts/Custom/WorldChat.cpp            |  120 +
 src/server/scripts/Custom/account_mount.cpp        |   53 +
 src/server/scripts/Custom/all-in-one.cpp           | 1329 +++++++++++
 src/server/scripts/Custom/announce_login.cpp       |   26 +
 src/server/scripts/Custom/beastmaster.cpp          |  383 +++
 src/server/scripts/Custom/bountyhunter.cpp         |  463 ++++
 src/server/scripts/Custom/chat_censor.cpp          |  106 +
 src/server/scripts/Custom/enchant.cpp              | 1619 +++++++++++++
 src/server/scripts/Custom/gon_playerscripts.cpp    |   31 +
 src/server/scripts/Custom/guildmaster.cpp          |  308 +++
 src/server/scripts/Custom/killstreak.cpp           |   61 +
 src/server/scripts/Custom/levelnpc.cpp             |  191 ++
 src/server/scripts/Custom/login_reset.cpp          |   28 +
 src/server/scripts/Custom/npc_arena1v1.cpp         |  309 +++
 src/server/scripts/Custom/npc_arena1v1.h           |   69 +
 src/server/scripts/Custom/npc_lottery.cpp          |  360 +++
 src/server/scripts/Custom/npc_teleport.cpp         |  219 ++
 src/server/scripts/Custom/npc_vote_rewarder.cpp    |  386 +++
 src/server/scripts/Custom/npcbuff.cpp              |  424 ++++
 src/server/scripts/Custom/professionnpc.cpp        |  394 ++++
 src/server/scripts/Custom/summon.cpp               |   46 +
 src/server/scripts/Spells/spell_generic.cpp        |   29 +-
 src/server/worldserver/CMakeLists.txt              |    5 +
 src/server/worldserver/CommandLine/CliRunnable.cpp |    9 +
 src/server/worldserver/Main.cpp                    |   35 +
 src/server/worldserver/worldserver.conf.dist       |  951 ++++++++
 159 files changed, 28172 insertions(+), 238 deletions(-)
 create mode 100644 Patch_List.txt
 create mode 100644 README.NPCTELEPORT
 create mode 100644 Reforging_README.md
 create mode 100644 TransmogVendor_README.md
 create mode 100644 sql/TrinityCore-Patches/All-In-One/auth_AIO.sql
 create mode 100644 sql/TrinityCore-Patches/All-In-One/characters_AIO.sql
 create mode 100644 sql/TrinityCore-Patches/All-In-One/world_AIO.sql
 create mode 100644 sql/TrinityCore-Patches/ArenaGambler/CharactersDB.sql
 create mode 100644 sql/TrinityCore-Patches/ArenaGambler/WorldDB.sql
 create mode 100644 sql/TrinityCore-Patches/Arena_Template_NPC/character.Arena_Template_NPC.sql
 create mode 100644 sql/TrinityCore-Patches/BloodMoneyDuels/world.bloodmoneyduel.sql
 create mode 100644 sql/TrinityCore-Patches/BountyHunter/characters.BountyHunter.sql
 create mode 100644 sql/TrinityCore-Patches/BountyHunter/world.BountyHunter.sql
 create mode 100644 sql/TrinityCore-Patches/External_Mail/characters.external_mail.sql
 create mode 100644 sql/TrinityCore-Patches/Guildhouses/world_guildhouses.sql
 create mode 100644 sql/TrinityCore-Patches/LevelNPC/world.levelnpc.sql
 create mode 100644 sql/TrinityCore-Patches/Lotto/world.lottery.sql
 create mode 100644 sql/TrinityCore-Patches/Reforging/characters.reforging.sql
 create mode 100644 sql/TrinityCore-Patches/Reforging/world.reforging.sql
 create mode 100644 sql/TrinityCore-Patches/SummonNPC/world.summonnpc-item.sql
 create mode 100644 sql/TrinityCore-Patches/TeleNPC2/world.npc_teleport.sql
 create mode 100644 sql/TrinityCore-Patches/Transmog/Transmog_CHANGELOG.md
 create mode 100644 sql/TrinityCore-Patches/Transmog/Transmog_README.md
 create mode 100644 sql/TrinityCore-Patches/Transmog/characters.Transmog.sql
 create mode 100644 sql/TrinityCore-Patches/Transmog/world.Transmog.sql
 create mode 100644 sql/TrinityCore-Patches/TransmogVendor/characters.TransmogVendor.sql
 create mode 100644 sql/TrinityCore-Patches/TransmogVendor/world_TransMogVendor.sql
 create mode 100644 sql/TrinityCore-Patches/TriniIRC/World_TrinityChat.sql
 create mode 100644 sql/TrinityCore-Patches/TrinityJail/auth.jail.sql
 create mode 100644 sql/TrinityCore-Patches/TrinityJail/characters_jail.sql
 create mode 100644 sql/TrinityCore-Patches/TrinityJail/world_command_Deutsch.sql
 create mode 100644 sql/TrinityCore-Patches/TrinityJail/world_command_English.sql
 create mode 100644 sql/TrinityCore-Patches/TrinityJail/world_command_Francais.sql
 create mode 100644 sql/TrinityCore-Patches/TrinityJail/world_trinity_string.sql
 create mode 100644 sql/TrinityCore-Patches/Vote-Rewarder/world.vote-npc.sql
 create mode 100644 sql/TrinityCore-Patches/WoWArmory/characters.armory.sql
 create mode 100644 sql/TrinityCore-Patches/WorldChat/auth.worldchat.sql
 create mode 100644 sql/TrinityCore-Patches/arena1v1/character_v2.0.sql
 create mode 100644 sql/TrinityCore-Patches/arena1v1/world_v1.0.sql
 create mode 100644 sql/TrinityCore-Patches/beastmaster/world-beastmaster.sql
 create mode 100644 sql/TrinityCore-Patches/enchant/world.enchant.sql
 create mode 100644 sql/TrinityCore-Patches/npc_buff/world_npc_buff.sql
 create mode 100644 sql/TrinityCore-Patches/profession_npc/world_professionnpc.sql
 create mode 100644 src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp
 create mode 100644 src/server/game/AI/ScriptedAI/sc_npc_teleport.h
 create mode 100644 src/server/game/Cfbg/Cfbg.cpp
 create mode 100644 src/server/game/Cfbg/Cfbg.h
 create mode 100644 src/server/game/TriniChat/IRCClient.cpp
 create mode 100644 src/server/game/TriniChat/IRCClient.h
 create mode 100644 src/server/game/TriniChat/IRCCmd.cpp
 create mode 100644 src/server/game/TriniChat/IRCCmd.h
 create mode 100644 src/server/game/TriniChat/IRCCmde.cpp
 create mode 100644 src/server/game/TriniChat/IRCFunc.h
 create mode 100644 src/server/game/TriniChat/IRCIO.cpp
 create mode 100644 src/server/game/TriniChat/IRCLog.cpp
 create mode 100644 src/server/game/TriniChat/IRCLog.h
 create mode 100644 src/server/game/TriniChat/IRCSock.cpp
 create mode 100644 src/server/game/TriniChat/MCS_OnlinePlayers.cpp
 create mode 100644 src/server/game/TriniChat/MCS_OnlinePlayers.h
 create mode 100644 src/server/scripts/Commands/cs_jail.cpp
 create mode 100644 src/server/scripts/Custom/ArenaGambler.cpp
 create mode 100644 src/server/scripts/Custom/ArenaGamblingSystem.cpp
 create mode 100644 src/server/scripts/Custom/ArenaGamblingSystem.h
 create mode 100644 src/server/scripts/Custom/Arena_Anti_Draw.cpp
 create mode 100644 src/server/scripts/Custom/BloodMoneyDuels.cpp
 create mode 100644 src/server/scripts/Custom/DoubleXP.cpp
 create mode 100644 src/server/scripts/Custom/LearnSpells.cpp
 create mode 100644 src/server/scripts/Custom/Phased_Duels.cpp
 create mode 100644 src/server/scripts/Custom/Reforging.cpp
 create mode 100644 src/server/scripts/Custom/TemplateNPC.cpp
 create mode 100644 src/server/scripts/Custom/TemplateNPC.h
 create mode 100644 src/server/scripts/Custom/TransmogDisplayVendor.cpp
 create mode 100644 src/server/scripts/Custom/TransmogDisplayVendorConf.h
 create mode 100644 src/server/scripts/Custom/Transmogrification.cpp
 create mode 100644 src/server/scripts/Custom/Transmogrification.h
 create mode 100644 src/server/scripts/Custom/Transmogrifier.cpp
 create mode 100644 src/server/scripts/Custom/VAS_AutoBalance.cpp
 create mode 100644 src/server/scripts/Custom/WorldChat.cpp
 create mode 100644 src/server/scripts/Custom/account_mount.cpp
 create mode 100644 src/server/scripts/Custom/all-in-one.cpp
 create mode 100644 src/server/scripts/Custom/announce_login.cpp
 create mode 100644 src/server/scripts/Custom/beastmaster.cpp
 create mode 100644 src/server/scripts/Custom/bountyhunter.cpp
 create mode 100644 src/server/scripts/Custom/chat_censor.cpp
 create mode 100644 src/server/scripts/Custom/enchant.cpp
 create mode 100644 src/server/scripts/Custom/gon_playerscripts.cpp
 create mode 100644 src/server/scripts/Custom/guildmaster.cpp
 create mode 100644 src/server/scripts/Custom/killstreak.cpp
 create mode 100644 src/server/scripts/Custom/levelnpc.cpp
 create mode 100644 src/server/scripts/Custom/login_reset.cpp
 create mode 100644 src/server/scripts/Custom/npc_arena1v1.cpp
 create mode 100644 src/server/scripts/Custom/npc_arena1v1.h
 create mode 100644 src/server/scripts/Custom/npc_lottery.cpp
 create mode 100644 src/server/scripts/Custom/npc_teleport.cpp
 create mode 100644 src/server/scripts/Custom/npc_vote_rewarder.cpp
 create mode 100644 src/server/scripts/Custom/npcbuff.cpp
 create mode 100644 src/server/scripts/Custom/professionnpc.cpp
 create mode 100644 src/server/scripts/Custom/summon.cpp

diff --git a/Patch_List.txt b/Patch_List.txt
new file mode 100644
index 0000000..71f8d1d
--- /dev/null
+++ b/Patch_List.txt
@@ -0,0 +1,33 @@
+335a_prepatch.patch
+2015_11_01-255_in_Who_List.patch
+2015_11_01-Cheats-FastFishing-AttackAndRespawnSpeed.patch
+2015_11_01-Fatigue.patch
+2015_11_01-Guard-Elite-Honor.patch
+2015_11_01-Killstreak.patch
+2015_11_01-PlayedTime.patch
+2015_11_01-PVP-Ranks.patch
+2015_11_01-StartGuild.patch
+2015_11_01-TeleNPC2-SummonNPC.patch
+2015_11_01-TrinityIRC.patch
+2015_11_01-VoteRewards.patch
+2015_11_01-WorldChat.patch
+2015_11_09-GuildHouses.patch
+2015_11_10-Arena_Gambler.patch
+2015_11_10-Arena_Template.patch
+2015_11_10-Reforging.patch
+2015_11_17-All-In-One.patch
+2015_11_18-Armory.patch
+2015_11_18-External_Mail.patch
+2015_11_18-VAS_AutoBalance.patch
+2015_12_02-Transmog-with-Vendor.patch
+2015_12_08-1v1ArenaFITTED.patch
+2015_12_24-TrinityJail.patch
+2015_12_26-CrossFactionBG.patch
+2015_12_27-AutoLearnSpells.patch
+2015_12_27-BloodMoneyDuel.patch
+2016_01_09-Account_Mounts.patch
+2016_01_09-Announce_Login.patch
+2016_01_09-Arena_Anti_Draw.patch
+2016_01_09-Login_Reset.patch
+2016_01_09-Phased_Duels.patch
+2016_01_10-Double_XP_Weekend.patch
diff --git a/README.NPCTELEPORT b/README.NPCTELEPORT
new file mode 100644
index 0000000..015c9c2
--- /dev/null
+++ b/README.NPCTELEPORT
@@ -0,0 +1,14 @@
+NPC Teleport for Trinity
+
+Original author : Wilibald09
+
+Allows you to add a custom NPC for teleporting, using .npc add 100000.
+The default NPC is entry 100000.
+
+All settings are located in the DB, so you can customize and add destinations,
+set level restrictions and also charge the player for teleporting.
+
+Installation:
+
+Run the query setup_npc_teleport.sql located in the trinity sql directory on
+your world DB. This will setup the DB and you can customize from there.
diff --git a/Reforging_README.md b/Reforging_README.md
new file mode 100644
index 0000000..e26d9bf
--- /dev/null
+++ b/Reforging_README.md
@@ -0,0 +1,40 @@
+#Reforging [![Build Status](https://travis-ci.org/Rochet2/TrinityCore.svg?branch=reforging)](https://travis-ci.org/Rochet2/TrinityCore)
+
+####About
+Blizz*like* reforging
+Change 40% of your item stats to something else
+Sends item packets so you can see the changes on item tooltips
+Simple and easy to use interface
+Made for 3.3.5a.<br />
+Source: https://rochet2.github.io/?page=Reforging
+
+Video: https://youtu.be/84EtvKTfqQM
+
+####Installation
+
+Available as:
+- Direct merge: https://github.com/Rochet2/TrinityCore/tree/reforging
+- Diff: https://github.com/Rochet2/TrinityCore/compare/reforging.diff
+- Patch: https://github.com/Rochet2/TrinityCore/compare/reforging.patch
+
+Using direct merge:
+- open git bash to source location
+- do `git remote add rochet2 https://github.com/Rochet2/TrinityCore.git`
+- do `git pull rochet2 reforging`
+- use cmake and compile
+
+Using diff:
+- DO NOT COPY THE DIFF DIRECTLY! It causes apply to fail.
+- download the diff by __right clicking__ the link and select __Save link as__
+- place the downloaded `reforging.diff` to the source root folder
+- open git bash to source location
+- do `git apply reforging.diff`
+- use cmake and compile
+
+After compiling:
+- Navigate to `\src\server\scripts\Custom\Reforging\sql\`
+- Run `characters.reforging.sql` to your characters database
+ - optionally you can also insert a reforger NPC to your database by running `world.reforging.sql` to your world database.
+
+####Bugs and Contact
+Report issues and similar to https://rochet2.github.io/
diff --git a/TransmogVendor_README.md b/TransmogVendor_README.md
new file mode 100644
index 0000000..de921d6
--- /dev/null
+++ b/TransmogVendor_README.md
@@ -0,0 +1,49 @@
+#Transmogrification Display Vendor [![Build Status](https://travis-ci.org/Rochet2/TrinityCore.svg?branch=transmogvendor)](https://travis-ci.org/Rochet2/TrinityCore)
+
+####About
+Original idea by LilleCarl.
+Coding work and execution by Rochet2.
+Transmogrification Display Vendor allows you to change the display of an item to something else.
+You can use any item display in the game, as long as it fits the requirements.
+Requirements can be tweaked in the `TransmogDisplayVendor.cpp` file.
+Basically any item should work with transmogrification. Custom items as well. No item is hardcoded to the system.
+Has a feature to work with the regular [Transmogrification](http://rochet2.github.io/Transmogrification.html). This can be enabled before compiling in `TransmogDisplayVendor.h`.
+Made for 3.3.5a.<br />
+Source: http://www.trinitycore.org/f/topic/7993-transmogrification-display-vendor/
+
+Video: https://youtu.be/PIheEziN_dY
+
+####Installation
+
+Available as:
+- Direct merge: https://github.com/Rochet2/TrinityCore/tree/transmogvendor
+- Diff: https://github.com/Rochet2/TrinityCore/compare/TrinityCore:3.3.5...transmogvendor.diff
+- Diff in github view: https://github.com/Rochet2/TrinityCore/compare/TrinityCore:3.3.5...transmogvendor
+
+Using direct merge:
+- open git bash to source location
+- do `git remote add rochet2 https://github.com/Rochet2/TrinityCore.git`
+- do `git pull rochet2 transmogvendor`
+- use cmake and compile
+
+Using diff *(recommended)*:
+- DO NOT COPY THE DIFF DIRECTLY! It causes apply to fail.
+- download the diff by __right clicking__ the link and select __Save link as__
+- place the downloaded `transmogvendor.diff` to the source root folder
+- open git bash to source location
+- do `git apply transmogvendor.diff`
+ - if using the regular transmogrification, simply use --reject with either and overwrite the parts of the other. Order doesnt matter, as long as duplicate code doesnt exist.
+- use cmake and compile
+
+After compiling:
+- Navigate to `\src\server\scripts\Custom\TransmogDisplayVendor\sql\`
+- Run `characters.sql` to your characters database
+ - This is same file as with the regular transmog
+- Optionally you can also insert a transmogrifier NPC to your database by running `world_NPC.sql` to your world database.
+
+####Usage
+Equip an item that is suitable for transmogrification.
+Talk to Transmogrifier and select the item slot. Then select the quality and then the item you want to transmogrify to.
+
+####Bugs and Contact
+Report issues and similar to http://rochet2.github.io/
diff --git a/sql/TrinityCore-Patches/All-In-One/auth_AIO.sql b/sql/TrinityCore-Patches/All-In-One/auth_AIO.sql
new file mode 100644
index 0000000..ed0d7ea
--- /dev/null
+++ b/sql/TrinityCore-Patches/All-In-One/auth_AIO.sql
@@ -0,0 +1,11 @@
+CREATE TABLE `hacked` (
+ `charname` CHAR( 50) NOT NULL
+);
+
+CREATE TABLE `lagreports` (
+ `account` CHAR( 50) NOT NULL
+);
+
+CREATE TABLE `vipek2` (
+ `account` CHAR( 50) NOT NULL
+);
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/All-In-One/characters_AIO.sql b/sql/TrinityCore-Patches/All-In-One/characters_AIO.sql
new file mode 100644
index 0000000..f131461
--- /dev/null
+++ b/sql/TrinityCore-Patches/All-In-One/characters_AIO.sql
@@ -0,0 +1 @@
+REPLACE INTO `mail` (`id`, `messageType`, `stationery`, `mailTemplateId`, `sender`, `receiver`, `subject`, `has_items`, `expire_time`, `deliver_time`, `money`, `cod`, `checked`) VALUES (60003, 0, 41, 0, 0, 0, 'Money For You!', 0, 0, 0, 4294967295, 0, 1);
diff --git a/sql/TrinityCore-Patches/All-In-One/world_AIO.sql b/sql/TrinityCore-Patches/All-In-One/world_AIO.sql
new file mode 100644
index 0000000..2ab17ef
--- /dev/null
+++ b/sql/TrinityCore-Patches/All-In-One/world_AIO.sql
@@ -0,0 +1,31 @@
+-- Updates
+-- WARNING! It's changes official blizz data!
+UPDATE `creature_template` SET `faction`=35 WHERE `entry` IN(28474, 914, 23128, 17204, 5115, 4584, 16655, 28958, 4090, 23534);
+
+-- Inserts
+REPLACE INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `Probability0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `Probability1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `Probability2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `Probability3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `Probability4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `Probability5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `Probability6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `Probability7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80000, 'Sorry, you are not VIP member.', NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+REPLACE INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `Probability0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `Probability1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `Probability2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `Probability3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `Probability4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `Probability5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `Probability6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `Probability7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80001, 'Welcome Dear VIP.', NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+REPLACE INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `Probability0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `Probability1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `Probability2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `Probability3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `Probability4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `Probability5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `Probability6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `Probability7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80006, 'Your skills are set to max.', NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+REPLACE INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `Probability0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `Probability1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `Probability2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `Probability3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `Probability4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `Probability5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `Probability6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `Probability7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80007, 'It\'s Time To choose!', NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+REPLACE INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `Probability0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `Probability1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `Probability2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `Probability3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `Probability4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `Probability5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `Probability6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `Probability7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80010, 'Donation help text', NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+REPLACE INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `Probability0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `Probability1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `Probability2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `Probability3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `Probability4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `Probability5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `Probability6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `Probability7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80011, 'Normal help text', NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+REPLACE INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `Probability0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `Probability1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `Probability2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `Probability3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `Probability4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `Probability5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `Probability6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `Probability7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80012, 'Ingame help text', NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+
+INSERT INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `Probability0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `Probability1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `Probability2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `Probability3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `Probability4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `Probability5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `Probability6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `Probability7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80013, 'You Don\'t have resurrection sickness!', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, 1);
+INSERT INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `Probability0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `Probability1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `Probability2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `Probability3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `Probability4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `Probability5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `Probability6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `Probability7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80014, 'You Don\'t have a pet!', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, 1);
+INSERT INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `Probability0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `Probability1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `Probability2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `Probability3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `Probability4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `Probability5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `Probability6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `Probability7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80016, 'Welcome! My Name is AIO. What can I help for you?', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, 1);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (998, '|cffff0000<Announcer>: Join Warsong Guilch!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (999, '|cffff0000<Announcer>: Join Wintergrasp!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (997, '|cffff0000<Announcer>: Join Arathi Basin!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (996, '|cffff0000<Announcer>: Join Eye of the Storm!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (995, '|cffff0000<Announcer>: Join Random Battleground!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (994, '|cffff0000<Announcer>: Join Arena 2v2!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (993, '|cffff0000<Announcer>: Join Arena 3v3!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (992, '|cffff0000<Announcer>: Join Arena 5v5!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (991, '|cffff0000<Announcer>: Join Alterac Valley!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (990, '|cffff0000<Announcer>: Join Strand of the Ancients!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+
+-- Creature_template entry. Make sure entry number does not conflict.
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `dmgschool`, `BaseAttackTime`, `RangeAttackTime`, `BaseVariance`, `RangeVariance`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `HealthModifier`, `ManaModifier`, `ArmorModifier`, `DamageModifier`, `ExperienceModifier`, `RacialLeader`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) values
+('80000','0','0','0','0','0','2591','0','0','0','Young Woman','You need it, I got it.','','0','80','80','0','35','1','1','1.14286','1','1','0','1500','0','1','1','1','0','2048','0','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','EventAI','0','3','1','1','1','1','1','1','0','0','1','0','0','npc_all','0');
+-- end
diff --git a/sql/TrinityCore-Patches/ArenaGambler/CharactersDB.sql b/sql/TrinityCore-Patches/ArenaGambler/CharactersDB.sql
new file mode 100644
index 0000000..ac486b2
--- /dev/null
+++ b/sql/TrinityCore-Patches/ArenaGambler/CharactersDB.sql
@@ -0,0 +1,59 @@
+/*
+ * Author: Xees
+ * Description: This file is used to apply the database tables needed for the ArenaGambler
+ * Version: 1.2
+*/
+create table `custom_duel_config` (
+    `optionIndex` int (10),
+    `optionName` varchar (60),
+    `optionValue` float
+);
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('0','MAP ID ','1');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('1','X CORDS','-7218.97');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('2','Y CORDS','982.622');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('3','Z CORDS','303.524');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('4','O CORDS','1.40677');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('5','MINIMUM LEVEL','60');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('6','LEVEL DIFF','3');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('7','REWARD ON FLED','1');
+
+create table `custom_duel_statistics` (
+    `playerGUID` int (11),
+    `duelsLost` int (10),
+    `duelsWon` int (10),
+    `duelsRefused` int (10),
+    `duelsTotal` int (10)
+);
+
+INSERT INTO `custom_duel_config`
+            (`optionIndex`,
+             `optionName`,
+             `optionValue`)
+VALUES ('12',
+        'ENABLE ONLY CURRENCY',
+        '0');
+INSERT INTO `custom_duel_config`
+            (`optionIndex`,
+             `optionName`,
+             `optionValue`)
+VALUES ('13',
+        'ENABLE EQUAL BETS',
+        '0');
+
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('11','ENABLE ITEM LIMITS','0');
+
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('8','MAXIMUM BET','1000');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('9','ENABLE GM DUEL','0');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('10','ENABLE SAMEIP DUEL','0');
+
+create table `custom_duel_storage` (
+    `matchId` int (10),
+    `challengerGUID` int (11),
+    `defenderGUID` int (11),
+    `challengerItemId` mediumint (8),
+    `challengerItemCount` int (11),
+    `defenderItemId` mediumint (8),
+    `defenderItemCount` int (11),
+    `matchDate` timestamp ,
+    `matchWinner` int (11)
+);
diff --git a/sql/TrinityCore-Patches/ArenaGambler/WorldDB.sql b/sql/TrinityCore-Patches/ArenaGambler/WorldDB.sql
new file mode 100644
index 0000000..1d314b7
--- /dev/null
+++ b/sql/TrinityCore-Patches/ArenaGambler/WorldDB.sql
@@ -0,0 +1,318 @@
+
+/*Data for the table `creature` */
+
+DELETE FROM `creature` WHERE `guid` IN (1112144, 1112145, 1112146, 1112148, 1112149, 1112150, 1112151, 1112152, 1112153, 1112155, 1112156, 1112157, 1112158, 1112159, 1112160, 1112161, 1112162, 1112163, 1112164, 1112165, 1112166, 1118308);
+
+INSERT INTO `creature`(`guid`,`id`,`map`,`zoneId`,`areaId`,`spawnMask`,`PhaseMask`,`modelid`,`equipment_id`,`position_x`,`position_y`,`position_z`,`orientation`,`spawntimesecs`,`spawndist`,`currentwaypoint`,`curhealth`,`curmana`,`MovementType`,`npcflag`,`unit_flags`,`dynamicflags`,`VerifiedBuild`) VALUES
+(1118308,908001,1,0,0,1,1,0,0,-7207.9,1056.01,327.532,4.59111,300,0,0,108000,0,2,0,0,0,0),
+(1112166,25266,1,0,0,1,1,0,0,-7272.97,986.543,306.361,6.18204,300,0,0,42,0,2,0,0,0,0),
+(1112165,25266,1,0,0,1,1,0,0,-7272,994.955,306.361,6.18204,300,0,0,42,0,2,0,0,0,0),
+(1112163,25266,1,0,0,1,1,0,0,-7162.96,966.158,307.122,3.02317,300,0,0,42,0,2,0,0,0,0),
+(1112164,25266,1,0,0,1,1,0,0,-7273.19,989.977,306.361,6.18204,300,0,0,42,0,2,0,0,0,0),
+(1112162,25266,1,0,0,1,1,0,0,-7160.46,971.542,308.005,3.02317,300,0,0,42,0,2,0,0,0,0),
+(1112160,25266,1,0,0,1,1,0,0,-7166.61,968.537,306.36,3.02317,300,0,0,42,0,2,0,0,0,0),
+(1112161,25266,1,0,0,1,1,0,0,-7165.4,978.728,306.36,3.02317,300,0,0,42,0,2,0,0,0,0),
+(1112159,25266,1,0,0,1,1,0,0,-7166.34,970.852,306.36,3.02317,300,0,0,42,0,2,0,0,0,0),
+(1112158,25266,1,0,0,1,1,0,0,-7165.9,974.529,306.36,3.02317,300,0,0,42,0,2,0,0,0,0),
+(1112157,25266,1,0,0,1,1,0,0,-7162.03,975.112,306.944,3.02317,300,0,0,42,0,2,0,0,0,0),
+(1112145,25266,1,0,0,1,1,0,0,-7277.48,986.356,307.508,6.11808,300,0,0,42,0,2,0,0,0,0),
+(1112146,25266,1,0,0,1,1,0,0,-7277.03,989.028,307.5,6.11808,300,0,0,42,0,2,0,0,0,0),
+(1112156,25266,1,0,0,1,1,0,0,-7161.6,978.72,306.836,3.02317,300,0,0,42,0,2,0,0,0,0),
+(1112155,25266,1,0,0,1,1,0,0,-7159.16,978.43,308.144,3.02317,300,0,0,42,0,2,0,0,0,0),
+(1112152,25266,1,0,0,1,1,0,0,-7160.59,981.296,307.276,3.02317,300,0,0,42,0,2,0,0,0,0),
+(1112153,25266,1,0,0,1,1,0,0,-7158.82,981.086,308.239,3.02317,300,0,0,42,0,2,0,0,0,0),
+(1112150,25266,1,0,0,1,1,0,0,-7276.97,995.476,307.962,6.11808,300,0,0,42,0,2,0,0,0,0),
+(1112151,25266,1,0,0,1,1,0,0,-7275.67,995.258,307.121,6.11808,300,0,0,42,0,2,0,0,0,0),
+(1112149,25266,1,0,0,1,1,0,0,-7277.57,991.893,307.982,6.11808,300,0,0,42,0,2,0,0,0,0),
+(1112148,25266,1,0,0,1,1,0,0,-7275.89,991.613,307.009,6.11808,300,0,0,42,0,2,0,0,0,0),
+(1112144,25266,1,0,0,1,1,0,0,-7277.83,984.264,307.587,6.11808,300,0,0,42,0,2,0,0,0,0);
+
+/*Data for the table `creature_template` */
+
+DELETE FROM `creature_template` WHERE `entry` = 25266;
+
+INSERT INTO `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`trainer_type`,`trainer_class`,`trainer_race`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`) VALUES
+(25266,0,0,0,0,0,24818,3422,24819,24821,'Arena Gambler','','',0,255,255,0,35,0,1,1.14286,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,5,1,1,1,1,0,0,1,0,0,'',1);
+
+/*Data for the table `gameobject` */
+
+DELETE FROM `gameobject` WHERE `guid` IN (60046, 67903, 67906, 67907, 67908, 67909, 67918, 67919, 67920, 67921, 72037, 72043, 72058, 73361, 223623, 239644, 239650, 239651, 239653, 239655, 239656, 239657, 239658, 239659, 239660, 239661, 239669, 239670, 239671, 239672, 239673, 239674, 239675, 239886, 239888, 239889, 239891, 239893, 239894, 239895, 239896, 239897, 239903, 239906, 239913, 239922, 239923, 239933, 239934, 239941, 239944, 239946, 239948, 239949, 239950, 239951, 239952, 239954, 239955, 239957, 239958, 239959, 239960, 239961, 239962, 239966, 239968, 239970, 239971, 239972, 239973, 239974, 239975, 239976, 239977, 239985, 239992, 239994, 239997, 240003, 240004, 240005, 240008, 240010, 240015, 240016, 240017, 240019, 240020, 240021, 240023, 240024, 240026, 240027, 240028, 240063, 240064, 240065, 240066, 240067, 240068, 240069, 240072, 240073, 240074, 240075, 240076, 240077, 240080, 240085, 240086, 240087, 240088, 240089, 240090, 240091, 240092, 240093, 240094, 240095, 240096, 240097, 240098, 240099, 240100, 240109, 240118, 240119, 240120, 240121, 240122, 240123, 240124, 240125, 240126, 240127, 240128, 240133, 240136, 240137, 240141, 240144, 240147, 240149, 240150, 240152, 240153, 240155, 240160, 240164, 240166, 240167, 240168, 240169, 240170, 240171, 240172, 240174, 240175, 240176, 240177, 240178, 240179, 240180, 240181, 240182, 240183, 240184, 240193, 240194, 240195, 240196, 240197, 240198, 240199, 240200, 240202, 240203, 240204, 240205, 240206, 240207, 240208, 240209, 240210, 240211, 240212, 240213, 240214, 240215, 240216, 240217, 240218, 240219, 240220, 240221, 240222, 240223, 240224, 240225, 240226, 240227, 240228, 240229, 240230, 240231, 240232, 9044951, 9044969, 9044974, 9044976, 9044977, 9044978, 9044979, 9044980, 9044981, 9044982, 9045336, 9046953, 9046955, 9051186, 9055707, 9092464, 9092906, 9109862, 9109906, 9119083, 9119088, 9180717, 9180720, 9180728, 9330402, 9330403, 9347465, 9347468, 9365139, 9365229, 9365230, 9365232, 9365244, 9365245, 9365246, 9365247);
+
+INSERT INTO `gameobject`(`guid`,`id`,`map`,`zoneId`,`areaId`,`spawnMask`,`PhaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`,`VerifiedBuild`) VALUES
+(9045336,8021000,1,0,0,1,1,-7217.97,1054.25,331.856,5.24803,0,0,0.494776,-0.86902,300,0,1,0),
+(239650,8010000,1,0,0,1,1,-7218.95,982.451,299.273,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239651,8010001,1,0,0,1,1,-7218.95,982.451,299.273,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239644,8010002,0,0,0,1,1,-8942.42,-4009.48,331.64,0.943155,0,0,0.454292,0.890853,25,0,1,0),
+(239653,8010003,1,0,0,1,1,-7218.95,982.451,299.273,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(9044977,8007862,1,0,0,1,1,-7224.76,1021.03,303.523,1.40272,0,0,0.645258,0.763965,300,0,1,0),
+(9044978,8007862,1,0,0,1,1,-7201.21,1017.04,303.523,1.40272,0,0,0.645258,0.763965,300,0,1,0),
+(9044951,8007658,1,0,0,1,1,-7207.87,1056.14,327.535,4.52314,0,0,0.770754,-0.637133,300,0,1,0),
+(9046955,800342,1,0,0,1,1,-7212.74,1056.6,335.527,4.59111,0,0,0.748659,-0.662955,300,0,1,0),
+(9046953,800342,1,0,0,1,1,-7202.82,1055.39,335.527,4.59111,0,0,0.748659,-0.662955,300,0,1,0),
+(9044976,8008124,1,0,0,1,1,-7207.83,1055.98,342.182,1.41429,0,0,0.649667,0.760219,300,0,1,0),
+(9055707,8008054,1,0,0,1,1,-7137.07,970.488,329.703,1.51134,0,0,0.685777,0.727812,300,0,1,0),
+(9044974,8008054,1,0,0,1,1,-7302.17,994.336,328.471,4.55182,0,0,0.761539,-0.648119,300,0,1,0),
+(9044969,8008054,1,0,0,1,1,-7232.73,900.85,329.059,6.09277,0,0,0.0950627,-0.995471,300,0,1,0),
+(9044979,8004714,1,0,0,1,1,-7280.03,1002.39,303.523,6.13,0,0,0.0765184,-0.997068,300,0,1,0),
+(9044980,8004714,1,0,0,1,1,-7283.71,978.588,303.523,6.13,0,0,0.0765184,-0.997068,300,0,1,0),
+(9044981,8004714,1,0,0,1,1,-7155.47,985.314,303.524,6.13,0,0,0.0765184,-0.997068,300,0,1,0),
+(9044982,8004714,1,0,0,1,1,-7158.91,962.114,303.524,6.13,0,0,0.0765184,-0.997068,300,0,1,0),
+(240164,70264,1,0,0,1,1,-7211.89,921.652,307.653,3.01201,0,0,0.997902,0.0647469,25,0,1,0),
+(240166,70264,1,0,0,1,1,-7211.89,921.652,303.524,3.01201,0,0,0.997902,0.0647469,25,0,1,0),
+(240167,70264,1,0,0,1,1,-7211.64,923.561,304.714,3.01201,0,0,0.997902,0.0647469,25,0,1,0),
+(240168,70264,1,0,0,1,1,-7210.66,920.395,305.123,3.10238,0,0,0.999808,0.0196051,25,0,1,0),
+(240169,70264,1,0,0,1,1,-7210,922.433,304.547,3.52728,0,0,0.981463,-0.191651,25,0,1,0),
+(240170,70264,1,0,0,1,1,-7211.74,925.442,305.599,3.55012,0,0,0.97921,-0.202848,25,0,1,0),
+(240171,70264,1,0,0,1,1,-7211.08,927.887,303.524,2.53696,0,0,0.954649,0.297734,25,0,1,0),
+(240172,70264,1,0,0,1,1,-7210.16,925.499,303.523,0.171338,0,0,0.0855642,0.996333,25,0,1,0),
+(240174,70264,1,0,0,1,1,-7212.64,918.485,307.331,2.88561,0,0,0.99182,0.127644,25,0,1,0),
+(240175,70264,1,0,0,1,1,-7213.07,916.643,307.346,4.4564,0,0,0.791581,-0.611065,25,0,1,0),
+(240176,70264,1,0,0,1,1,-7213.5,915.324,306.69,4.4564,0,0,0.791581,-0.611065,25,0,1,0),
+(240177,70264,1,0,0,1,1,-7213.94,913.631,308.328,2.57459,0,0,0.960082,0.27972,25,0,1,0),
+(240178,70264,1,0,0,1,1,-7210.59,918.498,303.524,2.23965,0,0,0.900025,0.435839,25,0,1,0),
+(240179,70264,1,0,0,1,1,-7211,916.593,304.705,2.5813,0,0,0.961015,0.276496,25,0,1,0),
+(240180,70264,1,0,0,1,1,-7211.58,914.537,304.612,5.18568,0,0,0.521622,-0.853176,25,0,1,0),
+(240181,70264,1,0,0,1,1,-7214.78,911.262,309.84,2.45752,0,0,0.942074,0.335406,25,0,1,0),
+(240182,70264,1,0,0,1,1,-7216.24,912.227,306.76,5.43418,0,0,0.411866,-0.911244,25,0,1,0),
+(240183,70264,1,0,0,1,1,-7212.83,912.539,307.181,2.37505,0,0,0.927447,0.373954,25,0,1,0),
+(240184,70264,1,0,0,1,1,-7213.46,909.984,307.23,0.549789,0,0,0.271445,0.962454,25,0,1,0),
+(240194,70264,1,0,0,1,1,-7209.58,914.14,303.524,3.51295,0,0,0.982811,-0.184616,25,0,1,0),
+(240195,70264,1,0,0,1,1,-7208.91,916.507,303.523,3.29697,0,0,0.996984,-0.0776098,25,0,1,0),
+(240196,70264,1,0,0,1,1,-7208.91,920.253,303.524,3.50117,0,0,0.983881,-0.178823,25,0,1,0),
+(240197,70264,1,0,0,1,1,-7211.93,910.935,303.523,2.14636,0,0,0.878724,0.477331,25,0,1,0),
+(240198,70264,1,0,0,1,1,-7211.66,909.391,304.125,3.06528,0,0,0.999272,0.0381473,25,0,1,0),
+(240199,70264,1,0,0,1,1,-7243.47,918.183,306.827,2.88084,0,0,0.991513,0.130006,25,0,1,0),
+(240200,70264,1,0,0,1,1,-7242.56,920.043,306.432,6.18659,0,0,0.0482802,-0.998834,25,0,1,0),
+(240202,70264,1,0,0,1,1,-7242.34,922.252,307.37,4.61579,0,0,0.740422,-0.672143,25,0,1,0),
+(240203,70264,1,0,0,1,1,-7241.58,918.298,307.496,5.83709,0,0,0.221202,-0.975228,25,0,1,0),
+(240204,70264,1,0,0,1,1,-7242.13,920.107,308.89,6.18659,0,0,0.0482802,-0.998834,25,0,1,0),
+(240205,70264,1,0,0,1,1,-7240.56,920.002,306.682,3.3923,0,0,0.992153,-0.125027,25,0,1,0),
+(240206,70264,1,0,0,1,1,-7243.02,924.059,309.946,6.17654,0,0,0.0532979,-0.998579,25,0,1,0),
+(240207,70264,1,0,0,1,1,-7243.01,924.088,305.274,6.17654,0,0,0.0532979,-0.998579,25,0,1,0),
+(240208,70264,1,0,0,1,1,-7243.04,924.253,303.523,6.17654,0,0,0.0532979,-0.998579,25,0,1,0),
+(240209,70264,1,0,0,1,1,-7241.35,924.009,307.062,1.96681,0,0,0.83239,0.55419,25,0,1,0),
+(240210,70264,1,0,0,1,1,-7241.94,925.8,305.81,5.47362,0,0,0.393821,-0.919187,25,0,1,0),
+(240211,70264,1,0,0,1,1,-7241.6,928.466,303.523,6.04382,0,0,0.119399,-0.992846,25,0,1,0),
+(240212,70264,1,0,0,1,1,-7241.24,930.286,305.206,3.14491,0,0,0.999999,-0.00165872,25,0,1,0),
+(240213,70264,1,0,0,1,1,-7243.68,926.66,303.523,5.75479,0,0,0.261137,-0.965302,25,0,1,0),
+(240214,70264,1,0,0,1,1,-7242.97,929.298,303.523,5.94014,0,0,0.170683,-0.985326,25,0,1,0),
+(240215,70264,1,0,0,1,1,-7242.62,931.894,303.523,0.27742,0,0,0.138265,0.990395,25,0,1,0),
+(240216,70264,1,0,0,1,1,-7240.76,933.186,304.251,4.5225,0,0,0.770957,-0.636887,25,0,1,0),
+(240217,70264,1,0,0,1,1,-7240.6,934.86,303.523,1.03381,0,0,0.494194,0.869352,25,0,1,0),
+(240218,70264,1,0,0,1,1,-7240.63,927.437,308.706,3.04601,0,0,0.998858,0.0477748,25,0,1,0),
+(240219,70264,1,0,0,1,1,-7239.85,928.99,306.613,4.15651,0,0,0.873982,-0.485958,25,0,1,0),
+(240220,70264,1,0,0,1,1,-7239.49,930.882,305.622,0.293923,0,0,0.146433,0.989221,25,0,1,0),
+(240221,70264,1,0,0,1,1,-7243.6,927.232,307.087,2.75142,0,0,0.981031,0.19385,25,0,1,0),
+(240222,70264,1,0,0,1,1,-7243.98,921.131,303.523,0.378774,0,0,0.188257,0.98212,25,0,1,0),
+(240223,70264,1,0,0,1,1,-7245.03,918.867,303.523,5.00398,0,0,0.596875,-0.802334,25,0,1,0),
+(240224,70264,1,0,0,1,1,-7243.15,916.057,303.523,0.849226,0,0,0.411968,0.911198,25,0,1,0),
+(240225,70264,1,0,0,1,1,-7240.85,916.565,303.523,2.12943,0,0,0.87465,0.484755,25,0,1,0),
+(240226,70264,1,0,0,1,1,-7245.19,916.681,303.523,0.8453,0,0,0.410179,0.912005,25,0,1,0),
+(240141,8009248,1,0,0,1,1,-7226.12,929.725,303.755,0.169878,0,0,0.0848367,0.996395,25,0,1,0),
+(9119088,8009248,1,0,0,1,1,-1823.82,-4584.27,-109.975,5.70834,0,0,0.283482,-0.958978,300,0,1,0),
+(240149,8009248,1,0,0,1,1,-7227.33,920.772,306.682,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(240147,8009248,1,0,0,1,1,-7226.91,923.893,305.622,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(240144,8009248,1,0,0,1,1,-7226.49,926.943,304.55,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(9119083,8009248,1,0,0,1,1,-1823.47,-4583.57,-110.052,4.20586,0,0,0.861725,-0.507375,300,0,1,0),
+(9347465,8009248,1,0,0,1,1,6459.17,-4273.97,667.048,3.94114,0,0,0.921148,-0.389212,300,0,1,0),
+(9347468,8009248,1,0,0,1,1,6474.25,-4258.45,665.93,3.94114,0,0,0.921148,-0.389212,300,0,1,0),
+(240150,181640,1,0,0,1,1,-7228.43,912.741,306.682,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(240152,181640,1,0,0,1,1,-7235.39,917.648,306.682,0.438242,0,0,0.217372,0.976089,25,0,1,0),
+(240153,181640,1,0,0,1,1,-7220.81,916.125,306.681,2.44007,0,0,0.939112,0.343611,25,0,1,0),
+(240155,181640,1,0,0,1,1,-7218.34,922.78,306.683,2.96331,0,0,0.99603,0.0890233,25,0,1,0),
+(240160,181640,1,0,0,1,1,-7236.27,924.809,306.682,6.1303,0,0,0.0763687,-0.99708,25,0,1,0),
+(9365229,186393,1,0,0,1,1,-3067.83,2199.85,43.8142,1.85265,0,0,0.799417,0.600776,300,0,1,0),
+(9365139,186393,1,0,0,1,1,-2789.46,2291.79,53.9035,2.34029,0,0,0.920808,0.390016,300,0,1,0),
+(240010,186393,1,0,0,1,1,-7162.65,959.809,303.523,4.58374,0,0,0.751097,-0.660192,25,0,1,0),
+(240008,186393,1,0,0,1,1,-7158.73,989.066,303.524,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(239922,186393,1,0,0,1,1,-7279.56,975.823,303.523,4.57633,0,0,0.753539,-0.657403,25,0,1,0),
+(239997,186393,1,0,0,1,1,-7159.63,980.321,306.361,3.00559,0,0,0.997689,0.0679491,25,0,1,0),
+(239913,186393,1,0,0,1,1,-7275.58,1004.97,303.523,1.43885,0,0,0.658953,0.752184,25,0,1,0),
+(239923,186393,1,0,0,1,1,-7277.64,990.373,306.361,6.1613,0,0,0.0609072,-0.998143,25,0,1,0),
+(239933,186393,1,0,0,1,1,-7278.38,984.389,306.36,6.1613,0,0,0.0609072,-0.998143,25,0,1,0),
+(239934,186393,1,0,0,1,1,-7276.92,996.3,306.36,6.1613,0,0,0.0609072,-0.998143,25,0,1,0),
+(240065,186393,1,0,0,1,1,-7248.77,1032.2,306.361,3.77837,0,0,0.949741,-0.313037,25,0,1,0),
+(240080,186393,1,0,0,1,1,-7174.38,1012.29,303.523,3.79203,0,0,0.94758,-0.319518,25,0,1,0),
+(240064,186393,1,0,0,1,1,-7259.13,1024.25,306.361,0.640679,0,0,0.314889,0.949129,25,0,1,0),
+(240100,186393,1,0,0,1,1,-7262.34,949.284,303.524,0.654239,0,0,0.321317,0.946972,25,0,1,0),
+(240128,186393,1,0,0,1,1,-7187.33,939.703,303.523,2.21718,0,0,0.895071,0.445923,25,0,1,0),
+(240024,186393,1,0,0,1,1,-7252.32,1026.1,303.524,5.3627,0,0,0.444166,-0.895945,25,0,1,0),
+(239992,186393,1,0,0,1,1,-7160.45,974.339,306.361,3.00559,0,0,0.997689,0.0679491,25,0,1,0),
+(239994,186393,1,0,0,1,1,-7161.27,968.374,306.362,3.00559,0,0,0.997689,0.0679491,25,0,1,0),
+(240227,186393,1,0,0,1,1,-7176.13,1019.19,306.361,5.36606,0,0,0.442661,-0.896689,25,0,1,0),
+(240228,186393,1,0,0,1,1,-7168.2,1008.91,306.36,2.24018,0,0,0.900139,0.435603,25,0,1,0),
+(240229,186393,1,0,0,1,1,-7260.57,942.307,306.36,2.22945,0,0,0.89779,0.440424,25,0,1,0),
+(240230,186393,1,0,0,1,1,-7268.58,952.669,306.36,5.36319,0,0,0.443945,-0.896054,25,0,1,0),
+(240231,186393,1,0,0,1,1,-7180.39,941.411,306.36,3.79612,0,0,0.946925,-0.321454,25,0,1,0),
+(240232,186393,1,0,0,1,1,-7190.67,933.47,306.36,0.654529,0,0,0.321454,0.946925,25,0,1,0),
+(9365230,186393,1,0,0,1,1,-3077.56,2197.23,42.7844,1.83087,0,0,0.792826,0.609448,300,0,1,0),
+(9365232,186393,1,0,0,1,1,-3504.66,2071.59,42.6084,1.13352,0,0,0.536904,0.843644,300,0,1,0),
+(9365244,186393,1,0,0,1,1,-4759.7,1584.99,84.6154,0.124395,0,0,0.0621572,0.998066,300,0,1,0),
+(9365245,186393,1,0,0,1,1,-4758.94,1578.86,85.7949,0.124395,0,0,0.0621572,0.998066,300,0,1,0),
+(9365246,186393,1,0,0,1,1,-4758.17,1572.71,87.2961,0.124395,0,0,0.0621572,0.998066,300,0,1,0),
+(9365247,186393,1,0,0,1,1,-4757.39,1566.47,87.6473,0.124395,0,0,0.0621572,0.998066,300,0,1,0),
+(60046,188596,571,0,0,1,1,3404.73,-5394.46,267.362,1.18682,0,0,0,1,300,100,0,0),
+(239948,188596,1,0,0,1,1,-7164.57,975.06,303.523,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(239950,188596,1,0,0,1,1,-7163.66,981.741,303.523,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(240026,188596,1,0,0,1,1,-7257.12,1032.41,303.524,5.3627,0,0,0.444166,-0.895945,25,0,1,0),
+(240090,188596,1,0,0,1,1,-7268.73,944.317,303.523,0.654239,0,0,0.321317,0.946972,25,0,1,0),
+(240015,188596,1,0,0,1,1,-7255.01,1029.64,303.524,5.3627,0,0,0.444165,-0.895945,25,0,1,0),
+(240091,188596,1,0,0,1,1,-7270.72,946.901,303.523,0.654239,0,0,0.321317,0.946972,25,0,1,0),
+(239658,188596,1,0,0,1,1,-7276.42,1000.47,303.523,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239657,188596,1,0,0,1,1,-7276.87,997.127,303.523,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239656,188596,1,0,0,1,1,-7277.33,993.788,303.523,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239655,188596,1,0,0,1,1,-7277.78,990.448,303.523,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239669,188596,1,0,0,1,1,-7273.63,989.883,303.523,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239661,188596,1,0,0,1,1,-7279.1,980.338,303.523,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239670,188596,1,0,0,1,1,-7273.17,993.224,303.523,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239672,188596,1,0,0,1,1,-7272.26,999.903,303.523,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239659,188596,1,0,0,1,1,-7278.22,987.078,303.523,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239660,188596,1,0,0,1,1,-7278.66,983.707,303.523,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239671,188596,1,0,0,1,1,-7272.72,996.564,303.523,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239673,188596,1,0,0,1,1,-7274.08,986.518,303.524,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239674,188596,1,0,0,1,1,-7274.54,983.151,303.524,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239675,188596,1,0,0,1,1,-7275,979.786,303.524,1.43571,0,0,0.65777,0.753219,25,0,1,0),
+(239949,188596,1,0,0,1,1,-7164.12,978.4,303.523,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(240077,188596,1,0,0,1,1,-7166.01,1014.58,303.523,3.79203,0,0,0.94758,-0.319518,25,0,1,0),
+(239960,188596,1,0,0,1,1,-7160.4,974.416,303.524,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(239951,188596,1,0,0,1,1,-7163.21,985.081,303.523,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(240028,188596,1,0,0,1,1,-7259.67,1030.47,303.523,5.3627,0,0,0.444166,-0.895945,25,0,1,0),
+(239958,188596,1,0,0,1,1,-7161.31,967.734,303.524,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(240068,188596,1,0,0,1,1,-7168.78,1012.46,303.524,3.79203,0,0,0.94758,-0.319518,25,0,1,0),
+(240069,188596,1,0,0,1,1,-7174.66,1020.19,303.524,3.79203,0,0,0.94758,-0.319518,25,0,1,0),
+(240072,188596,1,0,0,1,1,-7166.81,1009.87,303.523,3.79203,0,0,0.94758,-0.319518,25,0,1,0),
+(240067,188596,1,0,0,1,1,-7170.75,1015.05,303.524,3.79203,0,0,0.94758,-0.319518,25,0,1,0),
+(240066,188596,1,0,0,1,1,-7172.72,1017.64,303.524,3.79203,0,0,0.94758,-0.319518,25,0,1,0),
+(239961,188596,1,0,0,1,1,-7159.95,977.758,303.524,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(239955,188596,1,0,0,1,1,-7165.94,964.962,303.524,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(239957,188596,1,0,0,1,1,-7161.76,964.393,303.523,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(240027,188596,1,0,0,1,1,-7254.53,1034.39,303.524,5.3627,0,0,0.444166,-0.895945,25,0,1,0),
+(240075,188596,1,0,0,1,1,-7169.95,1019.76,303.523,3.79203,0,0,0.94758,-0.319518,25,0,1,0),
+(239966,188596,1,0,0,1,1,-7159.03,984.508,303.524,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(239962,188596,1,0,0,1,1,-7159.49,981.1,303.524,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(239952,188596,1,0,0,1,1,-7165.03,971.695,303.524,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(239959,188596,1,0,0,1,1,-7160.85,971.074,303.524,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(239954,188596,1,0,0,1,1,-7165.49,968.329,303.524,1.43571,0,0,0.657771,0.753218,25,0,1,0),
+(240124,188596,1,0,0,1,1,-7179.38,939.825,303.523,1.78622,0,0,0.779027,0.626991,25,0,1,0),
+(240125,188596,1,0,0,1,1,-7189.66,932.069,303.523,2.21718,0,0,0.895071,0.445923,25,0,1,0),
+(240092,188596,1,0,0,1,1,-7267.97,949.005,303.523,0.654239,0,0,0.321317,0.946972,25,0,1,0),
+(240098,188596,1,0,0,1,1,-7262.1,941.384,303.524,0.654239,0,0,0.321317,0.946972,25,0,1,0),
+(240099,188596,1,0,0,1,1,-7259.35,943.486,303.524,0.654239,0,0,0.321317,0.946972,25,0,1,0),
+(240096,188596,1,0,0,1,1,-7266.02,946.459,303.524,0.654239,0,0,0.321317,0.946972,25,0,1,0),
+(240097,188596,1,0,0,1,1,-7264.05,943.929,303.524,0.654239,0,0,0.321317,0.946972,25,0,1,0),
+(240095,188596,1,0,0,1,1,-7266.78,941.771,303.524,0.654239,0,0,0.321317,0.946972,25,0,1,0),
+(240094,188596,1,0,0,1,1,-7267.21,953.693,303.523,0.654239,0,0,0.321317,0.946972,25,0,1,0),
+(240121,188596,1,0,0,1,1,-7187.05,934.013,303.523,2.21718,0,0,0.895071,0.445923,25,0,1,0),
+(240093,188596,1,0,0,1,1,-7269.95,951.589,303.523,0.654239,0,0,0.321317,0.946972,25,0,1,0),
+(240127,188596,1,0,0,1,1,-7181.46,942.585,303.523,2.57948,0,0,0.960763,0.27737,25,0,1,0),
+(240120,188596,1,0,0,1,1,-7184.97,931.254,303.523,2.21718,0,0,0.895071,0.445923,25,0,1,0),
+(240119,188596,1,0,0,1,1,-7179.81,935.147,303.524,2.21718,0,0,0.895071,0.445923,25,0,1,0),
+(240123,188596,1,0,0,1,1,-7181.94,937.892,303.523,2.21718,0,0,0.895071,0.445923,25,0,1,0),
+(240126,188596,1,0,0,1,1,-7191.74,934.827,303.523,2.21718,0,0,0.895071,0.445923,25,0,1,0),
+(240118,188596,1,0,0,1,1,-7182.37,933.215,303.524,2.21718,0,0,0.895071,0.445923,25,0,1,0),
+(240122,188596,1,0,0,1,1,-7184.5,935.96,303.523,2.21718,0,0,0.895071,0.445923,25,0,1,0),
+(240076,188596,1,0,0,1,1,-7167.98,1017.17,303.523,3.79203,0,0,0.94758,-0.319518,25,0,1,0),
+(240017,188596,1,0,0,1,1,-7260.11,1025.76,303.524,5.3627,0,0,0.444165,-0.895945,25,0,1,0),
+(240021,188596,1,0,0,1,1,-7247.73,1030.83,303.524,5.3627,0,0,0.444165,-0.895945,25,0,1,0),
+(240020,188596,1,0,0,1,1,-7249.82,1033.58,303.524,5.3627,0,0,0.444165,-0.895945,25,0,1,0),
+(240019,188596,1,0,0,1,1,-7252.42,1031.61,303.524,5.3627,0,0,0.444165,-0.895945,25,0,1,0),
+(240023,188596,1,0,0,1,1,-7258.02,1023.01,303.523,5.3627,0,0,0.444165,-0.895945,25,0,1,0),
+(240016,188596,1,0,0,1,1,-7257.56,1027.7,303.524,5.3627,0,0,0.444165,-0.895945,25,0,1,0),
+(240073,188596,1,0,0,1,1,-7169.55,1007.76,303.523,3.79203,0,0,0.94758,-0.319518,25,0,1,0),
+(240074,188596,1,0,0,1,1,-7177.41,1018.09,303.523,3.79203,0,0,0.94758,-0.319518,25,0,1,0),
+(240193,70264,1,0,0,1,1,-7210.52,912.412,304.893,2.5155,0,0,0.9514,0.307959,25,0,1,0),
+(239891,178764,1,0,0,1,1,-7272.6,985.626,306.361,6.1481,0,0,0.0674923,-0.99772,25,0,1,0),
+(239897,178764,1,0,0,1,1,-7270.77,999.019,306.36,6.1481,0,0,0.0674923,-0.99772,25,0,1,0),
+(239896,178764,1,0,0,1,1,-7271.12,996.481,306.36,6.1481,0,0,0.0674923,-0.99772,25,0,1,0),
+(239893,178764,1,0,0,1,1,-7272.26,988.172,306.361,6.1481,0,0,0.0674923,-0.99772,25,0,1,0),
+(239895,178764,1,0,0,1,1,-7271.48,993.817,306.361,6.1481,0,0,0.0674923,-0.99772,25,0,1,0),
+(239894,178764,1,0,0,1,1,-7271.88,990.953,306.361,6.1481,0,0,0.0674923,-0.99772,25,0,1,0),
+(239888,178764,1,0,0,1,1,-7273.33,980.292,306.361,6.1481,0,0,0.0674923,-0.99772,25,0,1,0),
+(239889,178764,1,0,0,1,1,-7272.95,983.06,306.361,6.1481,0,0,0.0674923,-0.99772,25,0,1,0),
+(239886,178764,1,0,0,1,1,-7273.7,977.636,306.361,6.1481,0,0,0.0674923,-0.99772,25,0,1,0),
+(239906,178764,1,0,0,1,1,-7276.49,978.036,306.361,4.59361,0,0,0.747829,-0.663891,25,0,1,0),
+(239903,178764,1,0,0,1,1,-7270.44,1001.47,306.36,1.43885,0,0,0.658953,0.752184,25,0,1,0),
+(239946,178764,1,0,0,1,1,-7281.08,978.658,306.36,6.14417,0,0,0.0694537,-0.997585,25,0,1,0),
+(239968,178764,1,0,0,1,1,-7164.82,986.986,306.36,3.01043,0,0,0.99785,0.0655325,25,0,1,0),
+(239972,178764,1,0,0,1,1,-7165.9,978.853,306.36,3.01043,0,0,0.99785,0.0655325,25,0,1,0),
+(239977,178764,1,0,0,1,1,-7167.68,965.418,306.36,3.01043,0,0,0.99785,0.0655325,25,0,1,0),
+(239975,178764,1,0,0,1,1,-7166.97,970.755,306.36,3.01043,0,0,0.99785,0.0655325,25,0,1,0),
+(9051186,178764,1,0,0,1,1,-7168,963.017,306.36,4.61838,0,0,0.739552,-0.6731,300,0,1,0),
+(239973,178764,1,0,0,1,1,-7166.25,976.209,306.36,3.01043,0,0,0.99785,0.0655325,25,0,1,0),
+(239971,178764,1,0,0,1,1,-7165.54,981.532,306.36,3.01043,0,0,0.99785,0.0655325,25,0,1,0),
+(239974,178764,1,0,0,1,1,-7166.62,973.406,306.36,3.01043,0,0,0.99785,0.0655325,25,0,1,0),
+(239970,178764,1,0,0,1,1,-7165.18,984.315,306.36,3.01043,0,0,0.99785,0.0655325,25,0,1,0),
+(239985,178764,1,0,0,1,1,-7161.79,986.521,306.361,1.42079,0,0,0.652132,0.758105,25,0,1,0),
+(239976,178764,1,0,0,1,1,-7167.32,968.097,306.36,3.01043,0,0,0.99785,0.0655325,25,0,1,0),
+(67907,194593,571,0,0,1,1,8460.36,927.153,544.916,3.14159,0,0,0,1,180,255,1,0),
+(239944,194593,1,0,0,1,1,-7278.25,996.463,308.409,6.1613,0,0,0.0609072,-0.998143,25,0,1,0),
+(67909,194595,571,0,0,1,1,8459.95,992.174,544.922,-2.94959,0,0,0,1,180,255,1,0),
+(239941,194595,1,0,0,1,1,-7279.28,990.573,308.462,6.1613,0,0,0.0609072,-0.998143,25,0,1,0),
+(67903,194589,571,0,0,1,1,8439.42,1010.37,544.698,-1.50971,0,0,0,1,180,255,1,0),
+(73361,194589,571,0,0,1,1,8439.42,1010.37,544.698,-1.50971,0,0,0,0,0,0,1,0),
+(9180728,194589,1,0,0,1,1,-7279.68,984.602,308.397,6.1613,0,0,0.0609048,-0.998144,300,0,1,0),
+(223623,170592,1,0,0,1,1,-1824.72,-4583.54,-115.128,4.53332,0,0,0.767499,-0.64105,25,0,1,0),
+(240063,170592,1,0,0,1,1,-7256.76,1032,307.052,5.3627,0,0,0.444166,-0.895945,25,0,1,0),
+(240085,170592,1,0,0,1,1,-7168.76,1016.56,306.909,3.79203,0,0,0.94758,-0.319518,25,0,1,0),
+(240109,170592,1,0,0,1,1,-7268.44,944.602,307.092,0.654239,0,0,0.321317,0.946972,25,0,1,0),
+(240133,170592,1,0,0,1,1,-7182.67,933.532,306.979,2.21718,0,0,0.895071,0.445923,25,0,1,0),
+(9092906,170592,1,0,0,1,1,-9781.68,-2860.63,119.206,0.279273,0,0,0.139183,0.990267,300,0,1,0),
+(9092464,170592,1,0,0,1,1,-7310.55,2233.88,72.4531,0.480897,0,0,0.238138,0.971231,300,0,1,0),
+(9109862,170592,1,0,0,1,1,5855.94,-1995.04,689.745,5.42784,0,0,0.414754,-0.909934,300,0,1,0),
+(9109906,170592,1,0,0,1,1,5871.12,-2012.51,689.701,2.28655,0,0,0.909997,0.414615,300,0,1,0),
+(9330403,170592,1,0,0,1,1,-5082.57,-1103.69,87.1186,0.534018,0,0,0.263848,0.964564,300,0,1,0),
+(9330402,170592,1,0,0,1,1,-5060.65,-1089.75,86.936,3.74954,0,0,0.954155,-0.299314,300,0,1,0),
+(67920,194606,571,0,0,1,1,8307.43,705.927,553.644,0.253072,0,0,0,1,180,255,1,0),
+(240136,194606,1,0,0,1,1,-7272.44,946.637,306.36,0.654239,0,0,0.321317,0.946972,25,0,1,0),
+(240137,194606,1,0,0,1,1,-7267.45,940.127,306.361,0.654239,0,0,0.321317,0.946972,25,0,1,0),
+(67908,194594,571,0,0,1,1,8460.08,950.043,545.051,-3.09792,0,0,0,1,180,255,1,0),
+(9180720,194594,1,0,0,1,1,-7184.78,929.577,306.361,2.21718,0,0,0.895071,0.445924,300,0,1,0),
+(9180717,194594,1,0,0,1,1,-7178.15,934.61,306.362,2.24088,0,0,0.900292,0.435286,300,0,1,0),
+(67921,194607,571,0,0,1,1,8338.74,687.096,553.701,1.59698,0,0,0,1,180,255,1,0),
+(240004,194607,1,0,0,1,1,-7159.92,968.19,308.414,3.00559,0,0,0.997689,0.0679491,25,0,1,0),
+(67919,194605,571,0,0,1,1,8319.33,744.352,553.701,-0.98611,0,0,0,1,180,255,1,0),
+(240003,194605,1,0,0,1,1,-7158.89,974.126,308.49,3.00559,0,0,0.997689,0.0679491,25,0,1,0),
+(67918,194604,571,0,0,1,1,8357.72,744.694,553.627,-2.30383,0,0,0,1,180,255,1,0),
+(240005,194604,1,0,0,1,1,-7158.29,979.98,308.413,3.00559,0,0,0.997689,0.0679491,25,0,1,0),
+(72058,194592,571,0,0,1,1,8458.11,905.744,546.489,2.82392,0,0,0.987412,0.158169,30,0,1,0),
+(72043,194592,571,0,0,1,1,8670.57,692.054,547.522,1.89567,0,0,0.812154,0.583443,30,0,1,0),
+(67906,194592,571,0,0,1,1,8459.21,905.564,545.516,2.75761,0,0,0,1,180,255,1,0),
+(240088,194592,1,0,0,1,1,-7164.78,1014.48,306.361,3.79203,0,0,0.94758,-0.319518,25,0,1,0),
+(240089,194592,1,0,0,1,1,-7169.75,1021,306.36,3.79203,0,0,0.94758,-0.319518,25,0,1,0),
+(72037,194608,571,0,0,1,1,8368.94,708.93,553.772,2.93164,0,0,0.994495,0.104784,30,0,1,0),
+(240087,194608,1,0,0,1,1,-7254.69,1036.01,306.361,5.3627,0,0,0.444166,-0.895945,25,0,1,0),
+(240086,194608,1,0,0,1,1,-7261.24,1031,306.36,5.3627,0,0,0.444166,-0.895945,25,0,1,0);
+
+/*Data for the table `gameobject_template` */
+
+DELETE FROM `gameobject_template` WHERE `entry` IN (8021000, 8010000, 8010001, 8010002, 8010003, 8007862, 8007658, 800342, 8008124, 8008054, 8004714, 8009248, 181640, 186393, 188596, 70264, 178764, 194593, 194595, 194589, 170592, 194606, 194594, 194607, 194605, 194604, 194592, 194608);
+
+INSERT INTO `gameobject_template`(`entry`,`type`,`displayId`,`name`,`IconName`,`castBarCaption`,`unk1`,`faction`,`flags`,`size`,`data0`,`data1`,`data2`,`data3`,`data4`,`data5`,`data6`,`data7`,`data8`,`data9`,`data10`,`data11`,`data12`,`data13`,`data14`,`data15`,`data16`,`data17`,`data18`,`data19`,`data20`,`data21`,`data22`,`data23`,`AIName`,`ScriptName`,`VerifiedBuild`) VALUES
+(8021000,10,8520,'Arena Records','','','',0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','duel_records_system',1),
+(8010000,33,9276,'Arena 0','','','',0,0,1.4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(8010001,33,9256,'Arena 1','','','',0,0,1.4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(8010002,33,9257,'Arena 2','','','',0,0,1.4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(8010003,33,9258,'Arena 3','','','',0,0,1.4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(8007862,5,7862,'Arena Bonfire','','','',0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(8007658,5,7658,'Arena Earth Rune','','','',0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(800342,5,342,'Arena Wall Rune','','','',0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(8008124,5,8124,'Arena Eye of Acherus','','','',0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(8008054,5,8054,'Arena Skull of Acherus','','','',0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(8004714,5,4714,'Arena Light Powersource','','','',0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(8009248,5,9248,'Arena Flat Steel','','','',0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(181640,7,6690,'Arena Throne','','','',0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(186393,5,6725,'Arena Bleachers','','','',0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(188596,5,7812,'Arena Pedestal','','','',0,4,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(70264,5,6752,'Arena Ice Block','','','',0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(178764,5,5453,'Arena Rope Line','','','',0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(194593,5,8620,'Ironforge Banner','','','',0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(194595,5,8616,'Darnassus Banner','','','',0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(194589,5,8617,'Exodar Banner','','','',0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(170592,7,2810,'Arena Throne','','','',0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(194606,5,8615,'Horde Banner','','','',0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(194594,5,8623,'Alliance Banner','','','',0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(194607,5,8621,'Orgrimmar Banner','','','',0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(194605,5,8622,'Silvermoon City Banner','','','',0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(194604,5,8624,'Thunder Bluff Banner','','','',0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(194592,5,8619,'Gnomeregan Banner','','','',0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1),
+(194608,5,8618,'Undercity Banner','','','',0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'','',1);
diff --git a/sql/TrinityCore-Patches/Arena_Template_NPC/character.Arena_Template_NPC.sql b/sql/TrinityCore-Patches/Arena_Template_NPC/character.Arena_Template_NPC.sql
new file mode 100644
index 0000000..72c5ee0
--- /dev/null
+++ b/sql/TrinityCore-Patches/Arena_Template_NPC/character.Arena_Template_NPC.sql
@@ -0,0 +1,2476 @@
+-- --------------------------------------------------------
+-- Host:                         127.0.0.1
+-- Server version:               5.6.26-log - MySQL Community Server (GPL)
+-- Server OS:                    Win64
+-- HeidiSQL Version:             9.2.0.4981
+-- --------------------------------------------------------
+
+/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
+/*!40101 SET NAMES utf8mb4 */;
+/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
+/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
+
+-- Dumping structure for table characters_dev.template_npc_alliance
+CREATE TABLE IF NOT EXISTS `template_npc_alliance` (
+  `playerClass` varchar(50) NOT NULL,
+  `playerSpec` varchar(50) NOT NULL,
+  `pos` int(10) unsigned NOT NULL DEFAULT '0',
+  `itemEntry` int(10) unsigned NOT NULL DEFAULT '0',
+  `enchant` int(10) unsigned NOT NULL DEFAULT '0',
+  `socket1` int(10) unsigned NOT NULL DEFAULT '0',
+  `socket2` int(10) unsigned NOT NULL DEFAULT '0',
+  `socket3` int(10) unsigned NOT NULL DEFAULT '0',
+  `bonusEnchant` int(10) unsigned NOT NULL DEFAULT '0',
+  `prismaticEnchant` int(10) DEFAULT NULL
+) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='Templates';
+
+-- Dumping data for table characters_dev.template_npc_alliance: ~502 rows (approximately)
+/*!40000 ALTER TABLE `template_npc_alliance` DISABLE KEYS */;
+INSERT INTO `template_npc_alliance` (`playerClass`, `playerSpec`, `pos`, `itemEntry`, `enchant`, `socket1`, `socket2`, `socket3`, `bonusEnchant`, `prismaticEnchant`) VALUES
+    ('Rogue', 'Assassination', 0, 41672, 3795, 3628, 3521, 0, 3314, 0),
+    ('Rogue', 'Assassination', 1, 42042, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 2, 41683, 3793, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 4, 41650, 3245, 3521, 3566, 0, 3600, 0),
+    ('Rogue', 'Assassination', 5, 41833, 0, 3521, 3521, 0, 0, 3729),
+    ('Rogue', 'Assassination', 7, 41837, 1597, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 6, 41655, 3823, 3521, 3879, 0, 3355, 0),
+    ('Rogue', 'Assassination', 8, 41841, 3845, 0, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 9, 41767, 1603, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 10, 42117, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 12, 42136, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 13, 51377, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 14, 42082, 1099, 0, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 15, 45958, 3789, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 16, 45962, 3731, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 17, 42451, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 0, 41672, 3795, 3628, 3521, 0, 3314, 0),
+    ('Rogue', 'Combat', 1, 42042, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 2, 41683, 3793, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 4, 41650, 3245, 3521, 3566, 0, 3600, 0),
+    ('Rogue', 'Combat', 5, 41833, 0, 3521, 3521, 0, 0, 3729),
+    ('Rogue', 'Combat', 6, 41655, 3823, 3521, 3879, 0, 3355, 0),
+    ('Rogue', 'Combat', 7, 41837, 1597, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 8, 41841, 3845, 0, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 9, 41767, 1603, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 10, 42117, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 12, 51377, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 13, 42136, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 14, 42082, 1099, 0, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 15, 42276, 3789, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 16, 42281, 3731, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 17, 42451, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Feral', 0, 41678, 3795, 3621, 3525, 0, 3314, 0),
+    ('Druid', 'Feral', 1, 46374, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Feral', 2, 41715, 3793, 3525, 0, 0, 0, 0),
+    ('Druid', 'Feral', 4, 41661, 3832, 3525, 3525, 0, 0, 0),
+    ('Druid', 'Feral', 5, 41833, 0, 3543, 3525, 0, 2877, 3729),
+    ('Druid', 'Feral', 6, 41667, 3823, 3525, 3879, 0, 3355, 0),
+    ('Druid', 'Feral', 7, 41837, 1597, 3525, 0, 0, 0, 0),
+    ('Druid', 'Feral', 8, 41841, 3845, 0, 0, 0, 0, 0),
+    ('Druid', 'Feral', 9, 41773, 1603, 3543, 0, 0, 2874, 0),
+    ('Druid', 'Feral', 10, 42119, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Feral', 11, 47934, 0, 3528, 0, 0, 2877, 0),
+    ('Druid', 'Feral', 12, 42136, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Feral', 13, 51377, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Feral', 14, 42082, 1099, 0, 0, 0, 0, 0),
+    ('Druid', 'Feral', 15, 45951, 3789, 3525, 3525, 0, 0, 0),
+    ('Druid', 'Feral', 17, 42589, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Restoration', 0, 41321, 3796, 3639, 3520, 0, 3352, 0),
+    ('Druid', 'Restoration', 1, 42044, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Restoration', 2, 41275, 3794, 3531, 0, 0, 2890, 0),
+    ('Druid', 'Restoration', 4, 41310, 3245, 3520, 3531, 0, 3600, 0),
+    ('Druid', 'Restoration', 5, 41618, 0, 3535, 3520, 0, 2872, 3729),
+    ('Druid', 'Restoration', 6, 41298, 3721, 3520, 3879, 0, 3602, 0),
+    ('Druid', 'Restoration', 7, 41622, 3232, 3531, 0, 0, 2878, 0),
+    ('Druid', 'Restoration', 8, 41626, 2332, 0, 0, 0, 0, 0),
+    ('Druid', 'Restoration', 9, 41287, 3246, 3548, 0, 0, 2890, 0),
+    ('Druid', 'Restoration', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Restoration', 11, 47928, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Restoration', 12, 42137, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Restoration', 13, 51377, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Restoration', 14, 42080, 3243, 0, 0, 0, 0, 0),
+    ('Druid', 'Restoration', 15, 42385, 3854, 3520, 3548, 0, 3602, 0),
+    ('Druid', 'Restoration', 17, 42579, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 0, 41672, 3795, 3628, 3521, 0, 3314, 0),
+    ('Rogue', 'Subtlety', 1, 42042, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 2, 41683, 3793, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 4, 41650, 3245, 3521, 3566, 0, 3600, 0),
+    ('Rogue', 'Subtlety', 5, 41833, 0, 3521, 3521, 0, 0, 3729),
+    ('Rogue', 'Subtlety', 6, 41655, 3823, 3521, 3879, 0, 3355, 0),
+    ('Rogue', 'Subtlety', 7, 41837, 1597, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 8, 41841, 3845, 0, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 9, 41767, 1603, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 10, 42117, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 12, 51377, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 13, 42136, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 14, 42082, 1099, 0, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 15, 45958, 3789, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 16, 45962, 3731, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 17, 42451, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Ballance', 0, 41327, 3796, 3621, 3520, 0, 3352, 0),
+    ('Druid', 'Ballance', 1, 42044, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Ballance', 4, 41316, 3245, 3520, 3531, 0, 3600, 0),
+    ('Druid', 'Ballance', 2, 41281, 3794, 3531, 0, 0, 2890, 0),
+    ('Druid', 'Ballance', 5, 41631, 0, 3879, 3520, 0, 2872, 3729),
+    ('Druid', 'Ballance', 6, 41304, 3721, 3520, 3548, 0, 3602, 0),
+    ('Druid', 'Ballance', 7, 41636, 3232, 3531, 0, 0, 2878, 0),
+    ('Druid', 'Ballance', 8, 41641, 2332, 0, 0, 0, 0, 0),
+    ('Druid', 'Ballance', 9, 41293, 3246, 3548, 0, 0, 2890, 0),
+    ('Druid', 'Ballance', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Ballance', 11, 47928, 0, 3520, 0, 0, 3752, 0),
+    ('Druid', 'Ballance', 12, 42137, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Ballance', 13, 51377, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Ballance', 14, 42076, 3243, 0, 0, 0, 0, 0),
+    ('Druid', 'Ballance', 15, 42364, 3854, 3520, 3535, 0, 3602, 0),
+    ('Druid', 'Ballance', 17, 42584, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Holy', 0, 41854, 3796, 3621, 3520, 0, 3352, 0),
+    ('Priest', 'Holy', 1, 42044, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Holy', 2, 41869, 3794, 3531, 0, 0, 2890, 0),
+    ('Priest', 'Holy', 4, 41859, 3245, 3520, 3531, 0, 3600, 0),
+    ('Priest', 'Holy', 5, 49179, 0, 3548, 3531, 0, 2872, 3729),
+    ('Priest', 'Holy', 6, 41864, 3721, 3520, 3879, 0, 2770, 0),
+    ('Priest', 'Holy', 7, 49183, 3232, 3531, 0, 0, 2878, 0),
+    ('Priest', 'Holy', 8, 49181, 2332, 0, 0, 0, 0, 0),
+    ('Priest', 'Holy', 9, 41874, 3246, 3548, 0, 0, 2890, 0),
+    ('Priest', 'Holy', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Holy', 11, 47732, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Holy', 12, 42135, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Holy', 13, 51377, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Holy', 14, 42082, 3243, 0, 0, 0, 0, 0),
+    ('Priest', 'Holy', 15, 42347, 3834, 3531, 0, 0, 0, 0),
+    ('Priest', 'Holy', 16, 42526, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Holy', 17, 42520, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Shadow', 0, 41915, 3796, 3621, 3563, 0, 3821, 0),
+    ('Priest', 'Shadow', 1, 42045, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Shadow', 2, 41934, 3794, 3563, 0, 0, 2868, 0),
+    ('Priest', 'Shadow', 4, 41921, 3832, 3563, 3563, 0, 3307, 0),
+    ('Priest', 'Shadow', 5, 49179, 0, 3590, 3590, 0, 2872, 3729),
+    ('Priest', 'Shadow', 6, 41927, 3721, 3520, 3590, 0, 2770, 0),
+    ('Priest', 'Shadow', 7, 49183, 3232, 3563, 0, 0, 2878, 0),
+    ('Priest', 'Shadow', 8, 49181, 2332, 0, 0, 0, 0, 0),
+    ('Priest', 'Shadow', 9, 41940, 3246, 3590, 0, 0, 3752, 0),
+    ('Priest', 'Shadow', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Shadow', 11, 47732, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Shadow', 12, 51377, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Shadow', 13, 42137, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Shadow', 14, 42077, 3243, 0, 0, 0, 0, 0),
+    ('Priest', 'Shadow', 15, 42347, 3834, 3590, 0, 0, 3752, 0),
+    ('Priest', 'Shadow', 17, 42520, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Shadow', 16, 42526, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Arcane', 0, 41946, 3820, 3621, 3520, 0, 3821, 0),
+    ('Mage', 'Arcane', 1, 42044, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Arcane', 2, 41965, 3794, 3531, 0, 0, 2868, 0),
+    ('Mage', 'Arcane', 4, 41953, 3245, 3520, 3531, 0, 3307, 0),
+    ('Mage', 'Arcane', 5, 49179, 0, 3548, 3520, 0, 2872, 3729),
+    ('Mage', 'Arcane', 6, 41959, 3721, 3520, 3548, 0, 2770, 0),
+    ('Mage', 'Arcane', 7, 49183, 3232, 3531, 0, 0, 2878, 0),
+    ('Mage', 'Arcane', 8, 49181, 2332, 0, 0, 0, 0, 0),
+    ('Mage', 'Arcane', 9, 41971, 3246, 3879, 0, 0, 3198, 0),
+    ('Mage', 'Arcane', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Arcane', 11, 47928, 0, 3520, 0, 0, 3752, 0),
+    ('Mage', 'Arcane', 12, 51377, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Arcane', 13, 47182, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Arcane', 14, 42077, 3243, 0, 0, 0, 0, 0),
+    ('Mage', 'Arcane', 15, 42347, 3834, 3548, 0, 0, 3752, 0),
+    ('Mage', 'Arcane', 16, 42526, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Arcane', 17, 42520, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Fire', 0, 41946, 3820, 3621, 3520, 0, 3821, 0),
+    ('Mage', 'Fire', 1, 42044, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Fire', 2, 41965, 3794, 3531, 0, 0, 2868, 0),
+    ('Mage', 'Fire', 4, 41953, 3245, 3520, 3531, 0, 3307, 0),
+    ('Mage', 'Fire', 5, 49179, 0, 3548, 3520, 0, 2872, 3729),
+    ('Mage', 'Fire', 6, 41959, 3721, 3520, 3548, 0, 2770, 0),
+    ('Mage', 'Fire', 7, 49183, 3232, 3531, 0, 0, 2878, 0),
+    ('Mage', 'Fire', 8, 49181, 2332, 0, 0, 0, 0, 0),
+    ('Mage', 'Fire', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Fire', 9, 41971, 3246, 3879, 0, 0, 3198, 0),
+    ('Mage', 'Fire', 11, 47928, 0, 3520, 0, 0, 3752, 0),
+    ('Mage', 'Fire', 12, 51377, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Fire', 13, 47182, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Fire', 14, 42077, 3243, 0, 0, 0, 0, 0),
+    ('Mage', 'Fire', 15, 42347, 3834, 3548, 0, 0, 3752, 0),
+    ('Mage', 'Fire', 16, 42526, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Fire', 17, 42520, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 0, 40828, 3795, 3628, 3518, 0, 2787, 0),
+    ('Paladin', 'Retribution', 1, 42042, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 2, 40869, 3793, 3552, 0, 0, 3263, 0),
+    ('Paladin', 'Retribution', 4, 40788, 3832, 3518, 3518, 0, 0, 0),
+    ('Paladin', 'Retribution', 6, 40849, 3823, 3518, 3536, 0, 3357, 0),
+    ('Paladin', 'Retribution', 5, 40883, 0, 3518, 3518, 0, 0, 3729),
+    ('Paladin', 'Retribution', 7, 40884, 1597, 3518, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 8, 40890, 3845, 0, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 9, 40808, 1603, 3518, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 10, 42117, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 12, 42136, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 13, 51377, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 14, 42082, 1099, 0, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 15, 42323, 3789, 3518, 3518, 0, 0, 0),
+    ('Paladin', 'Retribution', 17, 42853, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 0, 40828, 3795, 3628, 3518, 0, 2787, 0),
+    ('Paladin', 'Protection', 1, 42042, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 2, 40869, 3793, 3552, 0, 0, 3263, 0),
+    ('Paladin', 'Protection', 4, 40788, 3832, 3518, 3518, 0, 0, 0),
+    ('Paladin', 'Protection', 5, 40883, 0, 3518, 3518, 0, 0, 3729),
+    ('Paladin', 'Protection', 6, 40849, 3823, 3518, 3536, 0, 3357, 0),
+    ('Paladin', 'Protection', 7, 40884, 1597, 3518, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 8, 40890, 3845, 0, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 9, 40808, 1603, 3518, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 10, 42117, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 12, 42136, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 13, 51377, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 14, 42082, 1099, 0, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 15, 42286, 3789, 3863, 0, 0, 2936, 0),
+    ('Paladin', 'Protection', 16, 42560, 3849, 0, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 17, 42853, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Elemental', 0, 41019, 3796, 3621, 3866, 0, 2854, 0),
+    ('Shaman', 'Elemental', 1, 42044, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Elemental', 2, 41044, 3794, 3531, 0, 0, 2865, 0),
+    ('Shaman', 'Elemental', 4, 40993, 3832, 3866, 3531, 0, 3600, 0),
+    ('Shaman', 'Elemental', 5, 41071, 0, 3535, 3535, 0, 3596, 3729),
+    ('Shaman', 'Elemental', 6, 41033, 3721, 3866, 3535, 0, 3602, 0),
+    ('Shaman', 'Elemental', 7, 41076, 3232, 3531, 0, 0, 2878, 0),
+    ('Shaman', 'Elemental', 8, 41066, 2332, 0, 0, 0, 0, 0),
+    ('Shaman', 'Elemental', 9, 41007, 3246, 3535, 0, 0, 2865, 0),
+    ('Shaman', 'Elemental', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Elemental', 11, 42116, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Elemental', 12, 42137, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Elemental', 13, 51377, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Elemental', 14, 42078, 3831, 0, 0, 0, 0, 0),
+    ('Shaman', 'Elemental', 15, 42347, 3834, 3535, 0, 0, 3752, 0),
+    ('Shaman', 'Elemental', 16, 42565, 1128, 0, 0, 0, 0, 0),
+    ('Shaman', 'Elemental', 17, 42603, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Enhancement', 0, 41151, 3817, 3621, 3521, 0, 2843, 0),
+    ('Shaman', 'Enhancement', 1, 42042, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Enhancement', 2, 41211, 3808, 3565, 0, 0, 2874, 0),
+    ('Shaman', 'Enhancement', 4, 41081, 3832, 3521, 3521, 0, 0, 0),
+    ('Shaman', 'Enhancement', 5, 41236, 0, 3521, 3521, 0, 0, 3729),
+    ('Shaman', 'Enhancement', 6, 41199, 3823, 3521, 3521, 0, 0, 0),
+    ('Shaman', 'Enhancement', 7, 41231, 1597, 3521, 0, 0, 0, 0),
+    ('Shaman', 'Enhancement', 8, 41226, 3845, 0, 0, 0, 0, 0),
+    ('Shaman', 'Enhancement', 9, 41137, 1603, 3577, 0, 0, 2874, 0),
+    ('Shaman', 'Enhancement', 10, 42119, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Enhancement', 11, 42117, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Enhancement', 12, 51377, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Enhancement', 13, 42136, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Enhancement', 14, 42081, 3243, 0, 0, 0, 0, 0),
+    ('Shaman', 'Enhancement', 15, 42276, 3789, 3577, 0, 0, 2936, 0),
+    ('Shaman', 'Enhancement', 16, 42276, 3789, 3521, 0, 0, 0, 0),
+    ('Shaman', 'Enhancement', 17, 42608, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Restoration', 0, 41013, 3796, 3627, 3866, 0, 2854, 0),
+    ('Shaman', 'Restoration', 1, 42045, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Restoration', 2, 41038, 3794, 3530, 0, 0, 2865, 0),
+    ('Shaman', 'Restoration', 4, 40992, 3245, 3866, 3866, 0, 0, 0),
+    ('Shaman', 'Restoration', 5, 41052, 0, 3866, 3866, 0, 0, 3729),
+    ('Shaman', 'Restoration', 6, 41027, 3721, 3866, 3863, 0, 3602, 0),
+    ('Shaman', 'Restoration', 7, 41056, 3232, 3866, 0, 0, 0, 0),
+    ('Shaman', 'Restoration', 8, 41061, 2332, 0, 0, 0, 0, 0),
+    ('Shaman', 'Restoration', 9, 41001, 3246, 3866, 0, 0, 0, 0),
+    ('Shaman', 'Restoration', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Restoration', 11, 42116, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Restoration', 12, 42135, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Restoration', 13, 51377, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Restoration', 14, 42077, 3831, 0, 0, 0, 0, 0),
+    ('Shaman', 'Restoration', 15, 42353, 3834, 3866, 0, 0, 0, 0),
+    ('Shaman', 'Restoration', 16, 42571, 1128, 0, 0, 0, 0, 0),
+    ('Shaman', 'Restoration', 17, 42598, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 0, 41854, 3796, 3621, 3520, 0, 3352, 0),
+    ('Priest', 'Discipline', 1, 42044, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 2, 41869, 3794, 3531, 0, 0, 2890, 0),
+    ('Priest', 'Discipline', 4, 41859, 3245, 3520, 3531, 0, 3600, 0),
+    ('Priest', 'Discipline', 5, 49179, 0, 3548, 3531, 0, 2872, 3729),
+    ('Priest', 'Discipline', 6, 41864, 3721, 3520, 3879, 0, 2770, 0),
+    ('Priest', 'Discipline', 7, 49183, 3232, 3531, 0, 0, 2878, 0),
+    ('Priest', 'Discipline', 8, 49181, 2332, 0, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 9, 41874, 3246, 3548, 0, 0, 2890, 0),
+    ('Priest', 'Discipline', 11, 47732, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 12, 51377, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 13, 47041, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 14, 42082, 3243, 0, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 15, 42347, 3834, 3531, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 16, 42526, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 17, 42520, 0, 0, 0, 0, 0, 0),
+    ('Hunter', 'Beastmastery', 0, 41157, 3795, 3621, 3519, 0, 2843, 0),
+    ('Hunter', 'Beastmastery', 1, 42041, 0, 0, 0, 0, 0, 0),
+    ('Hunter', 'Beastmastery', 2, 41217, 3793, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Beastmastery', 4, 41087, 3245, 3519, 3519, 0, 0, 0),
+    ('Hunter', 'Beastmastery', 5, 41236, 0, 3535, 3519, 0, 2877, 3729),
+    ('Hunter', 'Beastmastery', 6, 41205, 3823, 3519, 3537, 0, 3355, 0),
+    ('Hunter', 'Beastmastery', 7, 41231, 3232, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Beastmastery', 8, 41226, 3845, 0, 0, 0, 0, 0),
+    ('Hunter', 'Beastmastery', 9, 41143, 1603, 3879, 0, 0, 2874, 0),
+    ('Hunter', 'Beastmastery', 10, 47934, 0, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Beastmastery', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('Hunter', 'Beastmastery', 12, 42136, 0, 0, 0, 0, 0, 0),
+    ('Hunter', 'Beastmastery', 13, 51377, 0, 0, 0, 0, 0, 0),
+    ('Hunter', 'Beastmastery', 14, 42082, 3243, 0, 0, 0, 0, 0),
+    ('Hunter', 'Beastmastery', 15, 42209, 3833, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Beastmastery', 16, 42228, 3731, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Beastmastery', 17, 42486, 3608, 0, 0, 0, 0, 0),
+    ('Hunter', 'Survival', 0, 41157, 3795, 3621, 3519, 0, 2843, 0),
+    ('Hunter', 'Survival', 1, 42041, 0, 0, 0, 0, 0, 0),
+    ('Hunter', 'Survival', 2, 41217, 3793, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Survival', 4, 41087, 3245, 3519, 3519, 0, 0, 0),
+    ('Hunter', 'Survival', 5, 41236, 0, 3535, 3519, 0, 2877, 3729),
+    ('Hunter', 'Survival', 6, 41205, 3823, 3519, 3537, 0, 3355, 0),
+    ('Hunter', 'Survival', 7, 41231, 3232, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Survival', 8, 41226, 3845, 0, 0, 0, 0, 0),
+    ('Hunter', 'Survival', 9, 41143, 1603, 3879, 0, 0, 2874, 0),
+    ('Hunter', 'Survival', 10, 47934, 0, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Survival', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('Hunter', 'Survival', 12, 42136, 0, 0, 0, 0, 0, 0),
+    ('Hunter', 'Survival', 13, 51377, 0, 0, 0, 0, 0, 0),
+    ('Hunter', 'Survival', 14, 42082, 3243, 0, 0, 0, 0, 0),
+    ('Hunter', 'Survival', 15, 42209, 3833, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Survival', 16, 42228, 3731, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Survival', 17, 42486, 3608, 0, 0, 0, 0, 0),
+    ('Paladin', 'Holy', 0, 40933, 3796, 3627, 3520, 0, 2854, 0),
+    ('Paladin', 'Holy', 1, 42043, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Holy', 2, 40963, 3794, 3865, 0, 0, 2865, 0),
+    ('Paladin', 'Holy', 4, 40907, 3832, 3520, 3865, 0, 3600, 0),
+    ('Paladin', 'Holy', 5, 40978, 0, 3546, 3866, 0, 3596, 3729),
+    ('Paladin', 'Holy', 6, 40939, 3721, 3520, 3546, 0, 3602, 0),
+    ('Paladin', 'Holy', 7, 40979, 3232, 3865, 0, 0, 2878, 0),
+    ('Paladin', 'Holy', 9, 40927, 3246, 3546, 0, 0, 2865, 0),
+    ('Paladin', 'Holy', 8, 40984, 2332, 0, 0, 0, 0, 0),
+    ('Paladin', 'Holy', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Holy', 11, 42116, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Holy', 12, 42137, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Holy', 13, 51377, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Holy', 14, 42076, 3831, 0, 0, 0, 0, 0),
+    ('Paladin', 'Holy', 15, 42353, 3834, 3546, 0, 0, 3752, 0),
+    ('Paladin', 'Holy', 16, 42571, 1128, 0, 0, 0, 0, 0),
+    ('Paladin', 'Holy', 17, 42615, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Frost', 0, 41946, 3820, 3621, 3520, 0, 3821, 0),
+    ('Mage', 'Frost', 1, 42044, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Frost', 2, 41965, 3794, 3531, 0, 0, 2868, 0),
+    ('Mage', 'Frost', 4, 41953, 3245, 3520, 3531, 0, 3307, 0),
+    ('Mage', 'Frost', 5, 49179, 0, 3548, 3520, 0, 2872, 3729),
+    ('Mage', 'Frost', 6, 41959, 3721, 3520, 3548, 0, 2770, 0),
+    ('Mage', 'Frost', 7, 49183, 3232, 3531, 0, 0, 2878, 0),
+    ('Mage', 'Frost', 8, 49181, 2332, 0, 0, 0, 0, 0),
+    ('Mage', 'Frost', 9, 41971, 3246, 3879, 0, 0, 3198, 0),
+    ('Mage', 'Frost', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Frost', 11, 47928, 0, 3520, 0, 0, 3752, 0),
+    ('Mage', 'Frost', 12, 51377, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Frost', 13, 47182, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Frost', 14, 42077, 3243, 0, 0, 0, 0, 0),
+    ('Mage', 'Frost', 15, 42347, 3834, 3548, 0, 0, 3752, 0),
+    ('Mage', 'Frost', 16, 42526, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Frost', 17, 42520, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 0, 41993, 3796, 3621, 3548, 0, 3821, 0),
+    ('Warlock', 'Affliction', 1, 42043, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 2, 42011, 3794, 3528, 0, 0, 2868, 0),
+    ('Warlock', 'Affliction', 4, 41998, 3245, 3520, 3528, 0, 3307, 0),
+    ('Warlock', 'Affliction', 5, 41899, 0, 3535, 3528, 0, 2872, 3729),
+    ('Warlock', 'Affliction', 6, 42005, 3721, 3520, 3528, 0, 0, 0),
+    ('Warlock', 'Affliction', 7, 49183, 3232, 3563, 0, 0, 2878, 0),
+    ('Warlock', 'Affliction', 8, 41910, 2332, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 9, 42017, 3246, 3535, 0, 0, 2872, 0),
+    ('Warlock', 'Affliction', 11, 42116, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 12, 51377, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 13, 42132, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 14, 42078, 3243, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 15, 42347, 3834, 3866, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 16, 42526, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 17, 42503, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 1, 42043, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 2, 42011, 3794, 3528, 0, 0, 2868, 0),
+    ('Warlock', 'Demonology', 4, 41998, 3245, 3520, 3528, 0, 3307, 0),
+    ('Warlock', 'Demonology', 5, 41899, 0, 3535, 3528, 0, 2872, 3729),
+    ('Warlock', 'Demonology', 6, 42005, 3721, 3520, 3528, 0, 0, 0),
+    ('Warlock', 'Demonology', 7, 49183, 3232, 3563, 0, 0, 2878, 0),
+    ('Warlock', 'Demonology', 8, 41910, 2332, 0, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 9, 42017, 3246, 3535, 0, 0, 2872, 0),
+    ('Warlock', 'Demonology', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 11, 42116, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 12, 51377, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 13, 42132, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 14, 42078, 3243, 0, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 15, 42347, 3834, 3866, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 16, 42526, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 17, 42503, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 0, 41993, 3796, 3621, 3548, 0, 3821, 0),
+    ('Warlock', 'Destruction', 1, 42043, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 2, 42011, 3794, 3528, 0, 0, 2868, 0),
+    ('Warlock', 'Destruction', 4, 41998, 3245, 3520, 3528, 0, 3307, 0),
+    ('Warlock', 'Destruction', 5, 41899, 0, 3535, 3528, 0, 2872, 3729),
+    ('Warlock', 'Destruction', 6, 42005, 3721, 3520, 3528, 0, 0, 0),
+    ('Warlock', 'Destruction', 7, 49183, 3232, 3563, 0, 0, 2878, 0),
+    ('Warlock', 'Destruction', 8, 41910, 2332, 0, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 9, 42017, 3246, 3535, 0, 0, 2872, 0),
+    ('Warlock', 'Destruction', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 11, 42116, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 12, 51377, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 13, 42132, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 14, 42078, 3243, 0, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 15, 42347, 3834, 3866, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 16, 42526, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 17, 42503, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 0, 40827, 3795, 3621, 3518, 0, 2787, 0),
+    ('DeathKnight', 'Blood', 1, 42041, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 2, 40868, 3852, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 4, 40787, 3832, 3518, 3518, 0, 0, 0),
+    ('DeathKnight', 'Blood', 5, 40883, 0, 3518, 3879, 0, 0, 3729),
+    ('DeathKnight', 'Blood', 6, 40848, 3823, 3518, 3535, 0, 3357, 0),
+    ('DeathKnight', 'Blood', 7, 40884, 1597, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 8, 40890, 3845, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 9, 40809, 1603, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 10, 42117, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 12, 51377, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 13, 42134, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 14, 42081, 3243, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 15, 42333, 3366, 3518, 3535, 0, 3764, 0),
+    ('DeathKnight', 'Blood', 17, 42621, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 0, 40827, 3795, 3621, 3518, 0, 2787, 0),
+    ('DeathKnight', 'Unholy', 1, 42041, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 2, 40868, 3852, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 4, 40787, 3832, 3518, 3518, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 5, 40883, 0, 3518, 3879, 0, 0, 3729),
+    ('DeathKnight', 'Unholy', 6, 40848, 3823, 3518, 3535, 0, 3357, 0),
+    ('DeathKnight', 'Unholy', 7, 40884, 1597, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 8, 40890, 3845, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 9, 40809, 1603, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 10, 42117, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 12, 51377, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 13, 42134, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 14, 42081, 3243, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 15, 42333, 3367, 3518, 3535, 0, 3764, 0),
+    ('DeathKnight', 'Unholy', 17, 42621, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 0, 40826, 3795, 3625, 3525, 0, 2787, 0),
+    ('Warrior', 'Protection', 1, 42042, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 2, 40866, 3793, 3550, 0, 0, 3263, 0),
+    ('Warrior', 'Protection', 4, 40789, 3832, 3525, 3550, 0, 3600, 0),
+    ('Warrior', 'Protection', 5, 40883, 0, 3525, 3525, 0, 0, 3729),
+    ('Warrior', 'Protection', 6, 40847, 3823, 3525, 3525, 0, 0, 0),
+    ('Warrior', 'Protection', 7, 40884, 1597, 3525, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 8, 40890, 3845, 0, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 9, 40807, 1603, 3525, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 10, 42119, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 11, 42117, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 12, 42136, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 13, 51377, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 14, 42082, 1099, 0, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 15, 42276, 3789, 3863, 0, 0, 2936, 0),
+    ('Warrior', 'Protection', 16, 42560, 3849, 0, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 17, 42486, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 0, 40826, 3795, 3625, 3525, 0, 2787, 0),
+    ('Warrior', 'Arms', 1, 42042, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 2, 40866, 3793, 3550, 0, 0, 3263, 0),
+    ('Warrior', 'Arms', 4, 40789, 3832, 3525, 3550, 0, 3600, 0),
+    ('Warrior', 'Arms', 5, 40883, 0, 3525, 3525, 0, 0, 3729),
+    ('Warrior', 'Arms', 6, 40847, 3823, 3525, 3525, 0, 0, 0),
+    ('Warrior', 'Arms', 7, 40884, 1597, 3525, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 8, 40890, 3845, 0, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 9, 40807, 1603, 3525, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 10, 42119, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 11, 42117, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 12, 42136, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 13, 51377, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 14, 42082, 1099, 0, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 15, 42323, 3789, 3525, 3525, 0, 0, 0),
+    ('Warrior', 'Arms', 17, 42486, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 0, 40826, 3795, 3625, 3525, 0, 2787, 0),
+    ('Warrior', 'Fury', 1, 42042, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 2, 40866, 3793, 3550, 0, 0, 3263, 0),
+    ('Warrior', 'Fury', 4, 40789, 3832, 3525, 3550, 0, 3600, 0),
+    ('Warrior', 'Fury', 5, 40883, 0, 3525, 3525, 0, 0, 3729),
+    ('Warrior', 'Fury', 6, 40847, 3823, 3525, 3525, 0, 0, 0),
+    ('Warrior', 'Fury', 7, 40884, 1597, 3525, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 8, 40890, 3845, 0, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 9, 40807, 1603, 3525, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 10, 42119, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 11, 42117, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 12, 42136, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 13, 51377, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 14, 42082, 1099, 0, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 15, 42323, 3789, 3525, 3525, 0, 0, 0),
+    ('Warrior', 'Fury', 16, 42323, 3789, 3525, 3525, 0, 0, 0),
+    ('Warrior', 'Fury', 17, 42486, 0, 0, 0, 0, 0, 0),
+    ('Hunter', 'Marksmanship', 0, 41157, 3795, 3621, 3519, 0, 2843, 0),
+    ('Hunter', 'Marksmanship', 1, 42041, 0, 0, 0, 0, 0, 0),
+    ('Hunter', 'Marksmanship', 2, 41217, 3793, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Marksmanship', 5, 41236, 0, 3535, 3519, 0, 2877, 3729),
+    ('Hunter', 'Marksmanship', 4, 41087, 3245, 3519, 3519, 0, 0, 0),
+    ('Hunter', 'Marksmanship', 6, 41205, 3823, 3519, 3537, 0, 3355, 0),
+    ('Hunter', 'Marksmanship', 7, 41231, 3232, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Marksmanship', 8, 41226, 3845, 0, 0, 0, 0, 0),
+    ('Hunter', 'Marksmanship', 9, 41143, 1603, 3879, 0, 0, 2874, 0),
+    ('Hunter', 'Marksmanship', 10, 47934, 0, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Marksmanship', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('Hunter', 'Marksmanship', 12, 42136, 0, 0, 0, 0, 0, 0),
+    ('Hunter', 'Marksmanship', 13, 51377, 0, 0, 0, 0, 0, 0),
+    ('Hunter', 'Marksmanship', 14, 42082, 3243, 0, 0, 0, 0, 0),
+    ('Hunter', 'Marksmanship', 15, 42209, 3833, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Marksmanship', 16, 42209, 3731, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Marksmanship', 17, 42486, 3608, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 0, 40827, 3795, 3621, 3518, 0, 2787, 0),
+    ('DeathKnight', 'Frost', 1, 42041, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 2, 40868, 3852, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 4, 40787, 3832, 3518, 3518, 0, 0, 0),
+    ('DeathKnight', 'Frost', 5, 40883, 0, 3518, 3879, 0, 0, 3729),
+    ('DeathKnight', 'Frost', 6, 40848, 3823, 3518, 3535, 0, 3357, 0),
+    ('DeathKnight', 'Frost', 7, 40884, 1597, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 8, 40890, 3845, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 9, 40809, 1603, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 10, 42117, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 12, 51377, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 13, 42134, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 14, 42081, 3243, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 15, 42209, 3370, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 16, 42209, 3594, 3535, 0, 0, 2936, 0),
+    ('DeathKnight', 'Frost', 17, 42621, 0, 0, 0, 0, 0, 0);
+/*!40000 ALTER TABLE `template_npc_alliance` ENABLE KEYS */;
+
+
+-- Dumping structure for table characters_dev.template_npc_glyphs
+CREATE TABLE IF NOT EXISTS `template_npc_glyphs` (
+  `playerClass` varchar(50) NOT NULL,
+  `playerSpec` varchar(50) NOT NULL,
+  `slot` tinyint(3) unsigned NOT NULL DEFAULT '0',
+  `glyph` smallint(5) unsigned NOT NULL DEFAULT '0'
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+-- Dumping data for table characters_dev.template_npc_glyphs: ~180 rows (approximately)
+/*!40000 ALTER TABLE `template_npc_glyphs` DISABLE KEYS */;
+INSERT INTO `template_npc_glyphs` (`playerClass`, `playerSpec`, `slot`, `glyph`) VALUES
+    ('Rogue', 'Assassination', 0, 733),
+    ('Rogue', 'Assassination', 1, 464),
+    ('Rogue', 'Assassination', 2, 467),
+    ('Rogue', 'Assassination', 3, 405),
+    ('Rogue', 'Assassination', 4, 469),
+    ('Rogue', 'Assassination', 5, 408),
+    ('Druid', 'Feral', 0, 166),
+    ('Druid', 'Feral', 1, 0),
+    ('Druid', 'Feral', 2, 0),
+    ('Druid', 'Feral', 3, 165),
+    ('Druid', 'Feral', 4, 551),
+    ('Druid', 'Feral', 5, 671),
+    ('Druid', 'Ballance', 0, 676),
+    ('Druid', 'Ballance', 1, 433),
+    ('Druid', 'Ballance', 2, 434),
+    ('Druid', 'Ballance', 3, 178),
+    ('Druid', 'Ballance', 4, 551),
+    ('Druid', 'Ballance', 5, 176),
+    ('Priest', 'Holy', 0, 251),
+    ('Priest', 'Holy', 1, 458),
+    ('Priest', 'Holy', 2, 459),
+    ('Priest', 'Holy', 3, 257),
+    ('Priest', 'Holy', 4, 463),
+    ('Priest', 'Holy', 5, 255),
+    ('Mage', 'Arcane', 0, 329),
+    ('Mage', 'Arcane', 2, 447),
+    ('Mage', 'Arcane', 1, 446),
+    ('Mage', 'Arcane', 3, 315),
+    ('Mage', 'Arcane', 4, 451),
+    ('Mage', 'Arcane', 5, 312),
+    ('Mage', 'Fire', 0, 329),
+    ('Mage', 'Fire', 1, 446),
+    ('Mage', 'Fire', 2, 447),
+    ('Mage', 'Fire', 3, 315),
+    ('Mage', 'Fire', 4, 451),
+    ('Mage', 'Fire', 5, 324),
+    ('Paladin', 'Retribution', 0, 183),
+    ('Paladin', 'Retribution', 1, 453),
+    ('Paladin', 'Retribution', 2, 455),
+    ('Paladin', 'Retribution', 3, 193),
+    ('Paladin', 'Retribution', 4, 456),
+    ('Paladin', 'Retribution', 5, 707),
+    ('Paladin', 'Protection', 0, 191),
+    ('Paladin', 'Protection', 1, 456),
+    ('Paladin', 'Protection', 2, 457),
+    ('Paladin', 'Protection', 3, 705),
+    ('Paladin', 'Protection', 4, 452),
+    ('Paladin', 'Protection', 5, 183),
+    ('Shaman', 'Elemental', 0, 754),
+    ('Shaman', 'Elemental', 2, 474),
+    ('Shaman', 'Elemental', 1, 476),
+    ('Shaman', 'Elemental', 3, 214),
+    ('Shaman', 'Elemental', 4, 552),
+    ('Shaman', 'Elemental', 5, 752),
+    ('Shaman', 'Enhancement', 0, 228),
+    ('Shaman', 'Enhancement', 1, 552),
+    ('Shaman', 'Enhancement', 2, 475),
+    ('Shaman', 'Enhancement', 3, 736),
+    ('Shaman', 'Enhancement', 4, 476),
+    ('Shaman', 'Enhancement', 5, 754),
+    ('Shaman', 'Restoration', 0, 223),
+    ('Shaman', 'Restoration', 1, 476),
+    ('Shaman', 'Restoration', 2, 552),
+    ('Shaman', 'Restoration', 3, 751),
+    ('Shaman', 'Restoration', 4, 475),
+    ('Shaman', 'Restoration', 5, 754),
+    ('Priest', 'Discipline', 0, 713),
+    ('Priest', 'Discipline', 1, 458),
+    ('Priest', 'Discipline', 2, 459),
+    ('Priest', 'Discipline', 3, 257),
+    ('Priest', 'Discipline', 4, 463),
+    ('Priest', 'Discipline', 5, 710),
+    ('Druid', 'Restoration', 0, 169),
+    ('Druid', 'Restoration', 1, 433),
+    ('Druid', 'Restoration', 2, 435),
+    ('Druid', 'Restoration', 3, 168),
+    ('Druid', 'Restoration', 4, 551),
+    ('Druid', 'Restoration', 5, 676),
+    ('Hunter', 'Beastmastery', 0, 351),
+    ('Hunter', 'Beastmastery', 1, 439),
+    ('Hunter', 'Beastmastery', 2, 440),
+    ('Hunter', 'Beastmastery', 3, 358),
+    ('Hunter', 'Beastmastery', 4, 441),
+    ('Hunter', 'Beastmastery', 5, 356),
+    ('Hunter', 'Survival', 0, 351),
+    ('Hunter', 'Survival', 1, 439),
+    ('Hunter', 'Survival', 2, 440),
+    ('Hunter', 'Survival', 3, 358),
+    ('Hunter', 'Survival', 4, 441),
+    ('Hunter', 'Survival', 5, 691),
+    ('Paladin', 'Holy', 0, 706),
+    ('Paladin', 'Holy', 1, 455),
+    ('Paladin', 'Holy', 2, 456),
+    ('Paladin', 'Holy', 3, 183),
+    ('Paladin', 'Holy', 4, 452),
+    ('Paladin', 'Holy', 5, 195),
+    ('Mage', 'Frost', 0, 700),
+    ('Mage', 'Frost', 1, 446),
+    ('Mage', 'Frost', 2, 447),
+    ('Mage', 'Frost', 3, 315),
+    ('Mage', 'Frost', 4, 451),
+    ('Mage', 'Frost', 5, 329),
+    ('Warlock', 'Destruction', 0, 759),
+    ('Warlock', 'Destruction', 1, 479),
+    ('Warlock', 'Destruction', 2, 480),
+    ('Warlock', 'Destruction', 3, 273),
+    ('Warlock', 'Destruction', 4, 478),
+    ('Warlock', 'Destruction', 5, 283),
+    ('Warlock', 'Affliction', 0, 759),
+    ('Warlock', 'Affliction', 1, 482),
+    ('Warlock', 'Affliction', 2, 477),
+    ('Warlock', 'Affliction', 3, 911),
+    ('Warlock', 'Affliction', 4, 478),
+    ('Warlock', 'Affliction', 5, 283),
+    ('Warlock', 'Demonology', 0, 759),
+    ('Warlock', 'Demonology', 1, 479),
+    ('Warlock', 'Demonology', 2, 480),
+    ('Warlock', 'Demonology', 3, 281),
+    ('Warlock', 'Demonology', 4, 477),
+    ('Warlock', 'Demonology', 5, 274),
+    ('DeathKnight', 'Unholy', 0, 772),
+    ('DeathKnight', 'Unholy', 1, 522),
+    ('DeathKnight', 'Unholy', 2, 553),
+    ('DeathKnight', 'Unholy', 3, 771),
+    ('DeathKnight', 'Unholy', 4, 518),
+    ('DeathKnight', 'Unholy', 5, 527),
+    ('Warrior', 'Arms', 0, 489),
+    ('Warrior', 'Arms', 1, 484),
+    ('Warrior', 'Arms', 2, 485),
+    ('Warrior', 'Arms', 3, 499),
+    ('Warrior', 'Arms', 4, 483),
+    ('Warrior', 'Arms', 5, 500),
+    ('Warrior', 'Protection', 0, 503),
+    ('Warrior', 'Protection', 1, 484),
+    ('Warrior', 'Protection', 2, 485),
+    ('Warrior', 'Protection', 3, 763),
+    ('Warrior', 'Protection', 4, 483),
+    ('Warrior', 'Protection', 5, 502),
+    ('Warrior', 'Fury', 0, 509),
+    ('Warrior', 'Fury', 1, 484),
+    ('Warrior', 'Fury', 2, 851),
+    ('Warrior', 'Fury', 3, 490),
+    ('Warrior', 'Fury', 4, 483),
+    ('Warrior', 'Fury', 5, 494),
+    ('Rogue', 'Subtlety', 0, 404),
+    ('Rogue', 'Subtlety', 1, 464),
+    ('Rogue', 'Subtlety', 2, 467),
+    ('Rogue', 'Subtlety', 3, 716),
+    ('Rogue', 'Subtlety', 4, 469),
+    ('Rogue', 'Subtlety', 5, 408),
+    ('Rogue', 'Combat', 0, 409),
+    ('Rogue', 'Combat', 1, 464),
+    ('Rogue', 'Combat', 2, 467),
+    ('Rogue', 'Combat', 3, 404),
+    ('Rogue', 'Combat', 4, 469),
+    ('Rogue', 'Combat', 5, 715),
+    ('Hunter', 'Marksmanship', 0, 351),
+    ('Hunter', 'Marksmanship', 1, 439),
+    ('Hunter', 'Marksmanship', 2, 440),
+    ('Hunter', 'Marksmanship', 3, 358),
+    ('Hunter', 'Marksmanship', 4, 441),
+    ('Hunter', 'Marksmanship', 5, 366),
+    ('DeathKnight', 'Blood', 0, 771),
+    ('DeathKnight', 'Blood', 2, 555),
+    ('DeathKnight', 'Blood', 1, 522),
+    ('DeathKnight', 'Blood', 3, 558),
+    ('DeathKnight', 'Blood', 4, 514),
+    ('DeathKnight', 'Blood', 5, 528),
+    ('DeathKnight', 'Frost', 0, 525),
+    ('DeathKnight', 'Frost', 1, 522),
+    ('DeathKnight', 'Frost', 2, 518),
+    ('DeathKnight', 'Frost', 3, 773),
+    ('DeathKnight', 'Frost', 4, 553),
+    ('DeathKnight', 'Frost', 5, 521),
+    ('Priest', 'Shadow', 0, 263),
+    ('Priest', 'Shadow', 1, 463),
+    ('Priest', 'Shadow', 2, 458),
+    ('Priest', 'Shadow', 3, 257),
+    ('Priest', 'Shadow', 4, 459),
+    ('Priest', 'Shadow', 5, 708);
+/*!40000 ALTER TABLE `template_npc_glyphs` ENABLE KEYS */;
+
+
+-- Dumping structure for table characters_dev.template_npc_horde
+CREATE TABLE IF NOT EXISTS `template_npc_horde` (
+  `playerClass` varchar(50) NOT NULL,
+  `playerSpec` varchar(50) NOT NULL,
+  `pos` int(10) unsigned NOT NULL DEFAULT '0',
+  `itemEntry` int(10) unsigned NOT NULL DEFAULT '0',
+  `enchant` int(10) unsigned NOT NULL DEFAULT '0',
+  `socket1` int(10) unsigned NOT NULL DEFAULT '0',
+  `socket2` int(10) unsigned NOT NULL DEFAULT '0',
+  `socket3` int(10) unsigned NOT NULL DEFAULT '0',
+  `bonusEnchant` int(10) unsigned NOT NULL DEFAULT '0',
+  `prismaticEnchant` int(10) DEFAULT NULL
+) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='Templates';
+
+-- Dumping data for table characters_dev.template_npc_horde: ~501 rows (approximately)
+/*!40000 ALTER TABLE `template_npc_horde` DISABLE KEYS */;
+INSERT INTO `template_npc_horde` (`playerClass`, `playerSpec`, `pos`, `itemEntry`, `enchant`, `socket1`, `socket2`, `socket3`, `bonusEnchant`, `prismaticEnchant`) VALUES
+    ('Rogue', 'Assassination', 0, 41672, 3795, 3628, 3521, 0, 3314, 0),
+    ('Rogue', 'Assassination', 1, 42042, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 2, 41683, 3793, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 4, 41650, 3245, 3521, 3566, 0, 3600, 0),
+    ('Rogue', 'Assassination', 5, 41833, 0, 3521, 3521, 0, 0, 3729),
+    ('Rogue', 'Assassination', 6, 41655, 3823, 3521, 3879, 0, 3355, 0),
+    ('Rogue', 'Assassination', 7, 41837, 1597, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 8, 41841, 3845, 0, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 9, 41767, 1603, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 10, 42117, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 12, 42136, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 13, 51378, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 14, 42082, 1099, 0, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 15, 45958, 3789, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 16, 45962, 3731, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 17, 42451, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 0, 41672, 3795, 3628, 3521, 0, 3314, 0),
+    ('Rogue', 'Subtlety', 1, 42042, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 2, 41683, 3793, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 4, 41650, 3245, 3521, 3566, 0, 3600, 0),
+    ('Rogue', 'Subtlety', 5, 41833, 0, 3521, 3521, 0, 0, 3729),
+    ('Rogue', 'Subtlety', 6, 41655, 3823, 3521, 3879, 0, 3355, 0),
+    ('Rogue', 'Subtlety', 7, 41837, 1597, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 8, 41841, 3845, 0, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 9, 41767, 1603, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 10, 42117, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 12, 51378, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 13, 42136, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 14, 42082, 1099, 0, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 15, 45958, 3789, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 16, 45962, 3731, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 17, 42451, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 0, 41672, 3795, 3628, 3521, 0, 3314, 0),
+    ('Rogue', 'Combat', 1, 42042, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 2, 41683, 3793, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 4, 41650, 3245, 3521, 3566, 0, 3600, 0),
+    ('Rogue', 'Combat', 5, 41833, 0, 3521, 3521, 0, 0, 3729),
+    ('Rogue', 'Combat', 6, 41655, 3823, 3521, 3879, 0, 3355, 0),
+    ('Rogue', 'Combat', 7, 41837, 1597, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 8, 41841, 3845, 0, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 9, 41767, 1603, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 10, 42117, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 12, 51378, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 13, 42136, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 14, 42082, 1099, 0, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 15, 42276, 3789, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 16, 42281, 3731, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 17, 42451, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Feral', 0, 41678, 3795, 3621, 3525, 0, 3314, 0),
+    ('Druid', 'Feral', 1, 46374, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Feral', 2, 41715, 3793, 3525, 0, 0, 0, 0),
+    ('Druid', 'Feral', 4, 41661, 3832, 3525, 3525, 0, 0, 0),
+    ('Druid', 'Feral', 5, 41833, 0, 3543, 3525, 0, 2877, 3729),
+    ('Druid', 'Feral', 6, 41667, 3823, 3525, 3879, 0, 3355, 0),
+    ('Druid', 'Feral', 7, 41837, 1597, 3525, 0, 0, 0, 0),
+    ('Druid', 'Feral', 8, 41841, 3845, 0, 0, 0, 0, 0),
+    ('Druid', 'Feral', 9, 41773, 1603, 3543, 0, 0, 2874, 0),
+    ('Druid', 'Feral', 10, 42119, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Feral', 11, 48007, 0, 3528, 0, 0, 2877, 0),
+    ('Druid', 'Feral', 12, 42136, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Feral', 13, 51378, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Feral', 14, 42082, 1099, 0, 0, 0, 0, 0),
+    ('Druid', 'Feral', 15, 45951, 3789, 3525, 3525, 0, 0, 0),
+    ('Druid', 'Feral', 17, 42589, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Ballance', 0, 41327, 3796, 3621, 3520, 0, 3352, 0),
+    ('Druid', 'Ballance', 1, 42044, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Ballance', 4, 41316, 3245, 3520, 3531, 0, 3600, 0),
+    ('Druid', 'Ballance', 2, 41281, 3794, 3531, 0, 0, 2890, 0),
+    ('Druid', 'Ballance', 5, 41631, 0, 3879, 3520, 0, 2872, 3729),
+    ('Druid', 'Ballance', 6, 41304, 3721, 3520, 3548, 0, 3602, 0),
+    ('Druid', 'Ballance', 7, 41636, 3232, 3531, 0, 0, 2878, 0),
+    ('Druid', 'Ballance', 8, 41641, 2332, 0, 0, 0, 0, 0),
+    ('Druid', 'Ballance', 9, 41293, 3246, 3548, 0, 0, 2890, 0),
+    ('Druid', 'Ballance', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Ballance', 11, 48001, 0, 3520, 0, 0, 3752, 0),
+    ('Druid', 'Ballance', 12, 42137, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Ballance', 13, 51378, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Ballance', 14, 42076, 3243, 0, 0, 0, 0, 0),
+    ('Druid', 'Ballance', 15, 42364, 3854, 3520, 3535, 0, 3602, 0),
+    ('Druid', 'Ballance', 17, 42584, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Holy', 0, 41854, 3796, 3621, 3520, 0, 3352, 0),
+    ('Priest', 'Holy', 1, 42044, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Holy', 2, 41869, 3794, 3531, 0, 0, 2890, 0),
+    ('Priest', 'Holy', 4, 41859, 3245, 3520, 3531, 0, 3600, 0),
+    ('Priest', 'Holy', 5, 49179, 0, 3548, 3531, 0, 2872, 3729),
+    ('Priest', 'Holy', 6, 41864, 3721, 3520, 3879, 0, 2770, 0),
+    ('Priest', 'Holy', 7, 49183, 3232, 3531, 0, 0, 2878, 0),
+    ('Priest', 'Holy', 8, 49181, 2332, 0, 0, 0, 0, 0),
+    ('Priest', 'Holy', 9, 41874, 3246, 3548, 0, 0, 2890, 0),
+    ('Priest', 'Holy', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Holy', 11, 47732, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Holy', 12, 42135, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Holy', 13, 51378, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Holy', 14, 42082, 3243, 0, 0, 0, 0, 0),
+    ('Priest', 'Holy', 15, 42347, 3834, 3531, 0, 0, 0, 0),
+    ('Priest', 'Holy', 16, 42526, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Holy', 17, 42520, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Arcane', 0, 41946, 3820, 3621, 3520, 0, 3821, 0),
+    ('Mage', 'Arcane', 1, 42044, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Arcane', 2, 41965, 3794, 3531, 0, 0, 2868, 0),
+    ('Mage', 'Arcane', 4, 41953, 3245, 3520, 3531, 0, 3307, 0),
+    ('Mage', 'Arcane', 5, 49179, 0, 3548, 3520, 0, 2872, 3729),
+    ('Mage', 'Arcane', 6, 41959, 3721, 3520, 3548, 0, 2770, 0),
+    ('Mage', 'Arcane', 7, 49183, 3232, 3531, 0, 0, 2878, 0),
+    ('Mage', 'Arcane', 8, 49181, 2332, 0, 0, 0, 0, 0),
+    ('Mage', 'Arcane', 9, 41971, 3246, 3879, 0, 0, 3198, 0),
+    ('Mage', 'Arcane', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Arcane', 11, 48001, 0, 3520, 0, 0, 3752, 0),
+    ('Mage', 'Arcane', 12, 51378, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Arcane', 13, 47316, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Arcane', 14, 42077, 3243, 0, 0, 0, 0, 0),
+    ('Mage', 'Arcane', 15, 42347, 3834, 3548, 0, 0, 3752, 0),
+    ('Mage', 'Arcane', 16, 42526, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Arcane', 17, 42520, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Fire', 0, 41946, 3820, 3621, 3520, 0, 3821, 0),
+    ('Mage', 'Fire', 1, 42044, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Fire', 2, 41965, 3794, 3531, 0, 0, 2868, 0),
+    ('Mage', 'Fire', 4, 41953, 3245, 3520, 3531, 0, 3307, 0),
+    ('Mage', 'Fire', 5, 49179, 0, 3548, 3520, 0, 2872, 3729),
+    ('Mage', 'Fire', 6, 41959, 3721, 3520, 3548, 0, 2770, 0),
+    ('Mage', 'Fire', 7, 49183, 3232, 3531, 0, 0, 2878, 0),
+    ('Mage', 'Fire', 8, 49181, 2332, 0, 0, 0, 0, 0),
+    ('Mage', 'Fire', 9, 41971, 3246, 3879, 0, 0, 3198, 0),
+    ('Mage', 'Fire', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Fire', 11, 48001, 0, 3520, 0, 0, 3752, 0),
+    ('Mage', 'Fire', 12, 51378, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Fire', 13, 47316, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Fire', 14, 42077, 3243, 0, 0, 0, 0, 0),
+    ('Mage', 'Fire', 15, 42347, 3834, 3548, 0, 0, 3752, 0),
+    ('Mage', 'Fire', 16, 42526, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Fire', 17, 42520, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 0, 40828, 3795, 3628, 3518, 0, 2787, 0),
+    ('Paladin', 'Retribution', 1, 42042, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 2, 40869, 3793, 3552, 0, 0, 3263, 0),
+    ('Paladin', 'Retribution', 4, 40788, 3832, 3518, 3518, 0, 0, 0),
+    ('Paladin', 'Retribution', 5, 40883, 0, 3518, 3518, 0, 0, 3729),
+    ('Paladin', 'Retribution', 6, 40849, 3823, 3518, 3536, 0, 3357, 0),
+    ('Paladin', 'Retribution', 7, 40884, 1597, 3518, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 8, 40890, 3845, 0, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 9, 40808, 1603, 3518, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 10, 42117, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 12, 42136, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 13, 51378, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 14, 42082, 1099, 0, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 15, 42323, 3789, 3518, 3518, 0, 0, 0),
+    ('Paladin', 'Retribution', 17, 42853, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 0, 40828, 3795, 3628, 3518, 0, 2787, 0),
+    ('Paladin', 'Protection', 1, 42042, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 2, 40869, 3793, 3552, 0, 0, 3263, 0),
+    ('Paladin', 'Protection', 4, 40788, 3832, 3518, 3518, 0, 0, 0),
+    ('Paladin', 'Protection', 5, 40883, 0, 3518, 3518, 0, 0, 3729),
+    ('Paladin', 'Protection', 6, 40849, 3823, 3518, 3536, 0, 3357, 0),
+    ('Paladin', 'Protection', 7, 40884, 1597, 3518, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 8, 40890, 3845, 0, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 9, 40808, 1603, 3518, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 10, 42117, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 12, 42136, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 13, 51378, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 14, 42082, 1099, 0, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 15, 42286, 3789, 3863, 0, 0, 2936, 0),
+    ('Paladin', 'Protection', 16, 42560, 3849, 0, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 17, 42853, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Elemental', 0, 41019, 3796, 3621, 3866, 0, 2854, 0),
+    ('Shaman', 'Elemental', 1, 42044, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Elemental', 2, 41044, 3794, 3531, 0, 0, 2865, 0),
+    ('Shaman', 'Elemental', 4, 40993, 3832, 3866, 3531, 0, 3600, 0),
+    ('Shaman', 'Elemental', 5, 41071, 0, 3535, 3535, 0, 3596, 3729),
+    ('Shaman', 'Elemental', 6, 41033, 3721, 3866, 3535, 0, 3602, 0),
+    ('Shaman', 'Elemental', 7, 41076, 3232, 3531, 0, 0, 2878, 0),
+    ('Shaman', 'Elemental', 8, 41066, 2332, 0, 0, 0, 0, 0),
+    ('Shaman', 'Elemental', 9, 41007, 3246, 3535, 0, 0, 2865, 0),
+    ('Shaman', 'Elemental', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Elemental', 11, 42116, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Elemental', 12, 42137, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Elemental', 13, 51378, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Elemental', 14, 42078, 3831, 0, 0, 0, 0, 0),
+    ('Shaman', 'Elemental', 15, 42347, 3834, 3535, 0, 0, 3752, 0),
+    ('Shaman', 'Elemental', 16, 42565, 1128, 0, 0, 0, 0, 0),
+    ('Shaman', 'Elemental', 17, 42603, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Enhancement', 0, 41151, 3817, 3621, 3521, 0, 2843, 0),
+    ('Shaman', 'Enhancement', 1, 42042, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Enhancement', 2, 41211, 3808, 3565, 0, 0, 2874, 0),
+    ('Shaman', 'Enhancement', 4, 41081, 3832, 3521, 3521, 0, 0, 0),
+    ('Shaman', 'Enhancement', 5, 41236, 0, 3521, 3521, 0, 0, 3729),
+    ('Shaman', 'Enhancement', 6, 41199, 3823, 3521, 3521, 0, 0, 0),
+    ('Shaman', 'Enhancement', 7, 41231, 1597, 3521, 0, 0, 0, 0),
+    ('Shaman', 'Enhancement', 8, 41226, 3845, 0, 0, 0, 0, 0),
+    ('Shaman', 'Enhancement', 9, 41137, 1603, 3577, 0, 0, 2874, 0),
+    ('Shaman', 'Enhancement', 10, 42119, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Enhancement', 11, 42117, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Enhancement', 12, 51378, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Enhancement', 13, 42136, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Enhancement', 15, 42276, 3789, 3577, 0, 0, 2936, 0),
+    ('Shaman', 'Enhancement', 14, 42081, 3243, 0, 0, 0, 0, 0),
+    ('Shaman', 'Enhancement', 16, 42276, 3789, 3521, 0, 0, 0, 0),
+    ('Shaman', 'Enhancement', 17, 42608, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Restoration', 0, 41013, 3796, 3627, 3866, 0, 2854, 0),
+    ('Shaman', 'Restoration', 1, 42045, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Restoration', 2, 41038, 3794, 3530, 0, 0, 2865, 0),
+    ('Shaman', 'Restoration', 4, 40992, 3245, 3866, 3866, 0, 0, 0),
+    ('Shaman', 'Restoration', 5, 41052, 0, 3866, 3866, 0, 0, 3729),
+    ('Shaman', 'Restoration', 6, 41027, 3721, 3866, 3863, 0, 3602, 0),
+    ('Shaman', 'Restoration', 7, 41056, 3232, 3866, 0, 0, 0, 0),
+    ('Shaman', 'Restoration', 8, 41061, 2332, 0, 0, 0, 0, 0),
+    ('Shaman', 'Restoration', 9, 41001, 3246, 3866, 0, 0, 0, 0),
+    ('Shaman', 'Restoration', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Restoration', 11, 42116, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Restoration', 12, 42135, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Restoration', 13, 51378, 0, 0, 0, 0, 0, 0),
+    ('Shaman', 'Restoration', 14, 42077, 3831, 0, 0, 0, 0, 0),
+    ('Shaman', 'Restoration', 15, 42353, 3834, 3866, 0, 0, 0, 0),
+    ('Shaman', 'Restoration', 16, 42571, 1128, 0, 0, 0, 0, 0),
+    ('Shaman', 'Restoration', 17, 42598, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 0, 41854, 3796, 3639, 3520, 0, 3352, 0),
+    ('Priest', 'Discipline', 1, 42044, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 2, 41869, 3794, 3531, 0, 0, 2890, 0),
+    ('Priest', 'Discipline', 4, 41859, 3245, 3520, 3531, 0, 3600, 0),
+    ('Priest', 'Discipline', 5, 49179, 0, 3548, 3531, 0, 2872, 3729),
+    ('Priest', 'Discipline', 6, 41864, 3721, 3520, 3879, 0, 2770, 0),
+    ('Priest', 'Discipline', 7, 49183, 3232, 3531, 0, 0, 2878, 0),
+    ('Priest', 'Discipline', 8, 49181, 2332, 0, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 9, 41874, 3246, 3548, 0, 0, 2890, 0),
+    ('Priest', 'Discipline', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 11, 47732, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 12, 51378, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 13, 47271, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 14, 42082, 3243, 0, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 15, 42347, 3834, 3531, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 16, 42526, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 17, 42520, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Restoration', 1, 42044, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Restoration', 2, 41275, 3794, 3531, 0, 0, 2890, 0),
+    ('Druid', 'Restoration', 4, 41310, 3245, 3520, 3531, 0, 3600, 0),
+    ('Druid', 'Restoration', 5, 41618, 0, 3535, 3520, 0, 2872, 3729),
+    ('Druid', 'Restoration', 6, 41298, 3721, 3520, 3879, 0, 3602, 0),
+    ('Druid', 'Restoration', 7, 41622, 3232, 3531, 0, 0, 2878, 0),
+    ('Druid', 'Restoration', 8, 41626, 2332, 0, 0, 0, 0, 0),
+    ('Druid', 'Restoration', 9, 41287, 3246, 3548, 0, 0, 2890, 0),
+    ('Druid', 'Restoration', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Restoration', 11, 48001, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Restoration', 12, 42137, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Restoration', 14, 42080, 3243, 0, 0, 0, 0, 0),
+    ('Druid', 'Restoration', 13, 51378, 0, 0, 0, 0, 0, 0),
+    ('Druid', 'Restoration', 15, 42385, 3854, 3520, 3548, 0, 3602, 0),
+    ('Druid', 'Restoration', 17, 42579, 0, 0, 0, 0, 0, 0),
+    ('Hunter', 'Marksmanship', 0, 41157, 3795, 3621, 3519, 0, 2843, 0),
+    ('Hunter', 'Marksmanship', 1, 42041, 0, 0, 0, 0, 0, 0),
+    ('Hunter', 'Marksmanship', 2, 41217, 3793, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Marksmanship', 4, 41087, 3245, 3519, 3519, 0, 0, 0),
+    ('Hunter', 'Marksmanship', 5, 41236, 0, 3535, 3519, 0, 2877, 3729),
+    ('Hunter', 'Marksmanship', 6, 41205, 3823, 3519, 3537, 0, 3355, 0),
+    ('Hunter', 'Marksmanship', 7, 41231, 3232, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Marksmanship', 8, 41226, 3845, 0, 0, 0, 0, 0),
+    ('Hunter', 'Marksmanship', 9, 41143, 1603, 3879, 0, 0, 2874, 0),
+    ('Hunter', 'Marksmanship', 10, 48007, 0, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Marksmanship', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('Hunter', 'Marksmanship', 12, 42136, 0, 0, 0, 0, 0, 0),
+    ('Hunter', 'Marksmanship', 13, 51378, 0, 0, 0, 0, 0, 0),
+    ('Hunter', 'Marksmanship', 14, 42082, 3243, 0, 0, 0, 0, 0),
+    ('Hunter', 'Marksmanship', 15, 42209, 3833, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Marksmanship', 16, 42228, 3731, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Marksmanship', 17, 42486, 3608, 0, 0, 0, 0, 0),
+    ('Hunter', 'Beastmastery', 0, 41157, 3795, 3621, 3519, 0, 2843, 0),
+    ('Hunter', 'Beastmastery', 1, 42041, 0, 0, 0, 0, 0, 0),
+    ('Hunter', 'Beastmastery', 2, 41217, 3793, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Beastmastery', 4, 41087, 3245, 3519, 3519, 0, 0, 0),
+    ('Hunter', 'Beastmastery', 5, 41236, 0, 3535, 3519, 0, 2877, 3729),
+    ('Hunter', 'Beastmastery', 6, 41205, 3823, 3519, 3537, 0, 3355, 0),
+    ('Hunter', 'Beastmastery', 7, 41231, 3232, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Beastmastery', 8, 41226, 3845, 0, 0, 0, 0, 0),
+    ('Hunter', 'Beastmastery', 9, 41143, 1603, 3879, 0, 0, 2874, 0),
+    ('Hunter', 'Beastmastery', 10, 48007, 0, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Beastmastery', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('Hunter', 'Beastmastery', 12, 42136, 0, 0, 0, 0, 0, 0),
+    ('Hunter', 'Beastmastery', 13, 51378, 0, 0, 0, 0, 0, 0),
+    ('Hunter', 'Beastmastery', 14, 42082, 3243, 0, 0, 0, 0, 0),
+    ('Hunter', 'Beastmastery', 15, 42209, 3833, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Beastmastery', 16, 42228, 3731, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Beastmastery', 17, 42486, 3608, 0, 0, 0, 0, 0),
+    ('Hunter', 'Survival', 0, 41157, 3795, 3621, 3519, 0, 2843, 0),
+    ('Hunter', 'Survival', 1, 42041, 0, 0, 0, 0, 0, 0),
+    ('Hunter', 'Survival', 2, 41217, 3793, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Survival', 4, 41087, 3245, 3519, 3519, 0, 0, 0),
+    ('Hunter', 'Survival', 5, 41236, 0, 3535, 3519, 0, 2877, 3729),
+    ('Hunter', 'Survival', 6, 41205, 3823, 3519, 3537, 0, 3355, 0),
+    ('Hunter', 'Survival', 7, 41231, 3232, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Survival', 8, 41226, 3845, 0, 0, 0, 0, 0),
+    ('Hunter', 'Survival', 9, 41143, 1603, 3879, 0, 0, 2874, 0),
+    ('Hunter', 'Survival', 10, 48007, 0, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Survival', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('Hunter', 'Survival', 12, 42136, 0, 0, 0, 0, 0, 0),
+    ('Hunter', 'Survival', 13, 51378, 0, 0, 0, 0, 0, 0),
+    ('Hunter', 'Survival', 14, 42082, 3243, 0, 0, 0, 0, 0),
+    ('Hunter', 'Survival', 15, 42209, 3833, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Survival', 16, 42228, 3731, 3519, 0, 0, 0, 0),
+    ('Hunter', 'Survival', 17, 42486, 3608, 0, 0, 0, 0, 0),
+    ('Paladin', 'Holy', 0, 40933, 3796, 3627, 3520, 0, 2854, 0),
+    ('Paladin', 'Holy', 1, 42043, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Holy', 2, 40963, 3794, 3865, 0, 0, 2865, 0),
+    ('Paladin', 'Holy', 4, 40907, 3832, 3520, 3865, 0, 3600, 0),
+    ('Paladin', 'Holy', 5, 40978, 0, 3546, 3866, 0, 3596, 3729),
+    ('Paladin', 'Holy', 6, 40939, 3721, 3520, 3546, 0, 3602, 0),
+    ('Paladin', 'Holy', 7, 40979, 3232, 3865, 0, 0, 2878, 0),
+    ('Paladin', 'Holy', 8, 40984, 2332, 0, 0, 0, 0, 0),
+    ('Paladin', 'Holy', 9, 40927, 3246, 3546, 0, 0, 2865, 0),
+    ('Paladin', 'Holy', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Holy', 11, 42116, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Holy', 12, 42137, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Holy', 13, 51378, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Holy', 14, 42076, 3831, 0, 0, 0, 0, 0),
+    ('Paladin', 'Holy', 15, 42353, 3834, 3546, 0, 0, 3752, 0),
+    ('Paladin', 'Holy', 16, 42571, 1128, 0, 0, 0, 0, 0),
+    ('Paladin', 'Holy', 17, 42615, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 0, 41993, 3796, 3621, 3548, 0, 3821, 0),
+    ('Warlock', 'Destruction', 1, 42043, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 2, 42011, 3794, 3528, 0, 0, 2868, 0),
+    ('Warlock', 'Destruction', 4, 41998, 3245, 3520, 3528, 0, 3307, 0),
+    ('Warlock', 'Destruction', 5, 41899, 0, 3535, 3531, 0, 2872, 3729),
+    ('Warlock', 'Destruction', 6, 42005, 3721, 3520, 3528, 0, 0, 0),
+    ('Warlock', 'Destruction', 7, 49183, 3232, 3563, 0, 0, 2878, 0),
+    ('Warlock', 'Destruction', 8, 41910, 2332, 0, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 9, 42017, 3246, 3535, 0, 0, 2872, 0),
+    ('Warlock', 'Destruction', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 11, 42116, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 12, 51378, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 13, 42132, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 14, 42078, 3243, 0, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 15, 42347, 0, 3866, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 16, 42526, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 17, 42503, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 0, 41993, 3796, 3621, 3548, 0, 3821, 0),
+    ('Warlock', 'Demonology', 1, 42043, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 2, 42011, 3794, 3528, 0, 0, 2868, 0),
+    ('Warlock', 'Demonology', 4, 41998, 3245, 3520, 3528, 0, 3307, 0),
+    ('Warlock', 'Demonology', 5, 41899, 0, 3535, 3528, 0, 2872, 3729),
+    ('Warlock', 'Demonology', 6, 42005, 3721, 3520, 3528, 0, 0, 0),
+    ('Warlock', 'Demonology', 7, 49183, 3232, 3563, 0, 0, 2878, 0),
+    ('Warlock', 'Demonology', 8, 41910, 2332, 0, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 9, 42017, 3246, 3535, 0, 0, 2872, 0),
+    ('Warlock', 'Demonology', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 11, 42116, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 12, 51378, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 13, 42132, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 14, 42078, 3243, 0, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 15, 42347, 3834, 3866, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 16, 42526, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 17, 42503, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 0, 41993, 3796, 3621, 3548, 0, 3821, 0),
+    ('Warlock', 'Affliction', 1, 42043, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 2, 42011, 3794, 3528, 0, 0, 2868, 0),
+    ('Warlock', 'Affliction', 4, 41998, 3245, 3520, 3528, 0, 3307, 0),
+    ('Warlock', 'Affliction', 5, 41899, 0, 3535, 3528, 0, 2872, 3729),
+    ('Warlock', 'Affliction', 6, 42005, 3721, 3520, 3528, 0, 0, 0),
+    ('Warlock', 'Affliction', 7, 49183, 3232, 3563, 0, 0, 2878, 0),
+    ('Warlock', 'Affliction', 8, 41910, 2332, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 9, 42017, 3246, 3535, 0, 0, 2872, 0),
+    ('Warlock', 'Affliction', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 11, 42116, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 12, 51378, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 13, 42132, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 14, 42078, 3243, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 16, 42526, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 15, 42347, 3834, 3866, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 17, 42503, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Frost', 0, 41946, 3820, 3621, 3520, 0, 3821, 0),
+    ('Mage', 'Frost', 1, 42044, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Frost', 2, 41965, 3794, 3531, 0, 0, 2868, 0),
+    ('Mage', 'Frost', 4, 41953, 3245, 3520, 3531, 0, 3307, 0),
+    ('Mage', 'Frost', 5, 49179, 0, 3548, 3520, 0, 2872, 3729),
+    ('Mage', 'Frost', 6, 41959, 3721, 3520, 3548, 0, 2770, 0),
+    ('Mage', 'Frost', 7, 49183, 3232, 3531, 0, 0, 2878, 0),
+    ('Mage', 'Frost', 8, 49181, 2332, 0, 0, 0, 0, 0),
+    ('Mage', 'Frost', 9, 41971, 3246, 3879, 0, 0, 3198, 0),
+    ('Mage', 'Frost', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Frost', 11, 48001, 0, 3520, 0, 0, 3752, 0),
+    ('Mage', 'Frost', 12, 51378, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Frost', 13, 47316, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Frost', 14, 42077, 3243, 0, 0, 0, 0, 0),
+    ('Mage', 'Frost', 15, 42347, 3834, 3548, 0, 0, 3752, 0),
+    ('Mage', 'Frost', 16, 42526, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Frost', 17, 42520, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 1, 42041, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 2, 40868, 3852, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 4, 40787, 3832, 3518, 3518, 0, 0, 0),
+    ('DeathKnight', 'Blood', 5, 40883, 0, 3518, 3879, 0, 0, 3729),
+    ('DeathKnight', 'Blood', 6, 40848, 3823, 3518, 3535, 0, 3357, 0),
+    ('DeathKnight', 'Blood', 7, 40884, 1597, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 8, 40890, 3845, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 9, 40809, 1603, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 10, 42117, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 12, 51378, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 13, 42134, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 14, 42081, 3243, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 15, 42333, 3366, 3518, 3535, 0, 3764, 0),
+    ('DeathKnight', 'Blood', 17, 42621, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 0, 40827, 3795, 3621, 3518, 0, 2787, 0),
+    ('DeathKnight', 'Frost', 1, 42041, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 2, 40868, 3852, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 4, 40787, 3832, 3518, 3518, 0, 0, 0),
+    ('DeathKnight', 'Frost', 5, 40883, 0, 3518, 3879, 0, 0, 3729),
+    ('DeathKnight', 'Frost', 6, 40848, 3823, 3518, 3535, 0, 3357, 0),
+    ('DeathKnight', 'Frost', 7, 40884, 1597, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 8, 40890, 3845, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 9, 40809, 1603, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 10, 42117, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 12, 51378, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 13, 42134, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 14, 42081, 3243, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 15, 42209, 3370, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 16, 42209, 3594, 3535, 0, 0, 2936, 0),
+    ('DeathKnight', 'Frost', 17, 42621, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 0, 40827, 3795, 3621, 3518, 0, 2787, 0),
+    ('DeathKnight', 'Unholy', 1, 42041, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 2, 40868, 3852, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 4, 40787, 3832, 3518, 3518, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 5, 40883, 0, 3518, 3879, 0, 0, 3729),
+    ('DeathKnight', 'Unholy', 6, 40848, 3823, 3518, 3535, 0, 3357, 0),
+    ('DeathKnight', 'Unholy', 7, 40884, 1597, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 8, 40890, 3845, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 9, 40809, 1603, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 10, 42117, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 12, 51378, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 13, 42134, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 14, 42081, 3243, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 15, 42333, 3367, 3518, 3535, 0, 3764, 0),
+    ('DeathKnight', 'Unholy', 17, 42621, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 0, 40826, 3795, 3625, 3525, 0, 2787, 0),
+    ('Warrior', 'Protection', 1, 42042, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 2, 40866, 3793, 3550, 0, 0, 3263, 0),
+    ('Warrior', 'Protection', 5, 40883, 0, 3525, 3525, 0, 0, 3729),
+    ('Warrior', 'Protection', 4, 40789, 3832, 3525, 3550, 0, 3600, 0),
+    ('Warrior', 'Protection', 6, 40847, 3823, 3525, 3525, 0, 0, 0),
+    ('Warrior', 'Protection', 7, 40884, 1597, 3525, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 8, 40890, 3845, 0, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 9, 40807, 1603, 3525, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 10, 42119, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 11, 42117, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 12, 42136, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 13, 51378, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 14, 42082, 1099, 0, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 15, 42276, 3789, 3863, 0, 0, 2936, 0),
+    ('Warrior', 'Protection', 16, 42560, 3849, 0, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 17, 42486, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 0, 40826, 3795, 3625, 3525, 0, 2787, 0),
+    ('Warrior', 'Fury', 1, 42042, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 2, 40866, 3793, 3550, 0, 0, 3263, 0),
+    ('Warrior', 'Fury', 4, 40789, 3832, 3525, 3550, 0, 3600, 0),
+    ('Warrior', 'Fury', 5, 40883, 0, 3525, 3525, 0, 0, 3729),
+    ('Warrior', 'Fury', 6, 40847, 3823, 3525, 3525, 0, 0, 0),
+    ('Warrior', 'Fury', 7, 40884, 1597, 3525, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 8, 40890, 3845, 0, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 9, 40807, 1603, 3525, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 10, 42119, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 11, 42117, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 12, 42136, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 13, 51378, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 14, 42082, 1099, 0, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 15, 42323, 3789, 3525, 3525, 0, 0, 0),
+    ('Warrior', 'Fury', 16, 42323, 3789, 3525, 3525, 0, 0, 0),
+    ('Warrior', 'Fury', 17, 42486, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 0, 40826, 3795, 3625, 3525, 0, 2787, 0),
+    ('Warrior', 'Arms', 1, 42042, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 2, 40866, 3793, 3550, 0, 0, 3263, 0),
+    ('Warrior', 'Arms', 4, 40789, 3832, 3525, 3550, 0, 3600, 0),
+    ('Warrior', 'Arms', 5, 40883, 0, 3525, 3525, 0, 0, 3729),
+    ('Warrior', 'Arms', 6, 40847, 3823, 3525, 3525, 0, 0, 0),
+    ('Warrior', 'Arms', 7, 40884, 1597, 3525, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 8, 40890, 3845, 0, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 9, 40807, 1603, 3525, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 10, 42119, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 11, 42117, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 12, 42136, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 13, 51378, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 14, 42082, 1099, 0, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 15, 42323, 3789, 3525, 3525, 0, 0, 0),
+    ('Warrior', 'Arms', 17, 42486, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Shadow', 0, 41854, 3796, 3621, 3520, 0, 3352, 0),
+    ('Priest', 'Shadow', 1, 42045, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Shadow', 2, 41934, 3794, 3563, 0, 0, 2868, 0),
+    ('Priest', 'Shadow', 4, 41921, 3832, 3563, 3563, 0, 3307, 0),
+    ('Priest', 'Shadow', 5, 49179, 0, 3590, 3590, 0, 2872, 3729),
+    ('Priest', 'Shadow', 6, 41927, 3721, 3520, 3590, 0, 2770, 0),
+    ('Priest', 'Shadow', 7, 49183, 3232, 3563, 0, 0, 2878, 0),
+    ('Priest', 'Shadow', 8, 49181, 2332, 0, 0, 0, 0, 0),
+    ('Priest', 'Shadow', 9, 41940, 3246, 3590, 0, 0, 3752, 0),
+    ('Priest', 'Shadow', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Shadow', 11, 47732, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Shadow', 12, 45518, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Shadow', 13, 42137, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Shadow', 14, 42077, 3243, 0, 0, 0, 0, 0),
+    ('Priest', 'Shadow', 15, 42347, 3834, 3590, 0, 0, 3752, 0),
+    ('Priest', 'Shadow', 16, 42526, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Shadow', 17, 42520, 0, 0, 0, 0, 0, 0);
+/*!40000 ALTER TABLE `template_npc_horde` ENABLE KEYS */;
+
+
+-- Dumping structure for table characters_dev.template_npc_human
+CREATE TABLE IF NOT EXISTS `template_npc_human` (
+  `playerClass` varchar(50) NOT NULL,
+  `playerSpec` varchar(50) NOT NULL,
+  `pos` int(10) unsigned NOT NULL DEFAULT '0',
+  `itemEntry` int(10) unsigned NOT NULL DEFAULT '0',
+  `enchant` int(10) unsigned NOT NULL DEFAULT '0',
+  `socket1` int(10) unsigned NOT NULL DEFAULT '0',
+  `socket2` int(10) unsigned NOT NULL DEFAULT '0',
+  `socket3` int(10) unsigned NOT NULL DEFAULT '0',
+  `bonusEnchant` int(10) unsigned NOT NULL DEFAULT '0',
+  `prismaticEnchant` int(10) DEFAULT NULL
+) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='Templates';
+
+-- Dumping data for table characters_dev.template_npc_human: ~354 rows (approximately)
+/*!40000 ALTER TABLE `template_npc_human` DISABLE KEYS */;
+INSERT INTO `template_npc_human` (`playerClass`, `playerSpec`, `pos`, `itemEntry`, `enchant`, `socket1`, `socket2`, `socket3`, `bonusEnchant`, `prismaticEnchant`) VALUES
+    ('Rogue', 'Assassination', 0, 41672, 3795, 3628, 3521, 0, 3314, 0),
+    ('Rogue', 'Assassination', 1, 42042, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 2, 41683, 3793, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 4, 41650, 3245, 3521, 3566, 0, 3600, 0),
+    ('Rogue', 'Assassination', 5, 41833, 0, 3521, 3521, 0, 0, 3729),
+    ('Rogue', 'Assassination', 6, 41655, 3823, 3521, 3879, 0, 3355, 0),
+    ('Rogue', 'Assassination', 7, 41837, 1597, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 8, 41841, 3845, 0, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 9, 41767, 1603, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 10, 42117, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 12, 42136, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 13, 46038, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 14, 42082, 1099, 0, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 15, 45958, 3789, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 16, 45962, 3731, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Assassination', 17, 42451, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 0, 41854, 3796, 3621, 3520, 0, 3352, 0),
+    ('Priest', 'Discipline', 1, 42044, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 2, 41869, 3794, 3531, 0, 0, 2890, 0),
+    ('Priest', 'Discipline', 4, 41859, 3245, 3520, 3531, 0, 3600, 0),
+    ('Priest', 'Discipline', 5, 49179, 0, 3548, 3531, 0, 2872, 3729),
+    ('Priest', 'Discipline', 6, 41864, 3721, 3520, 3879, 0, 2770, 0),
+    ('Priest', 'Discipline', 7, 49183, 3232, 3531, 0, 0, 2878, 0),
+    ('Priest', 'Discipline', 8, 49181, 2332, 0, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 9, 41874, 3246, 3548, 0, 0, 2890, 0),
+    ('Priest', 'Discipline', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 11, 47732, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 12, 42135, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 13, 47041, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 14, 42082, 3243, 0, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 15, 42347, 3834, 3531, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 16, 42526, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Discipline', 17, 42520, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Holy', 0, 41854, 3796, 3621, 3520, 0, 3352, 0),
+    ('Priest', 'Holy', 1, 42044, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Holy', 2, 41869, 3794, 3531, 0, 0, 2890, 0),
+    ('Priest', 'Holy', 4, 41859, 3245, 3520, 3531, 0, 3600, 0),
+    ('Priest', 'Holy', 5, 49179, 0, 3548, 3531, 0, 2872, 3729),
+    ('Priest', 'Holy', 6, 41864, 3721, 3520, 3879, 0, 2770, 0),
+    ('Priest', 'Holy', 7, 49183, 3232, 3531, 0, 0, 2878, 0),
+    ('Priest', 'Holy', 8, 49181, 2332, 0, 0, 0, 0, 0),
+    ('Priest', 'Holy', 9, 41874, 3246, 3548, 0, 0, 2890, 0),
+    ('Priest', 'Holy', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Holy', 11, 47732, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Holy', 12, 42135, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Holy', 13, 47041, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Holy', 14, 42082, 3243, 0, 0, 0, 0, 0),
+    ('Priest', 'Holy', 15, 42347, 3834, 3531, 0, 0, 0, 0),
+    ('Priest', 'Holy', 16, 42526, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Holy', 17, 42520, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Arcane', 0, 41946, 3820, 3621, 3520, 0, 3821, 0),
+    ('Mage', 'Arcane', 1, 42044, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Arcane', 2, 41965, 3794, 3531, 0, 0, 2868, 0),
+    ('Mage', 'Arcane', 4, 41953, 3245, 3520, 3531, 0, 3307, 0),
+    ('Mage', 'Arcane', 5, 49179, 0, 3548, 3520, 0, 2872, 3729),
+    ('Mage', 'Arcane', 7, 49183, 3232, 3531, 0, 0, 2878, 0),
+    ('Mage', 'Arcane', 6, 41959, 3721, 3520, 3548, 0, 2770, 0),
+    ('Mage', 'Arcane', 8, 49181, 2332, 0, 0, 0, 0, 0),
+    ('Mage', 'Arcane', 9, 41971, 3246, 3879, 0, 0, 3198, 0),
+    ('Mage', 'Arcane', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Arcane', 11, 47928, 0, 3520, 0, 0, 3752, 0),
+    ('Mage', 'Arcane', 12, 42137, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Arcane', 13, 47182, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Arcane', 14, 42077, 3243, 0, 0, 0, 0, 0),
+    ('Mage', 'Arcane', 15, 42347, 3834, 3548, 0, 0, 3752, 0),
+    ('Mage', 'Arcane', 16, 42526, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Arcane', 17, 42520, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Fire', 0, 41946, 3820, 3621, 3520, 0, 3821, 0),
+    ('Mage', 'Fire', 1, 42044, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Fire', 2, 41965, 3794, 3531, 0, 0, 2868, 0),
+    ('Mage', 'Fire', 4, 41953, 3245, 3520, 3531, 0, 3307, 0),
+    ('Mage', 'Fire', 5, 49179, 0, 3548, 3520, 0, 2872, 3729),
+    ('Mage', 'Fire', 6, 41959, 3721, 3520, 3548, 0, 2770, 0),
+    ('Mage', 'Fire', 7, 49183, 3232, 3531, 0, 0, 2878, 0),
+    ('Mage', 'Fire', 8, 49181, 2332, 0, 0, 0, 0, 0),
+    ('Mage', 'Fire', 9, 41971, 3246, 3879, 0, 0, 3198, 0),
+    ('Mage', 'Fire', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Fire', 11, 47928, 0, 3520, 0, 0, 3752, 0),
+    ('Mage', 'Fire', 12, 42137, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Fire', 13, 47182, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Fire', 14, 42077, 3243, 0, 0, 0, 0, 0),
+    ('Mage', 'Fire', 15, 42347, 3834, 3548, 0, 0, 3752, 0),
+    ('Mage', 'Fire', 16, 42526, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Fire', 17, 42520, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 0, 40828, 3795, 3628, 3518, 0, 2787, 0),
+    ('Paladin', 'Retribution', 1, 42042, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 2, 40869, 3793, 3552, 0, 0, 3263, 0),
+    ('Paladin', 'Retribution', 4, 40788, 3832, 3518, 3518, 0, 0, 0),
+    ('Paladin', 'Retribution', 5, 40883, 0, 3518, 3518, 0, 0, 3729),
+    ('Paladin', 'Retribution', 6, 40849, 3823, 3518, 3536, 0, 3357, 0),
+    ('Paladin', 'Retribution', 7, 40884, 1597, 3518, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 8, 40890, 3845, 0, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 9, 40808, 1603, 3518, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 10, 42117, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 12, 42136, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 13, 46038, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 14, 42082, 1099, 0, 0, 0, 0, 0),
+    ('Paladin', 'Retribution', 15, 42323, 3789, 3518, 3518, 0, 0, 0),
+    ('Paladin', 'Retribution', 17, 42853, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 0, 40828, 3795, 3628, 3518, 0, 2787, 0),
+    ('Paladin', 'Protection', 1, 42042, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 2, 40869, 3793, 3552, 0, 0, 3263, 0),
+    ('Paladin', 'Protection', 4, 40788, 3832, 3518, 3518, 0, 0, 0),
+    ('Paladin', 'Protection', 5, 40883, 0, 3518, 3518, 0, 0, 3729),
+    ('Paladin', 'Protection', 6, 40849, 3823, 3518, 3536, 0, 3357, 0),
+    ('Paladin', 'Protection', 7, 40884, 1597, 3518, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 8, 40890, 3845, 0, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 9, 40808, 1603, 3518, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 10, 42117, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 12, 42136, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 13, 46038, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 14, 42082, 1099, 0, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 15, 42286, 3789, 3863, 0, 0, 2936, 0),
+    ('Paladin', 'Protection', 16, 42560, 3849, 0, 0, 0, 0, 0),
+    ('Paladin', 'Protection', 17, 42853, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Holy', 0, 40933, 3796, 3627, 3520, 0, 2854, 0),
+    ('Paladin', 'Holy', 1, 42043, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Holy', 2, 40963, 3794, 3865, 0, 0, 2865, 0),
+    ('Paladin', 'Holy', 4, 40907, 3832, 3520, 3865, 0, 3600, 0),
+    ('Paladin', 'Holy', 5, 40978, 0, 3546, 3866, 0, 3596, 3729),
+    ('Paladin', 'Holy', 7, 40979, 3232, 3865, 0, 0, 2878, 0),
+    ('Paladin', 'Holy', 6, 40939, 3721, 3520, 3546, 0, 3602, 0),
+    ('Paladin', 'Holy', 8, 40984, 2332, 0, 0, 0, 0, 0),
+    ('Paladin', 'Holy', 9, 40927, 3246, 3546, 0, 0, 2865, 0),
+    ('Paladin', 'Holy', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Holy', 11, 42116, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Holy', 12, 42137, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Holy', 13, 47041, 0, 0, 0, 0, 0, 0),
+    ('Paladin', 'Holy', 14, 42076, 3831, 0, 0, 0, 0, 0),
+    ('Paladin', 'Holy', 15, 42353, 3834, 3546, 0, 0, 3752, 0),
+    ('Paladin', 'Holy', 16, 42571, 1128, 0, 0, 0, 0, 0),
+    ('Paladin', 'Holy', 17, 42615, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Frost', 0, 41946, 3820, 3621, 3520, 0, 3821, 0),
+    ('Mage', 'Frost', 1, 42044, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Frost', 2, 41965, 3794, 3531, 0, 0, 2868, 0),
+    ('Mage', 'Frost', 4, 41953, 3245, 3520, 3531, 0, 3307, 0),
+    ('Mage', 'Frost', 5, 49179, 0, 3548, 3520, 0, 2872, 3729),
+    ('Mage', 'Frost', 6, 41959, 3721, 3520, 3548, 0, 2770, 0),
+    ('Mage', 'Frost', 7, 49183, 3232, 3531, 0, 0, 2878, 0),
+    ('Mage', 'Frost', 8, 49181, 2332, 0, 0, 0, 0, 0),
+    ('Mage', 'Frost', 9, 41971, 3246, 3879, 0, 0, 3198, 0),
+    ('Mage', 'Frost', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Frost', 11, 47928, 0, 3520, 0, 0, 3752, 0),
+    ('Mage', 'Frost', 12, 42137, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Frost', 13, 47182, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Frost', 14, 42077, 3243, 0, 0, 0, 0, 0),
+    ('Mage', 'Frost', 15, 42347, 3834, 3548, 0, 0, 3752, 0),
+    ('Mage', 'Frost', 16, 42526, 0, 0, 0, 0, 0, 0),
+    ('Mage', 'Frost', 17, 42520, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 0, 40827, 3795, 3621, 3518, 0, 2787, 0),
+    ('DeathKnight', 'Frost', 1, 42041, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 2, 40868, 3852, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 4, 40787, 3832, 3518, 3518, 0, 0, 0),
+    ('DeathKnight', 'Frost', 5, 40883, 0, 3518, 3879, 0, 0, 3729),
+    ('DeathKnight', 'Frost', 6, 40848, 3823, 3518, 3535, 0, 3357, 0),
+    ('DeathKnight', 'Frost', 7, 40884, 1597, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 8, 40890, 3845, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 9, 40809, 1603, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 10, 42117, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 12, 46038, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 13, 42134, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 14, 42081, 3243, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 15, 42209, 3370, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Frost', 16, 42209, 3594, 3535, 0, 0, 2936, 0),
+    ('DeathKnight', 'Frost', 17, 42621, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 0, 40827, 3795, 3621, 3518, 0, 2787, 0),
+    ('DeathKnight', 'Unholy', 1, 42041, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 2, 40868, 3852, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 4, 40787, 3832, 3518, 3518, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 5, 40883, 0, 3518, 3879, 0, 0, 3729),
+    ('DeathKnight', 'Unholy', 6, 40848, 3823, 3518, 3535, 0, 3357, 0),
+    ('DeathKnight', 'Unholy', 7, 40884, 1597, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 8, 40890, 3845, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 9, 40809, 1603, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 10, 42117, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 12, 46038, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 13, 42134, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 14, 42081, 3243, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Unholy', 15, 42333, 3367, 3518, 3535, 0, 3764, 0),
+    ('DeathKnight', 'Unholy', 17, 42621, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 1, 42043, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 2, 42011, 3794, 3528, 0, 0, 2868, 0),
+    ('Warlock', 'Destruction', 4, 41998, 3245, 3520, 3528, 0, 3307, 0),
+    ('Warlock', 'Destruction', 5, 41899, 0, 3535, 3531, 0, 2872, 3729),
+    ('Warlock', 'Destruction', 6, 42005, 3721, 3520, 3531, 0, 0, 0),
+    ('Warlock', 'Destruction', 7, 49183, 3232, 3563, 0, 0, 2878, 0),
+    ('Warlock', 'Destruction', 8, 41910, 2332, 0, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 9, 42017, 3246, 3535, 0, 0, 2872, 0),
+    ('Warlock', 'Destruction', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 11, 42116, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 12, 47182, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 13, 42132, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 14, 42078, 3243, 0, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 15, 42347, 0, 3866, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 16, 42526, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Destruction', 17, 42503, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 0, 41993, 3796, 3621, 3525, 0, 3821, 0),
+    ('Warlock', 'Affliction', 1, 42043, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 2, 42011, 3794, 3528, 0, 0, 2868, 0),
+    ('Warlock', 'Affliction', 3, 6097, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 4, 41998, 3245, 3520, 3528, 0, 3307, 0),
+    ('Warlock', 'Affliction', 5, 41899, 0, 3535, 3531, 0, 2872, 3729),
+    ('Warlock', 'Affliction', 6, 42005, 3721, 3520, 3531, 0, 0, 0),
+    ('Warlock', 'Affliction', 7, 49183, 3232, 3563, 0, 0, 2878, 0),
+    ('Warlock', 'Affliction', 8, 41910, 2332, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 9, 42017, 3246, 3535, 0, 0, 2872, 0),
+    ('Warlock', 'Affliction', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 11, 42116, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 12, 47182, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 13, 42132, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 14, 42078, 3243, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 15, 42347, 3834, 3866, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 16, 42526, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 17, 42520, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Affliction', 18, 38311, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 0, 41993, 3796, 3621, 3548, 0, 3821, 0),
+    ('Warlock', 'Demonology', 1, 42043, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 4, 41998, 3245, 3520, 3528, 0, 3307, 0),
+    ('Warlock', 'Demonology', 2, 42011, 3794, 3528, 0, 0, 2868, 0),
+    ('Warlock', 'Demonology', 5, 41899, 0, 3535, 3531, 0, 2872, 3729),
+    ('Warlock', 'Demonology', 6, 42005, 3721, 3520, 3531, 0, 0, 0),
+    ('Warlock', 'Demonology', 7, 49183, 3232, 3563, 0, 0, 2878, 0),
+    ('Warlock', 'Demonology', 8, 41910, 2332, 0, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 9, 42017, 3246, 3535, 0, 0, 2872, 0),
+    ('Warlock', 'Demonology', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 11, 42116, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 12, 51377, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 13, 42132, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 14, 42078, 3243, 0, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 15, 42347, 3834, 3866, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 16, 42526, 0, 0, 0, 0, 0, 0),
+    ('Warlock', 'Demonology', 17, 42503, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 1, 42042, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 0, 40826, 3795, 3625, 3525, 0, 2787, 0),
+    ('Warrior', 'Fury', 2, 40866, 3793, 3550, 0, 0, 3263, 0),
+    ('Warrior', 'Fury', 4, 40789, 3832, 3525, 3550, 0, 3600, 0),
+    ('Warrior', 'Fury', 5, 40883, 0, 3525, 3525, 0, 0, 3729),
+    ('Warrior', 'Fury', 6, 40847, 3823, 3525, 3525, 0, 0, 0),
+    ('Warrior', 'Fury', 7, 40884, 1597, 3525, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 8, 40890, 3845, 0, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 9, 40807, 1603, 3525, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 10, 42119, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 11, 42117, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 12, 42136, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 13, 50198, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 14, 42082, 1099, 0, 0, 0, 0, 0),
+    ('Warrior', 'Fury', 15, 42323, 3789, 3525, 3525, 0, 0, 0),
+    ('Warrior', 'Fury', 16, 42323, 3789, 3525, 3525, 0, 0, 0),
+    ('Warrior', 'Fury', 17, 42486, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 0, 40826, 3795, 3625, 3525, 0, 2787, 0),
+    ('Warrior', 'Arms', 1, 42042, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 2, 40866, 3793, 3550, 0, 0, 3263, 0),
+    ('Warrior', 'Arms', 4, 40789, 3832, 3525, 3550, 0, 3600, 0),
+    ('Warrior', 'Arms', 5, 40883, 0, 3525, 3525, 0, 0, 3729),
+    ('Warrior', 'Arms', 7, 40884, 1597, 3525, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 6, 40847, 3823, 3525, 3525, 0, 0, 0),
+    ('Warrior', 'Arms', 8, 40890, 3845, 0, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 9, 40807, 1603, 3525, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 10, 42119, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 11, 42117, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 12, 42136, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 13, 50198, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 14, 42082, 1099, 0, 0, 0, 0, 0),
+    ('Warrior', 'Arms', 15, 42323, 3789, 3525, 3525, 0, 0, 0),
+    ('Warrior', 'Arms', 17, 42486, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 0, 40826, 3795, 3625, 3525, 0, 2787, 0),
+    ('Warrior', 'Protection', 1, 42042, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 2, 40866, 3793, 3550, 0, 0, 3263, 0),
+    ('Warrior', 'Protection', 4, 40789, 3832, 3525, 3550, 0, 3600, 0),
+    ('Warrior', 'Protection', 5, 40883, 0, 3525, 3525, 0, 0, 3729),
+    ('Warrior', 'Protection', 6, 40847, 3823, 3525, 3525, 0, 0, 0),
+    ('Warrior', 'Protection', 7, 40884, 1597, 3525, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 8, 40890, 3845, 0, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 9, 40807, 1603, 3525, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 10, 42119, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 11, 42117, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 12, 42136, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 13, 50198, 0, 0, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 14, 42082, 1099, 0, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 15, 42276, 3789, 3863, 0, 0, 2936, 0),
+    ('Warrior', 'Protection', 16, 42560, 3849, 0, 0, 0, 0, 0),
+    ('Warrior', 'Protection', 17, 42486, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 0, 41672, 3795, 3628, 3521, 0, 3314, 0),
+    ('Rogue', 'Subtlety', 1, 42042, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 2, 41683, 3793, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 4, 41650, 3245, 3521, 3566, 0, 3600, 0),
+    ('Rogue', 'Subtlety', 5, 41833, 0, 3521, 3521, 0, 0, 3729),
+    ('Rogue', 'Subtlety', 6, 41655, 3823, 3521, 3879, 0, 3355, 0),
+    ('Rogue', 'Subtlety', 7, 41837, 1597, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 8, 41841, 3845, 0, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 9, 41767, 1603, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 10, 42117, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 12, 46038, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 13, 42136, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 14, 42082, 1099, 0, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 15, 45958, 3789, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 16, 45962, 3731, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Subtlety', 17, 42451, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 0, 41672, 3795, 3628, 3521, 0, 3314, 0),
+    ('Rogue', 'Combat', 1, 42042, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 2, 41683, 3793, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 4, 41650, 3245, 3521, 3566, 0, 3600, 0),
+    ('Rogue', 'Combat', 5, 41833, 0, 3521, 3521, 0, 0, 3729),
+    ('Rogue', 'Combat', 6, 41655, 3823, 3521, 3879, 0, 3355, 0),
+    ('Rogue', 'Combat', 7, 41837, 1597, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 8, 41841, 3845, 0, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 9, 41767, 1603, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 10, 42117, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 12, 46038, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 13, 42136, 0, 0, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 14, 42082, 1099, 0, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 15, 42276, 3789, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 16, 42281, 3731, 3521, 0, 0, 0, 0),
+    ('Rogue', 'Combat', 17, 42451, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 0, 40827, 3795, 3621, 3518, 0, 2787, 0),
+    ('DeathKnight', 'Blood', 1, 42041, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 2, 40868, 3852, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 4, 40787, 3832, 3518, 3518, 0, 0, 0),
+    ('DeathKnight', 'Blood', 5, 40883, 0, 3518, 3879, 0, 0, 3729),
+    ('DeathKnight', 'Blood', 6, 40848, 3823, 3518, 3535, 0, 3357, 0),
+    ('DeathKnight', 'Blood', 7, 40884, 1597, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 8, 40890, 3845, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 9, 40809, 1603, 3518, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 10, 42117, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 11, 42119, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 12, 46038, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 13, 42134, 0, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 14, 42081, 3243, 0, 0, 0, 0, 0),
+    ('DeathKnight', 'Blood', 15, 42333, 3366, 3518, 3535, 0, 3764, 0),
+    ('DeathKnight', 'Blood', 17, 42621, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Shadow', 0, 41854, 3796, 3621, 3520, 0, 3352, 0),
+    ('Priest', 'Shadow', 1, 42045, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Shadow', 2, 41934, 3794, 3563, 0, 0, 2868, 0),
+    ('Priest', 'Shadow', 4, 41921, 3832, 3563, 3563, 0, 3307, 0),
+    ('Priest', 'Shadow', 5, 49179, 0, 3590, 3590, 0, 2872, 3729),
+    ('Priest', 'Shadow', 6, 41927, 3721, 3520, 3590, 0, 2770, 0),
+    ('Priest', 'Shadow', 7, 49183, 3232, 3563, 0, 0, 2878, 0),
+    ('Priest', 'Shadow', 8, 49181, 2332, 0, 0, 0, 0, 0),
+    ('Priest', 'Shadow', 9, 41940, 3246, 3590, 0, 0, 3752, 0),
+    ('Priest', 'Shadow', 10, 42118, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Shadow', 11, 47732, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Shadow', 12, 45518, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Shadow', 13, 42137, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Shadow', 14, 42077, 3243, 0, 0, 0, 0, 0),
+    ('Priest', 'Shadow', 15, 42347, 3834, 3590, 0, 0, 3752, 0),
+    ('Priest', 'Shadow', 16, 42526, 0, 0, 0, 0, 0, 0),
+    ('Priest', 'Shadow', 17, 42520, 0, 0, 0, 0, 0, 0);
+/*!40000 ALTER TABLE `template_npc_human` ENABLE KEYS */;
+
+
+-- Dumping structure for table characters_dev.template_npc_talents
+CREATE TABLE IF NOT EXISTS `template_npc_talents` (
+  `playerClass` varchar(50) NOT NULL,
+  `playerSpec` varchar(50) NOT NULL,
+  `talentId` int(10) unsigned NOT NULL DEFAULT '0'
+) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='Templates';
+
+-- Dumping data for table characters_dev.template_npc_talents: ~839 rows (approximately)
+/*!40000 ALTER TABLE `template_npc_talents` DISABLE KEYS */;
+INSERT INTO `template_npc_talents` (`playerClass`, `playerSpec`, `talentId`) VALUES
+    ('Rogue', 'Assassination', 1329),
+    ('Rogue', 'Assassination', 13848),
+    ('Rogue', 'Assassination', 13866),
+    ('Rogue', 'Assassination', 13971),
+    ('Rogue', 'Assassination', 13980),
+    ('Rogue', 'Assassination', 14066),
+    ('Rogue', 'Assassination', 14072),
+    ('Rogue', 'Assassination', 14083),
+    ('Rogue', 'Assassination', 14094),
+    ('Rogue', 'Assassination', 14116),
+    ('Rogue', 'Assassination', 14135),
+    ('Rogue', 'Assassination', 14142),
+    ('Rogue', 'Assassination', 14159),
+    ('Rogue', 'Assassination', 14161),
+    ('Rogue', 'Assassination', 14173),
+    ('Rogue', 'Assassination', 14177),
+    ('Rogue', 'Assassination', 14185),
+    ('Rogue', 'Assassination', 14195),
+    ('Rogue', 'Assassination', 14983),
+    ('Rogue', 'Assassination', 16515),
+    ('Rogue', 'Assassination', 30895),
+    ('Rogue', 'Assassination', 31209),
+    ('Rogue', 'Assassination', 31245),
+    ('Rogue', 'Assassination', 51626),
+    ('Rogue', 'Assassination', 51636),
+    ('Rogue', 'Assassination', 58410),
+    ('Rogue', 'Assassination', 58425),
+    ('Rogue', 'Assassination', 58426),
+    ('Druid', 'Feral', 16835),
+    ('Druid', 'Feral', 16864),
+    ('Druid', 'Feral', 16931),
+    ('Druid', 'Feral', 16938),
+    ('Druid', 'Feral', 16941),
+    ('Druid', 'Feral', 16944),
+    ('Druid', 'Feral', 16949),
+    ('Druid', 'Feral', 16968),
+    ('Druid', 'Feral', 16975),
+    ('Druid', 'Feral', 16999),
+    ('Druid', 'Feral', 17007),
+    ('Druid', 'Feral', 17061),
+    ('Druid', 'Feral', 17071),
+    ('Druid', 'Feral', 24866),
+    ('Druid', 'Feral', 24894),
+    ('Druid', 'Feral', 33851),
+    ('Druid', 'Feral', 33856),
+    ('Druid', 'Feral', 33873),
+    ('Druid', 'Feral', 33867),
+    ('Druid', 'Feral', 33917),
+    ('Druid', 'Feral', 37116),
+    ('Druid', 'Feral', 48412),
+    ('Druid', 'Feral', 48485),
+    ('Druid', 'Feral', 48495),
+    ('Druid', 'Feral', 49377),
+    ('Druid', 'Feral', 50334),
+    ('Druid', 'Feral', 51269),
+    ('Druid', 'Feral', 61336),
+    ('Druid', 'Feral', 63503),
+    ('Druid', 'Ballance', 5570),
+    ('Druid', 'Ballance', 16818),
+    ('Druid', 'Ballance', 16820),
+    ('Druid', 'Ballance', 16835),
+    ('Druid', 'Ballance', 16840),
+    ('Druid', 'Ballance', 16847),
+    ('Druid', 'Ballance', 16864),
+    ('Druid', 'Ballance', 16899),
+    ('Druid', 'Ballance', 16913),
+    ('Druid', 'Ballance', 17051),
+    ('Druid', 'Ballance', 17066),
+    ('Druid', 'Ballance', 17119),
+    ('Druid', 'Ballance', 24858),
+    ('Druid', 'Ballance', 33591),
+    ('Druid', 'Ballance', 33596),
+    ('Druid', 'Ballance', 33606),
+    ('Druid', 'Ballance', 33956),
+    ('Druid', 'Ballance', 33831),
+    ('Druid', 'Ballance', 35364),
+    ('Druid', 'Ballance', 48393),
+    ('Druid', 'Ballance', 48396),
+    ('Druid', 'Ballance', 48412),
+    ('Druid', 'Ballance', 48505),
+    ('Druid', 'Ballance', 48511),
+    ('Druid', 'Ballance', 48514),
+    ('Druid', 'Ballance', 48525),
+    ('Druid', 'Ballance', 50516),
+    ('Druid', 'Ballance', 57865),
+    ('Druid', 'Ballance', 61346),
+    ('Priest', 'Holy', 14767),
+    ('Priest', 'Holy', 14771),
+    ('Priest', 'Holy', 14777),
+    ('Priest', 'Holy', 14791),
+    ('Priest', 'Holy', 15011),
+    ('Priest', 'Holy', 15014),
+    ('Priest', 'Holy', 15018),
+    ('Priest', 'Holy', 15031),
+    ('Priest', 'Holy', 15356),
+    ('Priest', 'Holy', 15362),
+    ('Priest', 'Holy', 17191),
+    ('Priest', 'Holy', 19236),
+    ('Priest', 'Holy', 20711),
+    ('Priest', 'Holy', 27790),
+    ('Priest', 'Holy', 27904),
+    ('Priest', 'Holy', 33142),
+    ('Priest', 'Holy', 33154),
+    ('Priest', 'Holy', 33162),
+    ('Priest', 'Holy', 34860),
+    ('Priest', 'Holy', 34861),
+    ('Priest', 'Holy', 47567),
+    ('Priest', 'Holy', 47788),
+    ('Priest', 'Holy', 63543),
+    ('Priest', 'Holy', 63737),
+    ('Mage', 'Arcane', 12042),
+    ('Mage', 'Arcane', 12043),
+    ('Mage', 'Arcane', 12469),
+    ('Mage', 'Arcane', 12472),
+    ('Mage', 'Arcane', 12496),
+    ('Mage', 'Arcane', 12503),
+    ('Mage', 'Arcane', 12577),
+    ('Mage', 'Arcane', 12592),
+    ('Mage', 'Arcane', 12598),
+    ('Mage', 'Arcane', 12672),
+    ('Mage', 'Arcane', 12840),
+    ('Mage', 'Arcane', 15060),
+    ('Mage', 'Arcane', 18459),
+    ('Mage', 'Arcane', 18464),
+    ('Mage', 'Arcane', 29440),
+    ('Mage', 'Arcane', 31572),
+    ('Mage', 'Arcane', 31583),
+    ('Mage', 'Arcane', 31588),
+    ('Mage', 'Arcane', 31589),
+    ('Mage', 'Arcane', 35581),
+    ('Mage', 'Arcane', 44379),
+    ('Mage', 'Arcane', 44399),
+    ('Mage', 'Arcane', 44403),
+    ('Mage', 'Arcane', 44425),
+    ('Mage', 'Arcane', 54490),
+    ('Mage', 'Arcane', 54646),
+    ('Mage', 'Arcane', 55094),
+    ('Mage', 'Arcane', 55340),
+    ('Mage', 'Fire', 11080),
+    ('Mage', 'Fire', 11113),
+    ('Mage', 'Fire', 11129),
+    ('Mage', 'Fire', 11247),
+    ('Mage', 'Fire', 11255),
+    ('Mage', 'Fire', 11366),
+    ('Mage', 'Fire', 11368),
+    ('Mage', 'Fire', 12350),
+    ('Mage', 'Fire', 12353),
+    ('Mage', 'Fire', 12358),
+    ('Mage', 'Fire', 12399),
+    ('Mage', 'Fire', 12469),
+    ('Mage', 'Fire', 12592),
+    ('Mage', 'Fire', 12840),
+    ('Mage', 'Fire', 12848),
+    ('Mage', 'Fire', 12873),
+    ('Mage', 'Fire', 13043),
+    ('Mage', 'Fire', 29444),
+    ('Mage', 'Fire', 31642),
+    ('Mage', 'Fire', 31658),
+    ('Mage', 'Fire', 31661),
+    ('Mage', 'Fire', 31680),
+    ('Mage', 'Fire', 34296),
+    ('Mage', 'Fire', 44448),
+    ('Mage', 'Fire', 44457),
+    ('Mage', 'Fire', 44472),
+    ('Mage', 'Fire', 54646),
+    ('Mage', 'Fire', 54659),
+    ('Mage', 'Fire', 54734),
+    ('Mage', 'Fire', 64357),
+    ('Paladin', 'Retribution', 20045),
+    ('Paladin', 'Retribution', 20057),
+    ('Paladin', 'Retribution', 20066),
+    ('Paladin', 'Retribution', 20105),
+    ('Paladin', 'Retribution', 20113),
+    ('Paladin', 'Retribution', 20121),
+    ('Paladin', 'Retribution', 20175),
+    ('Paladin', 'Retribution', 20266),
+    ('Paladin', 'Retribution', 20332),
+    ('Paladin', 'Retribution', 20337),
+    ('Paladin', 'Retribution', 20375),
+    ('Paladin', 'Retribution', 25836),
+    ('Paladin', 'Retribution', 25957),
+    ('Paladin', 'Retribution', 26023),
+    ('Paladin', 'Retribution', 31868),
+    ('Paladin', 'Retribution', 31869),
+    ('Paladin', 'Retribution', 31872),
+    ('Paladin', 'Retribution', 31878),
+    ('Paladin', 'Retribution', 31881),
+    ('Paladin', 'Retribution', 35395),
+    ('Paladin', 'Retribution', 35397),
+    ('Paladin', 'Retribution', 53376),
+    ('Paladin', 'Retribution', 53382),
+    ('Paladin', 'Retribution', 53385),
+    ('Paladin', 'Retribution', 53488),
+    ('Paladin', 'Retribution', 53503),
+    ('Paladin', 'Retribution', 53519),
+    ('Paladin', 'Protection', 20105),
+    ('Paladin', 'Protection', 20121),
+    ('Paladin', 'Protection', 20135),
+    ('Paladin', 'Protection', 20140),
+    ('Paladin', 'Protection', 20175),
+    ('Paladin', 'Protection', 20179),
+    ('Paladin', 'Protection', 20198),
+    ('Paladin', 'Protection', 20266),
+    ('Paladin', 'Protection', 20337),
+    ('Paladin', 'Protection', 20470),
+    ('Paladin', 'Protection', 20488),
+    ('Paladin', 'Protection', 20911),
+    ('Paladin', 'Protection', 20925),
+    ('Paladin', 'Protection', 25957),
+    ('Paladin', 'Protection', 31849),
+    ('Paladin', 'Protection', 31852),
+    ('Paladin', 'Protection', 31860),
+    ('Paladin', 'Protection', 31867),
+    ('Paladin', 'Protection', 31935),
+    ('Paladin', 'Protection', 33776),
+    ('Paladin', 'Protection', 53519),
+    ('Paladin', 'Protection', 53530),
+    ('Paladin', 'Protection', 53592),
+    ('Paladin', 'Protection', 53585),
+    ('Paladin', 'Protection', 53595),
+    ('Paladin', 'Protection', 53696),
+    ('Paladin', 'Protection', 53711),
+    ('Paladin', 'Protection', 63646),
+    ('Paladin', 'Protection', 64205),
+    ('Shaman', 'Elemental', 16041),
+    ('Shaman', 'Elemental', 16108),
+    ('Shaman', 'Elemental', 16130),
+    ('Shaman', 'Elemental', 16161),
+    ('Shaman', 'Elemental', 16164),
+    ('Shaman', 'Elemental', 16166),
+    ('Shaman', 'Elemental', 16287),
+    ('Shaman', 'Elemental', 16305),
+    ('Shaman', 'Elemental', 16582),
+    ('Shaman', 'Elemental', 17487),
+    ('Shaman', 'Elemental', 28998),
+    ('Shaman', 'Elemental', 29000),
+    ('Shaman', 'Elemental', 29065),
+    ('Shaman', 'Elemental', 29080),
+    ('Shaman', 'Elemental', 30666),
+    ('Shaman', 'Elemental', 30679),
+    ('Shaman', 'Elemental', 30706),
+    ('Shaman', 'Elemental', 43338),
+    ('Shaman', 'Elemental', 51470),
+    ('Shaman', 'Elemental', 51479),
+    ('Shaman', 'Elemental', 51482),
+    ('Shaman', 'Elemental', 51486),
+    ('Shaman', 'Elemental', 51490),
+    ('Shaman', 'Elemental', 60188),
+    ('Shaman', 'Elemental', 62101),
+    ('Shaman', 'Elemental', 63372),
+    ('Shaman', 'Enhancement', 16112),
+    ('Shaman', 'Enhancement', 16130),
+    ('Shaman', 'Enhancement', 16164),
+    ('Shaman', 'Enhancement', 16268),
+    ('Shaman', 'Enhancement', 16284),
+    ('Shaman', 'Enhancement', 16272),
+    ('Shaman', 'Enhancement', 16287),
+    ('Shaman', 'Enhancement', 16305),
+    ('Shaman', 'Enhancement', 16306),
+    ('Shaman', 'Enhancement', 17364),
+    ('Shaman', 'Enhancement', 17489),
+    ('Shaman', 'Enhancement', 28998),
+    ('Shaman', 'Enhancement', 29080),
+    ('Shaman', 'Enhancement', 29086),
+    ('Shaman', 'Enhancement', 29179),
+    ('Shaman', 'Enhancement', 30798),
+    ('Shaman', 'Enhancement', 30809),
+    ('Shaman', 'Enhancement', 30814),
+    ('Shaman', 'Enhancement', 30823),
+    ('Shaman', 'Enhancement', 43338),
+    ('Shaman', 'Enhancement', 51522),
+    ('Shaman', 'Enhancement', 51524),
+    ('Shaman', 'Enhancement', 51532),
+    ('Shaman', 'Enhancement', 51533),
+    ('Shaman', 'Enhancement', 51881),
+    ('Shaman', 'Enhancement', 51885),
+    ('Shaman', 'Enhancement', 60103),
+    ('Shaman', 'Enhancement', 63374),
+    ('Shaman', 'Restoration', 974),
+    ('Shaman', 'Restoration', 16130),
+    ('Shaman', 'Restoration', 16188),
+    ('Shaman', 'Restoration', 16190),
+    ('Shaman', 'Restoration', 16198),
+    ('Shaman', 'Restoration', 16206),
+    ('Shaman', 'Restoration', 16213),
+    ('Shaman', 'Restoration', 16214),
+    ('Shaman', 'Restoration', 16229),
+    ('Shaman', 'Restoration', 16232),
+    ('Shaman', 'Restoration', 16240),
+    ('Shaman', 'Restoration', 16287),
+    ('Shaman', 'Restoration', 16293),
+    ('Shaman', 'Restoration', 17487),
+    ('Shaman', 'Restoration', 29191),
+    ('Shaman', 'Restoration', 29202),
+    ('Shaman', 'Restoration', 30866),
+    ('Shaman', 'Restoration', 30869),
+    ('Shaman', 'Restoration', 30886),
+    ('Shaman', 'Restoration', 51555),
+    ('Shaman', 'Restoration', 51558),
+    ('Shaman', 'Restoration', 51561),
+    ('Shaman', 'Restoration', 51566),
+    ('Shaman', 'Restoration', 51881),
+    ('Shaman', 'Restoration', 51886),
+    ('Shaman', 'Restoration', 55198),
+    ('Shaman', 'Restoration', 61295),
+    ('Priest', 'Discipline', 10060),
+    ('Priest', 'Discipline', 14751),
+    ('Priest', 'Discipline', 14767),
+    ('Priest', 'Discipline', 14769),
+    ('Priest', 'Discipline', 14771),
+    ('Priest', 'Discipline', 14777),
+    ('Priest', 'Discipline', 14781),
+    ('Priest', 'Discipline', 14791),
+    ('Priest', 'Discipline', 15009),
+    ('Priest', 'Discipline', 15012),
+    ('Priest', 'Discipline', 15363),
+    ('Priest', 'Discipline', 18555),
+    ('Priest', 'Discipline', 19236),
+    ('Priest', 'Discipline', 27815),
+    ('Priest', 'Discipline', 27904),
+    ('Priest', 'Discipline', 33190),
+    ('Priest', 'Discipline', 33202),
+    ('Priest', 'Discipline', 33206),
+    ('Priest', 'Discipline', 34910),
+    ('Priest', 'Discipline', 45244),
+    ('Priest', 'Discipline', 47508),
+    ('Priest', 'Discipline', 47515),
+    ('Priest', 'Discipline', 47516),
+    ('Priest', 'Discipline', 47537),
+    ('Priest', 'Discipline', 47540),
+    ('Priest', 'Discipline', 52800),
+    ('Priest', 'Discipline', 57472),
+    ('Priest', 'Discipline', 63574),
+    ('Druid', 'Restoration', 16820),
+    ('Druid', 'Restoration', 16835),
+    ('Druid', 'Restoration', 16836),
+    ('Druid', 'Restoration', 16847),
+    ('Druid', 'Restoration', 16850),
+    ('Druid', 'Restoration', 16864),
+    ('Druid', 'Restoration', 17051),
+    ('Druid', 'Restoration', 17066),
+    ('Druid', 'Restoration', 17076),
+    ('Druid', 'Restoration', 17108),
+    ('Druid', 'Restoration', 17113),
+    ('Druid', 'Restoration', 17116),
+    ('Druid', 'Restoration', 17120),
+    ('Druid', 'Restoration', 24946),
+    ('Druid', 'Restoration', 33880),
+    ('Druid', 'Restoration', 33883),
+    ('Druid', 'Restoration', 33890),
+    ('Druid', 'Restoration', 34153),
+    ('Druid', 'Restoration', 35364),
+    ('Druid', 'Restoration', 48412),
+    ('Druid', 'Restoration', 48438),
+    ('Druid', 'Restoration', 48537),
+    ('Druid', 'Restoration', 51183),
+    ('Druid', 'Restoration', 57814),
+    ('Druid', 'Restoration', 57865),
+    ('Druid', 'Restoration', 61345),
+    ('Druid', 'Restoration', 63411),
+    ('Druid', 'Restoration', 65139),
+    ('Hunter', 'Beastmastery', 19421),
+    ('Hunter', 'Beastmastery', 19431),
+    ('Hunter', 'Beastmastery', 19434),
+    ('Hunter', 'Beastmastery', 19456),
+    ('Hunter', 'Beastmastery', 19490),
+    ('Hunter', 'Beastmastery', 19575),
+    ('Hunter', 'Beastmastery', 19574),
+    ('Hunter', 'Beastmastery', 19577),
+    ('Hunter', 'Beastmastery', 19587),
+    ('Hunter', 'Beastmastery', 19592),
+    ('Hunter', 'Beastmastery', 19602),
+    ('Hunter', 'Beastmastery', 19609),
+    ('Hunter', 'Beastmastery', 19620),
+    ('Hunter', 'Beastmastery', 19623),
+    ('Hunter', 'Beastmastery', 20895),
+    ('Hunter', 'Beastmastery', 34454),
+    ('Hunter', 'Beastmastery', 34460),
+    ('Hunter', 'Beastmastery', 34470),
+    ('Hunter', 'Beastmastery', 34484),
+    ('Hunter', 'Beastmastery', 34692),
+    ('Hunter', 'Beastmastery', 35030),
+    ('Hunter', 'Beastmastery', 53260),
+    ('Hunter', 'Beastmastery', 53264),
+    ('Hunter', 'Beastmastery', 53265),
+    ('Hunter', 'Beastmastery', 53270),
+    ('Hunter', 'Beastmastery', 56318),
+    ('Hunter', 'Survival', 3674),
+    ('Hunter', 'Survival', 19259),
+    ('Hunter', 'Survival', 19287),
+    ('Hunter', 'Survival', 19373),
+    ('Hunter', 'Survival', 19386),
+    ('Hunter', 'Survival', 19388),
+    ('Hunter', 'Survival', 19431),
+    ('Hunter', 'Survival', 19434),
+    ('Hunter', 'Survival', 19490),
+    ('Hunter', 'Survival', 19500),
+    ('Hunter', 'Survival', 19503),
+    ('Hunter', 'Survival', 19553),
+    ('Hunter', 'Survival', 24297),
+    ('Hunter', 'Survival', 34484),
+    ('Hunter', 'Survival', 34496),
+    ('Hunter', 'Survival', 34499),
+    ('Hunter', 'Survival', 34503),
+    ('Hunter', 'Survival', 34839),
+    ('Hunter', 'Survival', 52785),
+    ('Hunter', 'Survival', 53292),
+    ('Hunter', 'Survival', 53301),
+    ('Hunter', 'Survival', 56337),
+    ('Hunter', 'Survival', 56341),
+    ('Hunter', 'Survival', 56344),
+    ('Hunter', 'Survival', 63458),
+    ('Paladin', 'Holy', 20143),
+    ('Paladin', 'Holy', 20175),
+    ('Paladin', 'Holy', 20208),
+    ('Paladin', 'Holy', 20215),
+    ('Paladin', 'Holy', 20216),
+    ('Paladin', 'Holy', 20239),
+    ('Paladin', 'Holy', 20256),
+    ('Paladin', 'Holy', 20261),
+    ('Paladin', 'Holy', 20361),
+    ('Paladin', 'Holy', 20470),
+    ('Paladin', 'Holy', 20473),
+    ('Paladin', 'Holy', 20488),
+    ('Paladin', 'Holy', 25829),
+    ('Paladin', 'Holy', 25836),
+    ('Paladin', 'Holy', 31821),
+    ('Paladin', 'Holy', 31825),
+    ('Paladin', 'Holy', 31840),
+    ('Paladin', 'Holy', 31842),
+    ('Paladin', 'Holy', 53519),
+    ('Paladin', 'Holy', 53530),
+    ('Paladin', 'Holy', 53553),
+    ('Paladin', 'Holy', 53557),
+    ('Paladin', 'Holy', 53563),
+    ('Paladin', 'Holy', 53576),
+    ('Paladin', 'Holy', 54154),
+    ('Paladin', 'Holy', 63650),
+    ('Paladin', 'Holy', 64205),
+    ('Mage', 'Frost', 11426),
+    ('Mage', 'Frost', 11958),
+    ('Mage', 'Frost', 12467),
+    ('Mage', 'Frost', 12472),
+    ('Mage', 'Frost', 12497),
+    ('Mage', 'Frost', 12571),
+    ('Mage', 'Frost', 12592),
+    ('Mage', 'Frost', 12598),
+    ('Mage', 'Frost', 12606),
+    ('Mage', 'Frost', 12840),
+    ('Mage', 'Frost', 12952),
+    ('Mage', 'Frost', 12983),
+    ('Mage', 'Frost', 15047),
+    ('Mage', 'Frost', 16758),
+    ('Mage', 'Frost', 16766),
+    ('Mage', 'Frost', 28332),
+    ('Mage', 'Frost', 28593),
+    ('Mage', 'Frost', 29444),
+    ('Mage', 'Frost', 31683),
+    ('Mage', 'Frost', 31687),
+    ('Mage', 'Frost', 44545),
+    ('Mage', 'Frost', 44549),
+    ('Mage', 'Frost', 44557),
+    ('Mage', 'Frost', 44571),
+    ('Mage', 'Frost', 44572),
+    ('Mage', 'Frost', 54646),
+    ('Mage', 'Frost', 54659),
+    ('Mage', 'Frost', 54787),
+    ('Mage', 'Frost', 55092),
+    ('Mage', 'Frost', 55094),
+    ('Mage', 'Frost', 55340),
+    ('Warlock', 'Destruction', 17792),
+    ('Warlock', 'Destruction', 17834),
+    ('Warlock', 'Destruction', 17877),
+    ('Warlock', 'Destruction', 17918),
+    ('Warlock', 'Destruction', 17958),
+    ('Warlock', 'Destruction', 17962),
+    ('Warlock', 'Destruction', 18120),
+    ('Warlock', 'Destruction', 18130),
+    ('Warlock', 'Destruction', 18136),
+    ('Warlock', 'Destruction', 18699),
+    ('Warlock', 'Destruction', 18704),
+    ('Warlock', 'Destruction', 18708),
+    ('Warlock', 'Destruction', 18710),
+    ('Warlock', 'Destruction', 18744),
+    ('Warlock', 'Destruction', 18756),
+    ('Warlock', 'Destruction', 19028),
+    ('Warlock', 'Destruction', 30145),
+    ('Warlock', 'Destruction', 30283),
+    ('Warlock', 'Destruction', 30292),
+    ('Warlock', 'Destruction', 30302),
+    ('Warlock', 'Destruction', 34939),
+    ('Warlock', 'Destruction', 47231),
+    ('Warlock', 'Destruction', 47260),
+    ('Warlock', 'Destruction', 47270),
+    ('Warlock', 'Destruction', 50796),
+    ('Warlock', 'Destruction', 59741),
+    ('Warlock', 'Destruction', 63351),
+    ('Warlock', 'Affliction', 17785),
+    ('Warlock', 'Affliction', 17805),
+    ('Warlock', 'Affliction', 17814),
+    ('Warlock', 'Affliction', 18095),
+    ('Warlock', 'Affliction', 18176),
+    ('Warlock', 'Affliction', 18180),
+    ('Warlock', 'Affliction', 18219),
+    ('Warlock', 'Affliction', 18223),
+    ('Warlock', 'Affliction', 18275),
+    ('Warlock', 'Affliction', 18288),
+    ('Warlock', 'Affliction', 18699),
+    ('Warlock', 'Affliction', 18704),
+    ('Warlock', 'Affliction', 18708),
+    ('Warlock', 'Affliction', 18744),
+    ('Warlock', 'Affliction', 19028),
+    ('Warlock', 'Affliction', 30057),
+    ('Warlock', 'Affliction', 30064),
+    ('Warlock', 'Affliction', 30108),
+    ('Warlock', 'Affliction', 30143),
+    ('Warlock', 'Affliction', 32383),
+    ('Warlock', 'Affliction', 32394),
+    ('Warlock', 'Affliction', 32484),
+    ('Warlock', 'Affliction', 47200),
+    ('Warlock', 'Affliction', 47205),
+    ('Warlock', 'Affliction', 47231),
+    ('Warlock', 'Affliction', 48181),
+    ('Warlock', 'Affliction', 53759),
+    ('Warlock', 'Affliction', 58435),
+    ('Warlock', 'Affliction', 63108),
+    ('Warlock', 'Demonology', 17791),
+    ('Warlock', 'Demonology', 17803),
+    ('Warlock', 'Demonology', 17877),
+    ('Warlock', 'Demonology', 17959),
+    ('Warlock', 'Demonology', 18693),
+    ('Warlock', 'Demonology', 18699),
+    ('Warlock', 'Demonology', 18708),
+    ('Warlock', 'Demonology', 18707),
+    ('Warlock', 'Demonology', 18710),
+    ('Warlock', 'Demonology', 18744),
+    ('Warlock', 'Demonology', 18756),
+    ('Warlock', 'Demonology', 18768),
+    ('Warlock', 'Demonology', 18773),
+    ('Warlock', 'Demonology', 19028),
+    ('Warlock', 'Demonology', 23785),
+    ('Warlock', 'Demonology', 30145),
+    ('Warlock', 'Demonology', 30146),
+    ('Warlock', 'Demonology', 30321),
+    ('Warlock', 'Demonology', 30248),
+    ('Warlock', 'Demonology', 35693),
+    ('Warlock', 'Demonology', 47231),
+    ('Warlock', 'Demonology', 47240),
+    ('Warlock', 'Demonology', 47247),
+    ('Warlock', 'Demonology', 59672),
+    ('Warlock', 'Demonology', 63123),
+    ('Warlock', 'Demonology', 63158),
+    ('Warlock', 'Demonology', 63351),
+    ('DeathKnight', 'Unholy', 49036),
+    ('DeathKnight', 'Unholy', 49039),
+    ('DeathKnight', 'Unholy', 49158),
+    ('DeathKnight', 'Unholy', 49194),
+    ('DeathKnight', 'Unholy', 49206),
+    ('DeathKnight', 'Unholy', 49222),
+    ('DeathKnight', 'Unholy', 49565),
+    ('DeathKnight', 'Unholy', 49568),
+    ('DeathKnight', 'Unholy', 49572),
+    ('DeathKnight', 'Unholy', 49589),
+    ('DeathKnight', 'Unholy', 49599),
+    ('DeathKnight', 'Unholy', 49611),
+    ('DeathKnight', 'Unholy', 49632),
+    ('DeathKnight', 'Unholy', 49638),
+    ('DeathKnight', 'Unholy', 49657),
+    ('DeathKnight', 'Unholy', 49664),
+    ('DeathKnight', 'Unholy', 50121),
+    ('DeathKnight', 'Unholy', 50147),
+    ('DeathKnight', 'Unholy', 50392),
+    ('DeathKnight', 'Unholy', 50886),
+    ('DeathKnight', 'Unholy', 51052),
+    ('DeathKnight', 'Unholy', 51161),
+    ('DeathKnight', 'Unholy', 51456),
+    ('DeathKnight', 'Unholy', 51746),
+    ('DeathKnight', 'Unholy', 52143),
+    ('DeathKnight', 'Unholy', 55090),
+    ('DeathKnight', 'Unholy', 55237),
+    ('DeathKnight', 'Unholy', 55623),
+    ('DeathKnight', 'Unholy', 55667),
+    ('DeathKnight', 'Unholy', 56835),
+    ('Warrior', 'Arms', 12294),
+    ('Warrior', 'Arms', 12323),
+    ('Warrior', 'Arms', 12328),
+    ('Warrior', 'Arms', 12658),
+    ('Warrior', 'Arms', 12677),
+    ('Warrior', 'Arms', 12704),
+    ('Warrior', 'Arms', 12712),
+    ('Warrior', 'Arms', 12835),
+    ('Warrior', 'Arms', 12856),
+    ('Warrior', 'Arms', 12867),
+    ('Warrior', 'Arms', 12960),
+    ('Warrior', 'Arms', 12963),
+    ('Warrior', 'Arms', 16464),
+    ('Warrior', 'Arms', 16492),
+    ('Warrior', 'Arms', 16494),
+    ('Warrior', 'Arms', 20505),
+    ('Warrior', 'Arms', 29623),
+    ('Warrior', 'Arms', 29724),
+    ('Warrior', 'Arms', 29838),
+    ('Warrior', 'Arms', 29859),
+    ('Warrior', 'Arms', 35449),
+    ('Warrior', 'Arms', 46855),
+    ('Warrior', 'Arms', 46860),
+    ('Warrior', 'Arms', 46866),
+    ('Warrior', 'Arms', 46924),
+    ('Warrior', 'Arms', 56614),
+    ('Warrior', 'Arms', 56638),
+    ('Warrior', 'Arms', 61222),
+    ('Warrior', 'Arms', 64976),
+    ('Warrior', 'Protection', 12658),
+    ('Warrior', 'Protection', 12697),
+    ('Warrior', 'Protection', 12727),
+    ('Warrior', 'Protection', 12764),
+    ('Warrior', 'Protection', 12799),
+    ('Warrior', 'Protection', 12803),
+    ('Warrior', 'Protection', 12804),
+    ('Warrior', 'Protection', 12809),
+    ('Warrior', 'Protection', 12818),
+    ('Warrior', 'Protection', 12867),
+    ('Warrior', 'Protection', 12958),
+    ('Warrior', 'Protection', 12960),
+    ('Warrior', 'Protection', 12975),
+    ('Warrior', 'Protection', 16464),
+    ('Warrior', 'Protection', 16494),
+    ('Warrior', 'Protection', 16542),
+    ('Warrior', 'Protection', 20243),
+    ('Warrior', 'Protection', 29144),
+    ('Warrior', 'Protection', 29594),
+    ('Warrior', 'Protection', 29599),
+    ('Warrior', 'Protection', 29792),
+    ('Warrior', 'Protection', 46968),
+    ('Warrior', 'Protection', 46953),
+    ('Warrior', 'Protection', 47296),
+    ('Warrior', 'Protection', 50687),
+    ('Warrior', 'Protection', 57499),
+    ('Warrior', 'Protection', 58874),
+    ('Warrior', 'Protection', 61222),
+    ('Warrior', 'Protection', 59089),
+    ('Warrior', 'Fury', 12292),
+    ('Warrior', 'Fury', 12318),
+    ('Warrior', 'Fury', 12323),
+    ('Warrior', 'Fury', 12664),
+    ('Warrior', 'Fury', 12676),
+    ('Warrior', 'Fury', 12835),
+    ('Warrior', 'Fury', 12856),
+    ('Warrior', 'Fury', 12960),
+    ('Warrior', 'Fury', 12974),
+    ('Warrior', 'Fury', 13048),
+    ('Warrior', 'Fury', 16463),
+    ('Warrior', 'Fury', 16492),
+    ('Warrior', 'Fury', 20501),
+    ('Warrior', 'Fury', 20503),
+    ('Warrior', 'Fury', 23588),
+    ('Warrior', 'Fury', 23881),
+    ('Warrior', 'Fury', 29763),
+    ('Warrior', 'Fury', 29776),
+    ('Warrior', 'Fury', 29801),
+    ('Warrior', 'Fury', 29889),
+    ('Warrior', 'Fury', 46911),
+    ('Warrior', 'Fury', 46915),
+    ('Warrior', 'Fury', 46917),
+    ('Warrior', 'Fury', 56924),
+    ('Warrior', 'Fury', 56932),
+    ('Warrior', 'Fury', 60970),
+    ('Warrior', 'Fury', 61222),
+    ('Rogue', 'Subtlety', 13866),
+    ('Rogue', 'Subtlety', 13971),
+    ('Rogue', 'Subtlety', 13976),
+    ('Rogue', 'Subtlety', 14063),
+    ('Rogue', 'Subtlety', 14066),
+    ('Rogue', 'Subtlety', 14072),
+    ('Rogue', 'Subtlety', 14080),
+    ('Rogue', 'Subtlety', 14083),
+    ('Rogue', 'Subtlety', 14094),
+    ('Rogue', 'Subtlety', 14132),
+    ('Rogue', 'Subtlety', 14142),
+    ('Rogue', 'Subtlety', 14160),
+    ('Rogue', 'Subtlety', 14164),
+    ('Rogue', 'Subtlety', 14173),
+    ('Rogue', 'Subtlety', 14183),
+    ('Rogue', 'Subtlety', 14185),
+    ('Rogue', 'Subtlety', 14983),
+    ('Rogue', 'Subtlety', 16511),
+    ('Rogue', 'Subtlety', 30895),
+    ('Rogue', 'Subtlety', 30906),
+    ('Rogue', 'Subtlety', 31220),
+    ('Rogue', 'Subtlety', 31223),
+    ('Rogue', 'Subtlety', 36554),
+    ('Rogue', 'Subtlety', 51696),
+    ('Rogue', 'Subtlety', 51701),
+    ('Rogue', 'Subtlety', 51712),
+    ('Rogue', 'Subtlety', 51713),
+    ('Rogue', 'Subtlety', 58425),
+    ('Rogue', 'Combat', 5952),
+    ('Rogue', 'Combat', 13750),
+    ('Rogue', 'Combat', 13789),
+    ('Rogue', 'Combat', 13803),
+    ('Rogue', 'Combat', 13843),
+    ('Rogue', 'Combat', 13852),
+    ('Rogue', 'Combat', 13854),
+    ('Rogue', 'Combat', 13863),
+    ('Rogue', 'Combat', 13867),
+    ('Rogue', 'Combat', 13875),
+    ('Rogue', 'Combat', 13872),
+    ('Rogue', 'Combat', 13877),
+    ('Rogue', 'Combat', 13971),
+    ('Rogue', 'Combat', 14062),
+    ('Rogue', 'Combat', 14066),
+    ('Rogue', 'Combat', 14094),
+    ('Rogue', 'Combat', 14166),
+    ('Rogue', 'Combat', 14251),
+    ('Rogue', 'Combat', 14278),
+    ('Rogue', 'Combat', 31126),
+    ('Rogue', 'Combat', 31131),
+    ('Rogue', 'Combat', 32601),
+    ('Rogue', 'Combat', 51674),
+    ('Rogue', 'Combat', 51689),
+    ('Rogue', 'Combat', 51690),
+    ('Rogue', 'Combat', 58413),
+    ('Rogue', 'Combat', 58425),
+    ('Rogue', 'Combat', 61329),
+    ('Rogue', 'Combat', 61331),
+    ('Hunter', 'Marksmanship', 19256),
+    ('Hunter', 'Marksmanship', 19286),
+    ('Hunter', 'Marksmanship', 19388),
+    ('Hunter', 'Marksmanship', 19407),
+    ('Hunter', 'Marksmanship', 19418),
+    ('Hunter', 'Marksmanship', 19431),
+    ('Hunter', 'Marksmanship', 19434),
+    ('Hunter', 'Marksmanship', 19466),
+    ('Hunter', 'Marksmanship', 19490),
+    ('Hunter', 'Marksmanship', 19500),
+    ('Hunter', 'Marksmanship', 19503),
+    ('Hunter', 'Marksmanship', 19506),
+    ('Hunter', 'Marksmanship', 19508),
+    ('Hunter', 'Marksmanship', 23989),
+    ('Hunter', 'Marksmanship', 24691),
+    ('Hunter', 'Marksmanship', 34476),
+    ('Hunter', 'Marksmanship', 34484),
+    ('Hunter', 'Marksmanship', 34489),
+    ('Hunter', 'Marksmanship', 34490),
+    ('Hunter', 'Marksmanship', 34496),
+    ('Hunter', 'Marksmanship', 34950),
+    ('Hunter', 'Marksmanship', 35102),
+    ('Hunter', 'Marksmanship', 35111),
+    ('Hunter', 'Marksmanship', 52785),
+    ('Hunter', 'Marksmanship', 53209),
+    ('Hunter', 'Marksmanship', 53217),
+    ('Hunter', 'Marksmanship', 53221),
+    ('Hunter', 'Marksmanship', 53232),
+    ('Hunter', 'Marksmanship', 53238),
+    ('Hunter', 'Marksmanship', 53246),
+    ('DeathKnight', 'Blood', 48982),
+    ('DeathKnight', 'Blood', 49005),
+    ('DeathKnight', 'Blood', 49028),
+    ('DeathKnight', 'Blood', 49393),
+    ('DeathKnight', 'Blood', 49395),
+    ('DeathKnight', 'Blood', 49480),
+    ('DeathKnight', 'Blood', 49483),
+    ('DeathKnight', 'Blood', 49489),
+    ('DeathKnight', 'Blood', 49497),
+    ('DeathKnight', 'Blood', 49504),
+    ('DeathKnight', 'Blood', 49530),
+    ('DeathKnight', 'Blood', 49534),
+    ('DeathKnight', 'Blood', 49787),
+    ('DeathKnight', 'Blood', 50029),
+    ('DeathKnight', 'Blood', 50034),
+    ('DeathKnight', 'Blood', 50147),
+    ('DeathKnight', 'Blood', 50150),
+    ('DeathKnight', 'Blood', 50371),
+    ('DeathKnight', 'Blood', 51456),
+    ('DeathKnight', 'Blood', 53138),
+    ('DeathKnight', 'Blood', 55050),
+    ('DeathKnight', 'Blood', 55062),
+    ('DeathKnight', 'Blood', 55108),
+    ('DeathKnight', 'Blood', 55225),
+    ('DeathKnight', 'Blood', 55233),
+    ('DeathKnight', 'Blood', 61158),
+    ('DeathKnight', 'Blood', 62908),
+    ('DeathKnight', 'Frost', 48982),
+    ('DeathKnight', 'Frost', 49039),
+    ('DeathKnight', 'Frost', 49143),
+    ('DeathKnight', 'Frost', 49184),
+    ('DeathKnight', 'Frost', 49203),
+    ('DeathKnight', 'Frost', 49393),
+    ('DeathKnight', 'Frost', 49479),
+    ('DeathKnight', 'Frost', 49483),
+    ('DeathKnight', 'Frost', 49489),
+    ('DeathKnight', 'Frost', 49491),
+    ('DeathKnight', 'Frost', 49538),
+    ('DeathKnight', 'Frost', 49657),
+    ('DeathKnight', 'Frost', 49662),
+    ('DeathKnight', 'Frost', 49791),
+    ('DeathKnight', 'Frost', 49796),
+    ('DeathKnight', 'Frost', 50043),
+    ('DeathKnight', 'Frost', 50130),
+    ('DeathKnight', 'Frost', 50138),
+    ('DeathKnight', 'Frost', 50147),
+    ('DeathKnight', 'Frost', 50191),
+    ('DeathKnight', 'Frost', 50884),
+    ('DeathKnight', 'Frost', 51130),
+    ('DeathKnight', 'Frost', 51456),
+    ('DeathKnight', 'Frost', 51473),
+    ('DeathKnight', 'Frost', 54637),
+    ('DeathKnight', 'Frost', 59057),
+    ('DeathKnight', 'Frost', 66192),
+    ('Priest', 'Shadow', 14747),
+    ('Priest', 'Shadow', 14791),
+    ('Priest', 'Shadow', 15008),
+    ('Priest', 'Shadow', 15286),
+    ('Priest', 'Shadow', 15308),
+    ('Priest', 'Shadow', 15316),
+    ('Priest', 'Shadow', 15317),
+    ('Priest', 'Shadow', 15331),
+    ('Priest', 'Shadow', 15336),
+    ('Priest', 'Shadow', 15338),
+    ('Priest', 'Shadow', 15407),
+    ('Priest', 'Shadow', 15448),
+    ('Priest', 'Shadow', 15473),
+    ('Priest', 'Shadow', 15487),
+    ('Priest', 'Shadow', 17191),
+    ('Priest', 'Shadow', 17322),
+    ('Priest', 'Shadow', 27816),
+    ('Priest', 'Shadow', 27840),
+    ('Priest', 'Shadow', 27904),
+    ('Priest', 'Shadow', 33193),
+    ('Priest', 'Shadow', 33213),
+    ('Priest', 'Shadow', 33225),
+    ('Priest', 'Shadow', 33371),
+    ('Priest', 'Shadow', 34914),
+    ('Priest', 'Shadow', 47570),
+    ('Priest', 'Shadow', 47581),
+    ('Priest', 'Shadow', 47585),
+    ('Priest', 'Shadow', 51167),
+    ('Priest', 'Shadow', 63627),
+    ('Priest', 'Shadow', 64044);
+/*!40000 ALTER TABLE `template_npc_talents` ENABLE KEYS */;
+/*!40101 SET SQL_MODE=IFNULL(@OLD_SQL_MODE, '') */;
+/*!40014 SET FOREIGN_KEY_CHECKS=IF(@OLD_FOREIGN_KEY_CHECKS IS NULL, 1, @OLD_FOREIGN_KEY_CHECKS) */;
+/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
diff --git a/sql/TrinityCore-Patches/BloodMoneyDuels/world.bloodmoneyduel.sql b/sql/TrinityCore-Patches/BloodMoneyDuels/world.bloodmoneyduel.sql
new file mode 100644
index 0000000..4a9c601
--- /dev/null
+++ b/sql/TrinityCore-Patches/BloodMoneyDuels/world.bloodmoneyduel.sql
@@ -0,0 +1 @@
+INSERT INTO `creature_template` (`entry`, `modelid1`, `name`, `minlevel`, `maxlevel`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `BaseVariance`, `RangeVariance`, `unit_class`, `unit_flags`, `unit_flags2`, `InhabitType`, `HoverHeight`, `HealthModifier`, `ManaModifier`, `ArmorModifier`, `DamageModifier`, `ExperienceModifier`, `RegenHealth`, `flags_extra`, `ScriptName`) VALUES (100001, 26502, 'Duel Master', 83, 83, 35, 1, 1, 1.14286, 2, 1, 1, 1, 1, 2, 2048, 3, 1, 1, 1, 1, 1, 1, 1, 2, 'npc_blood_money');
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/BountyHunter/characters.BountyHunter.sql b/sql/TrinityCore-Patches/BountyHunter/characters.BountyHunter.sql
new file mode 100644
index 0000000..edccae3
--- /dev/null
+++ b/sql/TrinityCore-Patches/BountyHunter/characters.BountyHunter.sql
@@ -0,0 +1,38 @@
+-- phpMyAdmin SQL Dump
+-- version 4.1.12
+-- http://www.phpmyadmin.net
+--
+-- Host: localhost:3306
+-- Erstellungszeit: 17. Jun 2014 um 20:34
+-- Server Version: 5.5.35-0+wheezy1
+-- PHP-Version: 5.4.16
+
+SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
+SET time_zone = "+00:00";
+
+
+/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
+/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
+/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
+/*!40101 SET NAMES utf8 */;
+
+--
+-- Datenbank: `characters`
+--
+
+-- --------------------------------------------------------
+
+--
+-- Table Structure for `bounties`
+--
+
+CREATE TABLE IF NOT EXISTS `bounties` (
+  `guid` int(200) unsigned NOT NULL,
+  `visual` varchar(200) NOT NULL,
+  `price` int(200) NOT NULL,
+  PRIMARY KEY (`guid`)
+) ENGINE=InnoDB DEFAULT CHARSET=latin1;
+
+/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
+/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
+/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
diff --git a/sql/TrinityCore-Patches/BountyHunter/world.BountyHunter.sql b/sql/TrinityCore-Patches/BountyHunter/world.BountyHunter.sql
new file mode 100644
index 0000000..ab8e3a4
--- /dev/null
+++ b/sql/TrinityCore-Patches/BountyHunter/world.BountyHunter.sql
@@ -0,0 +1,5 @@
+-- Bounty Hunter NPC
+
+DELETE FROM `creature_template` WHERE (`entry`=99014);
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `dmgschool`, `BaseAttackTime`, `RangeAttackTime`, `BaseVariance`, `RangeVariance`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `HealthModifier`, `ManaModifier`, `ArmorModifier`, `DamageModifier`, `ExperienceModifier`, `RacialLeader`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) VALUES
+('99014','0','0','0','0','0','24818','3422','24819','24821','George','Bounty Hunter','','0','80','80','0','35','1','1','1.14286','1','0','0','0','0','1','1','1','0','0','0','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','5','1','1','1','1','0','0','1','0','0','BountyHunter','1');
diff --git a/sql/TrinityCore-Patches/External_Mail/characters.external_mail.sql b/sql/TrinityCore-Patches/External_Mail/characters.external_mail.sql
new file mode 100644
index 0000000..8cd6a05
--- /dev/null
+++ b/sql/TrinityCore-Patches/External_Mail/characters.external_mail.sql
@@ -0,0 +1,10 @@
+CREATE TABLE `mail_external` (
+  `id` bigint(20) unsigned NOT NULL auto_increment,
+  `receiver` bigint(20) unsigned NOT NULL,
+  `subject` varchar(200) default 'Support Message',
+  `message` varchar(500) default 'Support Message',
+  `money` bigint(20) unsigned NOT NULL default '0',
+  `item` bigint(20) unsigned NOT NULL default '0',
+  `item_count` bigint(20) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM AUTO_INCREMENT=7525 DEFAULT CHARSET=utf8;
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/Guildhouses/world_guildhouses.sql b/sql/TrinityCore-Patches/Guildhouses/world_guildhouses.sql
new file mode 100644
index 0000000..e668bf6
--- /dev/null
+++ b/sql/TrinityCore-Patches/Guildhouses/world_guildhouses.sql
@@ -0,0 +1,67 @@
+-- ----------------------------
+-- Table structure for guildhouses
+-- ----------------------------
+
+DROP TABLE IF EXISTS `guildhouses`;
+
+CREATE TABLE `guildhouses` (
+  `id` int(8) unsigned NOT NULL auto_increment,
+  `guildId` bigint(20) NOT NULL default '0',
+  `x` double NOT NULL,
+  `y` double NOT NULL,
+  `z` double NOT NULL,
+  `map` int(11) NOT NULL,
+  `comment` varchar(255) NOT NULL default '',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM AUTO_INCREMENT=42 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
+
+-- ----------------------------
+-- Records
+-- ----------------------------
+INSERT INTO `guildhouses` VALUES
+('1', '0', '16222', '16266', '14.2', '1', 'GM Island'),
+('2', '0', '-10711', '2483', '8', '1', 'Tauren village at Veiled Sea (Silithus)'),
+('3', '0', '-8323', '-343', '146', '0', 'Fishing outside an Northshire Abbey (Elwynn Forest'),
+('4', '0', '7368', '-1560', '163', '1', 'Troll Village in mountains (Darkshore)'),
+('5', '0', '-4151', '-1400', '198', '0', 'Dwarven village outside Ironforge (Wetlands)'),
+('6', '0', '-1840', '-4233', '2.14', '0', 'Dwarven village (Arathi Highlands, Forbidding Sea)'),
+('8', '0', '-723', '-1076', '179', '1', 'Tauren camp (Mulgore, Red Rock)'),
+('9', '0', '-206', '1666', '80', '0', 'Shadowfang Keep an outside instance (Silverpine Forest)'),
+('10', '0', '-6374', '1262', '7', '0', 'Harbor house outside Stormwind (Elwynn Forest)'),
+('11', '0', '-8640', '580', '96', '0', 'Empty jail between canals (Stormwind)'),
+('12', '0', '-4844', '-1066', '502', '0', 'Old Ironforge'),
+('13', '0', '-4863', '-1658', '503.5', '0', 'Ironforge Airport'),
+('14', '0', '1146', '-165', '313', '37', 'Azshara Crater instance (Alliance entrance)'),
+('15', '0', '-123', '858', '298', '37', 'Azshara Crater instance (Horde entrance)'),
+('16', '0', '4303', '-2760', '16.8', '0', 'Quel\'Thalas Tower'),
+('17', '0', '-6161', '-790', '423', '0', 'Crashed gnome airplane (between Dun Morogh and Searing Gorge)'),
+('18', '0', '-11790', '-1640', '54.7', '0', 'Zul\'Gurub an outside instance (Stranglethorn Vale)'),
+('19', '0', '-11805', '-4754', '6', '1', 'Goblin village (Tanaris, South Seas)'),
+('20', '0', '-9296', '670', '132', '0', 'Villains camp outside an Stormwind (Elwynn Forest)'),
+('21', '0', '3414', '-3380', '142.2', '0', 'Stratholm an outside instance'),
+('22', '0', '4654', '-3772', '944', '1', 'Kalimdor Hyjal (Aka World Tree)'),
+('23', '0', '2176', '-4766', '55', '1', 'The Ring of Valor (Aka. Orgrimmar Arena)'),
+('24', '0', '1951.512085', '1530.475586', '247.288147', '1', 'Stonetalon Logging Camp'),
+('25', '0', '2813.660645', '2248.552979', '215.524643', '1', 'Stonetalon Ruins'),
+('28', '0', '9725.27', '-21.43', '20.03', '1', 'Teldrassil Furbold camp'),
+('29', '0', '-3855', '-3479', '579', '0', 'Wetlands mountain camp'),
+('30', '0', '-5362', '-2540', '485', '0', 'Ortell\'s Hideout'),
+('31', '0', '-12865', '-1396', '115', '0', 'Stranglethorn Secret Cave'),
+('32', '0', '-11073', '-1956', '39', '0', 'Karazhan Smiley'),
+('33', '0', '-11084', '-1801', '53', '0', 'Well of the Forgotten (Aka. Karazhan Crypt or Lower Karazhan)'),
+('34', '0', '1683.235474', '286.458801', '-45.451775', '0', 'Undercity Top Tier'),
+('35', '0', '-8521.3', '599.5', '101.399338', '0', 'Stormwind Cut-Throat Alley'),
+('36', '0', '-5933', '452', '509', '0', 'Forgotten gnome camp'),
+('37', '0', '-920.231323', '7096.489258', '170.35289', '530', 'Outland Nagrand : Newton\'s Remains'),
+('38', '0', '-2140.501953', '9142.6875', '137.041855', '530', 'Outland Nagrand : Tomb'),
+('39', '0', '-483.401794', '7461.944824', '186.120987', '530', 'Outland Nagrand: Challe\'s Home for Little Tykes'),
+('40', '0', '2387.753906', '3191.757324', '152.669388', '530', 'Outland Netherstorm: Nova\'s Shrine');
+
+-- *************************
+-- * NPC Guildhouse Keeper *
+-- *************************
+
+DELETE FROM creature_template WHERE `entry`=13;
+
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `dmgschool`, `BaseAttackTime`, `RangeAttackTime`, `BaseVariance`, `RangeVariance`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `HealthModifier`, `ManaModifier`, `ArmorModifier`, `DamageModifier`, `ExperienceModifier`, `RacialLeader`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) values
+('13','0','0','0','0','0','26789','0','0','0','Beltez','Guildhouse Keeper',NULL,'0','80','80','0','35','1','1','1.14286','0.75','0','0','1400','1900','1','1','1','0','0','8','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','1','3','1','1','1','1','1','1','0','0','1','0','0','guildmaster','12340');
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/LevelNPC/world.levelnpc.sql b/sql/TrinityCore-Patches/LevelNPC/world.levelnpc.sql
new file mode 100644
index 0000000..2ff9750
--- /dev/null
+++ b/sql/TrinityCore-Patches/LevelNPC/world.levelnpc.sql
@@ -0,0 +1,5 @@
+-- Creature_template entry. Make sure entry number does not conflict.
+DELETE FROM `creature_template` WHERE `entry` = 60003;
+
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `dmgschool`, `BaseAttackTime`, `RangeAttackTime`, `BaseVariance`, `RangeVariance`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `HealthModifier`, `ManaModifier`, `ArmorModifier`, `DamageModifier`, `ExperienceModifier`, `RacialLeader`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) values
+('60003','0','0','0','0','0','2591','0','0','0','Lucy','Level NPC','','0','80','80','0','35','1','1','1.14286','1','1','0','1500','0','1','1','1','0','2048','0','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','EventAI','0','3','1','1','1','1','1','1','0','0','1','0','0','levelnpc','0');
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/Lotto/world.lottery.sql b/sql/TrinityCore-Patches/Lotto/world.lottery.sql
new file mode 100644
index 0000000..62ca63b
--- /dev/null
+++ b/sql/TrinityCore-Patches/Lotto/world.lottery.sql
@@ -0,0 +1,44 @@
+DELETE FROM `trinity_string` where `entry` IN ('11010', '11011', '11012');
+INSERT INTO `trinity_string` (`entry`, `content_default`) VALUES ('11010', '|cffff0000[Lottery]: The contest is over! Total bets involved: %u. The winning numbers: %s. The Jackpot contains %u gold and was not paid.|r');
+INSERT INTO `trinity_string` (`entry`, `content_default`) VALUES ('11011', '|cffff0000[Lottery]: The contest is over! Total bets involved: %u. The winning numbers: %s.  %s hit the Jackpot and wins %u gold! Congratulations!|r');
+INSERT INTO `trinity_string` (`entry`, `content_default`) VALUES ('11012', '|cffff0000[Lottery]: The contest is over! Total bets involved: %u. The winning numbers: %s.  %u players hit the Jackpot and everyone wins %u gold. Congratulations!|r');
+
+DROP TABLE IF EXISTS `lottery_winners`;
+CREATE TABLE `lottery_winners` (
+  `id` int(10) unsigned NOT NULL,
+  `name` varchar(12) NOT NULL,
+  `guid` int(10) unsigned NOT NULL DEFAULT '0',
+  `bet` longtext NOT NULL,
+  `betPoints` int(10) unsigned NOT NULL DEFAULT '0',
+  `time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP
+) ENGINE=MyISAM DEFAULT CHARSET=utf8;
+
+
+DROP TABLE IF EXISTS `lottery_bets`;
+CREATE TABLE `lottery_bets` (
+  `id` int(10) unsigned NOT NULL DEFAULT '1',
+  `name` varchar(12) NOT NULL,
+  `guid` int(10) unsigned NOT NULL DEFAULT '0',
+  `bet` longtext NOT NULL,
+  `time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
+  PRIMARY KEY (`id`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8;
+
+
+DROP TABLE IF EXISTS `lottery`;
+CREATE TABLE `lottery` (
+  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
+  `numbers` longtext NOT NULL,
+  `jackpot` int(10) unsigned NOT NULL DEFAULT '0',
+  `time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
+  PRIMARY KEY (`id`)
+) ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
+
+
+REPLACE INTO `game_event` (`eventEntry`, `start_time`, `end_time`, `occurence`, `length`, `holiday`, `description`, `world_event`, `announce`) VALUES
+(132, '2013-08-21 20:00:00', '2020-12-31 06:00:00', 1440, 1, 0, 'Lottery', 0, 2);
+
+
+DELETE FROM `creature_template` WHERE (`entry`=900010);
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `dmgschool`, `BaseAttackTime`, `RangeAttackTime`, `BaseVariance`, `RangeVariance`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `HealthModifier`, `ManaModifier`, `ArmorModifier`, `DamageModifier`, `ExperienceModifier`, `RacialLeader`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) VALUES
+('900010', '0', '0', '0', '0', '0', '7993', '0', '0', '0', 'Lotty', '- by GoN -', NULL, '0', '80', '80', '0', '35', '1', '1', '1.14286', '0.75', '0', '0', '1400', '1900', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '7', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '', '1', '3', '1', '1', '1', '1', '1', '1', '0', '0', '1', '0', '0', 'npc_lottery', '12340');
diff --git a/sql/TrinityCore-Patches/Reforging/characters.reforging.sql b/sql/TrinityCore-Patches/Reforging/characters.reforging.sql
new file mode 100644
index 0000000..9ac7bf6
--- /dev/null
+++ b/sql/TrinityCore-Patches/Reforging/characters.reforging.sql
@@ -0,0 +1,10 @@
+CREATE TABLE `custom_reforging` (
+	`GUID` INT(10) UNSIGNED NOT NULL COMMENT 'item guid low',
+	`increase` INT(10) UNSIGNED NOT NULL COMMENT 'stat_type',
+	`decrease` INT(10) UNSIGNED NOT NULL COMMENT 'stat_type',
+	`stat_value` INT(10) NOT NULL DEFAULT '0' COMMENT 'stat change',
+	`Owner` INT(10) UNSIGNED NULL DEFAULT NULL COMMENT 'player guid',
+	PRIMARY KEY (`GUID`)
+)
+COLLATE='utf8_general_ci'
+ENGINE=InnoDB;
diff --git a/sql/TrinityCore-Patches/Reforging/world.reforging.sql b/sql/TrinityCore-Patches/Reforging/world.reforging.sql
new file mode 100644
index 0000000..9a91aae
--- /dev/null
+++ b/sql/TrinityCore-Patches/Reforging/world.reforging.sql
@@ -0,0 +1,6 @@
+SET
+@Entry = 190011,
+@Name = "Thaumaturge Vashreen";
+DELETE FROM `creature_template` WHERE `entry` = @Entry;
+INSERT INTO `creature_template` (`entry`, `modelid1`, `modelid2`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `scale`, `rank`, `dmgschool`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `RacialLeader`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`) VALUES
+(@Entry, 20988, 0, @Name, "Arcane Reforger", NULL, 0, 80, 80, 2, 35, 1, 1, 0, 0, 2000, 0, 1, 0, 7, 138936390, 0, 0, 0, '', 0, 3, 1, 0, 0, 1, 0, 0, 'REFORGER_NPC');
diff --git a/sql/TrinityCore-Patches/SummonNPC/world.summonnpc-item.sql b/sql/TrinityCore-Patches/SummonNPC/world.summonnpc-item.sql
new file mode 100644
index 0000000..695b845
--- /dev/null
+++ b/sql/TrinityCore-Patches/SummonNPC/world.summonnpc-item.sql
@@ -0,0 +1,4 @@
+-- Example item:
+DELETE FROM `item_template` WHERE `entry` = 100000;
+insert into `item_template` (`entry`, `class`, `subclass`, `SoundOverrideSubclass`, `name`, `displayid`, `Quality`, `Flags`, `FlagsExtra`, `BuyCount`, `BuyPrice`, `SellPrice`, `InventoryType`, `AllowableClass`, `AllowableRace`, `ItemLevel`, `RequiredLevel`, `RequiredSkill`, `RequiredSkillRank`, `requiredspell`, `requiredhonorrank`, `RequiredCityRank`, `RequiredReputationFaction`, `RequiredReputationRank`, `maxcount`, `stackable`, `ContainerSlots`, `StatsCount`, `stat_type1`, `stat_value1`, `stat_type2`, `stat_value2`, `stat_type3`, `stat_value3`, `stat_type4`, `stat_value4`, `stat_type5`, `stat_value5`, `stat_type6`, `stat_value6`, `stat_type7`, `stat_value7`, `stat_type8`, `stat_value8`, `stat_type9`, `stat_value9`, `stat_type10`, `stat_value10`, `ScalingStatDistribution`, `ScalingStatValue`, `dmg_min1`, `dmg_max1`, `dmg_type1`, `dmg_min2`, `dmg_max2`, `dmg_type2`, `armor`, `holy_res`, `fire_res`, `nature_res`, `frost_res`, `shadow_res`, `arcane_res`, `delay`, `ammo_type`, `RangedModRange`, `spellid_1`, `spelltrigger_1`, `spellcharges_1`, `spellppmRate_1`, `spellcooldown_1`, `spellcategory_1`, `spellcategorycooldown_1`, `spellid_2`, `spelltrigger_2`, `spellcharges_2`, `spellppmRate_2`, `spellcooldown_2`, `spellcategory_2`, `spellcategorycooldown_2`, `spellid_3`, `spelltrigger_3`, `spellcharges_3`, `spellppmRate_3`, `spellcooldown_3`, `spellcategory_3`, `spellcategorycooldown_3`, `spellid_4`, `spelltrigger_4`, `spellcharges_4`, `spellppmRate_4`, `spellcooldown_4`, `spellcategory_4`, `spellcategorycooldown_4`, `spellid_5`, `spelltrigger_5`, `spellcharges_5`, `spellppmRate_5`, `spellcooldown_5`, `spellcategory_5`, `spellcategorycooldown_5`, `bonding`, `description`, `PageText`, `LanguageID`, `PageMaterial`, `startquest`, `lockid`, `Material`, `sheath`, `RandomProperty`, `RandomSuffix`, `block`, `itemset`, `MaxDurability`, `area`, `Map`, `BagFamily`, `TotemCategory`, `socketColor_1`, `socketContent_1`, `socketColor_2`, `socketContent_2`, `socketColor_3`, `socketContent_3`, `socketBonus`, `GemProperties`, `RequiredDisenchantSkill`, `ArmorDamageModifier`, `duration`, `ItemLimitCategory`, `HolidayId`, `ScriptName`, `DisenchantID`, `FoodType`, `minMoneyLoot`, `maxMoneyLoot`, `flagsCustom`, `VerifiedBuild`) values
+('100000','15','0','-1','Icerune','46787','4','72','0','1','0','0','0','-1','-1','1','1','0','0','0','0','0','0','6','1','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','18282','0','0','0','8000','0','-1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','1','|cff00FF00Use: Summons Lithathrad Teleporter.|r','0','0','0','0','0','3','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','-1','0','0','0','0','summon','0','0','0','0','0','-4');
diff --git a/sql/TrinityCore-Patches/TeleNPC2/world.npc_teleport.sql b/sql/TrinityCore-Patches/TeleNPC2/world.npc_teleport.sql
new file mode 100644
index 0000000..abaa188
--- /dev/null
+++ b/sql/TrinityCore-Patches/TeleNPC2/world.npc_teleport.sql
@@ -0,0 +1,119 @@
+DROP TABLE IF EXISTS `custom_npc_tele_category`;
+CREATE TABLE `custom_npc_tele_category` (
+  `id` int(6) unsigned NOT NULL default '0',
+  `name` varchar(255) NOT NULL default '',
+  `flag` tinyint(3) unsigned NOT NULL default '0',
+  `data0` bigint(20) unsigned NOT NULL default '0',
+  `data1` int(6) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8;
+
+DROP TABLE IF EXISTS `custom_npc_tele_destination`;
+CREATE TABLE `custom_npc_tele_destination` (
+  `id` int(6) unsigned NOT NULL auto_increment,
+  `name` char(100) NOT NULL default '',
+  `pos_X` float NOT NULL default '0',
+  `pos_Y` float NOT NULL default '0',
+  `pos_Z` float NOT NULL default '0',
+  `map` smallint(5) unsigned NOT NULL default '0',
+  `orientation` float NOT NULL default '0',
+  `level` tinyint(3) unsigned NOT NULL default '0',
+  `cost` int(10) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
+
+DROP TABLE IF EXISTS `custom_npc_tele_association`;
+CREATE TABLE `custom_npc_tele_association` (
+  `cat_id` int(6) unsigned NOT NULL default '0',
+  `dest_id` int(6) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`cat_id`, `dest_id`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8;
+
+TRUNCATE `custom_npc_tele_category`;
+INSERT INTO `custom_npc_tele_category`
+   (`id`, `name`, `flag`, `data0`, `data1`)
+VALUES
+   (1, 'Cities', 0, 1, 0),
+   (2, 'Cities', 0, 2, 0),
+   (3, 'Battlegrounds', 0, 1, 0),
+   (4, 'Battlegrounds', 0, 2, 0),
+   (5, 'Arenas', 0, 0, 0),
+   (6, '[Instances Lvl 1-60]', 0, 0, 0),
+   (7, '[Instances Lvl 60+]', 5, 60, 0),
+   (8, '[Instances Lvl 70+]', 5, 70, 0),
+   (9, 'Destinations MJ', 3, 0, 0);
+
+TRUNCATE `custom_npc_tele_destination`;
+INSERT INTO `custom_npc_tele_destination`
+   (`id`, `name`, `pos_X`, `pos_Y`, `pos_Z`, `map`, `orientation`, `level`, `cost`)
+VALUES
+   (1, 'Alterac Valley', 883.187, -489.375, 96.7618, 30, 3.06932, 0, 0),
+   (2, 'Alterac Valley', -818.155, -623.043, 54.0884, 30, 2.1, 0, 0),
+   (3, 'Arathi Basin', 686.053, 683.165, -12.9149, 529, 0.18, 0, 0),
+   (4, 'Arathi Basin', 1308.68, 1306.03, -9.0107, 529, 3.91285, 0, 0),
+   (5, 'Black Temple', -3610.72, 324.988, 37.4, 530, 3.28298, 0, 0),
+   (6, 'Blackfathom Deeps', 4254.58, 664.74, -29.04, 1, 1.97, 0, 0),
+   (7, 'Blackrock Depths', -7301.03, -913.19, 165.37, 0, 0.08, 0, 0),
+   (8, 'Blackrock Spire', -7535.43, -1212.04, 285.45, 0, 5.29, 0, 0),
+   (9, 'Blackwing Lair', -7665.55, -1102.49, 400.679, 469, 0, 0, 0),
+   (10, 'Caverns of Time', -8173.66, -4746.36, 33.8423, 1, 4.93989, 0, 0),
+   (11, 'Circle of Blood', 2839.44, 5930.17, 11.1002, 530, 3.16284, 0, 0),
+   (12, 'Coilfang Reservoir', 517.288, 6976.28, 32.0072, 530, 0, 0, 0),
+   (13, 'Darnassus', 9947.52, 2482.73, 1316.21, 1, 0, 0, 0),
+   (14, 'Dire Maul', -3982.47, 1127.79, 161.02, 1, 0.05, 0, 0),
+   (15, 'Exodar', -4073.03, -12020.4, -1.47, 530, 0, 0, 0),
+   (16, 'Eye of the Storm', 2487.72, 1609.12, 1224.64, 566, 3.35671, 0, 0),
+   (17, 'Eye of the Storm', 1843.73, 1529.77, 1224.43, 566, 0.297579, 0, 0),
+   (18, 'Goldshire', -9464, 62, 56, 0, 0, 0, 0),
+   (19, 'Gruul\'s Lair', 3539.01, 5082.36, 1.69107, 530, 0, 0, 0),
+   (20, 'Gurubashi', -13261.3, 168.294, 35.0792, 0, 1.00688, 0, 0),
+   (21, 'Hellfire Citadel', -305.816, 3056.4, -2.47318, 530, 2.01, 0, 0),
+   (22, 'Ironforge', -4924.07, -951.95, 501.55, 0, 5.4, 0, 0),
+   (23, 'Isle Of Quel\'Danas', 12947.4, -6893.31, 5.68398, 530, 3.09154, 0, 0),
+   (24, 'Karazhan', -11118.8, -2010.84, 47.0807, 0, 0, 0, 0),
+   (25, 'Maraudon', -1433.33, 2955.34, 96.21, 1, 4.82, 0, 0),
+   (26, 'Molten Core', 1121.45, -454.317, -101.33, 230, 3.5, 0, 0),
+   (27, 'Naxxramas', 3125.18, -3748.02, 136.049, 0, 0, 0, 0),
+   (28, 'Onyxia\'s Lair', -4707.44, -3726.82, 54.6723, 1, 3.8, 0, 0),
+   (29, 'Orgrimmar', 1552.5, -4420.66, 8.94802, 1, 0, 0, 0),
+   (30, 'Razor Hill', 315.721, -4743.4, 10.4867, 1, 0, 0, 0),
+   (31, 'Razorfen Downs', -4645.08, -2470.85, 85.53, 1, 4.39, 0, 0),
+   (32, 'Razorfen Kraul', -4484.04, -1739.4, 86.47, 1, 1.23, 0, 0),
+   (33, 'Ring of Trials', -1999.94, 6581.71, 11.32, 530, 2.3, 0, 0),
+   (34, 'Ruins of Ahn\'Qiraj', -8409.03, 1498.83, 27.3615, 1, 2.49757, 0, 0),
+   (35, 'Scholomance', 1219.01, -2604.66, 85.61, 0, 0.5, 0, 0),
+   (36, 'Shadowfang Keep', -254.47, 1524.68, 76.89, 0, 1.56, 0, 0),
+   (37, 'Shattrath City', -1850.21, 5435.82, -10.9614, 530, 3.40391, 0, 0),
+   (38, 'Silvermoon', 9338.74, -7277.27, 13.7895, 530, 0, 0, 0),
+   (39, 'Stormwind', -8960.14, 516.266, 96.3568, 0, 0, 0, 0),
+   (40, 'Stratholme', 3263.54, -3379.46, 143.59, 0, 0, 0, 0),
+   (41, 'Tempest Keep', 3089.58, 1399.05, 187.653, 530, 4.79407, 0, 0),
+   (42, 'Temple of Ahn\'Qiraj', -8245.84, 1983.74, 129.072, 1, 0.936195, 0, 0),
+   (43, 'The Deadmines', -11212, 1658.58, 25.67, 0, 1.45, 0, 0),
+   (44, 'The Maul', -3761.49, 1133.43, 132.083, 1, 4.57259, 0, 0),
+   (45, 'The Scarlet Monastery', 2843.89, -693.74, 139.32, 0, 5.11, 0, 0),
+   (46, 'The Sunken Temple', -10346.9, -3851.9, -43.41, 0, 6.09, 0, 0),
+   (47, 'The Wailing Caverns', -722.53, -2226.3, 16.94, 1, 2.71, 0, 0),
+   (48, 'Thunder Bluff', -1290, 147.034, 129.682, 1, 4.919, 0, 0),
+   (49, 'Uldaman', -6119.7, -2957.3, 204.11, 0, 0.03, 0, 0),
+   (50, 'Undercity', 1819.71, 238.79, 60.5321, 0, 0, 0, 0),
+   (51, 'Warsong Gulch', 930.851, 1431.57, 345.537, 489, 0.015704, 0, 0),
+   (52, 'Warsong Gulch', 1525.95, 1481.66, 352.001, 489, 3.20756, 0, 0),
+   (53, 'Zul\'Aman', 6846.95, -7954.5, 170.028, 530, 4.61501, 0, 0),
+   (54, 'Zul\'Farrak', -6839.39, -2911.03, 8.87, 1, 0.41, 0, 0),
+   (55, 'Zul\'Gurub', -11916.7, -1212.82, 92.2868, 0, 4.6095, 0, 0),
+   (56, 'Ile des MJ', 16254, 16276.9, 14.5082, 1, 1.70269, 0, 0);
+
+TRUNCATE `custom_npc_tele_association`;
+INSERT INTO `custom_npc_tele_association`
+  (`cat_id`, `dest_id`)
+VALUES
+  (1, 13), (1, 15), (1, 18), (1, 22), (1, 23), (1, 37), (1, 39), (2, 23), (2, 29), (2, 30), (2, 37), (2, 38), (2, 48), (2, 50), (3, 1), (3, 4), (3, 16), (3, 52), (4, 2), (4, 3), (4, 17), (4, 51), (5, 11), (5, 20), (5, 33), (5, 44), (6, 6), (6, 7), (6, 8), (6, 14), (6, 25), (6, 31), (6, 32), (6, 35), (6, 36), (6, 40), (6, 43), (6, 45), (6, 46), (6, 47), (6, 49), (6, 54), (7, 9), (7, 26), (7, 27), (7, 28), (7, 34), (7, 42), (7, 55), (8, 5), (8, 10), (8, 12), (8, 19), (8, 21), (8, 24), (8, 41), (8, 53), (9, 56);
+
+-- `npc_text`
+REPLACE INTO `npc_text` (`ID`, `text0_0`) VALUES
+   (100000, 'Choose your Category.'),
+   (100001, 'Choose your Destination.');
+
+-- `creature_template`
+INSERT INTO `creature_template` (`entry`, `modelid1`, `name`, `minlevel`, `maxlevel`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `BaseVariance`, `RangeVariance`, `unit_class`, `unit_flags`, `unit_flags2`, `InhabitType`, `HoverHeight`, `HealthModifier`, `ManaModifier`, `ArmorModifier`, `DamageModifier`, `ExperienceModifier`, `RegenHealth`, `flags_extra`, `ScriptName`) VALUES (100000, 26502, 'TeleNPC2', 83, 83, 35, 1, 1, 1.14286, 2, 1, 1, 1, 1, 2, 2048, 3, 1, 1, 1, 1, 1, 1, 1, 2, 'npc_teleport');
diff --git a/sql/TrinityCore-Patches/Transmog/Transmog_CHANGELOG.md b/sql/TrinityCore-Patches/Transmog/Transmog_CHANGELOG.md
new file mode 100644
index 0000000..5903bf0
--- /dev/null
+++ b/sql/TrinityCore-Patches/Transmog/Transmog_CHANGELOG.md
@@ -0,0 +1,126 @@
+####6.1
+- Update to newest TC
+- Made guid changes
+
+####6.0
+- Removed mutex locks - Different code style, works with ACE and boost, probably more efficient
+- Added regex checking for preset name
+- Fixed random properties not registering as item stats (Thanks Aokromes)
+- Made the code / patch compatible with herbs+veins patch (Thanks Aokromes)
+- Moved to bithub - Allows autogenerate patch and diff and management is easier:
+- https://github.com/Rochet2/TrinityCore/tree/transmog
+- Gist was at: https://gist.github.com/Rochet2/2c8765b53f8dda1e296a
+
+####5.6
+- Fixed few linux compile warnings
+- Moved to GIST
+- Old versions etc still available from:
+https://drive.google.com/folderview?id=0Bx5knS2IsjatTlVtWHRwbUN3VlE&usp=sharing
+
+####5.5
+- Updated to latest TC  rev
+- Fixed some tabs to spaces
+- Fixed a warning on gcc
+
+####5.4
+- Updated to latest TC rev
+
+####5.3
+- Rewrote transmogrification logic to be blizzlike.
+- Implemented multithread support.
+- Tweaked saving to work so that your data is saved whenever the player is saved.
+- This means that crashes can not be abused and DB wont have SQL executing and querying all the time.
+
+####5.2
+- Some logic fixes and other
+
+####5.1
+- Config options should now work properly. Please notify here if some still bug
+- Can transmog bows with guns and crossbows
+- Can transmog cloth to leather with config settings set
+- Can transmog robes with chest pieces
+- You should now be able to view the info menus with the new NPC
+- Allow shirt's to be transmogrified (were shown in menu but you weren't able to before)
+- Mirror image (mage spell) should now correctly copy the transmogrified outfit. Before it still got your old item displays.
+- Added new config options:
+
+####5.0
+- Ripped cata branch functions and thus altered how everything is coded pretty much.
+- Dropped translation support
+- Added colored item links as well as icons all over the place
+- Added new feature: Sets
+- Added many config options, for example to allow cloth and plate to be transmogrified with each other
+
+####4.0
+- I changed all the methods to normal functions and moved them to Transmogrification.cpp
+- I also updated the way transmogrifications are stored
+
+####3.9
+- Nothing was added
+- Now supporting latest TDB: 0d3554d4bf
+- Also tested and works on latest
+- Changed diff to patch for better compability
+
+####3.8
+- Nothing was added
+- Now supporting latest TDB: da9865b683
+
+####3.7
+- Quick update to the patch for latest trinitycore version
+
+####3.6
+- Updated the code to work with the new trinitycore changes
+- Added config (See the bottom of worldserver.conf)
+- Added token cost possibility -- in config
+- Added cost modification possibility -- in config
+- Added quality requirement modification possibility -- in config
+
+####3.5
+- Fixed a crash on item deletion from guild deleting and more
+
+####3.4
+- Added localization possibilities, even though I am not quite sure if it works and if it is good or good enough. Only tested that english works
+- Added possibility to disable gold cost before compiling
+- Cleaned all the code I could find to TrinityCore standards .. I think
+
+####3.3
+- Transformed the script into a full coremod instead of having some code in the gossip script. This allows the transmogrification methods to be used on any item anywhere.
+- Changed the way fake display entries are stored in the core. Instead of having a new variable for the item class, I am now having a contained, much like locales have.
+- Changed the files into one patch file like Aokromes suggested. You can find the DB table creation SQLs from sql/characters_transmogrification/
+- Removed prepared statements
+- Fake display entries are now loaded when the server starts up. All nonexistant item guids will be deleted before loading and when loading, all invalid item entries are deleted (deleted some custom items aye?
+
+####3.2
+- Fixed an issue with DB saving not taking action on login or server restart.
+
+####3.1
+- Corrected the quality check, which was left to return true in any case
+- Fixed invisible item entries from newly created items (.additem for example)
+
+####3.0
+- It will have mailing and auction etc restrictions properly coded (yay, no more Fake owner!)
+- Having its own prepared statement now
+- Moved loading transmogs to the item loading part.
+- The script should now be added to scriptloader by the patch. So you just need to add it to solution.
+- Included an NPC sql for everyone with NPC problems :3
+
+####2.2
+- Added a few sounds, altered to use switch instead of an IF block
+- Modified to have a separate table
+- And more?
+
+####2.1
+- Fixed a crash when getting item template of item entry 0
+
+####2.0
+- Possibly more ..
+- Implemented cost
+- Changed quality checks
+- Fixed few problems
+- Changed some messages for more blizzlike feeling
+- After trying to transmogrify or remove a transmogrification, you get to the item selection screen instead of main menu
+- Added Remove Transmogrification buttons and update main menu button (removed nevermind)
+- Added more checks for safety and blizzlike feeling
+
+####1.0
+- Added DB saving and remove transmogrifications option -> patch, sql and script needed
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/Transmog/Transmog_README.md b/sql/TrinityCore-Patches/Transmog/Transmog_README.md
new file mode 100644
index 0000000..f7f1588
--- /dev/null
+++ b/sql/TrinityCore-Patches/Transmog/Transmog_README.md
@@ -0,0 +1,53 @@
+#Transmogrification [![Build Status](https://travis-ci.org/Rochet2/TrinityCore.svg?branch=transmog)](https://travis-ci.org/Rochet2/TrinityCore)
+
+####About
+Transmogrification allows you to change the display of an item to something else.
+You can use any item in your bags as source of display, as long as it fits the requirements.
+Requirements can be tweaked in the server configuration file.
+Basically any item should work with transmogrification. Custom items as well. No item is hardcoded to the system.
+Has a feature to store sets of displays. This can be removed before compiling or in the configuration file.
+Made for 3.3.5a.<br />
+Source: http://rochet2.github.io/Transmogrification.html
+
+Video: https://youtu.be/xtH4ogz12iM
+
+####Installation
+
+Available as:
+- Direct merge: https://github.com/Rochet2/TrinityCore/tree/transmog
+- Diff: https://github.com/Rochet2/TrinityCore/compare/TrinityCore:3.3.5...transmog.diff
+- Diff in github view: https://github.com/Rochet2/TrinityCore/compare/TrinityCore:3.3.5...transmog
+
+Using direct merge:
+- open git bash to source location
+- do `git remote add rochet2 https://github.com/Rochet2/TrinityCore.git`
+- do `git pull rochet2 transmog`
+- use cmake and compile
+
+Using diff:
+- DO NOT COPY THE DIFF DIRECTLY! It causes apply to fail.
+- download the diff by __right clicking__ the link and select __Save link as__
+- place the downloaded `transmog.diff` to the source root folder
+- open git bash to source location
+- do `git apply transmog.diff`
+- use cmake and compile
+
+After compiling:
+- Navigate to `\src\server\scripts\Custom\Transmog\sql\`
+- Run `characters.sql` to your characters database
+- Run `world_texts.sql` to your world database
+ - optionally you can also insert a transmogrifier NPC to your database by running `world_NPC.sql` to your world database.
+- Change the settings to your liking in `worldserver.conf` (Note that you should copy over the new config created)
+
+####Usage
+Equip an item that is suitable for transmogrification.
+Have an item in your bags that is suitable to be used to transmogrify the equipped item
+Talk to Transmogrifier and select the item slot. Then select the item you want to transmogrify to.
+Click to proceed when prompted and your items are transmogrified.
+Currently the default settings are according to this: http://wowwiki.wikia.com/Transmogrification#Current_rules
+Tweak the settings if you need in worldserver.conf
+
+####Changelog: [Changelog](https://github.com/Rochet2/TrinityCore/blob/transmog/src/server/scripts/Custom/Transmog/CHANGELOG.md)
+
+####Bugs and Contact
+Report issues and similar to https://rochet2.github.io/
diff --git a/sql/TrinityCore-Patches/Transmog/characters.Transmog.sql b/sql/TrinityCore-Patches/Transmog/characters.Transmog.sql
new file mode 100644
index 0000000..4529815
--- /dev/null
+++ b/sql/TrinityCore-Patches/Transmog/characters.Transmog.sql
@@ -0,0 +1,37 @@
+-- --------------------------------------------------------
+-- Host:                         localhost
+-- Server version:               5.5.39 - MySQL Community Server (GPL)
+-- Server OS:                    Win32
+-- HeidiSQL Version:             9.1.0.4894
+-- --------------------------------------------------------
+
+/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
+/*!40101 SET NAMES utf8mb4 */;
+/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
+/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
+
+-- Dumping structure for table tc_c.custom_transmogrification
+CREATE TABLE IF NOT EXISTS `custom_transmogrification` (
+  `GUID` int(10) unsigned NOT NULL COMMENT 'Item guidLow',
+  `FakeEntry` int(10) unsigned NOT NULL COMMENT 'Item entry',
+  `Owner` int(10) unsigned NOT NULL COMMENT 'Player guidLow',
+  PRIMARY KEY (`GUID`),
+  KEY `Owner` (`Owner`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='6_2';
+
+-- Data exporting was unselected.
+
+
+-- Dumping structure for table tc_c.custom_transmogrification_sets
+CREATE TABLE IF NOT EXISTS `custom_transmogrification_sets` (
+  `Owner` int(10) unsigned NOT NULL COMMENT 'Player guidlow',
+  `PresetID` tinyint(3) unsigned NOT NULL COMMENT 'Preset identifier',
+  `SetName` text COMMENT 'SetName',
+  `SetData` text COMMENT 'Slot1 Entry1 Slot2 Entry2',
+  PRIMARY KEY (`Owner`,`PresetID`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='6_1';
+
+-- Data exporting was unselected.
+/*!40101 SET SQL_MODE=IFNULL(@OLD_SQL_MODE, '') */;
+/*!40014 SET FOREIGN_KEY_CHECKS=IF(@OLD_FOREIGN_KEY_CHECKS IS NULL, 1, @OLD_FOREIGN_KEY_CHECKS) */;
+/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
diff --git a/sql/TrinityCore-Patches/Transmog/world.Transmog.sql b/sql/TrinityCore-Patches/Transmog/world.Transmog.sql
new file mode 100644
index 0000000..9086eab
--- /dev/null
+++ b/sql/TrinityCore-Patches/Transmog/world.Transmog.sql
@@ -0,0 +1,29 @@
+-- NPC
+
+SET
+@Entry = 190010,
+@Name = "Warpweaver";
+
+INSERT INTO `creature_template` (`entry`, `modelid1`, `modelid2`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `scale`, `rank`, `dmgschool`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `RacialLeader`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`) VALUES
+(@Entry, 19646, 0, @Name, "Transmogrifier", NULL, 0, 80, 80, 2, 35, 1, 1, 0, 0, 2000, 0, 1, 0, 7, 138936390, 0, 0, 0, '', 0, 3, 1, 0, 0, 1, 0, 0, 'Creature_Transmogrify');
+
+-- Texts
+
+SET @TEXT_ID := 50000;
+INSERT INTO `npc_text` (`ID`, `text0_0`) VALUES
+(@TEXT_ID, 'Transmogrification allows you to change how your items look like without changing the stats of the items.\r\nItems used in transmogrification are no longer refundable, tradeable and are bound to you.\r\nUpdating a menu updates the view and prices.\r\n\r\nNot everything can be transmogrified with eachother.\r\nRestrictions include but are not limited to:\r\nOnly armor and weapons can be transmogrified\r\nGuns, bows and crossbows can be transmogrified with eachother\r\nFishing poles can not be transmogrified\r\nYou must be able to equip both items used in the process.\r\n\r\nTransmogrifications stay on your items as long as you own them.\r\nIf you try to put the item in guild bank or mail it to someone else, the transmogrification is stripped.\r\n\r\nYou can also remove transmogrifications for free at the transmogrifier.'),
+(@TEXT_ID+1, 'You can save your own transmogrification sets.\r\n\r\nTo save, first you must transmogrify your equipped items.\r\nThen when you go to the set management menu and go to save set menu,\r\nall items you have transmogrified are displayed so you see what you are saving.\r\nIf you think the set is fine, you can click to save the set and name it as you wish.\r\n\r\nTo use a set you can click the saved set in the set management menu and then select use set.\r\nIf the set has a transmogrification for an item that is already transmogrified, the old transmogrification is lost.\r\nNote that same transmogrification restrictions apply when trying to use a set as in normal transmogrification.\r\n\r\nTo delete a set you can go to the set\'s menu and select delete set.');
+
+SET @STRING_ENTRY := 11100;
+INSERT INTO `trinity_string` (`entry`, `content_default`) VALUES
+(@STRING_ENTRY+0, 'Item transmogrified'),
+(@STRING_ENTRY+1, 'Equipment slot is empty'),
+(@STRING_ENTRY+2, 'Invalid source item selected'),
+(@STRING_ENTRY+3, 'Source item does not exist'),
+(@STRING_ENTRY+4, 'Destination item does not exist'),
+(@STRING_ENTRY+5, 'Selected items are invalid'),
+(@STRING_ENTRY+6, 'Not enough money'),
+(@STRING_ENTRY+7, 'You don\'t have enough tokens'),
+(@STRING_ENTRY+8, 'Transmogrifications removed'),
+(@STRING_ENTRY+9, 'There are no transmogrifications'),
+(@STRING_ENTRY+10, 'Invalid name inserted');
diff --git a/sql/TrinityCore-Patches/TransmogVendor/characters.TransmogVendor.sql b/sql/TrinityCore-Patches/TransmogVendor/characters.TransmogVendor.sql
new file mode 100644
index 0000000..4529815
--- /dev/null
+++ b/sql/TrinityCore-Patches/TransmogVendor/characters.TransmogVendor.sql
@@ -0,0 +1,37 @@
+-- --------------------------------------------------------
+-- Host:                         localhost
+-- Server version:               5.5.39 - MySQL Community Server (GPL)
+-- Server OS:                    Win32
+-- HeidiSQL Version:             9.1.0.4894
+-- --------------------------------------------------------
+
+/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
+/*!40101 SET NAMES utf8mb4 */;
+/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
+/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
+
+-- Dumping structure for table tc_c.custom_transmogrification
+CREATE TABLE IF NOT EXISTS `custom_transmogrification` (
+  `GUID` int(10) unsigned NOT NULL COMMENT 'Item guidLow',
+  `FakeEntry` int(10) unsigned NOT NULL COMMENT 'Item entry',
+  `Owner` int(10) unsigned NOT NULL COMMENT 'Player guidLow',
+  PRIMARY KEY (`GUID`),
+  KEY `Owner` (`Owner`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='6_2';
+
+-- Data exporting was unselected.
+
+
+-- Dumping structure for table tc_c.custom_transmogrification_sets
+CREATE TABLE IF NOT EXISTS `custom_transmogrification_sets` (
+  `Owner` int(10) unsigned NOT NULL COMMENT 'Player guidlow',
+  `PresetID` tinyint(3) unsigned NOT NULL COMMENT 'Preset identifier',
+  `SetName` text COMMENT 'SetName',
+  `SetData` text COMMENT 'Slot1 Entry1 Slot2 Entry2',
+  PRIMARY KEY (`Owner`,`PresetID`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='6_1';
+
+-- Data exporting was unselected.
+/*!40101 SET SQL_MODE=IFNULL(@OLD_SQL_MODE, '') */;
+/*!40014 SET FOREIGN_KEY_CHECKS=IF(@OLD_FOREIGN_KEY_CHECKS IS NULL, 1, @OLD_FOREIGN_KEY_CHECKS) */;
+/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
diff --git a/sql/TrinityCore-Patches/TransmogVendor/world_TransMogVendor.sql b/sql/TrinityCore-Patches/TransmogVendor/world_TransMogVendor.sql
new file mode 100644
index 0000000..8407c8a
--- /dev/null
+++ b/sql/TrinityCore-Patches/TransmogVendor/world_TransMogVendor.sql
@@ -0,0 +1,6 @@
+SET
+@Entry = 190012,
+@Name = "Narpweaver";
+DELETE FROM `creature_template` WHERE `entry` = @Entry;
+INSERT INTO `creature_template` (`entry`, `modelid1`, `modelid2`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `scale`, `rank`, `dmgschool`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `RacialLeader`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`) VALUES
+(@Entry, 19646, 0, @Name, "Transmogrifier", NULL, 0, 80, 80, 2, 35, 129, 1, 0, 0, 2000, 0, 1, 0, 7, 138936390, 0, 0, 0, '', 0, 3, 1, 0, 0, 1, 0, 0, 'NPC_TransmogDisplayVendor');
diff --git a/sql/TrinityCore-Patches/TriniIRC/World_TrinityChat.sql b/sql/TrinityCore-Patches/TriniIRC/World_TrinityChat.sql
new file mode 100644
index 0000000..48dd18e
--- /dev/null
+++ b/sql/TrinityCore-Patches/TriniIRC/World_TrinityChat.sql
@@ -0,0 +1,81 @@
+/**
+* Table structure for irc_commands
+*/
+DROP TABLE IF EXISTS `irc_commands`;
+CREATE TABLE `irc_commands` (
+  `Command` varchar(10) NOT NULL default '',
+  `Description` varchar(350) default NULL,
+  `gmlevel` tinyint(3) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`Command`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='IRC Module System';
+
+/**
+* Records
+*/
+INSERT INTO `irc_commands` VALUES ('acct', '[acct <Player> <(un)lock/email/pass/rename/gmlevel>] : Perform Action To <Player> Account.', '3');
+INSERT INTO `irc_commands` VALUES ('ban', '[ban <Player/IP> <ip/acct/unban/reason>] : Ban/Unban <Player>', '3');
+INSERT INTO `irc_commands` VALUES ('chan', '[chan <op/deop/voice/devoice> <*IRC Nick*>] : Set Mode On Yourself, If <IRC Nick> Is Specified Then Set mode On Nick.', '3');
+INSERT INTO `irc_commands` VALUES ('char', '[char <Player> <mailcheat/taxicheat/maxskill/setskill/combatstop/quest/mod>] : Perform Action To Character.', '3');
+INSERT INTO `irc_commands` VALUES ('fun', '[fun <Player> <Sound/Say>] : Do Selected Fun Action To <Player>.', '3');
+INSERT INTO `irc_commands` VALUES ('help', '[help Command] : Use No Paramaters For List Of Available Commands.', '0');
+INSERT INTO `irc_commands` VALUES ('inchan', '[inchan <Channel>] : Display Users In Selected In Game <Channel>', '0');
+INSERT INTO `irc_commands` VALUES ('info', '[info] : Display Server Info. (Number Of Players Online/Max Since Last Restart/Uptime)', '0');
+INSERT INTO `irc_commands` VALUES ('item', '[item <Player> <add> <ItemID/[ItemName]> <Amount>] : Additem To <Player>, Use <ItemID> Or <[Exact Item Name]>.', '3');
+INSERT INTO `irc_commands` VALUES ('jail', '[jail <Player> <release/Reason>] : Jail Selected <Player> For <Reason>. Using release As <Reason> Releases Player.', '3');
+INSERT INTO `irc_commands` VALUES ('kick', '[kick <Player> <Reason>] : Kick <Player> For <Reason>.', '3');
+INSERT INTO `irc_commands` VALUES ('kill', '[kill <Player> <Reason>] : Kill <Player> For <Reason>.', '3');
+INSERT INTO `irc_commands` VALUES ('level', '[level <Player> <NewLevel>] : Level <Player> To <NewLevel>. *Can Be Done Offline*', '3');
+INSERT INTO `irc_commands` VALUES ('login', '[login <UserName> <Password>] : Login To TriniChat Admin Mode.  (Must Be Done In A PM)', '0');
+INSERT INTO `irc_commands` VALUES ('logout', '[logout] : Logout Of TriniChat Admin Mode.', '0');
+INSERT INTO `irc_commands` VALUES ('lookup', '[lookup <acct/char/creature/faction/go/item/quest/skill/spell/tele> <ID/Name>] : ', '3');
+INSERT INTO `irc_commands` VALUES ('money', '[money <Player> <(-)Money>] : Give Money To <Player>, Use - To Take Money. *Can Be Done Offline*', '3');
+INSERT INTO `irc_commands` VALUES ('mute', '[mute <Player> <release/TimeInMins> <Reason>] : Mute Player For Reason, For <TimeInMins>. Using release As Time Releases Player. *Can Be Done Offline*', '3');
+INSERT INTO `irc_commands` VALUES ('online', '[online] : Display All Users Logged In Game.', '0');
+INSERT INTO `irc_commands` VALUES ('pm', '[pm <Player> <Message>] : Whisper <Player> In WoW <Message>.', '3');
+INSERT INTO `irc_commands` VALUES ('reload', '[reload] : Reload TriniChat Config Options And Security Level From DataBase.', '3');
+INSERT INTO `irc_commands` VALUES ('restart', '[restart] : Restart TriniChat, NOT Trinity Core World Server Itself. Forces Reconnection To IRC Server.', '3');
+INSERT INTO `irc_commands` VALUES ('revive', '[revive <Player>] : Revive <Player>.', '3');
+INSERT INTO `irc_commands` VALUES ('saveall', '[saveall] : Forces Trinity Core To Save All Players.', '3');
+INSERT INTO `irc_commands` VALUES ('server', '[server setmotd [<motd>]/flusharenapoints]', '3');
+INSERT INTO `irc_commands` VALUES ('shutdown', '[shutdown <TimeInSeconds>] : Shuts The Server Down In <TimeInSeconds>, Use 0 For Immediate Shut Down', '3');
+INSERT INTO `irc_commands` VALUES ('spell', '[spell <Player> <Cast/Learn/UnLearn> <SpellID>] : Make <Player> <Learn> Or <UnLearn> A Spell, Or <Cast> A Spell On A <Player>.', '3');
+INSERT INTO `irc_commands` VALUES ('sysmsg', '[sysmsg <a/n/e/add/del/list> <Message>] : Broadcasts A System Message. (a-Broadcast System Message)(n-Broadcast Notify Message)(e-Event Message)', '3');
+INSERT INTO `irc_commands` VALUES ('tele', '[tele <Player> <l/c/r/to/cr/go/homebind> <Loc.Name/MAPID X Y Z/Recall/Player/Creature GUID/Gameobject GUID>] : Teleport Player To Location, Coords, Recall Location, Another Player, Creature or Gameobject. (l-Location)(c-Coords)', '3');
+INSERT INTO `irc_commands` VALUES ('top', '[top <accttime/chartime/money> <limit>] : Display top stats for given option. Only GM Higher Than Config Option Can Use Limit.', '3');
+INSERT INTO `irc_commands` VALUES ('who', '[who] : Displays Users Currently Logged In To TriniChat.', '1');
+
+/**
+* Table structure for irc_inchan
+*/
+DROP TABLE IF EXISTS `irc_inchan`;
+CREATE TABLE `irc_inchan` (
+  `guid` int(11) unsigned NOT NULL default '0' COMMENT 'Global Unique Identifier',
+  `name` varchar(12) NOT NULL default '',
+  `channel` varchar(15) NOT NULL default '',
+  PRIMARY KEY  (`guid`,`channel`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 ROW_FORMAT=FIXED COMMENT='IRC Module System';
+
+/**
+* Records
+*/
+
+/**
+* Table structure for irc_autoannounce
+*/
+DROP TABLE IF EXISTS `irc_autoannounce`;
+CREATE TABLE `irc_autoannounce` (
+  `id` int(11) NOT NULL auto_increment,
+  `message` longtext NOT NULL,
+  `addedby` varchar(12) NOT NULL default '',
+  PRIMARY KEY  (`id`)
+) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COMMENT='IRC Module System';
+
+/**
+* Records
+*/
+INSERT INTO `irc_autoannounce` VALUES ('1', 'Welcome to IRC Channel', '');
+
+DELETE FROM `trinity_string` WHERE entry IN (6610,6611,6612);
+INSERT INTO `trinity_string` VALUES ('6610', '|cffff0000[System Message]: %s|r', null, null, null, null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('6611', '|cffff0000[Server Event]: %s|r', null, null, null, null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('6612', '|cffff0000[Automatic]: %s|r', null, null, null, null, null, null, null, null);
diff --git a/sql/TrinityCore-Patches/TrinityJail/auth.jail.sql b/sql/TrinityCore-Patches/TrinityJail/auth.jail.sql
new file mode 100644
index 0000000..2634cfc
--- /dev/null
+++ b/sql/TrinityCore-Patches/TrinityJail/auth.jail.sql
@@ -0,0 +1,13 @@
+DELETE FROM `rbac_permissions` WHERE `id` IN (901,902,903,904);
+INSERT INTO `rbac_permissions` (`id`, `name`) VALUES
+(901, 'Command: jail player'),
+(902, 'Command: jail info'),
+(903, 'Command: jail release'),
+(904, 'Command: jail reload');
+
+DELETE FROM `rbac_linked_permissions` WHERE `linkedid` IN (901,902,903,904);
+INSERT INTO `rbac_linked_permissions` (`id`,`linkedId`) VALUES
+(193, 901),
+(195, 902),
+(193, 903),
+(193, 904);
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/TrinityJail/characters_jail.sql b/sql/TrinityCore-Patches/TrinityJail/characters_jail.sql
new file mode 100644
index 0000000..af7e672
--- /dev/null
+++ b/sql/TrinityCore-Patches/TrinityJail/characters_jail.sql
@@ -0,0 +1,66 @@
+/*
+MySQL Data Transfer
+Source Host: localhost
+Source Database: characters
+Target Host: localhost
+Target Database: characters
+Date: 25.04.2010 00:00:00
+*/
+DROP TABLE IF EXISTS `jail`;
+SET FOREIGN_KEY_CHECKS=0;
+-- ----------------------------
+-- Table structure for jail
+-- ----------------------------
+CREATE TABLE `jail` (
+  `guid` int(11) unsigned NOT NULL COMMENT 'GUID of the jail brother',
+  `char` varchar(13) NOT NULL COMMENT 'Jailed charname',
+  `release` int(11) unsigned NOT NULL COMMENT 'Release time for the char',
+  `amnestietime` int(11) NOT NULL,
+  `reason` varchar(255) NOT NULL COMMENT 'Reason for the jail',
+  `times` int(11) unsigned NOT NULL COMMENT 'How many times this char already was jailed',
+  `gmacc` int(11) unsigned NOT NULL COMMENT 'Used GM acc to jail this char',
+  `gmchar` varchar(13) NOT NULL COMMENT 'Used GM char to jail this char',
+  `lasttime` timestamp NOT NULL default '0000-00-00 00:00:00' on update CURRENT_TIMESTAMP COMMENT 'Last time jailed',
+  `duration` int(11) unsigned NOT NULL default '0' COMMENT 'Duration of the jail',
+  PRIMARY KEY  (`guid`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 COMMENT='Jail table for Trinitycore by WarHead Edited by SPGM';
+
+-- ----------------------------
+-- Records 
+-- ----------------------------
+DROP TABLE IF EXISTS `jail_conf`;
+SET FOREIGN_KEY_CHECKS=0;
+-- ----------------------------
+-- Table structure for jail_conf
+-- ----------------------------
+
+CREATE TABLE `jail_conf` (
+  `id` int(11) NOT NULL auto_increment,
+  `obt` varchar(50) default NULL,
+  `jail_conf` int(11) default NULL,
+  `jail_tele` float default NULL,
+  `help_ger` varchar(255) character set latin1 default '',
+  `help_enq` varchar(255) default '',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM AUTO_INCREMENT=18 DEFAULT CHARSET=utf8;
+
+-- ----------------------------
+-- Records 
+-- ----------------------------
+INSERT INTO `jail_conf` VALUES ('1', 'm_jailconf_max_jails', '3', null, 'Hier legst ihre fest nach wie fielen Jails der Char gelscht werden \r\nStandart = 3\r\n ', 'How many time the characters can be Jailed before being deleted\r\nDefault = 3');
+INSERT INTO `jail_conf` VALUES ('2', 'm_jailconf_max_duration', '672', null, 'Hier legst ihre fest wie hoch der maximale Jail Time in Stunden \r\nStandart = 672\r\n', 'Here put how high the maximum Jail Time in hours\r\nDefault = 672');
+INSERT INTO `jail_conf` VALUES ('3', 'm_jailconf_min_reason', '25', null, 'Hier legst ihre die minimalen Zeichen fest die als Grund angeben msst  \r\nStandart = 25\r\n\r\n', 'Here list how many characters are needed as the minimum reason\r\nDefault = 25');
+INSERT INTO `jail_conf` VALUES ('4', 'm_jailconf_warn_player', '1', null, 'Hier legst ihre fest wann der Char gewarnt wirt  bevor er gelscht wird \r\nStandart = 1\r\n', 'How many time to warn the player before jailing them\r\nDefault = 1');
+INSERT INTO `jail_conf` VALUES ('5', 'm_jailconf_amnestie', '180', null, 'Hier legst ihre in Tagen fest wann der Jail Status  auf 0 zurckgesetzt wird   \r\nStandart = 180 Tage (das entspricht ca.  Jahr)  \r\n                     0  Tage (Aus)\r\n', 'This is how many in days when the Jail is status is set to 0\r\nStandard = 180 days (approximately  year)\r\n                     0 days (off)');
+INSERT INTO `jail_conf` VALUES ('6', 'm_jailconf_ally_x', null, '31.7282', 'Teleport Alliance  X Achse \r\nStandart = 31,7282\r\n', 'Teleport Alliance  X Axis \r\nStandart = 31,7282\r\n');
+INSERT INTO `jail_conf` VALUES ('7', 'm_jailconf_ally_y', null, '135.794', 'Teleport Alliance  Y Achse \r\nStandart = 135,794\r\n', 'Teleport Alliance  Y Axis \r\nStandart = 135,794\r\n');
+INSERT INTO `jail_conf` VALUES ('8', 'm_jailconf_ally_z', null, '-40.0508', 'Teleport Alliance  Z Achse \r\nStandart = -40,0508', 'Teleport Alliance  Z Axis \r\nStandart = -40,0508');
+INSERT INTO `jail_conf` VALUES ('9', 'm_jailconf_ally_o', null, '4.73516', 'Teleport Alliance  blickrichtung\r\nStandart = 4,73516', 'Teleport Alliance  Orientation\r\nStandart = 4,73516');
+INSERT INTO `jail_conf` VALUES ('10', 'm_jailconf_ally_m', '35', null, 'Teleport Alliance  Mape\r\nStandart = 35', 'Teleport Alliance  Map\r\nStandart = 35');
+INSERT INTO `jail_conf` VALUES ('11', 'm_jailconf_horde_x', null, '2179.85', 'Teleport Horde  X Achse \r\nStandart = \r\n', 'Teleport Horde  X Axis \r\nStandart = \r\n');
+INSERT INTO `jail_conf` VALUES ('12', 'm_jailconf_horde_y', null, '-4763.96', 'Teleport Horde  Y Achse \r\nStandart = -4763,96', 'Teleport Horde  Y Axis \r\nStandart = -4763,96');
+INSERT INTO `jail_conf` VALUES ('13', 'm_jailconf_horde_z', null, '54.911', 'Teleport Horde  Z Achse \r\nStandart = 54,911', 'Teleport Horde  Z Axis \r\nStandart = 54,911');
+INSERT INTO `jail_conf` VALUES ('14', 'm_jailconf_horde_o', null, '4.44216', 'Teleport  Horde  blickrichtung\r\nStandart = 4,44216', 'Teleport  Horde  Orientation\r\nStandart = 4,44216');
+INSERT INTO `jail_conf` VALUES ('15', 'm_jailconf_horde_m', '1', null, 'Teleport Horde  Mape\r\nStandart = 1', 'eleport Horde  Map\r\nStandart = 1');
+INSERT INTO `jail_conf` VALUES ('16', 'm_jailconf_ban', '0', null, 'Nach wie vielen Jail soll der  Account Gebant werden\r\nStandart = 0  (aus)\r\n', 'After how many jails the account will be Banned\r\nDefault = 0 (off)');
+INSERT INTO `jail_conf` VALUES ('17', 'm_jailconf_radius', '10', null, 'Legt den Bewegung Radius in Metern waren des Jails fest\r\nStandart = 10\r\n', 'Sets the range of motion in meters of the jail\r\nDefault = 10');
diff --git a/sql/TrinityCore-Patches/TrinityJail/world_command_Deutsch.sql b/sql/TrinityCore-Patches/TrinityJail/world_command_Deutsch.sql
new file mode 100644
index 0000000..5d2589c
--- /dev/null
+++ b/sql/TrinityCore-Patches/TrinityJail/world_command_Deutsch.sql
@@ -0,0 +1,7 @@
+/* World Command Deutsch */
+DELETE FROM `command` WHERE name IN ('jail','jailinfo','unjail','jailreload');
+INSERT INTO `command` (name, permission, help) VALUES
+('jail', 1, 'Syntax: .jail Charakter Stunden Grund\nBuchtet den \'Charakter\' fr \'Stunden\' aus dem \'Grund\' ein.'),
+('jailinfo', 0, 'Syntax: .jailinfo\nZeigt dir deinen Knast-Status an.'),
+('unjail', 1, 'Syntax: .unjail Charakter\nEntlt den \'Charakter\' aus dem Knast.'),
+('jailreload', 3, 'Syntax: .jailreload\nLdt die Jail-Konfiguration neu.');
diff --git a/sql/TrinityCore-Patches/TrinityJail/world_command_English.sql b/sql/TrinityCore-Patches/TrinityJail/world_command_English.sql
new file mode 100644
index 0000000..03333b5
--- /dev/null
+++ b/sql/TrinityCore-Patches/TrinityJail/world_command_English.sql
@@ -0,0 +1,7 @@
+/* World Command English */
+DELETE FROM `command` WHERE name IN ('jail player','jail info','jail release','jail reload');
+INSERT INTO `command` (name, permission, help) VALUES
+('jail player', 1, 'Syntax: .jail player character hours reason\nJailed the \'character\' for \'hours\' with the \'reason\'.'),
+('jail info', 0, 'Syntax: .jailinfo\nShows your jail status.'),
+('jail release', 1, 'Syntax: .release character\nRealeases the \'character\' out of the jail.'),
+('jail reload', 3, 'Syntax: .jailreload\nLoads the jail config new.');
diff --git a/sql/TrinityCore-Patches/TrinityJail/world_command_Francais.sql b/sql/TrinityCore-Patches/TrinityJail/world_command_Francais.sql
new file mode 100644
index 0000000..9c9bdfc
--- /dev/null
+++ b/sql/TrinityCore-Patches/TrinityJail/world_command_Francais.sql
@@ -0,0 +1,7 @@
+/* World Command Francais */
+DELETE FROM `command` WHERE name IN ('jail','jailinfo','unjail','jailreload');
+INSERT INTO `command` (name, permission, help) VALUES
+('jail', 1, 'Syntaxe: .jail #personage #heures #raison\nEmprisonner un \'personnage\' pendant \'heures\' pour la \'raison\'.'),
+('jailinfo', 0, 'Syntaxe: .jailinfo\nVoir le statut de vos emprisonnements.'),
+('unjail', 1, 'Syntaxe: .unjail #personnages\nLibrer le \'personnage\' de la prison.'),
+('jailreload', 3, 'Syntaxe: .jailreload\nRecharger la configuration du Jail.');
diff --git a/sql/TrinityCore-Patches/TrinityJail/world_trinity_string.sql b/sql/TrinityCore-Patches/TrinityJail/world_trinity_string.sql
new file mode 100644
index 0000000..d5cc99c
--- /dev/null
+++ b/sql/TrinityCore-Patches/TrinityJail/world_trinity_string.sql
@@ -0,0 +1,41 @@
+/* World trinity_string */
+SET NAMES 'utf8';
+DELETE FROM trinity_string WHERE `entry` IN (950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983);
+
+INSERT INTO `trinity_string` VALUES 
+('950', 'You are jailed by \'%s\' for %u hour(s)!', null, 'Vous tes emprisonn par \'%s\' pour %u heures!', 'Du wurdest von \'%s\' fr %u Stunde(n) eingebuchtet!', null, null, null, null, null),
+('951', '\'%s\' wrote this as reason: \'%s\'', null, '%s a crit ceci comme tant la raison de votre emprisonnement: %s.', '\'%s\' gab dies als Grund an: \'%s\'', null, null, null, null, null),
+('952', '\'%s\' was jailed by you for %u hour(s).', null, 'Vous avez emprisonn %s pour %u heures!', '\'%s\' wurde von dir fr %u Stunde(n) eingebuchtet.', null, null, null, null, null),
+('953', 'You was released out of the jail by %s.', null, 'Vous avez t liber de la prison par %s.', '\'%s\' hat dich aus dem Knast entlassen.', null, null, null, null, null),
+('954', 'You have released %s out of the jail.', null, 'Vous avez liber \'%s\' de la prison.', 'Du hast \'%s\' aus dem Knast geholt.', null, null, null, null, null),
+('955', 'No reason given or reason is < %u chars!', null, 'Aucune raison d\\\'emprisonnement donne ou la raison est < %u personnages.', 'Du hast keinen Grund angegeben, oder der Grund ist < %u Zeichen!', null, null, null, null, null),
+('956', 'No name given!', null, 'Aucun nom donn!', 'Du hast keinen Namen angegeben!', null, null, null, null, null),
+('957', 'No time given!', null, 'Aucun temps donn!', 'Du hast keine Zeit angegeben!', null, null, null, null, null),
+('958', 'The jailtime must be between 1 and %u hours!', null, 'Le temps d\\\'emprisonnement est situ entre 1 et %u heures!', 'Die Jail-Zeit muss zwischen 1 und %u Std. liegen!', null, null, null, null, null),
+('959', 'The character \'%s\' is not jailed!', null, '\'%s\' n\\\'est pas emprisonn!', 'Der Charakter \'%s\' ist berhaupt nicht im Knast!', null, null, null, null, null),
+('960', 'Command forbidden for jailed characters!', null, 'Commandes interdites pour les personnages emprisons!', 'Sorry, aber das d?rfen Gefangene nicht!', null, null, null, null, null),
+('961', 'You have %u hour(s) left in the jail.', null, 'Vous avez %u heures  attendre avant de quitter la prison.', 'Du musst noch %u Stunde(n) absitzen.', null, null, null, null, null),
+('962', 'You have %u minute(s) left in the jail.', null, 'Vous avez %u minutes attendre avant de quitter la prison.', 'Du musst noch %u Minute(n) absitzen.', null, null, null, null, null),
+('963', 'You\'re a free like a bird! ;-)', null, 'Vous tes libre.', 'Du bist frei wie ein Vogel! ;-)', null, null, null, null, null),
+('964', '%s was %u times jailed and has %u minute(s) left. Last time jailed by %s. Last reason was: \'%s\'', null, '%s a t librde prison, il avait t emprisonn pour %u et a t libr au aprs %u minutes. Il avait t emprisonn par %s, pour la raison suivante: %s', '\'%s\' war bis jetzt %u mal im Knast, und hat noch %u Minute(n) abzusitzen.\n Zuletzt eingebuchtet von: \'%s\'\nLetzter Grund: %s', null, null, null, null, null),
+('965', '\'%s\' was never jailed.', null, '\'%s\' n\\\'a jamais t emprisonn.', '\'%s\' hat eine weie Weste.', null, null, null, null, null),
+('966', 'You can\'t jail yourself!', null, 'Vous ne pouvez pas vous emprisonner vous-m me!', 'Du kannst dich nicht selber einbuchten!', null, null, null, null, null),
+('967', 'You can\'t unjail yourself!', null, 'Vous ne pouvez pas vous librer vous m me!', 'So weit kommt es noch, da Knastbruder sich selber befreien! :-(', null, null, null, null, null),
+('968', '|cffff0000[!!! ATTENTION - IMPORTANT - WARNING !!!\r\n You were already %u times in prison. If you are in Jail for a total of  %u times, your character will be deleted\r\n|cffff0000!!! ATTENTION - IMPORTANT - WARNING !!!]', null, '|cffff0000[!!!ATTENTION - ATTENTION - ATTENTION!!!\r\n Vous tiez dj %u fois en prison en %u fois, votre personnage supprim\r\n|cffff0000!!! ATTENTION - ATTENTION - ATTENTION !!!]', '|cffff0000[!!! ACHTUNG - WICHTIG - WARNUNG !!!\r\n Du warst schon %u mal in Knast beim %u mal wird dein Charakter gelscht\r\n|cffff0000!!! ACHTUNG - WICHTIG - WARNUNG !!!]', null, null, null, null, null),
+('969', 'The character \'', null, 'Le personnage ', 'Der Charakter \'', null, null, null, null, null),
+('970', '\' was jailed for ', null, ' a t emprisonn pour ', '\' wurde fr ', null, null, null, null, null),
+('971', ' hour(s) by the GM character \'', null, ' heure(s) par le MJ ', ' Stunde(n) von dem GM-Charakter \'', null, null, null, null, null),
+('972', '\'. The reason is: ', null, '. La raison est: ', '\' eingebuchtet. Der Grund ist: ', null, null, null, null, null),
+('973', 'The jail configuration was reloaded.', null, 'La configuration de jail a t recharge.', 'Die Gefngnis-Konfiguration wurde neu geladen.', null, null, null, null, null),
+('974', '>> Trinity Jail config loaded.', null, '>> Configuration du jail charge.', '>> Gefngnis-Konfiguration geladen.', null, null, null, null, null),
+('975', 'Can\'t load jail config! Table empty or missed! Use characters_jail.sql!', null, 'Impossible de charger la configuration du jail! Table vide ou innexistante! Appliquez characters_jail.sql!', 'Fehler beim laden der Gef?ngnis-Konfiguration! Der Table \'jail_conf\' ist leer oder nicht vorhanden! Nutze die \'characters_jail.sql\'!', null, null, null, null, null),
+('976', 'Set all jail config settings to default...', null, 'Placez tous les param tres de configuration de prison par d faut.', 'Setze die Konfiguration des Gef?ngnisses auf Standardwerte...', null, null, null, null, null),
+('977', 'The Character \'%s\'  is jailed and teleportet into the jail.', null, 'Le personnage \'%s\'  est emprisonn et t leport dans la prison.', 'Der Charakter \'%s\'  ist ein Knastbruder und wird in den Knast teleportiert.', null, null, null, null, null),
+('978', 'The Character \'%s\'  was released out of the jail.', null, 'Le personnage %s  est liber  de prison.', 'Der Charakter \'%s\'  wurde aus dem Knast entlassen.', null, null, null, null, null),
+('979', 'A character with this name doesn\'t exists!', null, 'Il n\'y a aucun personnage portant ce nom.', 'Ein Charakter mit diesem Namen gibt es nicht!', null, null, null, null, null),
+('980', '|cffff0000[!!! ATTENTION - IMPORTANT - WARNING !!!\r\n You were already %u times in prison. If you are in Jail for a total of  %u times, your account  will be banned!\r\n|cffff0000!!! ATTENTION - IMPORTANT - WARNING !!!]', null, '|cffff0000[!!!ATTENTION - ATTENTION - ATTENTION!!!\r\n Vous avez %u fois en prison en %u fois votre compte sera banni\r\n|cffff0000!!! ATTENTION - ATTENTION - ATTENTION !!!]', '|cffff0000[!!! ACHTUNG - WICHTIG - WARNUNG !!!\r\n Du hast %u mal in Knast beim %u mal wird dein Account gebannt\r\n|cffff0000!!! ACHTUNG - WICHTIG - WARNUNG !!!]', null, null, null, null, null),
+('981', 'Max. jailtimes reached!', null, 'Nombre maximum d\'Jails atteint!', 'Maximale Anzahl an Jails erreicht!', null, null, null, null, null),
+('982', 'Robotron', null, 'Robotron', 'Robotron', null, null, null, null, null),
+('983', 'Your Jail status was reset to 0 ', null, 'Votre statut a t Jail  0 ', 'Dein Jail status wurde auf 0 zurck gesatzt', null, null, null, null, null);
+
+
diff --git a/sql/TrinityCore-Patches/Vote-Rewarder/world.vote-npc.sql b/sql/TrinityCore-Patches/Vote-Rewarder/world.vote-npc.sql
new file mode 100644
index 0000000..5d7a31d
--- /dev/null
+++ b/sql/TrinityCore-Patches/Vote-Rewarder/world.vote-npc.sql
@@ -0,0 +1,3 @@
+DELETE FROM `creature_template` WHERE `entry` = 60005;
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `dmgschool`, `BaseAttackTime`, `RangeAttackTime`, `BaseVariance`, `RangeVariance`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `HealthModifier`, `ManaModifier`, `ArmorModifier`, `DamageModifier`, `ExperienceModifier`, `RacialLeader`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) values
+('60005','0','0','0','0','0','18','0','18','0','George','Vote Rewards','','0','59','61','0','35','1','1.48','1.14286','0','0','0','1500','1900','1','1','1','0','0','0','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','1','3','1','1','1','1','1','1','0','0','1','0','0','npc_vote_rewarder','1');
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/WoWArmory/characters.armory.sql b/sql/TrinityCore-Patches/WoWArmory/characters.armory.sql
new file mode 100644
index 0000000..c816fe8
--- /dev/null
+++ b/sql/TrinityCore-Patches/WoWArmory/characters.armory.sql
@@ -0,0 +1,50 @@
+SET FOREIGN_KEY_CHECKS=0;
+
+-- ----------------------------
+-- Table structure for armory_character_stats
+-- ----------------------------
+DROP TABLE IF EXISTS `armory_character_stats`;
+CREATE TABLE `armory_character_stats` (
+  `guid` int(11) NOT NULL,
+  `data` longtext NOT NULL,
+  `save_date` int(11) DEFAULT NULL,
+  PRIMARY KEY (`guid`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 COMMENT='World of Warcraft Armory table';
+
+-- ----------------------------
+-- Table structure for armory_game_chart
+-- ----------------------------
+DROP TABLE IF EXISTS `armory_game_chart`;
+CREATE TABLE `armory_game_chart` (
+  `gameid` int(11) NOT NULL,
+  `teamid` int(11) NOT NULL,
+  `guid` int(11) NOT NULL,
+  `changeType` int(11) NOT NULL,
+  `ratingChange` int(11) NOT NULL,
+  `teamRating` int(11) NOT NULL,
+  `damageDone` int(11) NOT NULL,
+  `deaths` int(11) NOT NULL,
+  `healingDone` int(11) NOT NULL,
+  `damageTaken` int(11) NOT NULL,
+  `healingTaken` int(11) NOT NULL,
+  `killingBlows` int(11) NOT NULL,
+  `mapId` int(11) NOT NULL,
+  `start` int(11) NOT NULL,
+  `end` int(11) NOT NULL,
+  PRIMARY KEY (`gameid`,`teamid`,`guid`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 COMMENT='WoWArmory Game Chart';
+
+-- ----------------------------
+-- Table structure for character_feed_log
+-- ----------------------------
+DROP TABLE IF EXISTS `character_feed_log`;
+CREATE TABLE `character_feed_log` (
+  `guid` int(11) NOT NULL,
+  `type` smallint(1) NOT NULL,
+  `data` int(11) NOT NULL,
+  `date` int(11) DEFAULT NULL,
+  `counter` int(11) NOT NULL,
+  `difficulty` smallint(6) DEFAULT '-1',
+  `item_guid` int(11) DEFAULT '-1',
+  `item_quality` smallint(6) NOT NULL DEFAULT '-1'
+) ENGINE=MyISAM DEFAULT CHARSET=utf8;
diff --git a/sql/TrinityCore-Patches/WorldChat/auth.worldchat.sql b/sql/TrinityCore-Patches/WorldChat/auth.worldchat.sql
new file mode 100644
index 0000000..256c022
--- /dev/null
+++ b/sql/TrinityCore-Patches/WorldChat/auth.worldchat.sql
@@ -0,0 +1,5 @@
+INSERT INTO `rbac_permissions` (`id`, `name`) VALUES
+(1015, 'Command: world chat');
+
+INSERT INTO `rbac_linked_permissions` (`id`,`linkedId`) VALUES
+(195, 1015);
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/arena1v1/character_v2.0.sql b/sql/TrinityCore-Patches/arena1v1/character_v2.0.sql
new file mode 100644
index 0000000..9f6e4a4
--- /dev/null
+++ b/sql/TrinityCore-Patches/arena1v1/character_v2.0.sql
@@ -0,0 +1,2 @@
+-- Delete all 5v5 teams and members (core will crash if any 5v5 team exist)
+DELETE arena_team_member, arena_team FROM arena_team_member, arena_team WHERE arena_team_member.arenaTeamId = arena_team.arenaTeamId AND arena_team.type = 5;
diff --git a/sql/TrinityCore-Patches/arena1v1/world_v1.0.sql b/sql/TrinityCore-Patches/arena1v1/world_v1.0.sql
new file mode 100644
index 0000000..0222faf
--- /dev/null
+++ b/sql/TrinityCore-Patches/arena1v1/world_v1.0.sql
@@ -0,0 +1,3 @@
+DELETE FROM `creature_template` WHERE `entry` = 535200;
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `dmgschool`, `BaseAttackTime`, `RangeAttackTime`, `BaseVariance`, `RangeVariance`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `HealthModifier`, `ManaModifier`, `ArmorModifier`, `DamageModifier`, `ExperienceModifier`, `RacialLeader`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) VALUES
+('535200','0','0','0','0','0','18','0','18','0','LordPsyan','1v1 Arena master','','0','59','61','0','35','1','1.48','1.14286','0','0','0','1500','1900','1','1','1','0','0','0','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','1','3','1','1','1','1','1','1','0','0','1','0','0','npc_1v1arena','1');
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/beastmaster/world-beastmaster.sql b/sql/TrinityCore-Patches/beastmaster/world-beastmaster.sql
new file mode 100644
index 0000000..45c837a
--- /dev/null
+++ b/sql/TrinityCore-Patches/beastmaster/world-beastmaster.sql
@@ -0,0 +1,65 @@
+DROP TABLE IF EXISTS `beastmaster`;
+
+CREATE TABLE `beastmaster` (
+  `entry` INT(5) NOT NULL DEFAULT '0' COMMENT 'Pet entry number',
+  `cat_number` INT(5) NOT NULL DEFAULT '0' COMMENT '0-normal pet 1-exotic pet 2-pet spell',
+  `tokenOrGold` TINYINT(1) DEFAULT '0' COMMENT '0 = gold 1 = token',
+  `cost` INT(10) NOT NULL DEFAULT '0' COMMENT 'Amount in copper if tokenOrGold is 0 else number of tokens',
+  `token` INT(10) NOT NULL DEFAULT '0' COMMENT 'Token entry number (item_template.entry)',
+  `name` VARCHAR(255) DEFAULT NULL COMMENT 'Name of pet or name of pet spell',
+  `spell` INT(10) NOT NULL DEFAULT '0' COMMENT 'Spell entry number.',
+  PRIMARY KEY (`entry`)
+) ENGINE=INNODB DEFAULT CHARSET=utf8 COMMENT='Beastmaster System by LordPsyan';
+
+/*Data for the table `beastmaster` */
+
+INSERT INTO `beastmaster` (`entry`, `cat_number`, `tokenOrGold`, `cost`, `token`, `name`, `spell`) VALUES
+('1','0','1','1000','0','Spider','2349'),
+('2','0','0','1000','0','Bat','28233'),
+('3','0','0','1000','0','Bear','29319'),
+('4','0','0','1000','0','Boar','29996'),
+('5','0','0','1000','0','Cat','28097'),
+('6','0','0','1000','0','Carrion Bird','26838'),
+('7','0','0','1000','0','Crab','24478'),
+('8','0','0','1000','0','Crocolisk','1417'),
+('9','0','0','1000','0','Dragonhawk','27946'),
+('10','0','0','1000','0','Gorilla','28213'),
+('11','0','0','1000','0','Hyena','13036'),
+('12','0','0','1000','0','Moth','27421'),
+('13','0','0','1000','0','Owl','23136'),
+('14','0','0','1000','0','Raveger','17199'),
+('15','0','0','1000','0','Raptor','14821'),
+('16','0','0','1000','0','Serpent','28358'),
+('17','0','0','1000','0','Bug','28085'),
+('18','0','0','1000','0','Strider','22807'),
+('19','0','0','1000','0','Scorpid','9698'),
+('20','1','0','1000','0','Chimaera','21879'),
+('21','1','0','1000','0','Core Hound','21108'),
+('22','1','0','1000','0','Devilsaur','20931'),
+('23','1','0','1000','0','Rhino','30445'),
+('24','1','0','1000','0','Silithid','5460'),
+('25','1','0','1000','0','Worm','30148'),
+('26','1','0','1000','0','Loque\'nahak','32517'),
+('27','1','0','1000','0','Skoll','35189'),
+('28','1','0','1000','0','Gondria','33776'),
+('29','2','1','1000','0','Feed Pet','6991'),
+('30','2','0','1000','0','Call Pet','883'),
+('31','2','0','1000','0','Dismiss Pet','2641'),
+('32','2','0','1000','0','Mend Pet','136'),
+('33','2','0','1000','0','Revive Pet','982');
+
+-- Beastmaster NPC
+
+DELETE FROM `creature_template` WHERE `entry` = 99990;
+
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `dmgschool`, `BaseAttackTime`, `RangeAttackTime`, `BaseVariance`, `RangeVariance`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `HealthModifier`, `ManaModifier`, `ArmorModifier`, `DamageModifier`, `ExperienceModifier`, `RacialLeader`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) values
+('99990','0','0','0','0','0','26789','0','0','0','LordPsyan','Beastmaster Service','','0','80','80','0','35','129','1','1.14286','0.75','1','0','1500','0','1','1','1','0','0','0','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','1','1','0','0','1','0','0','Npc_Beastmaster','0');
+
+-- Sample npc vendor data for beastmaster
+
+DELETE FROM `npc_vendor` WHERE `entry` = 99990;
+
+INSERT INTO `npc_vendor` (`entry`, `slot`, `item`, `maxcount`, `incrtime`, `ExtendedCost`) VALUES
+('99990','0','4540','0','0','0'),
+('99990','0','4541','0','0','0'),
+('99990','0','4542','0','0','0');
diff --git a/sql/TrinityCore-Patches/enchant/world.enchant.sql b/sql/TrinityCore-Patches/enchant/world.enchant.sql
new file mode 100644
index 0000000..2cd5040
--- /dev/null
+++ b/sql/TrinityCore-Patches/enchant/world.enchant.sql
@@ -0,0 +1,4 @@
+-- Creature template. Young woman enchantress
+DELETE FROM `creature_template` WHERE `entry` = 100067;
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `dmgschool`, `BaseAttackTime`, `RangeAttackTime`, `BaseVariance`, `RangeVariance`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `HealthModifier`, `ManaModifier`, `ArmorModifier`, `DamageModifier`, `ExperienceModifier`, `RacialLeader`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) values
+('100067','0','0','0','0','0','2591','0','0','0','Young Woman','You need it, I got it.','','0','80','80','0','35','1','1','1.14286','1','1','0','1500','0','1','1','1','0','2048','0','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','EventAI','0','3','1','1','1','1','1','1','0','0','1','0','0','npc_enchantment','0');
diff --git a/sql/TrinityCore-Patches/npc_buff/world_npc_buff.sql b/sql/TrinityCore-Patches/npc_buff/world_npc_buff.sql
new file mode 100644
index 0000000..04233a5
--- /dev/null
+++ b/sql/TrinityCore-Patches/npc_buff/world_npc_buff.sql
@@ -0,0 +1,62 @@
+DROP TABLE IF EXISTS `npc_buff_spells`;
+
+CREATE TABLE `npc_buff_spells` (
+  `spell_id` int(5) NOT NULL default '0' COMMENT 'Spell entry number',
+  `cat_number` int(5) NOT NULL default '0' COMMENT '0-small buff 1-great buff 2-gm buff 3-player tools',
+  `cost` int(10) NOT NULL default '0' COMMENT 'cost amount in copper',
+  `name` text COMMENT 'Name of spell',
+  PRIMARY KEY  (`spell_id`)
+) ENGINE=MyISAM DEFAULT CHARSET=latin1;
+
+/*Data for the table `npc_buff_spells` */
+
+INSERT INTO `npc_buff_spells` (`spell_id`, `cat_number`, `cost`, `name`) VALUES
+-- Small Buff
+(48469,1001,10000,"Mark of the Wild"),
+(53307,1002,10000,"Thorns"),
+(43017,1003,10000,"Amplify Magic"),
+(42995,1004,10000,"Arcane Intellect"),
+(61024,1005,10000,"Dalaran Intellect"),
+(43015,1006,10000,"Dampen Magic"),
+(20217,1007,10000,"Blessing of Kings"),
+(48932,1008,10000,"Blessing of Might"),
+(48936,1009,10000,"Blessing of Wisdom"),
+(48072,1010,10000,"Divine Spirit"),
+(48161,1011,10000,"Power Word: Fortitude"),
+(48169,1012,10000,"Shadow Protection"),
+-- Great Buff
+(48470,2001,100000,"Gift of the Wild"),
+(43002,2002,100000,"Arcane Brilliance"),
+(61316,2003,100000,"Dalaran Brilliance"),
+(25898,2004,100000,"Greater Blessing of Kings"),
+(48934,2005,100000,"Greater Blessing of Might"),
+(25899,2006,100000,"Greater Blessing of Sanctuary"),
+(48938,2007,100000,"Greater Blessing of Wisdom"),
+(48162,2008,100000,"Prayer of Fortitude"),
+(48170,2009,100000,"Prayer of Shadow Protection"),
+(48074,2010,100000,"Prayer of Spirit"),
+-- GM Buff
+(17013,3001,0,"Agamaggan's Agility"),
+(16612,3002,0,"Agamaggan's Strength"),
+(58453,3003,0,"Armor Magic"),
+(34106,3004,0,"Armor Penetration"),
+(25661,3005,0,"Increased Stamina"),
+(16610,3006,0,"Razorhide"),
+(10767,3007,0,"Rising Spirit"),
+(16618,3008,0,"Spirit of the Wind"),
+(7764,3009,0,"Wisdom of Agamaggan"),
+-- Player Tools
+(46642,4001,0,"Give me Gold"),
+(24827,4002,0,"Give me Soul Shards"),
+(38588,4003,0,"Heal me please"),
+(53251,4004,0,"Heal me and party members Please"),
+(42956,4005,0,"Conjure Refreshment"),
+(42985,4006,0,"Conjure Mana Gem");
+
+DELETE FROM `creature_template` WHERE `entry` = 60002;
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `dmgschool`, `BaseAttackTime`, `RangeAttackTime`, `BaseVariance`, `RangeVariance`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `HealthModifier`, `ManaModifier`, `ArmorModifier`, `DamageModifier`, `ExperienceModifier`, `RacialLeader`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) values
+('60002','0','0','0','0','0','18','0','18','0','LordPsyan','Buffs master','','0','59','61','0','35','1','1.48','1.14286','0','0','0','1500','1900','1','1','1','0','0','0','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','1','3','1','1','1','1','1','1','0','0','1','0','0','npc_buff','1');
+
+REPLACE INTO `npc_text` (`ID`, `text0_0`) VALUES
+   (100002, 'Choose your Buff Type.'),
+   (100003, 'Choose your Buff.');
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/profession_npc/world_professionnpc.sql b/sql/TrinityCore-Patches/profession_npc/world_professionnpc.sql
new file mode 100644
index 0000000..696d3d7
--- /dev/null
+++ b/sql/TrinityCore-Patches/profession_npc/world_professionnpc.sql
@@ -0,0 +1,4 @@
+DELETE FROM `creature_template` WHERE `entry` = 60001;
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `dmgschool`, `BaseAttackTime`, `RangeAttackTime`, `BaseVariance`, `RangeVariance`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `HealthModifier`, `ManaModifier`, `ArmorModifier`, `DamageModifier`, `ExperienceModifier`, `RacialLeader`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) values
+('60001','0','0','0','0','0','18','0','18','0','Cyon','Profession master','','0','59','61','0','35','1','1.48','1.14286','0','0','0','1500','1900','1','1','1','0','0','0','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','1','3','1','1','1','1','1','1','0','0','1','0','0','professionnpc','1');
+-- end
diff --git a/src/common/Common.h b/src/common/Common.h
index e8adc55..b4661d3 100644
--- a/src/common/Common.h
+++ b/src/common/Common.h
@@ -103,11 +103,16 @@ enum TimeConstants
 
 enum AccountTypes
 {
-    SEC_PLAYER         = 0,
-    SEC_MODERATOR      = 1,
-    SEC_GAMEMASTER     = 2,
-    SEC_ADMINISTRATOR  = 3,
-    SEC_CONSOLE        = 4                                  // must be always last in list, accounts must have less security level always also
+    SEC_PLAYER          = 0,
+    SEC_VIP             = 1,
+    SEC_MODERATOR       = 2,
+    SEC_GAMEMASTER      = 3,
+    SEC_EVENTM          = 4,
+    SEC_HEADGM          = 5,
+    SEC_DEVELOPER       = 6,
+    SEC_ADMINISTRATOR   = 7,
+    SEC_OWNER           = 8,
+    SEC_CONSOLE = 9 // must be always last in list, accounts must have less security level always also
 };
 
 enum LocaleConstant
diff --git a/src/server/database/Database/Implementation/CharacterDatabase.cpp b/src/server/database/Database/Implementation/CharacterDatabase.cpp
index 65dcad6..e02d67a 100644
--- a/src/server/database/Database/Implementation/CharacterDatabase.cpp
+++ b/src/server/database/Database/Implementation/CharacterDatabase.cpp
@@ -142,6 +142,9 @@ void CharacterDatabaseConnection::DoPrepareStatements()
     PrepareStatement(CHAR_UPD_MAIL_RETURNED, "UPDATE mail SET sender = ?, receiver = ?, expire_time = ?, deliver_time = ?, cod = 0, checked = ? WHERE id = ?", CONNECTION_ASYNC);
     PrepareStatement(CHAR_UPD_MAIL_ITEM_RECEIVER, "UPDATE mail_items SET receiver = ? WHERE item_guid = ?", CONNECTION_ASYNC);
     PrepareStatement(CHAR_UPD_ITEM_OWNER, "UPDATE item_instance SET owner_guid = ? WHERE guid = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_GET_EXTERNAL_MAIL, "SELECT id, receiver, subject, message, money, item, item_count FROM mail_external ORDER BY id ASC", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_DEL_EXTERNAL_MAIL, "DELETE FROM mail_external WHERE id = ?", CONNECTION_ASYNC);
+
 
     PrepareStatement(CHAR_SEL_ITEM_REFUNDS, "SELECT player_guid, paidMoney, paidExtendedCost FROM item_refund_instance WHERE item_guid = ? AND player_guid = ? LIMIT 1", CONNECTION_SYNCH);
     PrepareStatement(CHAR_SEL_ITEM_BOP_TRADE, "SELECT allowedPlayers FROM item_soulbound_trade_data WHERE itemGuid = ? LIMIT 1", CONNECTION_SYNCH);
@@ -409,6 +412,7 @@ void CharacterDatabaseConnection::DoPrepareStatements()
     PrepareStatement(CHAR_INS_CHAR_INSTANCE, "INSERT INTO character_instance (guid, instance, permanent) VALUES (?, ?, ?)", CONNECTION_ASYNC);
     PrepareStatement(CHAR_UPD_GENDER_PLAYERBYTES, "UPDATE characters SET gender = ?, playerBytes = ?, playerBytes2 = ? WHERE guid = ?", CONNECTION_ASYNC);
     PrepareStatement(CHAR_DEL_CHARACTER_SKILL, "DELETE FROM character_skills WHERE guid = ? AND skill = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_DEL_JAIL, "DELETE FROM jail WHERE guid = ?", CONNECTION_ASYNC);
     PrepareStatement(CHAR_UPD_ADD_CHARACTER_SOCIAL_FLAGS, "UPDATE character_social SET flags = flags | ? WHERE guid = ? AND friend = ?", CONNECTION_ASYNC);
     PrepareStatement(CHAR_UPD_REM_CHARACTER_SOCIAL_FLAGS, "UPDATE character_social SET flags = flags & ~ ? WHERE guid = ? AND friend = ?", CONNECTION_ASYNC);
     PrepareStatement(CHAR_INS_CHARACTER_SOCIAL, "INSERT INTO character_social (guid, friend, flags) VALUES (?, ?, ?)", CONNECTION_ASYNC);
diff --git a/src/server/database/Database/Implementation/CharacterDatabase.h b/src/server/database/Database/Implementation/CharacterDatabase.h
index d801556..6379ff4 100644
--- a/src/server/database/Database/Implementation/CharacterDatabase.h
+++ b/src/server/database/Database/Implementation/CharacterDatabase.h
@@ -129,6 +129,8 @@ enum CharacterDatabaseStatements
     CHAR_UPD_MAIL_RETURNED,
     CHAR_UPD_MAIL_ITEM_RECEIVER,
     CHAR_UPD_ITEM_OWNER,
+    CHAR_GET_EXTERNAL_MAIL,
+    CHAR_DEL_EXTERNAL_MAIL,
     CHAR_SEL_ITEM_REFUNDS,
     CHAR_SEL_ITEM_BOP_TRADE,
     CHAR_DEL_ITEM_BOP_TRADE,
@@ -336,6 +338,7 @@ enum CharacterDatabaseStatements
     CHAR_INS_CHAR_INSTANCE,
     CHAR_UPD_GENDER_PLAYERBYTES,
     CHAR_DEL_CHARACTER_SKILL,
+    CHAR_DEL_JAIL,
     CHAR_UPD_ADD_CHARACTER_SOCIAL_FLAGS,
     CHAR_UPD_REM_CHARACTER_SOCIAL_FLAGS,
     CHAR_INS_CHARACTER_SOCIAL,
diff --git a/src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp b/src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp
new file mode 100644
index 0000000..7c26762
--- /dev/null
+++ b/src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp
@@ -0,0 +1,377 @@
+/**
+ *
+ * @File : sc_npc_teleport.cpp
+ *
+ * @Authors : Wilibald09
+ *
+ * @Date : 28/08/2008
+ *
+ * @Version : 1.2
+ *
+ **/
+
+#include "Player.h"
+#include "sc_npc_teleport.h"
+#include "WorldSession.h"
+
+#define TELE    nsNpcTel::CatDest
+#define PAGE    nsNpcTel::Page
+#define PAGEI   PAGE::Instance
+
+
+nsNpcTel::VCatDest nsNpcTel::TabCatDest;
+
+
+uint32 PAGE::operator [] (Player * const player) const
+{
+    for (VInst_t i(0); i < m_TabInstance.size(); ++i)
+    {
+        if (m_TabInstance[i].GetPlayer() == player)
+            return m_TabInstance[i].GetPageId();
+    }
+    return 0;
+}
+
+PAGE::Instance & PAGE::operator () (Player * const player)
+{
+    for (VInst_t i(0); i < m_TabInstance.size(); ++i)
+    {
+        if (m_TabInstance[i].GetPlayer() == player)
+            return m_TabInstance[i];
+    }
+    m_TabInstance.push_back(Instance(player));
+    return m_TabInstance.back();
+}
+
+PAGE::Instance & PAGEI::operator = (const uint32 &id)
+{
+    m_PageId = id;
+    return *this;
+}
+
+PAGE::Instance & PAGEI::operator ++ (void)
+{
+    ++m_PageId;
+    return *this;
+}
+
+PAGE::Instance PAGEI::operator ++ (int32)
+{
+    Instance tmp (*this);
+    ++m_PageId;
+    return tmp;
+}
+
+PAGE::Instance & PAGEI::operator -- (void)
+{
+    --m_PageId;
+    return *this;
+}
+
+PAGE::Instance PAGEI::operator -- (int32)
+{
+    Instance tmp (*this);
+    --m_PageId;
+    return tmp;
+}
+
+TELE::CatDest(const uint32 &id, const std::string &name,
+              const Flag &flag, const uint64 &data0, const uint32 &data1)
+    : m_id(id), m_name(name), m_flag(flag), m_data0(data0), m_data1(data1)
+{
+    m_TabDest.clear();
+}
+
+std::string TELE::GetName(const bool IsGM /* = false */) const
+{
+    if (!IsGM || m_flag != FLAG_TEAM)
+        return m_name;
+
+    switch (m_data0)
+    {
+      case TEAM_HORDE:      return std::string(m_name + " (H)");
+      case TEAM_ALLIANCE:   return std::string(m_name + " (A)");
+    }
+    return m_name;
+}
+
+bool TELE::IsAllowedToTeleport(Player * const player) const
+{
+    if (player->IsGameMaster())
+    {
+        if (m_flag == FLAG_GMLEVEL)
+            return player->GetSession()->GetSecurity() >= m_data0;
+        return true;
+    }
+
+    switch (m_flag)
+    {
+      case FLAG_TEAM:
+        switch (m_data0)
+        {
+          case TEAM_HORDE:      return player->GetTeam() == HORDE;
+          case TEAM_ALLIANCE:   return player->GetTeam() == ALLIANCE;
+          case TEAM_ALL:        return true;
+        }
+
+      case FLAG_GUILD:
+        return player->GetGuildId() == m_data0;
+
+      case FLAG_GMLEVEL:
+        return player->GetSession()->GetSecurity() >= m_data0;
+
+      case FLAG_ISGM:
+        return player->IsGameMaster();
+
+      case FLAG_ACCOUNT:
+        return player->GetSession()->GetAccountId() == m_data0;
+
+      case FLAG_LEVEL:
+        return player->getLevel() >= m_data0;
+
+      case FLAG_ITEM:
+        return player->HasItemCount(m_data0, m_data1, true);
+
+      case FLAG_QUEST:
+        if (m_data1 < MAX_QUEST_STATUS)
+            return player->GetQuestStatus(m_data0) == m_data1;
+        return player->GetQuestRewardStatus(m_data0);
+
+      case FLAG_GENDER:
+        return player->getGender() == m_data0;
+
+      case FLAG_RACE:
+        return player->getRace() == m_data0;
+
+      case FLAG_CLASS:
+        return player->getClass() == m_data0;
+
+      case FLAG_REPUTATION:
+        return player->GetReputationRank(m_data0) >= m_data1;
+
+      case FLAG_PLAYER:
+        return player->GetGUID() == m_data0;
+
+      default: TC_LOG_ERROR("misc", "Invalid flag (category: %u). Important problem...", GetCatID());
+    }
+
+    TC_LOG_ERROR("misc", "Invalid flag (category: %u). Important problem...", GetCatID());
+    return false;
+}
+
+uint32 TELE::CountOfCategoryAllowedBy(Player * const player)
+{
+    uint32 count (0);
+    for (VCatDest_t i(0); i < TabCatDest.size(); ++i)
+    {
+        if (TabCatDest[i].IsAllowedToTeleport(player))
+            ++count;
+    }
+    return count;
+}
+
+bool nsNpcTel::IsValidData(const uint32 &cat,   const Flag &flag,
+                           const uint64 &data0, const uint32 &data1)
+{
+    switch(flag)
+    {
+      case FLAG_TEAM:
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        if (data0 < MAX_FLAG_TEAM)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data0 (Team) (category: %u).", cat);
+        return false;
+
+      case FLAG_GUILD:
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data0 (GuildID) (category: %u).", cat);
+        return false;
+
+      case FLAG_GMLEVEL:
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < 256)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data0 (GmLevel) (category: %u).", cat);
+        return false;
+
+      case FLAG_ISGM:
+        if (data0)
+            TC_LOG_ERROR("misc", "Invalid data0 (category: %u).", cat);
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        return true;
+
+      case FLAG_ACCOUNT:
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data0 (AccountID) (category: %u).", cat);
+        return false;
+
+      case FLAG_LEVEL:
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < 256)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data0 (Level) (category: %u).", cat);
+        return false;
+
+      case FLAG_ITEM:
+        if (!data0)
+        {
+            TC_LOG_ERROR("misc", "Invalid data0 (ItemID) (category: %u).", cat);
+            return false;
+        }
+        if (data1)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data1 (Item Count) (category: %u).", cat);
+        return false;
+
+      case FLAG_QUEST:
+        if (!data0)
+        {
+            TC_LOG_ERROR("misc", "Invalid data0 (QuestID) (category: %u).", cat);
+            return false;
+        }
+        if (data1 < MAX_QUEST_STATUS + 1)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data1 (Quest Status) (category: %u).", cat);
+        return false;
+
+      case FLAG_GENDER:
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        if (data0 < GENDER_NONE)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data0 (Gender) (category: %u).", cat);
+        return false;
+
+      case FLAG_RACE:
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < MAX_RACES)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data0 (Race) (category: %u).", cat);
+        return false;
+
+      case FLAG_CLASS:
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < MAX_CLASSES)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data0 (Class) (category: %u).", cat);
+        return false;
+
+      case FLAG_REPUTATION:
+        if (!data0)
+        {
+            TC_LOG_ERROR("misc", "Invalid data0 (Faction/Reputation) (category: %u).", cat);
+            return false;
+        }
+        if (data1 <= REP_EXALTED)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data1 (Faction/Reputation) (category: %u).", cat);
+        return false;
+
+      case FLAG_PLAYER:
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data0 (PlayerGuid) (category: %u).", cat);
+        return false;
+
+      default: TC_LOG_ERROR("misc", "Invalid flag (category: %u).", cat);
+    }
+
+    TC_LOG_ERROR("misc", "Invalid flag (category: %u).", cat);
+    return false;
+}
+
+void LoadNpcTele(void)
+{
+    const char *Table[] =
+    {
+        "custom_npc_tele_category",
+        "custom_npc_tele_destination",
+        "custom_npc_tele_association",
+    };
+
+
+    QueryResult result = WorldDatabase.PQuery(
+        "SELECT `flag`, `data0`, `data1`, `cat_id`, C.`name` `namecat`, D.`name` `namedest`, "
+        //      0        1        2        3                  4                   5
+               "`pos_X`, `pos_Y`, `pos_Z`, `orientation`, `map`, `level`, `cost` "
+        //      6        7        8        9              10     11       12
+        "FROM `%s` C, `%s` D, `%s` A "
+        "WHERE C.`id` = `cat_id` AND D.`id` = `dest_id` "
+        "ORDER BY `namecat`, `cat_id`, `namedest`", Table[0], Table[1], Table[2]);
+
+    nsNpcTel::TabCatDest.clear();
+
+    if (result)
+    {
+        TC_LOG_INFO("server.loading", "Loading %s, %s and %s...", Table[0], Table[1], Table[2]);
+
+        uint32 catid = 0;
+        uint32 nbDest = 0;
+        bool IsValidCat = true;
+        bool FirstTime = true;
+
+        do
+        {
+            Field *fields = result->Fetch();
+
+            if (!IsValidCat && catid == fields[3].GetUInt32() && !FirstTime)
+                continue;
+
+            IsValidCat = true;
+            FirstTime = false;
+
+            if (!nsNpcTel::IsValidData(fields[3].GetUInt32(), (nsNpcTel::Flag)fields[0].GetUInt8(),
+                                       fields[1].GetUInt64(), fields[2].GetUInt32()))
+            {
+                IsValidCat = false;
+                catid = fields[3].GetUInt32();
+                continue;
+            }
+
+            if (catid != fields[3].GetUInt32())
+            {
+                catid = fields[3].GetUInt32();
+                nsNpcTel::CatDest categorie (catid, fields[4].GetString(), (nsNpcTel::Flag)fields[0].GetUInt8(),
+                                             fields[1].GetUInt64(), fields[2].GetUInt32());
+                nsNpcTel::TabCatDest.push_back(categorie);
+            }
+
+            nsNpcTel::Dest item =
+            {
+                fields[5].GetString(),   // Name
+                fields[6].GetFloat(),       // X
+                fields[7].GetFloat(),       // Y
+                fields[8].GetFloat(),       // Z
+                fields[9].GetFloat(),       // Orientation
+                fields[10].GetUInt16(),     // Map
+                fields[11].GetUInt8(),      // Level
+                fields[12].GetUInt32(),     // Cost
+            };
+
+            nsNpcTel::TabCatDest.back().AddDest(item);
+            ++nbDest;
+        } while (result->NextRow());
+
+        TC_LOG_INFO("server.loading", " ");
+        TC_LOG_INFO("server.loading", "Loaded %u npc_teleport.", nbDest);
+    } else TC_LOG_ERROR("misc", "WARNING >> Loaded 0 npc_teleport.");
+}
+
+
+#undef TELE
+#undef PAGE
+#undef PAGEI
diff --git a/src/server/game/AI/ScriptedAI/sc_npc_teleport.h b/src/server/game/AI/ScriptedAI/sc_npc_teleport.h
new file mode 100644
index 0000000..4830245
--- /dev/null
+++ b/src/server/game/AI/ScriptedAI/sc_npc_teleport.h
@@ -0,0 +1,151 @@
+/**
+ *
+ * @File : sc_npc_teleport.h
+ *
+ * @Authors : Wilibald09
+ *
+ * @Date : 19/08/2008
+ *
+ * @Version : 1.2
+ *
+ **/
+
+
+#ifndef SC_NPC_TELEPORT_H
+#define SC_NPC_TELEPORT_H
+
+#include <vector>
+
+
+namespace nsNpcTel
+{
+    // Different types of permissions
+    enum Flag
+    {
+        FLAG_TEAM       = 0,
+        FLAG_GUILD      = 1,
+        FLAG_GMLEVEL    = 2,
+        FLAG_ISGM       = 3,
+        FLAG_ACCOUNT    = 4,
+        FLAG_LEVEL      = 5,
+        FLAG_ITEM       = 6,
+        FLAG_QUEST      = 7,
+        FLAG_GENDER     = 8,
+        FLAG_RACE       = 9,
+        FLAG_CLASS      = 10,
+        FLAG_REPUTATION = 11,
+        FLAG_PLAYER     = 12,
+        MAX_FLAG,
+    };
+
+    // Different parameters of FLAG_TEAM
+    enum
+    {
+        TEAM_ALL        = 0,
+        TEAM_ALLIANCE   = 1,
+        TEAM_HORDE      = 2,
+        MAX_FLAG_TEAM,
+    };
+
+    // Structure representing the destinations
+    struct Dest
+    {
+        std::string m_name;
+        float       m_X, m_Y, m_Z, m_orient;
+        uint16      m_map;
+        uint8       m_level;
+        uint32      m_cost;
+    };
+
+    // Class representing the categories of destinations
+    class CatDest
+    {
+      public:
+
+        typedef std::vector<Dest> VDest;
+        typedef VDest::size_type  VDest_t;
+
+        CatDest(const uint32 &id, const std::string &name,
+                const Flag &flag, const uint64 &data0, const uint32 &data1);
+
+        void   AddDest  (const Dest &item)       { m_TabDest.push_back(item); }
+        Dest   GetDest  (const uint32 &id) const { return m_TabDest[id]; }
+        uint32 GetCatID (void)             const { return m_id; }
+        uint32 size     (void)             const { return m_TabDest.size(); }
+
+        std::string GetName(const bool IsGM = false)    const;
+        bool IsAllowedToTeleport(Player * const player) const;
+
+        static uint32 CountOfCategoryAllowedBy(Player * const player);
+
+      private:
+
+        uint32      m_id;
+        std::string m_name;
+        Flag        m_flag;
+        uint64      m_data0;
+        uint32      m_data1;
+        VDest       m_TabDest;
+    };
+
+    // Class page for current player
+    class Page
+    {
+      protected:
+
+        // Class instance for current player
+        class Instance
+        {
+          public:
+
+            Instance(Player * const player, const uint32 &PageId = 0)
+                : m_player(player), m_PageId(PageId) {}
+
+            Instance & operator =  (const uint32 &id);
+            Instance & operator ++ (void);
+            Instance   operator ++ (int32);
+            Instance & operator -- (void);
+            Instance   operator -- (int32);
+
+            uint32   GetPageId(void) const { return m_PageId; }
+            Player * GetPlayer(void) const { return m_player; }
+
+          private:
+
+            Player *m_player;
+            uint32  m_PageId;
+        };
+
+
+      public:
+
+        typedef std::vector<Instance> VInst;
+        typedef VInst::size_type      VInst_t;
+
+        Page(void) { m_TabInstance.clear(); }
+
+        Instance &   operator () (Player * const player);
+        uint32 operator [] (Player * const player) const;
+
+
+      private:
+
+        VInst m_TabInstance;
+    };
+
+    typedef std::vector <CatDest> VCatDest;
+    typedef VCatDest::size_type   VCatDest_t;
+
+    // Verification of data integrity
+    bool IsValidData(const uint32 &cat,   const Flag &flag,
+                     const uint64 &data0, const uint32 &data1);
+
+    extern VCatDest TabCatDest;
+}
+
+// Loading contents of database
+void LoadNpcTele(void);
+
+extern WorldDatabaseWorkerPool WorldDatabase;
+
+#endif
diff --git a/src/server/game/Accounts/RBAC.h b/src/server/game/Accounts/RBAC.h
index f4f76df..f3a1a23 100644
--- a/src/server/game/Accounts/RBAC.h
+++ b/src/server/game/Accounts/RBAC.h
@@ -699,7 +699,10 @@ enum RBACPermissions
 
     // custom permissions 1000+
     // Prepatch by LordPsyan
-    // 01
+    RBAC_PERM_COMMAND_JAIL                                   = 901,
+    RBAC_PERM_COMMAND_JAIL_INFO                              = 902,
+    RBAC_PERM_COMMAND_JAIL_UN                                = 903,
+    RBAC_PERM_COMMAND_JAIL_RELOAD                            = 904,
     // 02
     // 03
     // 04
@@ -718,7 +721,7 @@ enum RBACPermissions
     // 17
     // 18
     // 19
-    // 20
+    RBAC_PERM_COMMAND_WORLD_CHAT                             = 1015,
     // Visit http://www.realmsofwarcraft.com/bb for forums and information
     //
     // End of prepatch
diff --git a/src/server/game/Achievements/AchievementMgr.cpp b/src/server/game/Achievements/AchievementMgr.cpp
index 90e6182..78d0d9a 100644
--- a/src/server/game/Achievements/AchievementMgr.cpp
+++ b/src/server/game/Achievements/AchievementMgr.cpp
@@ -1512,6 +1512,12 @@ void AchievementMgr::CompletedAchievement(AchievementEntry const* achievement)
         achievement->ID, m_player->GetName().c_str(), m_player->GetGUID().GetCounter());
 
     SendAchievementEarned(achievement);
+
+    /** World of Warcraft Armory **/
+    if (sWorld->getBoolConfig(CONFIG_ARMORY_ENABLE))
+        GetPlayer()->CreateWowarmoryFeed(1, achievement->ID, 0, 0);
+    /** World of Warcraft Armory **/
+
     CompletedAchievementData& ca = m_completedAchievements[achievement->ID];
     ca.date = time(NULL);
     ca.changed = true;
diff --git a/src/server/game/Battlegrounds/Arena.cpp b/src/server/game/Battlegrounds/Arena.cpp
index 1ccf310..d8fb60b 100644
--- a/src/server/game/Battlegrounds/Arena.cpp
+++ b/src/server/game/Battlegrounds/Arena.cpp
@@ -40,9 +40,9 @@ Arena::Arena()
 void Arena::AddPlayer(Player* player)
 {
     Battleground::AddPlayer(player);
-    PlayerScores[player->GetGUID().GetCounter()] = new ArenaScore(player->GetGUID(), player->GetBGTeam());
+    PlayerScores[player->GetGUID().GetCounter()] = new ArenaScore(player->GetGUID(), player->GetTeam());
 
-    if (player->GetBGTeam() == ALLIANCE)        // gold
+    if (player->GetTeam() == ALLIANCE)       // gold
     {
         if (player->GetTeam() == HORDE)
             player->CastSpell(player, SPELL_HORDE_GOLD_FLAG, true);
@@ -171,7 +171,50 @@ void Arena::EndBattleground(uint32 winner)
 
                 _arenaTeamScores[winnerTeam].Assign(winnerChange, winnerMatchmakerRating, winnerArenaTeam->GetName());
                 _arenaTeamScores[loserTeam].Assign(loserChange, loserMatchmakerRating, loserArenaTeam->GetName());
-
+                /** World of Warcraft Armory **/
+                if (sWorld->getBoolConfig(CONFIG_ARMORY_ENABLE))
+                {
+                    uint32 maxChartID;
+                    QueryResult result = CharacterDatabase.PQuery("SELECT MAX(gameid) FROM armory_game_chart");
+                    if(!result)
+                        maxChartID = 0;
+                    else
+                    {
+                        maxChartID = (*result)[0].GetUInt32();
+                        //result.release();
+                    }
+                    uint32 gameID = maxChartID+1;
+                    for(BattlegroundScoreMap::const_iterator itr = PlayerScores.begin(); itr != PlayerScores.end(); ++itr)
+                    {
+                        Player* player = ObjectAccessor::FindConnectedPlayer(ObjectGuid(HighGuid::Player, itr->first));
+                        if (!player)
+                            continue;
+                        uint32 plTeamID = player->GetArenaTeamId(winnerArenaTeam->GetSlot());
+                        int changeType;
+                        uint32 resultRating;
+                        uint32 resultTeamID;
+                        int32 ratingChange;
+                        if (plTeamID == winnerArenaTeam->GetId())
+                        {
+                            changeType = 1; //win
+                            resultRating = winnerTeamRating;
+                            resultTeamID = plTeamID;
+                            ratingChange = winnerChange;
+                        }
+                        else
+                        {
+                            changeType = 2; //lose
+                            resultRating = loserTeamRating;
+                            resultTeamID = loserArenaTeam->GetId();
+                            ratingChange = loserChange;
+                        }
+                        std::ostringstream sql_query;
+                        //                                                        gameid,              teamid,                     guid,                    changeType,             ratingChange,               teamRating,                  damageDone,                          deaths,                          healingDone,                           damageTaken,,                           healingTaken,                         killingBlows,                      mapId,                 start,                   end
+                        sql_query << "INSERT INTO armory_game_chart VALUES ('" << gameID << "', '" << resultTeamID << "', '" << player->GetGUID() << "', '" << changeType << "', '" << ratingChange  << "', '" << resultRating << "', '" << itr->second->DamageDone << "', '" << itr->second->Deaths << "', '" << itr->second->HealingDone << "', '" << itr->second->DamageTaken << "', '" << itr->second->HealingTaken << "', '" << itr->second->KillingBlows << "', '" << m_MapId << "', '" << m_StartTime << "', '" << m_EndTime << "')";
+                        CharacterDatabase.Execute(sql_query.str().c_str());
+                    }
+                }
+                /** World of Warcraft Armory **/
                 TC_LOG_DEBUG("bg.arena", "Arena match Type: %u for Team1Id: %u - Team2Id: %u ended. WinnerTeamId: %u. Winner rating: +%d, Loser rating: %d",
                     GetArenaType(), GetArenaTeamIdByIndex(TEAM_ALLIANCE), GetArenaTeamIdByIndex(TEAM_HORDE), winnerArenaTeam->GetId(), winnerChange, loserChange);
 
diff --git a/src/server/game/Battlegrounds/ArenaTeam.cpp b/src/server/game/Battlegrounds/ArenaTeam.cpp
index ec007df..5b490d7 100644
--- a/src/server/game/Battlegrounds/ArenaTeam.cpp
+++ b/src/server/game/Battlegrounds/ArenaTeam.cpp
@@ -439,7 +439,7 @@ void ArenaTeam::Query(WorldSession* session)
     WorldPacket data(SMSG_ARENA_TEAM_QUERY_RESPONSE, 4*7+GetName().size()+1);
     data << uint32(GetId());                                // team id
     data << GetName();                                      // team name
-    data << uint32(GetType());                              // arena team type (2=2x2, 3=3x3 or 5=5x5)
+    data << uint32(GetType() == 1 ? 5 : GetType());         // arena team type (2=2x2, 3=3x3 or 1=1x1(modify 1 to 5, so player can see arenateam in 5v5 slot))
     data << uint32(BackgroundColor);                        // background color
     data << uint32(EmblemStyle);                            // emblem style
     data << uint32(EmblemColor);                            // emblem color
@@ -611,6 +611,8 @@ uint32 ArenaTeam::GetPoints(uint32 memberRating)
         points *= 0.76f;
     else if (Type == ARENA_TEAM_3v3)
         points *= 0.88f;
+    else if (Type == ARENA_TEAM_5v5) // 1v1 Arena
+        points *= sWorld->getFloatConfig(CONFIG_ARENA_1V1_ARENAPOINTS_MULTI);
 
     points *= sWorld->getRate(RATE_ARENA_POINTS);
 
diff --git a/src/server/game/Battlegrounds/ArenaTeam.h b/src/server/game/Battlegrounds/ArenaTeam.h
index f27c376..58bc0a3 100644
--- a/src/server/game/Battlegrounds/ArenaTeam.h
+++ b/src/server/game/Battlegrounds/ArenaTeam.h
@@ -82,7 +82,7 @@ enum ArenaTeamTypes
 {
     ARENA_TEAM_2v2      = 2,
     ARENA_TEAM_3v3      = 3,
-    ARENA_TEAM_5v5      = 5
+    ARENA_TEAM_5v5      = 1 // 1v1 Arena - 5v5 doesn't exist anymore
 };
 
 struct ArenaTeamMember
diff --git a/src/server/game/Battlegrounds/Battleground.cpp b/src/server/game/Battlegrounds/Battleground.cpp
index 100e2e6..528afea 100644
--- a/src/server/game/Battlegrounds/Battleground.cpp
+++ b/src/server/game/Battlegrounds/Battleground.cpp
@@ -147,6 +147,7 @@ Battleground::Battleground()
     m_StartMaxDist      = 0.0f;
     ScriptId            = 0;
 
+
     m_ArenaTeamIds[TEAM_ALLIANCE]   = 0;
     m_ArenaTeamIds[TEAM_HORDE]      = 0;
 
@@ -286,7 +287,7 @@ inline void Battleground::_CheckSafePositions(uint32 diff)
             if (Player* player = ObjectAccessor::FindPlayer(itr->first))
             {
                 Position pos = player->GetPosition();
-                Position const* startPos = GetTeamStartPosition(Battleground::GetTeamIndexByTeamId(player->GetBGTeam()));
+                Position const* startPos = GetTeamStartPosition(Battleground::GetTeamIndexByTeamId(player->GetTeam()));
                 if (pos.GetExactDistSq(startPos) > maxDist)
                 {
                     TC_LOG_DEBUG("bg.battleground", "BATTLEGROUND: Sending %s back to start location (map: %u) (possible exploit)", player->GetName().c_str(), GetMapId());
@@ -467,6 +468,11 @@ inline void Battleground::_ProcessJoin(uint32 diff)
         // First start warning - 2 or 1 minute
         SendMessageToAll(StartMessageIds[BG_STARTING_EVENT_FIRST], CHAT_MSG_BG_SYSTEM_NEUTRAL);
     }
+
+    // 1v1 Arena - Start arena after 15s, when all players are in arena
+    if(GetArenaType() == ARENA_TYPE_5v5 && GetStartDelayTime() > StartDelayTimes[BG_STARTING_EVENT_THIRD] && (m_PlayersCount[0] + m_PlayersCount[1]) == 2)
+        SetStartDelayTime(StartDelayTimes[BG_STARTING_EVENT_THIRD]);
+
     // After 1 minute or 30 seconds, warning is signaled
     else if (GetStartDelayTime() <= StartDelayTimes[BG_STARTING_EVENT_SECOND] && !(m_Events & BG_STARTING_EVENT_2))
     {
@@ -501,9 +507,10 @@ inline void Battleground::_ProcessJoin(uint32 diff)
                     WorldPacket status;
                     BattlegroundQueueTypeId bgQueueTypeId = sBattlegroundMgr->BGQueueTypeId(m_TypeID, GetArenaType());
                     uint32 queueSlot = player->GetBattlegroundQueueIndex(bgQueueTypeId);
-                    sBattlegroundMgr->BuildBattlegroundStatusPacket(&status, this, queueSlot, STATUS_IN_PROGRESS, 0, GetStartTime(), GetArenaType(), player->GetBGTeam());
+                    sBattlegroundMgr->BuildBattlegroundStatusPacket(&status, this, queueSlot, STATUS_IN_PROGRESS, 0, GetStartTime(), GetArenaType(), player->GetTeam());
                     player->SendDirectMessage(&status);
 
+
                     player->RemoveAurasDueToSpell(SPELL_ARENA_PREPARATION);
                     player->ResetAllPowers();
                     if (!player->IsGameMaster())
@@ -526,6 +533,7 @@ inline void Battleground::_ProcessJoin(uint32 diff)
                     }
                 }
 
+
             CheckWinConditions();
         }
         else
@@ -670,22 +678,37 @@ void Battleground::RewardHonorToTeam(uint32 Honor, uint32 TeamID)
             UpdatePlayerScore(player, SCORE_BONUS_HONOR, Honor);
 }
 
-void Battleground::RewardReputationToTeam(uint32 faction_id, uint32 Reputation, uint32 TeamID)
+void Battleground::RewardReputationToTeam(uint32 a_faction_id, uint32 h_faction_id, uint32 Reputation, uint32 TeamID)
 {
-    FactionEntry const* factionEntry = sFactionStore.LookupEntry(faction_id);
-    if (!factionEntry)
-        return;
+    FactionEntry const* a_factionEntry = sFactionStore.LookupEntry(a_faction_id);
+    FactionEntry const* h_factionEntry = sFactionStore.LookupEntry(h_faction_id);
 
     for (BattlegroundPlayerMap::const_iterator itr = m_Players.begin(); itr != m_Players.end(); ++itr)
     {
         Player* player = _GetPlayerForTeam(TeamID, itr, "RewardReputationToTeam");
-        if (!player)
-            continue;
+        if (!a_factionEntry || !h_factionEntry)
+             return;
 
-        uint32 repGain = Reputation;
-        AddPct(repGain, player->GetTotalAuraModifier(SPELL_AURA_MOD_REPUTATION_GAIN));
-        AddPct(repGain, player->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_FACTION_REPUTATION_GAIN, faction_id));
-        player->GetReputationMgr().ModifyReputation(factionEntry, repGain);
+        for (BattlegroundPlayerMap::const_iterator itr = m_Players.begin(); itr != m_Players.end(); ++itr)
+             {
+            if (itr->second.OfflineRemoveTime)
+                 continue;
+            
+                Player* player = ObjectAccessor::FindPlayer(itr->first);
+            
+                if (!player)
+                 {
+                TC_LOG_ERROR("bg.battleground", "BattleGround:RewardReputationToTeam: %u not found!", itr->first);
+                continue;
+                }
+            uint32 team = player->GetTeam();
+            if (team == TeamID)
+                
+                if (Player* player = _GetPlayerForTeam(TeamID, itr, "RewardReputationToTeam"))
+                 {
+                player->GetReputationMgr().ModifyReputation(player->GetCFSTeam() == ALLIANCE ? a_factionEntry : h_factionEntry, Reputation);
+                }
+            }
     }
 }
 
@@ -802,6 +825,8 @@ void Battleground::EndBattleground(uint32 winner)
             stmt->setUInt32(6,  score->second->GetBonusHonor());
             stmt->setUInt32(7,  score->second->GetDamageDone());
             stmt->setUInt32(8,  score->second->GetHealingDone());
+            stmt->setUInt32(8,  score->second->GetDamageTaken());
+            stmt->setUInt32(8,  score->second->GetHealingTaken());
             stmt->setUInt32(9,  score->second->GetAttr1());
             stmt->setUInt32(10, score->second->GetAttr2());
             stmt->setUInt32(11, score->second->GetAttr3());
@@ -811,6 +836,11 @@ void Battleground::EndBattleground(uint32 winner)
             CharacterDatabase.Execute(stmt);
         }
 
+
+
+
+
+
         // Reward winner team
         if (team == winner)
         {
@@ -823,6 +853,7 @@ void Battleground::EndBattleground(uint32 winner)
                     player->SetRandomWinner(true);
             }
 
+
             player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_WIN_BG, 1);
         }
         else
@@ -839,7 +870,7 @@ void Battleground::EndBattleground(uint32 winner)
         player->SendDirectMessage(&pvpLogData);
 
         WorldPacket data;
-        sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, this, player->GetBattlegroundQueueIndex(bgQueueTypeId), STATUS_IN_PROGRESS, TIME_TO_AUTOREMOVE, GetStartTime(), GetArenaType(), player->GetBGTeam());
+        sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, this, player->GetBattlegroundQueueIndex(bgQueueTypeId), STATUS_IN_PROGRESS, TIME_TO_AUTOREMOVE, GetStartTime(), GetArenaType(), player->GetTeam());
         player->SendDirectMessage(&data);
         player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_BATTLEGROUND, 1);
     }
@@ -958,6 +989,7 @@ void Battleground::RemovePlayerAtLeave(ObjectGuid guid, bool Transport, bool Sen
 
     if (player)
     {
+        player->FitPlayerInTeam(false, this);
         // Do next only if found in battleground
         player->SetBattlegroundId(0, BATTLEGROUND_TYPE_NONE);  // We're not in BG.
         // reset destination bg team
@@ -1026,7 +1058,7 @@ void Battleground::AddPlayer(Player* player)
 
     // score struct must be created in inherited class
 
-    uint32 team = player->GetBGTeam();
+    uint32 team = player->GetTeam();
 
     BattlegroundPlayer bp;
     bp.OfflineRemoveTime = 0;
@@ -1077,6 +1109,7 @@ void Battleground::AddPlayer(Player* player)
     // setup BG group membership
     PlayerAddedToBGCheckIfBGIsRunning(player);
     AddOrSetPlayerToCorrectBgGroup(player, team);
+    player->FitPlayerInTeam(true, this);
 }
 
 // this method adds player to his team's bg group, or sets his correct group if player is already in bg group
@@ -1146,8 +1179,8 @@ void Battleground::EventPlayerLoggedOut(Player* player)
 
         // 1 player is logging out, if it is the last, then end arena!
         if (isArena())
-            if (GetAlivePlayersCountByTeam(player->GetBGTeam()) <= 1 && GetPlayersCountByTeam(GetOtherTeam(player->GetBGTeam())))
-                EndBattleground(GetOtherTeam(player->GetBGTeam()));
+            if (GetAlivePlayersCountByTeam(player->GetTeam()) <= 1 && GetPlayersCountByTeam(GetOtherTeam(player->GetTeam())))
+                 EndBattleground(GetOtherTeam(player->GetTeam()));
     }
 }
 
@@ -1639,6 +1672,7 @@ void Battleground::SendWarningToAll(uint32 entry, ...)
                 vsnprintf(str, 1024, format, ap);
                 va_end(ap);
 
+
                 ChatHandler::BuildChatPacket(localizedPackets[player->GetSession()->GetSessionDbLocaleIndex()], CHAT_MSG_RAID_BOSS_EMOTE, LANG_UNIVERSAL, NULL, NULL, str);
             }
 
@@ -1770,7 +1804,7 @@ void Battleground::PlayerAddedToBGCheckIfBGIsRunning(Player* player)
     BuildPvPLogDataPacket(data);
     player->SendDirectMessage(&data);
 
-    sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, this, player->GetBattlegroundQueueIndex(bgQueueTypeId), STATUS_IN_PROGRESS, GetEndTime(), GetStartTime(), GetArenaType(), player->GetBGTeam());
+    sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, this, player->GetBattlegroundQueueIndex(bgQueueTypeId), STATUS_IN_PROGRESS, GetEndTime(), GetStartTime(), GetArenaType(), player->GetTeam());
     player->SendDirectMessage(&data);
 }
 
diff --git a/src/server/game/Battlegrounds/Battleground.h b/src/server/game/Battlegrounds/Battleground.h
index 03f138a..937089f 100644
--- a/src/server/game/Battlegrounds/Battleground.h
+++ b/src/server/game/Battlegrounds/Battleground.h
@@ -183,7 +183,7 @@ enum ArenaType
 {
     ARENA_TYPE_2v2          = 2,
     ARENA_TYPE_3v3          = 3,
-    ARENA_TYPE_5v5          = 5
+    ARENA_TYPE_5v5          = 1 // 1v1 Arena - 5v5 doesn't exist anymore
 };
 
 enum BattlegroundStartingEvents
@@ -365,7 +365,7 @@ class Battleground
         void CastSpellOnTeam(uint32 SpellID, uint32 TeamID);
         void RemoveAuraOnTeam(uint32 SpellID, uint32 TeamID);
         void RewardHonorToTeam(uint32 Honor, uint32 TeamID);
-        void RewardReputationToTeam(uint32 faction_id, uint32 Reputation, uint32 TeamID);
+        void RewardReputationToTeam(uint32 a_faction_id, uint32 h_faction_id, uint32 Reputation, uint32 TeamID);
         void UpdateWorldState(uint32 Field, uint32 Value);
         void UpdateWorldStateForPlayer(uint32 Field, uint32 Value, Player* player);
         virtual void EndBattleground(uint32 winner);
@@ -520,7 +520,7 @@ class Battleground
 
         ArenaTeamScore _arenaTeamScores[BG_TEAMS_COUNT];
 
-    private:
+    public:
         // Battleground
         BattlegroundTypeId m_TypeID;
         BattlegroundTypeId m_RandomTypeID;
@@ -602,7 +602,7 @@ class Battleground
         uint32 m_MaxPlayers;
         uint32 m_MinPlayersPerTeam;
         uint32 m_MinPlayers;
-
+    public:
         // Start location
         uint32 m_MapId;
         BattlegroundMap* m_Map;
diff --git a/src/server/game/Battlegrounds/BattlegroundMgr.cpp b/src/server/game/Battlegrounds/BattlegroundMgr.cpp
index 062d470..9874959 100644
--- a/src/server/game/Battlegrounds/BattlegroundMgr.cpp
+++ b/src/server/game/Battlegrounds/BattlegroundMgr.cpp
@@ -421,7 +421,7 @@ Battleground* BattlegroundMgr::CreateNewBattleground(BattlegroundTypeId original
                 maxPlayersPerTeam = 3;
                 break;
             case ARENA_TYPE_5v5:
-                maxPlayersPerTeam = 5;
+                maxPlayersPerTeam = 1; // 1v1 Arena
                 break;
         }
 
@@ -693,7 +693,7 @@ void BattlegroundMgr::SendToBattleground(Player* player, uint32 instanceId, Batt
     if (Battleground* bg = GetBattleground(instanceId, bgTypeId))
     {
         uint32 mapid = bg->GetMapId();
-        uint32 team = player->GetBGTeam();
+        uint32 team = player->GetTeam();
         if (team == 0)
             team = player->GetTeam();
 
diff --git a/src/server/game/Battlegrounds/BattlegroundQueue.cpp b/src/server/game/Battlegrounds/BattlegroundQueue.cpp
index 34588c7..99b04d3 100644
--- a/src/server/game/Battlegrounds/BattlegroundQueue.cpp
+++ b/src/server/game/Battlegrounds/BattlegroundQueue.cpp
@@ -154,6 +154,10 @@ GroupQueueInfo* BattlegroundQueue::AddGroup(Player* leader, Group* grp, Battlegr
         index += BG_TEAMS_COUNT;
     if (ginfo->Team == HORDE)
         index++;
+
+    if (sWorld->getBoolConfig(CROSSFACTION_SYSTEM_BATTLEGROUNDS) && ArenaType == 0)
+        index = BG_QUEUE_CROSSFACTION;
+
     TC_LOG_DEBUG("bg.battleground", "Adding Group to BattlegroundQueue bgTypeId : %u, bracket_id : %u, index : %u", BgTypeId, bracketId, index);
 
     uint32 lastOnlineTime = getMSTime();
@@ -163,6 +167,7 @@ GroupQueueInfo* BattlegroundQueue::AddGroup(Player* leader, Group* grp, Battlegr
     {
         ArenaTeam* Team = sArenaTeamMgr->GetArenaTeamById(arenateamid);
         if (Team)
+            if ((Team->GetType() == ARENA_TYPE_5v5 && sWorld->getBoolConfig(CONFIG_ARENA_1V1_ANNOUNCER)) || Team->GetType() != ARENA_TYPE_5v5)
             sWorld->SendWorldText(LANG_ARENA_QUEUE_ANNOUNCE_WORLD_JOIN, Team->GetName().c_str(), ginfo->ArenaType, ginfo->ArenaType, ginfo->ArenaTeamRating);
     }
 
@@ -198,30 +203,58 @@ GroupQueueInfo* BattlegroundQueue::AddGroup(Player* leader, Group* grp, Battlegr
         {
             if (Battleground* bg = sBattlegroundMgr->GetBattlegroundTemplate(ginfo->BgTypeId))
             {
-                uint32 MinPlayers = bg->GetMinPlayersPerTeam();
-                uint32 qHorde = 0;
-                uint32 qAlliance = 0;
-                uint32 q_min_level = bracketEntry->minLevel;
-                uint32 q_max_level = bracketEntry->maxLevel;
-                GroupsQueueType::const_iterator itr;
-                for (itr = m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_ALLIANCE].begin(); itr != m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_ALLIANCE].end(); ++itr)
-                    if (!(*itr)->IsInvitedToBGInstanceGUID)
-                        qAlliance += (*itr)->Players.size();
-                for (itr = m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_HORDE].begin(); itr != m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_HORDE].end(); ++itr)
-                    if (!(*itr)->IsInvitedToBGInstanceGUID)
-                        qHorde += (*itr)->Players.size();
-
-                // Show queue status to player only (when joining queue)
-                if (sWorld->getBoolConfig(CONFIG_BATTLEGROUND_QUEUE_ANNOUNCER_PLAYERONLY))
+                if (sWorld->getBoolConfig(CROSSFACTION_SYSTEM_BATTLEGROUNDS))
                 {
-                    ChatHandler(leader->GetSession()).PSendSysMessage(LANG_BG_QUEUE_ANNOUNCE_SELF, bg->GetName().c_str(), q_min_level, q_max_level,
-                        qAlliance, (MinPlayers > qAlliance) ? MinPlayers - qAlliance : (uint32)0, qHorde, (MinPlayers > qHorde) ? MinPlayers - qHorde : (uint32)0);
+                    char const* bgName = bg->GetName().c_str();
+                    uint32 MinPlayers = bg->GetMinPlayersPerTeam() * 2;
+                    uint32 qPlayers = 0;
+                    uint32 q_min_level = bracketEntry->minLevel;
+                    uint32 q_max_level = bracketEntry->maxLevel;
+                    for (GroupsQueueType::const_iterator itr = m_QueuedGroups[bracketId][BG_QUEUE_CROSSFACTION].begin(); itr != m_QueuedGroups[bracketId][BG_QUEUE_CROSSFACTION].end(); ++itr)
+                         if (!(*itr)->IsInvitedToBGInstanceGUID)
+                         qPlayers += (*itr)->Players.size();
+                    
+                        if (sWorld->getBoolConfig(CONFIG_BATTLEGROUND_QUEUE_ANNOUNCER_PLAYERONLY))
+                         {
+                        ChatHandler(leader->GetSession()).PSendSysMessage("Queue status for %s (Lvl: %u to %u) Queued players: %u (Need at least %u more)", bgName, q_min_level, q_max_level, qPlayers, MinPlayers - qPlayers);
+                        }
+                    else
+                         {
+                        std::ostringstream ss;
+                        ss << "|cffff0000[BG Queue Announcer]:|r " << bgName << " -- [" << q_min_level << "-" << q_max_level << "] " << qPlayers << "/" << MinPlayers;
+                        sWorld->SendGlobalText(ss.str().c_str(), NULL);
+                        }
                 }
                 // System message
                 else
                 {
-                    sWorld->SendWorldText(LANG_BG_QUEUE_ANNOUNCE_WORLD, bg->GetName().c_str(), q_min_level, q_max_level,
-                        qAlliance, (MinPlayers > qAlliance) ? MinPlayers - qAlliance : (uint32)0, qHorde, (MinPlayers > qHorde) ? MinPlayers - qHorde : (uint32)0);
+                    //      std::string bgName = bg->GetName().c_str();
+                    char const* bgName = bg->GetName().c_str();
+                    uint32 MinPlayers = bg->GetMinPlayersPerTeam();
+                    uint32 qHorde = 0;
+                    uint32 qAlliance = 0;
+                    uint32 q_min_level = bracketEntry->minLevel;
+                    uint32 q_max_level = bracketEntry->maxLevel;
+                    GroupsQueueType::const_iterator itr;
+                    for (itr = m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_ALLIANCE].begin(); itr != m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_ALLIANCE].end(); ++itr)
+                         if (!(*itr)->IsInvitedToBGInstanceGUID)
+                        qAlliance += (*itr)->Players.size();
+                    for (itr = m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_HORDE].begin(); itr != m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_HORDE].end(); ++itr)
+                         if (!(*itr)->IsInvitedToBGInstanceGUID)
+                        qHorde += (*itr)->Players.size();
+                    
+                                                               // Show queue status to player only (when joining queue)
+                        if (sWorld->getBoolConfig(CONFIG_BATTLEGROUND_QUEUE_ANNOUNCER_PLAYERONLY))
+                        {
+                        ChatHandler(leader->GetSession()).PSendSysMessage(LANG_BG_QUEUE_ANNOUNCE_SELF, bgName, q_min_level, q_max_level, //******
+                            qAlliance, (MinPlayers > qAlliance) ? MinPlayers - qAlliance : (uint32)0, qHorde, (MinPlayers > qHorde) ? MinPlayers - qHorde : (uint32)0);
+                        }
+                              // System message
+                        else
+                         {
+                        sWorld->SendWorldText(LANG_BG_QUEUE_ANNOUNCE_WORLD, bgName, q_min_level, q_max_level, //*******
+                            qAlliance, (MinPlayers > qAlliance) ? MinPlayers - qAlliance : (uint32)0, qHorde, (MinPlayers > qHorde) ? MinPlayers - qHorde : (uint32)0);
+                        }
                 }
             }
         }
@@ -309,7 +342,7 @@ void BattlegroundQueue::RemovePlayer(ObjectGuid guid, bool decreaseInvitedCount)
     {
         //we must check premade and normal team's queue - because when players from premade are joining bg,
         //they leave groupinfo so we can't use its players size to find out index
-        for (uint32 j = index; j < BG_QUEUE_GROUP_TYPES_COUNT; j += BG_TEAMS_COUNT)
+        for (uint8 j = 0; j < BG_QUEUE_GROUP_TYPES_COUNT; ++j)
         {
             GroupsQueueType::iterator k = m_QueuedGroups[bracket_id_tmp][j].begin();
             for (; k != m_QueuedGroups[bracket_id_tmp][j].end(); ++k)
@@ -355,6 +388,7 @@ void BattlegroundQueue::RemovePlayer(ObjectGuid guid, bool decreaseInvitedCount)
     // announce to world if arena team left queue for rated match, show only once
     if (group->ArenaType && group->IsRated && group->Players.empty() && sWorld->getBoolConfig(CONFIG_ARENA_QUEUE_ANNOUNCER_ENABLE))
         if (ArenaTeam* Team = sArenaTeamMgr->GetArenaTeamById(group->ArenaTeamId))
+            if (Team && ((Team->GetType() == ARENA_TYPE_5v5 && sWorld->getBoolConfig(CONFIG_ARENA_1V1_ANNOUNCER)) || Team->GetType() != ARENA_TYPE_5v5))
             sWorld->SendWorldText(LANG_ARENA_QUEUE_ANNOUNCE_WORLD_EXIT, Team->GetName().c_str(), group->ArenaType, group->ArenaType, group->ArenaTeamRating);
 
     // if player leaves queue and he is invited to rated arena match, then he have to lose
@@ -500,6 +534,10 @@ void BattlegroundQueue::FillPlayersToBG(Battleground* bg, BattlegroundBracketId
     uint32 aliCount   = m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_ALLIANCE].size();
     uint32 hordeCount = m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_HORDE].size();
 
+    if (!bg->isArena())
+         if (FillXPlayersToBG(bracket_id, bg, false))
+         return;
+
     // try to get even teams
     if (sWorld->getIntConfig(CONFIG_BATTLEGROUND_INVITATION_TYPE) == BG_QUEUE_INVITATION_TYPE_EVEN)
     {
@@ -773,7 +811,8 @@ void BattlegroundQueue::BattlegroundQueueUpdate(uint32 /*diff*/, BattlegroundTyp
     if (m_QueuedGroups[bracket_id][BG_QUEUE_PREMADE_ALLIANCE].empty() &&
         m_QueuedGroups[bracket_id][BG_QUEUE_PREMADE_HORDE].empty() &&
         m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_ALLIANCE].empty() &&
-        m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_HORDE].empty())
+        m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_HORDE].empty() &&
+        m_QueuedGroups[bracket_id][BG_QUEUE_CROSSFACTION].empty())
         return;
 
     // battleground with free slot for player should be always in the beggining of the queue
@@ -864,7 +903,8 @@ void BattlegroundQueue::BattlegroundQueueUpdate(uint32 /*diff*/, BattlegroundTyp
     {
         // if there are enough players in pools, start new battleground or non rated arena
         if (CheckNormalMatch(bg_template, bracket_id, MinPlayersPerTeam, MaxPlayersPerTeam)
-            || (bg_template->isArena() && CheckSkirmishForSameFaction(bracket_id, MinPlayersPerTeam)))
+            || (bg_template->isArena() && CheckSkirmishForSameFaction(bracket_id, MinPlayersPerTeam))
+            || CheckCrossFactionMatch(bracket_id, bg_template))
         {
             // we successfully created a pool
             Battleground* bg2 = sBattlegroundMgr->CreateNewBattleground(bgTypeId, bracketEntry, arenaType, false);
diff --git a/src/server/game/Battlegrounds/BattlegroundQueue.h b/src/server/game/Battlegrounds/BattlegroundQueue.h
index 31f1080..72ab6c1 100644
--- a/src/server/game/Battlegrounds/BattlegroundQueue.h
+++ b/src/server/game/Battlegrounds/BattlegroundQueue.h
@@ -42,6 +42,7 @@ struct GroupQueueInfo                                       // stores informatio
 {
     std::map<ObjectGuid, PlayerQueueInfo*> Players;         // player queue info map
     uint32  Team;                                           // Player team (ALLIANCE/HORDE)
+    uint32  CFSTeam;
     BattlegroundTypeId BgTypeId;                            // battleground type id
     bool    IsRated;                                        // rated
     uint8   ArenaType;                                      // 2v2, 3v3, 5v5 or 0 when BG
@@ -60,9 +61,10 @@ enum BattlegroundQueueGroupTypes
     BG_QUEUE_PREMADE_ALLIANCE   = 0,
     BG_QUEUE_PREMADE_HORDE      = 1,
     BG_QUEUE_NORMAL_ALLIANCE    = 2,
-    BG_QUEUE_NORMAL_HORDE       = 3
+    BG_QUEUE_NORMAL_HORDE = 3,
+    BG_QUEUE_CROSSFACTION = 4
 };
-#define BG_QUEUE_GROUP_TYPES_COUNT 4
+#define BG_QUEUE_GROUP_TYPES_COUNT 5
 
 enum BattlegroundQueueInvitationType
 {
@@ -81,6 +83,11 @@ class BattlegroundQueue
         void BattlegroundQueueUpdate(uint32 diff, BattlegroundTypeId bgTypeId, BattlegroundBracketId bracket_id, uint8 arenaType = 0, bool isRated = false, uint32 minRating = 0);
         void UpdateEvents(uint32 diff);
 
+        bool FillXPlayersToBG(BattlegroundBracketId bracket_id, Battleground* bg, bool start = false);
+        typedef std::multimap<int32, GroupQueueInfo*> QueuedGroupMap;
+        int32 PreAddPlayers(QueuedGroupMap m_PreGroupMap, int32 MaxAdd, uint32 MaxInTeam);
+        bool CheckCrossFactionMatch(BattlegroundBracketId bracket_id, Battleground* bg);
+
         void FillPlayersToBG(Battleground* bg, BattlegroundBracketId bracket_id);
         bool CheckPremadeMatch(BattlegroundBracketId bracket_id, uint32 MinPlayersPerTeam, uint32 MaxPlayersPerTeam);
         bool CheckNormalMatch(Battleground* bg_template, BattlegroundBracketId bracket_id, uint32 minPlayers, uint32 maxPlayers);
diff --git a/src/server/game/Battlegrounds/BattlegroundScore.h b/src/server/game/Battlegrounds/BattlegroundScore.h
index 428dece..c6650d6 100644
--- a/src/server/game/Battlegrounds/BattlegroundScore.h
+++ b/src/server/game/Battlegrounds/BattlegroundScore.h
@@ -47,7 +47,11 @@ enum ScoreType
 
     // SOTA
     SCORE_DESTROYED_DEMOLISHER  = 16,
-    SCORE_DESTROYED_WALL        = 17
+    SCORE_DESTROYED_WALL        = 17,
+    /** World of Warcraft Armory **/
+    SCORE_DAMAGE_TAKEN          = 18,
+    SCORE_HEALING_TAKEN         = 19
+    /** World of Warcraft Armory **/
 };
 
 struct BattlegroundScore
@@ -57,7 +61,7 @@ struct BattlegroundScore
 
     protected:
         BattlegroundScore(ObjectGuid playerGuid) : PlayerGuid(playerGuid), KillingBlows(0), Deaths(0),
-            HonorableKills(0), BonusHonor(0), DamageDone(0), HealingDone(0) { }
+            HonorableKills(0), BonusHonor(0), DamageDone(0), HealingDone(0), DamageTaken(0), HealingTaken(0) { }
 
         virtual ~BattlegroundScore() { }
 
@@ -83,6 +87,14 @@ struct BattlegroundScore
                 case SCORE_HEALING_DONE:    // Healing Done
                     HealingDone += value;
                     break;
+    /** World of Warcraft Armory **/
+                case SCORE_DAMAGE_TAKEN:    // Damage Taken
+                    DamageTaken += value;
+                    break;
+                case SCORE_HEALING_TAKEN:    // Healing Taken
+                    HealingTaken += value;
+                    break;
+    /** World of Warcraft Armory **/
                 default:
                     ASSERT(false && "Not implemented Battleground score type!");
                     break;
@@ -99,7 +111,10 @@ struct BattlegroundScore
             data << uint32(BonusHonor);
             data << uint32(DamageDone);
             data << uint32(HealingDone);
-
+    /** World of Warcraft Armory **/
+            data << uint32(DamageTaken);
+            data << uint32(HealingTaken);
+    /** World of Warcraft Armory **/
             BuildObjectivesBlock(data);
         }
 
@@ -114,12 +129,17 @@ struct BattlegroundScore
         uint32 GetBonusHonor() const      { return BonusHonor; }
         uint32 GetDamageDone() const      { return DamageDone; }
         uint32 GetHealingDone() const     { return HealingDone; }
-
+    /** World of Warcraft Armory **/
+        uint32 GetDamageTaken() const     { return DamageTaken; }
+        uint32 GetHealingTaken() const    { return HealingTaken; }
+    /** World of Warcraft Armory **/
         virtual uint32 GetAttr1() const { return 0; }
         virtual uint32 GetAttr2() const { return 0; }
         virtual uint32 GetAttr3() const { return 0; }
         virtual uint32 GetAttr4() const { return 0; }
         virtual uint32 GetAttr5() const { return 0; }
+        virtual uint32 GetAttr6() const { return 0; }
+        virtual uint32 GetAttr7() const { return 0; }
 
         ObjectGuid PlayerGuid;
 
@@ -130,6 +150,8 @@ struct BattlegroundScore
         uint32 BonusHonor;
         uint32 DamageDone;
         uint32 HealingDone;
+        uint32 DamageTaken;
+        uint32 HealingTaken;
 };
 
 #endif // TRINITY_BATTLEGROUND_SCORE_H
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp
index 8341511..162f590 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp
@@ -139,7 +139,7 @@ void BattlegroundAB::PostUpdateImpl(uint32 diff)
 
                 if (m_ReputationScoreTics[team] >= m_ReputationTics)
                 {
-                    (team == TEAM_ALLIANCE) ? RewardReputationToTeam(509, 10, ALLIANCE) : RewardReputationToTeam(510, 10, HORDE);
+                    RewardReputationToTeam(509, 510, 10, team == ALLIANCE ? ALLIANCE : HORDE);
                     m_ReputationScoreTics[team] -= m_ReputationTics;
                 }
 
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundAV.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundAV.cpp
index f7ee5c7..92eac6b 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundAV.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundAV.cpp
@@ -87,7 +87,7 @@ void BattlegroundAV::HandleKillUnit(Creature* unit, Player* killer)
     if (entry == BG_AV_CreatureInfo[AV_NPC_A_BOSS])
     {
         CastSpellOnTeam(23658, HORDE); //this is a spell which finishes a quest where a player has to kill the boss
-        RewardReputationToTeam(729, BG_AV_REP_BOSS, HORDE);
+        RewardReputationToTeam(729, 730, BG_AV_REP_BOSS, killer->GetTeam() == ALLIANCE ? ALLIANCE : HORDE);
         RewardHonorToTeam(GetBonusHonorFromKill(BG_AV_KILL_BOSS), HORDE);
         EndBattleground(HORDE);
         DelCreature(AV_CPLACE_TRIGGER17);
@@ -95,7 +95,7 @@ void BattlegroundAV::HandleKillUnit(Creature* unit, Player* killer)
     else if (entry == BG_AV_CreatureInfo[AV_NPC_H_BOSS])
     {
         CastSpellOnTeam(23658, ALLIANCE); //this is a spell which finishes a quest where a player has to kill the boss
-        RewardReputationToTeam(730, BG_AV_REP_BOSS, ALLIANCE);
+        RewardReputationToTeam(729, 730, BG_AV_REP_BOSS, killer->GetTeam() == ALLIANCE ? ALLIANCE : HORDE);
         RewardHonorToTeam(GetBonusHonorFromKill(BG_AV_KILL_BOSS), ALLIANCE);
         EndBattleground(ALLIANCE);
         DelCreature(AV_CPLACE_TRIGGER19);
@@ -108,7 +108,7 @@ void BattlegroundAV::HandleKillUnit(Creature* unit, Player* killer)
             return;
         }
         m_CaptainAlive[0]=false;
-        RewardReputationToTeam(729, BG_AV_REP_CAPTAIN, HORDE);
+        RewardReputationToTeam(729, 730, BG_AV_REP_CAPTAIN, killer->GetTeam() == ALLIANCE ? ALLIANCE : HORDE);
         RewardHonorToTeam(GetBonusHonorFromKill(BG_AV_KILL_CAPTAIN), HORDE);
         UpdateScore(ALLIANCE, (-1)*BG_AV_RES_CAPTAIN);
         //spawn destroyed aura
@@ -127,7 +127,7 @@ void BattlegroundAV::HandleKillUnit(Creature* unit, Player* killer)
             return;
         }
         m_CaptainAlive[1]=false;
-        RewardReputationToTeam(730, BG_AV_REP_CAPTAIN, ALLIANCE);
+        RewardReputationToTeam(729, 730, BG_AV_REP_CAPTAIN, killer->GetTeam() == ALLIANCE ? ALLIANCE : HORDE);
         RewardHonorToTeam(GetBonusHonorFromKill(BG_AV_KILL_CAPTAIN), ALLIANCE);
         UpdateScore(HORDE, (-1)*BG_AV_RES_CAPTAIN);
         //spawn destroyed aura
@@ -149,6 +149,7 @@ void BattlegroundAV::HandleQuestComplete(uint32 questid, Player* player)
     if (GetStatus() != STATUS_IN_PROGRESS)
         return;//maybe we should log this, cause this must be a cheater or a big bug
     uint8 team = GetTeamIndexByTeamId(player->GetTeam());
+    uint8 CFSteam = GetTeamIndexByTeamId(GetOtherTeam(player->GetTeam()));
     /// @todo add reputation, events (including quest not available anymore, next quest available, go/npc de/spawning)and maybe honor
     TC_LOG_DEBUG("bg.battleground", "BG_AV Quest %i completed", questid);
     switch (questid)
@@ -173,21 +174,21 @@ void BattlegroundAV::HandleQuestComplete(uint32 questid, Player* player)
         case AV_QUEST_A_COMMANDER1:
         case AV_QUEST_H_COMMANDER1:
             m_Team_QuestStatus[team][1]++;
-            RewardReputationToTeam(team, 1, player->GetTeam());
+            RewardReputationToTeam(team, CFSteam, 1, player->GetTeam());
             if (m_Team_QuestStatus[team][1] == 30)
                 TC_LOG_DEBUG("bg.battleground", "BG_AV Quest %i completed (need to implement some events here", questid);
             break;
         case AV_QUEST_A_COMMANDER2:
         case AV_QUEST_H_COMMANDER2:
             m_Team_QuestStatus[team][2]++;
-            RewardReputationToTeam(team, 1, player->GetTeam());
+            RewardReputationToTeam(team, CFSteam, 1, player->GetTeam());
             if (m_Team_QuestStatus[team][2] == 60)
                 TC_LOG_DEBUG("bg.battleground", "BG_AV Quest %i completed (need to implement some events here", questid);
             break;
         case AV_QUEST_A_COMMANDER3:
         case AV_QUEST_H_COMMANDER3:
             m_Team_QuestStatus[team][3]++;
-            RewardReputationToTeam(team, 1, player->GetTeam());
+            RewardReputationToTeam(team, CFSteam, 1, player->GetTeam());
             if (m_Team_QuestStatus[team][3] == 120)
                 TC_LOG_DEBUG("bg.battleground", "BG_AV Quest %i completed (need to implement some events here", questid);
             break;
@@ -469,7 +470,7 @@ void BattlegroundAV::EndBattleground(uint32 winner)
             rep[i]   += BG_AV_REP_SURVIVING_CAPTAIN;
         }
         if (rep[i] != 0)
-            RewardReputationToTeam(i == 0 ? 730 : 729, rep[i], i == 0 ? ALLIANCE : HORDE);
+            RewardReputationToTeam(729, 730, 10, i == ALLIANCE ? ALLIANCE : HORDE);
         if (kills[i] != 0)
             RewardHonorToTeam(GetBonusHonorFromKill(kills[i]), i == 0 ? ALLIANCE : HORDE);
     }
@@ -574,7 +575,7 @@ void BattlegroundAV::EventPlayerDestroyedPoint(BG_AV_Nodes node)
             SpawnBGObject(BG_AV_OBJECT_BURN_DUNBALDAR_SOUTH + i + (tmp * 10), RESPAWN_IMMEDIATELY);
 
         UpdateScore((owner == ALLIANCE) ? HORDE : ALLIANCE, -1 * BG_AV_RES_TOWER);
-        RewardReputationToTeam(owner == ALLIANCE ? 730 : 729, BG_AV_REP_TOWER, owner);
+        RewardReputationToTeam(729, 730, BG_AV_REP_TOWER, owner);
         RewardHonorToTeam(GetBonusHonorFromKill(BG_AV_KILL_TOWER), owner);
 
         SpawnBGObject(BG_AV_OBJECT_TAURA_A_DUNBALDAR_SOUTH+GetTeamIndexByTeamId(owner)+(2*tmp), RESPAWN_ONE_DAY);
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundWS.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundWS.cpp
index bc1ee3d..bf13781 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundWS.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundWS.cpp
@@ -307,7 +307,7 @@ void BattlegroundWS::EventPlayerCapturedFlag(Player* player)
         if (GetTeamScore(TEAM_ALLIANCE) < BG_WS_MAX_TEAM_SCORE)
             AddPoint(ALLIANCE, 1);
         PlaySoundToAll(BG_WS_SOUND_FLAG_CAPTURED_ALLIANCE);
-        RewardReputationToTeam(890, m_ReputationCapture, ALLIANCE);
+        
     }
     else
     {
@@ -326,8 +326,9 @@ void BattlegroundWS::EventPlayerCapturedFlag(Player* player)
         if (GetTeamScore(TEAM_HORDE) < BG_WS_MAX_TEAM_SCORE)
             AddPoint(HORDE, 1);
         PlaySoundToAll(BG_WS_SOUND_FLAG_CAPTURED_HORDE);
-        RewardReputationToTeam(889, m_ReputationCapture, HORDE);
+       
     }
+    RewardReputationToTeam(890, 889, m_ReputationCapture, player->GetTeam());
     //for flag capture is reward 2 honorable kills
     RewardHonorToTeam(GetBonusHonorFromKill(2), player->GetTeam());
 
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
index aae5b48..488757b 100644
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -46,9 +46,11 @@ file(GLOB_RECURSE sources_Spells Spells/*.cpp Spells/*.h)
 file(GLOB_RECURSE sources_Texts Texts/*.cpp Texts/*.h)
 file(GLOB_RECURSE sources_Tools Tools/*.cpp Tools/*.h)
 file(GLOB_RECURSE sources_Tickets Tickets/*.cpp Tickets/*.h)
+file(GLOB_RECURSE sources_TriniChat TriniChat/*.cpp TriniChat/*.h)
 file(GLOB_RECURSE sources_Warden Warden/*.cpp Warden/*.h)
 file(GLOB_RECURSE sources_Weather Weather/*.cpp Weather/*.h)
 file(GLOB_RECURSE sources_World World/*.cpp World/*.h)
+file(GLOB_RECURSE sources_Cfbg Cfbg/*.cpp Cfbg/*.h)
 
 # Create game-libary
 
@@ -95,11 +97,13 @@ set(game_STAT_SRCS
   ${sources_Skills}
   ${sources_Spells}
   ${sources_Texts}
+  ${sources_TriniChat}
   ${sources_Tools}
   ${sources_Tickets}
   ${sources_Warden}
   ${sources_Weather}
   ${sources_World}
+  ${sources_Cfbg}
 )
 
 include_directories(
@@ -167,6 +171,7 @@ include_directories(
   ${CMAKE_CURRENT_SOURCE_DIR}/Texts
   ${CMAKE_CURRENT_SOURCE_DIR}/Tickets
   ${CMAKE_CURRENT_SOURCE_DIR}/Tools
+  ${CMAKE_CURRENT_SOURCE_DIR}/TriniChat
   ${CMAKE_CURRENT_SOURCE_DIR}/Warden
   ${CMAKE_CURRENT_SOURCE_DIR}/Warden/Modules
   ${CMAKE_CURRENT_SOURCE_DIR}/Weather
diff --git a/src/server/game/Cfbg/Cfbg.cpp b/src/server/game/Cfbg/Cfbg.cpp
new file mode 100644
index 0000000..e7a5867
--- /dev/null
+++ b/src/server/game/Cfbg/Cfbg.cpp
@@ -0,0 +1,363 @@
+/*
++ * Copyright (C) 2013-2015 MegaSource <http://www.megasource.com.br>
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms of the GNU General Public License as published by the
++ * Free Software Foundation; either version 2 of the License, or (at your
++ * option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but WITHOUT
++ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
++ * more details.
++ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+
+#include "Cfbg.h"
+#include "Battleground.h"
+#include "BattlegroundMgr.h"
+#include "Player.h"
+#include "Chat.h"
+#include "BattlegroundQueue.h"
+
+/*####################################################################################
+###############################CROSSFACTION BATTLEGROUNDS#############################
+####################################################################################*/
+uint8 Unit::getRace(bool forceoriginal) const
+{
+       if (GetTypeId() == TYPEID_PLAYER)
+       {
+               Player* pPlayer = ((Player*)this);
+
+               if (forceoriginal)
+                       return pPlayer->getCFSRace();
+
+               if (pPlayer->InArena())
+                       return GetByteValue(UNIT_FIELD_BYTES_0, 0);
+
+               if (!pPlayer->IsPlayingNative())
+                       return pPlayer->getFRace();
+       }
+
+       return GetByteValue(UNIT_FIELD_BYTES_0, 0);
+}
+
+bool Player::SendRealNameQuery()
+{
+       if (IsPlayingNative())
+               return false;
+
+       WorldPacket data(SMSG_NAME_QUERY_RESPONSE, (8 + 1 + 1 + 1 + 1 + 1 + 10));
+       data.appendPackGUID(GetGUID());                             // player guid
+       data << uint8(0);                                       // added in 3.1; if > 1, then end of packet
+       data << GetName();                                   // played name
+       data << uint8(0);                                       // realm name for cross realm BG usage
+       data << uint8(getCFSRace());
+       data << uint8(getGender());
+       data << uint8(getClass());
+       data << uint8(0);                                   // is not declined
+       GetSession()->SendPacket(&data);
+
+       return true;
+}
+
+void Player::SetFakeRaceAndMorph()
+{
+       if (getClass() == CLASS_DRUID)
+       {
+               if (GetCFSTeam() == ALLIANCE)
+               {
+                       m_FakeMorph = getGender() == GENDER_MALE ? FAKE_M_TAUREN : FAKE_F_TAUREN;
+                       m_FakeRace = RACE_TAUREN;
+               }
+               else if (getGender() == GENDER_MALE) // HORDE PLAYER, ONLY HAVE MALE NELF ID
+               {
+                       m_FakeMorph = FAKE_M_NELF;
+                       m_FakeRace = RACE_NIGHTELF;
+               }
+               else
+                       m_FakeRace = GetCFSTeam() == ALLIANCE ? RACE_BLOODELF : RACE_HUMAN;
+       }
+       else if (getClass() == CLASS_SHAMAN && GetCFSTeam() == HORDE && getGender() == GENDER_FEMALE)
+       {
+               m_FakeMorph = FAKE_F_DRAENEI; // Female Draenei
+               m_FakeRace = RACE_DRAENEI;
+       }
+       else
+       {
+               m_FakeRace = GetCFSTeam() == ALLIANCE ? RACE_BLOODELF : RACE_HUMAN;
+
+               if (GetCFSTeam() == HORDE)
+               {
+                       if (getGender() == GENDER_MALE)
+                               m_FakeMorph = 19723;
+                       else
+                               m_FakeMorph = 19724;
+               }
+               else
+               {
+                       if (getGender() == GENDER_MALE)
+                               m_FakeMorph = 20578;
+                       else
+                               m_FakeMorph = 20579;
+               }
+       }
+}
+
+bool Player::SendBattleGroundChat(uint32 msgtype, std::string message)
+{
+       // Select distance to broadcast to.
+       float distance = msgtype == CHAT_MSG_SAY ? sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_SAY) : sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_YELL);
+
+       if (Battleground* pBattleGround = GetBattleground())
+       {
+               if (pBattleGround->isArena()) // Only fake chat in BG's. CFBG should not interfere with arenas.
+                       return false;
+
+               for (Battleground::BattlegroundPlayerMap::const_iterator itr = pBattleGround->GetPlayers().begin(); itr != pBattleGround->GetPlayers().end(); ++itr)
+               {
+                       if (Player* pPlayer = ObjectAccessor::FindPlayer(itr->first))
+                       {
+                               if (GetDistance2d(pPlayer->GetPositionX(), pPlayer->GetPositionY()) <= distance)
+                               {
+                                       WorldPacket data(SMSG_MESSAGECHAT, 200);
+
+                                       if (GetTeam() == pPlayer->GetTeam())
+                                       {
+                                               WorldPacket data;
+                                               ChatHandler::BuildChatPacket(data, ChatMsg(msgtype), LANG_UNIVERSAL, pPlayer, NULL, message);
+                                           pPlayer->GetSession()->SendPacket(&data);
+                                       }
+                                       else if (msgtype != CHAT_MSG_EMOTE)
+                                       {
+                                               WorldPacket data;
+                                               ChatHandler::BuildChatPacket(data, ChatMsg(msgtype), pPlayer->GetTeam() == ALLIANCE ? LANG_ORCISH : LANG_COMMON, pPlayer, NULL, message);
+                                               pPlayer->GetSession()->SendPacket(&data);
+                                       }
+                                       pPlayer->GetSession()->SendPacket(&data);
+                               }
+                       }
+               }
+               return true;
+       }
+       else
+               return false;
+}
+
+void Player::MorphFit(bool value)
+{
+       if (!IsPlayingNative() && value)
+       {
+               SetDisplayId(GetFakeMorph());
+               SetNativeDisplayId(GetFakeMorph());
+       }
+       else
+               InitDisplayIds();
+}
+
+void Player::FitPlayerInTeam(bool action, Battleground* pBattleGround)
+{
+       if (!pBattleGround)
+               pBattleGround = GetBattleground();
+
+       if ((!pBattleGround || pBattleGround->isArena()) && action)
+               return;
+
+       if (!IsPlayingNative() && action)
+               setFactionForRace(getRace());
+       else
+               setFactionForRace(getCFSRace());
+
+       if (action)
+               SetForgetBGPlayers(true);
+       else
+              SetForgetInListPlayers(true);
+
+       MorphFit(action);
+
+       if (pBattleGround && action)
+              SendChatMessage("%sYou are playing for the %s%s in this %s", MSG_COLOR_WHITE, GetTeam() == ALLIANCE ? MSG_COLOR_DARKBLUE"alliance" : MSG_COLOR_RED"horde", MSG_COLOR_WHITE, pBattleGround->GetName().c_str());
+}
+
+void Player::DoForgetPlayersInList()
+{
+       // m_FakePlayers is filled from a vector within the battleground
+       // they were in previously so all players that have been in that BG will be invalidated.
+       for (FakePlayers::const_iterator itr = m_FakePlayers.begin(); itr != m_FakePlayers.end(); ++itr)
+       {
+               WorldPacket data(SMSG_INVALIDATE_PLAYER, 8);
+               data << *itr;
+               GetSession()->SendPacket(&data);
+               if (Player* pPlayer = ObjectAccessor::FindPlayer(ObjectGuid(*itr)))
+       //      if (Player* pPlayer = ObjectAccessor::FindPlayer(*itr))
+                       GetSession()->SendNameQueryOpcode(pPlayer->GetGUID());
+       }
+       m_FakePlayers.clear();
+}
+
+void Player::DoForgetPlayersInBG(Battleground* pBattleGround)
+{
+       for (Battleground::BattlegroundPlayerMap::const_iterator itr = pBattleGround->GetPlayers().begin(); itr != pBattleGround->GetPlayers().end(); ++itr)
+       {
+               // Here we invalidate players in the bg to the added player
+               WorldPacket data1(SMSG_INVALIDATE_PLAYER, 8);
+               data1 << itr->first;
+               GetSession()->SendPacket(&data1);
+
+               if (Player* pPlayer = ObjectAccessor::FindPlayer(itr->first))
+               {
+                       GetSession()->SendNameQueryOpcode(pPlayer->GetGUID()); // Send namequery answer instantly if player is available
+                       // Here we invalidate the player added to players in the bg
+                       WorldPacket data2(SMSG_INVALIDATE_PLAYER, 8);
+                       data2 << GetGUID();
+                       pPlayer->GetSession()->SendPacket(&data2);
+                       pPlayer->GetSession()->SendNameQueryOpcode(GetGUID());
+               }
+       }
+}
+
+bool BattlegroundQueue::CheckCrossFactionMatch(BattlegroundBracketId bracket_id, Battleground* bg)
+{
+       if (!sWorld->getBoolConfig(CROSSFACTION_SYSTEM_BATTLEGROUNDS) || bg->isArena())
+               return false; // Only do this if crossbg's are enabled.
+
+       // Here we will add all players to selectionpool, later we check if there are enough and launch a bg.
+       FillXPlayersToBG(bracket_id, bg, true);
+
+       if (sBattlegroundMgr->isTesting() && (m_SelectionPools[TEAM_ALLIANCE].GetPlayerCount() || m_SelectionPools[TEAM_HORDE].GetPlayerCount()))
+               return true;
+
+       uint8 MPT = bg->GetMinPlayersPerTeam();
+       if (m_SelectionPools[TEAM_ALLIANCE].GetPlayerCount() < MPT || m_SelectionPools[TEAM_HORDE].GetPlayerCount() < MPT)
+               return false;
+
+       return true;
+}
+
+// This function will invite players in the least populated faction, which makes battleground queues much faster.
+// This function will return true if cross faction battlegrounds are enabled, otherwise return false,
+// which is useful in FillPlayersToBG. Because then we can interrupt the regular invitation if cross faction bg's are enabled.
+bool BattlegroundQueue::FillXPlayersToBG(BattlegroundBracketId bracket_id, Battleground* bg, bool start)
+{
+       uint8 queuedPeople = 0;
+       for (GroupsQueueType::const_iterator itr = m_QueuedGroups[bracket_id][BG_QUEUE_CROSSFACTION].begin(); itr != m_QueuedGroups[bracket_id][BG_QUEUE_CROSSFACTION].end(); ++itr)
+               if (!(*itr)->IsInvitedToBGInstanceGUID)
+                       queuedPeople += (*itr)->Players.size();
+
+               if (sWorld->getBoolConfig(CROSSFACTION_SYSTEM_BATTLEGROUNDS) && (sBattlegroundMgr->isTesting() || queuedPeople >= bg->GetMinPlayersPerTeam() * 2 || !start))
+       {
+               int32 aliFree = start ? bg->GetMaxPlayersPerTeam() : bg->GetFreeSlotsForTeam(ALLIANCE);
+               int32 hordeFree = start ? bg->GetMaxPlayersPerTeam() : bg->GetFreeSlotsForTeam(HORDE);
+              // Empty selection pools. They will be refilled from queued groups.
+               m_SelectionPools[TEAM_ALLIANCE].Init();
+               m_SelectionPools[TEAM_HORDE].Init();
+               int32 valiFree = aliFree;
+               int32 vhordeFree = hordeFree;
+               int32 diff = 0;
+
+
+               // Add teams to their own factions as far as possible.
+               if (start)
+               {
+                       QueuedGroupMap m_PreGroupMap_a, m_PreGroupMap_h;
+                       int32 m_SmallestOfTeams = 0;
+                       int32 queuedAlliance = 0;
+                       int32 queuedHorde = 0;
+
+                       for (GroupsQueueType::const_iterator itr = m_QueuedGroups[bracket_id][BG_QUEUE_CROSSFACTION].begin(); itr != m_QueuedGroups[bracket_id][BG_QUEUE_CROSSFACTION].end(); ++itr)
+                       {
+                               if ((*itr)->IsInvitedToBGInstanceGUID)
+                                       continue;
+
+                               bool alliance = (*itr)->CFSTeam == ALLIANCE;
+
+                               if (alliance)
+                               {
+                                       m_PreGroupMap_a.insert(std::make_pair((*itr)->Players.size(), *itr));
+                                       queuedAlliance += (*itr)->Players.size();
+                               }
+                               else
+                               {
+                                       m_PreGroupMap_h.insert(std::make_pair((*itr)->Players.size(), *itr));
+                                       queuedHorde += (*itr)->Players.size();
+                               }
+                       }
+
+                       m_SmallestOfTeams = std::min(std::min(aliFree, queuedAlliance), std::min(hordeFree, queuedHorde));
+
+                       valiFree -= PreAddPlayers(m_PreGroupMap_a, m_SmallestOfTeams, aliFree);
+                       vhordeFree -= PreAddPlayers(m_PreGroupMap_h, m_SmallestOfTeams, hordeFree);
+               }
+               QueuedGroupMap m_QueuedGroupMap;
+
+               for (GroupsQueueType::const_iterator itr = m_QueuedGroups[bracket_id][BG_QUEUE_CROSSFACTION].begin(); itr != m_QueuedGroups[bracket_id][BG_QUEUE_CROSSFACTION].end(); ++itr)
+                       m_QueuedGroupMap.insert(std::make_pair((*itr)->Players.size(), *itr));
+
+               for (QueuedGroupMap::reverse_iterator itr = m_QueuedGroupMap.rbegin(); itr != m_QueuedGroupMap.rend(); ++itr)
+               {
+                       GroupsQueueType allypool = m_SelectionPools[TEAM_ALLIANCE].SelectedGroups;
+                       GroupsQueueType hordepool = m_SelectionPools[TEAM_HORDE].SelectedGroups;
+
+                       GroupQueueInfo* ginfo = itr->second;
+
+                       // If player already was invited via pre adding (add to own team first) or he was already invited to a bg, skip.
+                       if (ginfo->IsInvitedToBGInstanceGUID ||
+                               std::find(allypool.begin(), allypool.end(), ginfo) != allypool.end() ||
+                               std::find(hordepool.begin(), hordepool.end(), ginfo) != hordepool.end() ||
+                               (m_SelectionPools[TEAM_ALLIANCE].GetPlayerCount() >= bg->GetMinPlayersPerTeam() &&
+                               m_SelectionPools[TEAM_HORDE].GetPlayerCount() >= bg->GetMinPlayersPerTeam()))
+                               continue;
+
+                       diff = abs(valiFree - vhordeFree);
+                       bool moreAli = valiFree < vhordeFree;
+
+                       if (diff > 0)
+                               ginfo->Team = moreAli ? HORDE : ALLIANCE;
+
+                       bool alliance = ginfo->Team == ALLIANCE;
+
+                       if (m_SelectionPools[alliance ? TEAM_ALLIANCE : TEAM_HORDE].AddGroup(ginfo, alliance ? aliFree : hordeFree))
+                               alliance ? valiFree -= ginfo->Players.size() : vhordeFree -= ginfo->Players.size();
+               }
+
+               return true;
+       }
+       return false;
+}
+
+int32 BattlegroundQueue::PreAddPlayers(QueuedGroupMap m_PreGroupMap, int32 MaxAdd, uint32 MaxInTeam)
+{
+       int32 LeftToAdd = MaxAdd;
+       uint32 Added = 0;
+
+       for (QueuedGroupMap::reverse_iterator itr = m_PreGroupMap.rbegin(); itr != m_PreGroupMap.rend(); ++itr)
+       {
+               int32 PlayerSize = itr->first;
+               bool alliance = itr->second->CFSTeam == ALLIANCE;
+
+               if (PlayerSize <= LeftToAdd && m_SelectionPools[alliance ? TEAM_ALLIANCE : TEAM_HORDE].AddGroup(itr->second, MaxInTeam))
+                       LeftToAdd -= PlayerSize, Added -= PlayerSize;
+       }
+
+       return LeftToAdd;
+}
+
+void Player::SendChatMessage(const char *format, ...)
+{
+       if (!IsInWorld())
+               return;
+
+       if (format)
+       {
+               va_list ap;
+               char str[2048];
+               va_start(ap, format);
+               vsnprintf(str, 2048, format, ap);
+               va_end(ap);
+
+               ChatHandler(GetSession()).SendSysMessage(str);
+       }
+}
\ No newline at end of file
diff --git a/src/server/game/Cfbg/Cfbg.h b/src/server/game/Cfbg/Cfbg.h
new file mode 100644
index 0000000..a362116
--- /dev/null
+++ b/src/server/game/Cfbg/Cfbg.h
@@ -0,0 +1,61 @@
+/*
++ * Copyright (C) 2013-2015 Mithos <http://www.megasource.com.br>
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms of the GNU General Public License as published by the
++ * Free Software Foundation; either version 2 of the License, or (at your
++ * option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but WITHOUT
++ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
++ * more details.
++ *
++ * You should have received a copy of the GNU General Public License along
++ * with this program. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+
+#ifndef _CUSTOM_H
+#define _CUSTOM_H
+
+#define MSG_COLOR_LIGHTRED     "|cffff6060"
+#define MSG_COLOR_LIGHTBLUE    "|cff00ccff"
+#define MSG_COLOR_ANN_GREEN    "|c1f40af20"
+#define MSG_COLOR_RED          "|cffff0000"
+#define MSG_COLOR_GOLD         "|cffffcc00"
+#define MSG_COLOR_SUBWHITE     "|cffbbbbbb"
+#define MSG_COLOR_MAGENTA      "|cffff00ff"
+#define MSG_COLOR_YELLOW       "|cffffff00"
+#define MSG_COLOR_CYAN         "|cff00ffff"
+#define MSG_COLOR_DARKBLUE     "|cff0000ff"
+
+#define MSG_COLOR_GREY         "|cff9d9d9d"
+#define MSG_COLOR_WHITE        "|cffffffff"
+#define MSG_COLOR_GREEN        "|cff1eff00"
+#define MSG_COLOR_BLUE         "|cff0080ff"
+#define MSG_COLOR_PURPLE       "|cffb048f8"
+#define MSG_COLOR_ORANGE       "|cffff8000"
+
+#define MSG_COLOR_DRUID        "|cffff7d0a"
+#define MSG_COLOR_HUNTER       "|cffabd473"
+#define MSG_COLOR_MAGE         "|cff69ccf0"
+#define MSG_COLOR_PALADIN      "|cfff58cba"
+#define MSG_COLOR_PRIEST       "|cffffffff"
+#define MSG_COLOR_ROGUE        "|cfffff569"
+#define MSG_COLOR_SHAMAN       "|cff0070de"
+#define MSG_COLOR_WARLOCK      "|cff9482c9"
+#define MSG_COLOR_WARRIOR      "|cffc79c6e"
+#define MSG_COLOR_DEATH_KNIGHT "|cffc41f3b"
+#define MSG_COLOR_MONK         "|cff00ff96"
+
+#define LIMIT_UINT32 2147483647
+
+enum FakeMorphs
+{
+       FAKE_F_TAUREN = 20584,
+       FAKE_M_TAUREN = 20585,
+       FAKE_M_NELF = 20318,
+       FAKE_F_DRAENEI = 20323,
+};
+#endif
\ No newline at end of file
diff --git a/src/server/game/Chat/Channels/Channel.cpp b/src/server/game/Chat/Channels/Channel.cpp
index 0875cee..7d1a183 100644
--- a/src/server/game/Chat/Channels/Channel.cpp
+++ b/src/server/game/Chat/Channels/Channel.cpp
@@ -24,6 +24,7 @@
 #include "DatabaseEnv.h"
 #include "AccountMgr.h"
 #include "Player.h"
+#include "IRCClient.h"
 
 Channel::Channel(std::string const& name, uint32 channelId, uint32 team):
     _announce(true),
@@ -209,6 +210,8 @@ void Channel::JoinChannel(Player* player, std::string const& pass)
 
     JoinNotify(guid);
 
+    sIRC->Handle_WoW_Channel(_name, ObjectAccessor::FindPlayer(guid), CHANNEL_JOIN);
+
     // Custom channel handling
     if (!IsConstant())
     {
@@ -259,6 +262,7 @@ void Channel::LeaveChannel(Player* player, bool send)
         SendToAll(&data);
     }
 
+    sIRC->Handle_WoW_Channel(_name, ObjectAccessor::FindPlayer(guid), CHANNEL_LEAVE);
     LeaveNotify(guid);
 
     if (!IsConstant())
diff --git a/src/server/game/Chat/Chat.cpp b/src/server/game/Chat/Chat.cpp
index 011b68a..1a45504 100644
--- a/src/server/game/Chat/Chat.cpp
+++ b/src/server/game/Chat/Chat.cpp
@@ -312,6 +312,14 @@ bool ChatHandler::ExecuteCommandInTable(std::vector<ChatCommand> const& table, c
                     areaId, areaName.c_str(), zoneName.c_str(),
                     (player->GetSelectedUnit()) ? player->GetSelectedUnit()->GetName().c_str() : "",
                     guid.ToString().c_str());
+                if ((sIRC->logmask & 2) != 0)
+                    {
+                        std::string logchan = "#";
+                        logchan += sIRC->logchan;
+                        std::stringstream ss;
+                        ss << sIRC->iLog.GetLogDateTimeStr() << ": [ " << player->GetName() << "(" << GetSession()->GetSecurity() << ") ] Used Command: [ " << fullcmd << " ] Target Guid: [" << guid.ToString().c_str() << "]";
+                        sIRC->Send_IRC_Channel(logchan,ss.str().c_str(), true, "LOG");
+                    }
             }
         }
         // some commands have custom error messages. Don't send the default one in these cases.
@@ -859,6 +867,38 @@ char* ChatHandler::extractKeyFromLink(char* text, char const* const* linkTypes,
     return NULL;
 }
 
+char const *fmtstring(char const *format, ...)
+{
+    va_list        argptr;
+    #define    MAX_FMT_STRING    32000
+    static char        temp_buffer[MAX_FMT_STRING];
+    static char        string[MAX_FMT_STRING];
+    static int        index = 0;
+    char    *buf;
+    int len;
+
+    va_start(argptr, format);
+    vsnprintf(temp_buffer,MAX_FMT_STRING, format, argptr);
+    va_end(argptr);
+
+    len = strlen(temp_buffer);
+
+    if (len >= MAX_FMT_STRING)
+        return "ERROR";
+
+    if (len + index >= MAX_FMT_STRING-1)
+    {
+        index = 0;
+    }
+
+    buf = &string[index];
+    memcpy(buf, temp_buffer, len+1);
+
+    index += len + 1;
+
+    return buf;
+}
+
 GameObject* ChatHandler::GetNearbyGameObject()
 {
     if (!m_session)
diff --git a/src/server/game/Chat/Chat.h b/src/server/game/Chat/Chat.h
index 7ce0792..dcbf0a5 100644
--- a/src/server/game/Chat/Chat.h
+++ b/src/server/game/Chat/Chat.h
@@ -23,6 +23,7 @@
 #include "StringFormat.h"
 #include "WorldSession.h"
 #include "RBAC.h"
+#include "../TriniChat/IRCClient.h"
 
 #include <vector>
 
@@ -182,4 +183,6 @@ class CliHandler : public ChatHandler
         Print* m_print;
 };
 
+char const *fmtstring(char const *format, ...);
+
 #endif
diff --git a/src/server/game/DataStores/DBCEnums.h b/src/server/game/DataStores/DBCEnums.h
index f0ea5b4..a894b94 100644
--- a/src/server/game/DataStores/DBCEnums.h
+++ b/src/server/game/DataStores/DBCEnums.h
@@ -32,7 +32,7 @@ enum LevelLimit
 
     // Server side limitation. Base at used code requirements.
     // also see MAX_LEVEL and GT_MAX_LEVEL define
-    STRONG_MAX_LEVEL = 255,
+    STRONG_MAX_LEVEL = 19,
 };
 
 enum BattlegroundBracketId                                  // bracketId for level ranges
diff --git a/src/server/game/DataStores/DBCStores.cpp b/src/server/game/DataStores/DBCStores.cpp
index 5f1de67..7cab92d 100644
--- a/src/server/game/DataStores/DBCStores.cpp
+++ b/src/server/game/DataStores/DBCStores.cpp
@@ -120,7 +120,7 @@ DBCStorage <HolidaysEntry>                sHolidaysStore(Holidaysfmt);
 DBCStorage <ItemEntry>                    sItemStore(Itemfmt);
 DBCStorage <ItemBagFamilyEntry>           sItemBagFamilyStore(ItemBagFamilyfmt);
 //DBCStorage <ItemCondExtCostsEntry> sItemCondExtCostsStore(ItemCondExtCostsEntryfmt);
-//DBCStorage <ItemDisplayInfoEntry> sItemDisplayInfoStore(ItemDisplayTemplateEntryfmt); -- not used currently
+DBCStorage <ItemDisplayInfoEntry> sItemDisplayInfoStore(ItemDisplayTemplateEntryfmt);
 DBCStorage <ItemExtendedCostEntry> sItemExtendedCostStore(ItemExtendedCostEntryfmt);
 DBCStorage <ItemLimitCategoryEntry> sItemLimitCategoryStore(ItemLimitCategoryEntryfmt);
 DBCStorage <ItemRandomPropertiesEntry> sItemRandomPropertiesStore(ItemRandomPropertiesfmt);
@@ -384,7 +384,7 @@ void LoadDBCStores(const std::string& dataPath)
 
     LoadDBC(availableDbcLocales, bad_dbc_files, sItemStore,                   dbcPath, "Item.dbc");
     LoadDBC(availableDbcLocales, bad_dbc_files, sItemBagFamilyStore,          dbcPath, "ItemBagFamily.dbc");
-    //LoadDBC(dbcCount, availableDbcLocales, bad_dbc_files, sItemDisplayInfoStore,        dbcPath, "ItemDisplayInfo.dbc");     -- not used currently
+    LoadDBC(availableDbcLocales, bad_dbc_files, sItemDisplayInfoStore,        dbcPath, "ItemDisplayInfo.dbc");
     //LoadDBC(dbcCount, availableDbcLocales, bad_dbc_files, sItemCondExtCostsStore,       dbcPath, "ItemCondExtCosts.dbc");
     LoadDBC(availableDbcLocales, bad_dbc_files, sItemExtendedCostStore,       dbcPath, "ItemExtendedCost.dbc");
     LoadDBC(availableDbcLocales, bad_dbc_files, sItemLimitCategoryStore,      dbcPath, "ItemLimitCategory.dbc");
diff --git a/src/server/game/DataStores/DBCStores.h b/src/server/game/DataStores/DBCStores.h
index 41a9738..481c765 100644
--- a/src/server/game/DataStores/DBCStores.h
+++ b/src/server/game/DataStores/DBCStores.h
@@ -135,7 +135,7 @@ extern DBCStorage <GtRegenMPPerSptEntry>         sGtRegenMPPerSptStore;
 extern DBCStorage <HolidaysEntry>                sHolidaysStore;
 extern DBCStorage <ItemEntry>                    sItemStore;
 extern DBCStorage <ItemBagFamilyEntry>           sItemBagFamilyStore;
-//extern DBCStorage <ItemDisplayInfoEntry>      sItemDisplayInfoStore; -- not used currently
+extern DBCStorage <ItemDisplayInfoEntry>         sItemDisplayInfoStore;
 extern DBCStorage <ItemExtendedCostEntry>        sItemExtendedCostStore;
 extern DBCStorage <ItemLimitCategoryEntry>       sItemLimitCategoryStore;
 extern DBCStorage <ItemRandomPropertiesEntry>    sItemRandomPropertiesStore;
diff --git a/src/server/game/DataStores/DBCStructure.h b/src/server/game/DataStores/DBCStructure.h
index d1794a0..aafed2a 100644
--- a/src/server/game/DataStores/DBCStructure.h
+++ b/src/server/game/DataStores/DBCStructure.h
@@ -1166,7 +1166,7 @@ struct ItemDisplayInfoEntry
     uint32      ID;                                         // 0        m_ID
                                                             // 1        m_modelName[2]
                                                             // 2        m_modelTexture[2]
-                                                            // 3        m_inventoryIcon
+    char*       inventoryIcon;                              // 3        m_inventoryIcon
                                                             // 4        m_geosetGroup[3]
                                                             // 5        m_flags
                                                             // 6        m_spellVisualID
diff --git a/src/server/game/DataStores/DBCfmt.h b/src/server/game/DataStores/DBCfmt.h
index aade6d9..7b2dfcc 100644
--- a/src/server/game/DataStores/DBCfmt.h
+++ b/src/server/game/DataStores/DBCfmt.h
@@ -73,7 +73,7 @@ char const GtRegenMPPerSptfmt[] = "f";
 char const Holidaysfmt[] = "niiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiixxsiix";
 char const Itemfmt[] = "niiiiiii";
 char const ItemBagFamilyfmt[] = "nxxxxxxxxxxxxxxxxx";
-//char const ItemDisplayTemplateEntryfmt[] = "nxxxxxxxxxxixxxxxxxxxxx";
+char const ItemDisplayTemplateEntryfmt[] = "nxxxxsxxxxxxxxxxxxxxxxxxx";
 //char const ItemCondExtCostsEntryfmt[] = "xiii";
 char const ItemExtendedCostEntryfmt[] = "niiiiiiiiiiiiiix";
 char const ItemLimitCategoryEntryfmt[] = "nxxxxxxxxxxxxxxxxxii";
diff --git a/src/server/game/Entities/Creature/Creature.cpp b/src/server/game/Entities/Creature/Creature.cpp
index 97b3a0b..1cd9e6d 100644
--- a/src/server/game/Entities/Creature/Creature.cpp
+++ b/src/server/game/Entities/Creature/Creature.cpp
@@ -1174,6 +1174,8 @@ void Creature::SelectLevel()
 
     SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, stats->AttackPower);
     SetModifierValue(UNIT_MOD_ATTACK_POWER_RANGED, BASE_VALUE, stats->RangedAttackPower);
+
+    sScriptMgr->Creature_SelectLevel(cInfo, this);
 }
 
 float Creature::_GetHealthMod(int32 Rank)
@@ -1552,7 +1554,7 @@ void Creature::setDeathState(DeathState s)
     if (s == JUST_DIED)
     {
         m_corpseRemoveTime = time(NULL) + m_corpseDelay;
-        m_respawnTime = time(NULL) + m_respawnDelay + m_corpseDelay;
+        m_respawnTime = time(NULL) + (m_respawnDelay / sWorld->getFloatConfig(CONFIG_RESPAWNSPEED)) + m_corpseDelay;
 
         // always save boss respawn time at death to prevent crash cheating
         if (sWorld->getBoolConfig(CONFIG_SAVE_RESPAWN_TIME_IMMEDIATELY) || isWorldBoss())
diff --git a/src/server/game/Entities/Item/Item.cpp b/src/server/game/Entities/Item/Item.cpp
index 70fa471..1a153a2 100644
--- a/src/server/game/Entities/Item/Item.cpp
+++ b/src/server/game/Entities/Item/Item.cpp
@@ -282,6 +282,17 @@ bool Item::Create(ObjectGuid::LowType guidlow, uint32 itemid, Player const* owne
 
     SetUInt32Value(ITEM_FIELD_DURATION, itemProto->Duration);
     SetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME, 0);
+    /** World of Warcraft Armory **/
+    if (sWorld->getBoolConfig(CONFIG_ARMORY_ENABLE))
+    {
+        if (itemProto->Quality > 2 && itemProto->Flags != 2048 && (itemProto->Class == ITEM_CLASS_WEAPON || itemProto->Class == ITEM_CLASS_ARMOR))
+        {
+            if (!GetOwner())
+                return true;
+            GetOwner()->CreateWowarmoryFeed(2, itemid, guidlow, itemProto->Quality);
+        }
+    }
+    /** World of Warcraft Armory **/
     return true;
 }
 
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index 77b4c69..b6eb6bf 100644
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -16,6 +16,8 @@
  * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include "../../../scripts/Custom/TransmogDisplayVendorConf.h"
+#include "../../../scripts/Custom/Transmogrification.h"
 #include "Player.h"
 #include "AccountMgr.h"
 #include "AchievementMgr.h"
@@ -32,6 +34,7 @@
 #include "ChannelMgr.h"
 #include "CharacterDatabaseCleaner.h"
 #include "Chat.h"
+#include "IRCClient.h"
 #include "Common.h"
 #include "ConditionMgr.h"
 #include "CreatureAI.h"
@@ -314,8 +317,30 @@ std::ostringstream& operator<< (std::ostringstream& ss, PlayerTaxi const& taxi)
     return ss;
 }
 
+
 Player::Player(WorldSession* session): Unit(true)
 {
+    m_FakeRace = 0;
+    m_RealRace = 0;
+    m_FakeMorph = 0;
+    m_ForgetBGPlayers = false;
+    m_ForgetInListPlayers = false;
+
+    m_jail_guid     = 0;
+    m_jail_char     = "";
+    m_jail_amnestie = false;
+    m_jail_warning  = false;
+    m_jail_isjailed = false;
+    m_jail_amnestietime =0;
+    m_jail_release  = 0;
+    m_jail_times    = 0;
+    m_jail_reason   = "";
+    m_jail_gmacc    = 0;
+    m_jail_gmchar   = "";
+    m_jail_lasttime = "";
+    m_jail_duration = 0;
+    // Jail end
+
     m_speakTime = 0;
     m_speakCount = 0;
 
@@ -418,6 +443,12 @@ Player::Player(WorldSession* session): Unit(true)
         m_bgBattlegroundQueueID[j].invitedToInstance = 0;
     }
 
+    // PlayedTimeReward
+    ptr_Interval = sConfigMgr->GetIntDefault("PlayedTimeReward.Interval", 0);
+    ptr_Money = sConfigMgr->GetIntDefault("PlayedTimeReward.Money", 0);
+    ptr_Honor = sConfigMgr->GetIntDefault("PlayedTimeReward.Honor", 0);
+    ptr_Arena = sConfigMgr->GetIntDefault("PlayedTimeReward.Arena", 0);
+
     m_logintime = time(NULL);
     m_Last_tick = m_logintime;
     m_Played_time[PLAYED_TIME_TOTAL] = 0;
@@ -672,6 +703,12 @@ bool Player::Create(ObjectGuid::LowType guidlow, CharacterCreateInfo* createInfo
     uint32 RaceClassGender = (createInfo->Race) | (createInfo->Class << 8) | (createInfo->Gender << 16);
 
     SetUInt32Value(UNIT_FIELD_BYTES_0, (RaceClassGender | (powertype << 24)));
+
+    SetCFSRace();
+    m_team = TeamForRace(getCFSRace());
+    SetFakeRaceAndMorph(); // m_team must be set before this can be used.
+    setFactionForRace(getCFSRace());
+
     InitDisplayIds();
     if (sWorld->getIntConfig(CONFIG_GAME_TYPE) == REALM_TYPE_PVP || sWorld->getIntConfig(CONFIG_GAME_TYPE) == REALM_TYPE_RPPVP)
     {
@@ -812,6 +849,7 @@ bool Player::Create(ObjectGuid::LowType guidlow, CharacterCreateInfo* createInfo
     for (PlayerCreateInfoActions::const_iterator action_itr = info->action.begin(); action_itr != info->action.end(); ++action_itr)
         addActionButton(action_itr->button, action_itr->action, action_itr->type);
 
+
     // original items
     if (CharStartOutfitEntry const* oEntry = GetCharStartOutfitEntry(createInfo->Race, createInfo->Class, createInfo->Gender))
     {
@@ -1005,8 +1043,11 @@ int32 Player::getMaxTimer(MirrorTimerType timer)
 {
     switch (timer)
     {
+    if(sConfigMgr->GetBoolDefault("fatigue.enabled", true)) // If "fatigue.enabled" is enabled
+        {
         case FATIGUE_TIMER:
             return MINUTE * IN_MILLISECONDS;
+        }
         case BREATH_TIMER:
         {
             if (!IsAlive() || HasAuraType(SPELL_AURA_WATER_BREATHING) || GetSession()->GetSecurity() >= AccountTypes(sWorld->getIntConfig(CONFIG_DISABLE_BREATHING)))
@@ -1089,6 +1130,9 @@ void Player::HandleDrowning(uint32 time_diff)
     }
 
     // In dark water
+if(sConfigMgr->GetBoolDefault("fatigue.enabled", true)) // If "fatigue.enabled" is enabled
+{
+
     if (m_MirrorTimerFlags & UNDERWARER_INDARKWATER)
     {
         // Fatigue timer not activated - activate it
@@ -1125,7 +1169,7 @@ void Player::HandleDrowning(uint32 time_diff)
         else if (m_MirrorTimerFlagsLast & UNDERWARER_INDARKWATER)
             SendMirrorTimer(FATIGUE_TIMER, DarkWaterTime, m_MirrorTimer[FATIGUE_TIMER], 10);
     }
-
+}
     if (m_MirrorTimerFlags & (UNDERWATER_INLAVA /*| UNDERWATER_INSLIME*/) && !(_lastLiquid && _lastLiquid->SpellId))
     {
         // Breath timer not activated - activate it
@@ -1248,6 +1292,77 @@ void Player::Update(uint32 p_time)
     SetCanDelayTeleport(true);
     Unit::Update(p_time);
     SetCanDelayTeleport(false);
+    if (m_jail_isjailed)
+    {
+        time_t localtime;
+        localtime = time(NULL);
+        
+        if (m_jail_release <= localtime)
+        {
+            m_jail_isjailed = false;
+            m_jail_release = 0;
+
+            _SaveJail();
+            
+            sWorld->SendWorldText(LANG_JAIL_CHAR_FREE, GetName().c_str());
+            
+            CastSpell(this,8690,false);
+
+            return;
+        }
+
+        if (m_team == ALLIANCE)
+        {
+            if (GetDistance(sObjectMgr->m_jailconf_ally_x, sObjectMgr->m_jailconf_ally_y, sObjectMgr->m_jailconf_ally_z) > sObjectMgr->m_jailconf_radius)
+            {
+                TeleportTo(sObjectMgr->m_jailconf_ally_m, sObjectMgr->m_jailconf_ally_x,
+                    sObjectMgr->m_jailconf_ally_y, sObjectMgr->m_jailconf_ally_z, sObjectMgr->m_jailconf_ally_o);
+                return;
+            }
+        }
+        else
+        {
+            if (GetDistance(sObjectMgr->m_jailconf_horde_x, sObjectMgr->m_jailconf_horde_y, sObjectMgr->m_jailconf_horde_z) > sObjectMgr->m_jailconf_radius)
+            {
+                TeleportTo(sObjectMgr->m_jailconf_horde_m, sObjectMgr->m_jailconf_horde_x,
+                    sObjectMgr->m_jailconf_horde_y, sObjectMgr->m_jailconf_horde_z, sObjectMgr->m_jailconf_horde_o);
+                return;
+            }
+            
+        }
+    }
+
+    if (m_jail_warning == true)
+    {
+        m_jail_warning  = false;
+        
+        if (sObjectMgr->m_jailconf_warn_player == m_jail_times || sObjectMgr->m_jailconf_warn_player <= m_jail_times)
+        {
+            if ((sObjectMgr->m_jailconf_max_jails-1 == m_jail_times-1) && sObjectMgr->m_jailconf_ban-1)
+            {
+                ChatHandler(GetSession()).PSendSysMessage(LANG_JAIL_WARNING_BAN, m_jail_times , sObjectMgr->m_jailconf_max_jails-1);
+            }
+            else
+            {
+                ChatHandler(GetSession()).PSendSysMessage(LANG_JAIL_WARNING, m_jail_times , sObjectMgr->m_jailconf_max_jails);
+            }
+                
+        }
+                return;
+    }
+if (m_jail_amnestie == true && sObjectMgr->m_jailconf_amnestie > 0)
+{
+    m_jail_amnestie =false;
+    time_t localtime;
+    localtime    = time(NULL);
+    
+    if (localtime >  m_jail_amnestietime)
+    {   
+        CharacterDatabase.PExecute("DELETE FROM `jail` WHERE `guid` = '%u'",GetGUID().GetCounter());
+        ChatHandler(GetSession()).PSendSysMessage(LANG_JAIL_AMNESTII);
+    }
+    return;
+}
 
     time_t now = time(NULL);
 
@@ -1289,6 +1404,21 @@ void Player::Update(uint32 p_time)
         LoginDatabase.Execute(stmt);
     }
 
+    // PlayedTimeReward
+    if (ptr_Interval > 0)
+    {
+        if (ptr_Interval <= p_time)
+        {
+            GetSession()->SendAreaTriggerMessage("Bonus for played time.");
+            ModifyMoney(ptr_Money);
+            ModifyHonorPoints(ptr_Honor);
+            ModifyArenaPoints(ptr_Arena);
+            ptr_Interval = sConfigMgr->GetIntDefault("PlayedTimeReward.Interval", 0);
+        }
+        else
+            ptr_Interval -= p_time;
+    }
+
     if (!m_timedquests.empty())
     {
         QuestSet::iterator iter = m_timedquests.begin();
@@ -1351,7 +1481,10 @@ void Player::Update(uint32 p_time)
 
                     // do attack
                     AttackerStateUpdate(victim, BASE_ATTACK);
-                    resetAttackTimer(BASE_ATTACK);
+                    if (sWorld->getBoolConfig(CONFIG_HURT_IN_REAL_TIME))
+                        AttackStop();
+                    else
+                        resetAttackTimer(BASE_ATTACK);
                 }
             }
 
@@ -1457,9 +1590,19 @@ void Player::Update(uint32 p_time)
     }
 
     if (m_deathState == JUST_DIED)
-        KillPlayer();
+//        KillPlayer();
+    {
+
+        // Prevent death of jailed players
+        if (!m_jail_isjailed) KillPlayer();
+        else
+        {
+            m_deathState = ALIVE;
+            RegenerateAll();
+        }
+    }
 
-    if (m_nextSave > 0)
+    if (m_nextSave > 0 && !m_jail_isjailed)
     {
         if (p_time >= m_nextSave)
         {
@@ -1830,6 +1973,7 @@ uint8 Player::GetChatTag() const
     if (HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_DEVELOPER))
         tag |= CHAT_TAG_DEV;
 
+
     return tag;
 }
 
@@ -1868,6 +2012,7 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
     if (!InBattleground() && mEntry->IsBattlegroundOrArena())
         return false;
 
+
     // client without expansion support
     if (GetSession()->Expansion() < mEntry->Expansion())
     {
@@ -2016,6 +2161,7 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
             if (pet)
                 UnsummonPetTemporaryIfAny();
 
+
             // remove all dyn objects
             RemoveAllDynObjects();
 
@@ -2036,6 +2182,7 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
                 if (Transport* transport = GetTransport())
                     data << transport->GetEntry() << GetMapId();
 
+
                 GetSession()->SendPacket(&data);
             }
 
@@ -2198,6 +2345,15 @@ void Player::RemoveFromWorld()
             SetViewpoint(viewpoint, false);
         }
     }
+  //TODO: FIXME
+    if (sIRC->ajoin == 1)
+    {
+        QueryResult result = WorldDatabase.PQuery("SELECT `name` FROM `irc_inchan` WHERE `name` = '%s'", GetName().c_str());
+        if (!result)
+        {
+            sIRC->AutoJoinChannel(this);
+        }
+    }
 }
 
 bool Player::IsImmunedToSpellEffect(SpellInfo const* spellInfo, uint32 index) const
@@ -2782,10 +2938,10 @@ void Player::GiveLevel(uint8 level)
         guild->UpdateMemberData(this, GUILD_MEMBER_DATA_LEVEL, level);
 
     PlayerLevelInfo info;
-    sObjectMgr->GetPlayerLevelInfo(getRace(), getClass(), level, &info);
+    sObjectMgr->GetPlayerLevelInfo(getCFSRace(), getClass(), level, &info);
 
     PlayerClassLevelInfo classInfo;
-    sObjectMgr->GetPlayerClassLevelInfo(getClass(), level, &classInfo);
+    
 
     // send levelup info to client
     WorldPacket data(SMSG_LEVELUP_INFO, (4+4+MAX_POWERS*4+MAX_STATS*4));
@@ -2827,6 +2983,17 @@ void Player::GiveLevel(uint8 level)
     InitTaxiNodesForLevel();
     InitGlyphsForLevel();
 
+  if ((sIRC->BOTMASK & 64) != 0 && sIRC->Status.size() > 0)
+    {
+        char  temp [5];
+        sprintf(temp, "%u", level);
+        std::string plevel = temp;
+        std::string pname = GetName();
+        std::string ircchan = "#";
+        ircchan += sIRC->Status;
+        sIRC->Send_IRC_Channel(ircchan, "\00311["+pname+"] : Has Reached Level: "+plevel, true);
+    }
+
     UpdateAllStats();
 
     if (sWorld->getBoolConfig(CONFIG_ALWAYS_MAXSKILL)) // Max weapon skill when leveling up
@@ -2920,7 +3087,7 @@ void Player::InitStatsForLevel(bool reapplyMods)
     sObjectMgr->GetPlayerClassLevelInfo(getClass(), getLevel(), &classInfo);
 
     PlayerLevelInfo info;
-    sObjectMgr->GetPlayerLevelInfo(getRace(), getClass(), getLevel(), &info);
+    sObjectMgr->GetPlayerLevelInfo(getCFSRace(), getClass(), getLevel(), &info);
 
     SetUInt32Value(PLAYER_FIELD_MAX_LEVEL, sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL));
     SetUInt32Value(PLAYER_NEXT_LEVEL_XP, sObjectMgr->GetXPForLevel(getLevel()));
@@ -3101,6 +3268,7 @@ void Player::SendInitialSpells()
 
     GetSpellHistory()->WritePacket<Player>(data);
 
+
     GetSession()->SendPacket(&data);
 
     TC_LOG_DEBUG("network", "CHARACTER: Sent Initial Spells");
@@ -4561,6 +4729,12 @@ void Player::DeleteFromDB(ObjectGuid playerguid, uint32 accountId, bool updateRe
 
             Corpse::DeleteFromDB(playerguid, trans);
 
+            /* World of Warcraft Armory */
+            trans->PAppend("DELETE FROM armory_character_stats WHERE guid = '%u'",guid);
+            trans->PAppend("DELETE FROM character_feed_log WHERE guid = '%u'",guid);
+            /* World of Warcraft Armory */
+
+
             CharacterDatabase.CommitTransaction(trans);
             break;
         }
@@ -4852,7 +5026,7 @@ Corpse* Player::CreateCorpse()
     // prevent existence 2 corpse for player
     SpawnCorpseBones();
 
-    uint32 _pb, _pb2, _cfb1, _cfb2;
+    uint32 _uf, _pb, _pb2, _cfb1, _cfb2;
 
     Corpse* corpse = new Corpse((m_ExtraFlags & PLAYER_EXTRA_PVP_DEATH) ? CORPSE_RESURRECTABLE_PVP : CORPSE_RESURRECTABLE_PVE);
     SetPvPDeath(false);
@@ -4865,9 +5039,11 @@ Corpse* Player::CreateCorpse()
 
     _corpseLocation.WorldRelocate(*this);
 
+    _uf = getCFSRace();
     _pb = GetUInt32Value(PLAYER_BYTES);
     _pb2 = GetUInt32Value(PLAYER_BYTES_2);
 
+    uint8 race       = (uint8) (_uf);
     uint8 skin       = (uint8)(_pb);
     uint8 face       = (uint8)(_pb >> 8);
     uint8 hairstyle  = (uint8)(_pb >> 16);
@@ -5109,6 +5285,7 @@ uint32 Player::DurabilityRepair(uint16 pos, bool cost, float discountMod, bool g
                 if (!guild->HandleMemberWithdrawMoney(GetSession(), costs, true))
                     return TotalCost;
 
+
                 TotalCost = costs;
             }
             else if (!HasEnoughMoney(costs))
@@ -5257,6 +5434,7 @@ void Player::UpdateLocalChannels(uint32 newZone)
                     if (channel->flags & CHANNEL_DBC_FLAG_CITY_ONLY && usedChannel)
                         continue;                            // Already on the channel, as city channel names are not changing
 
+
                     char new_channel_name_buf[100];
                     char const* currentNameExt;
 
@@ -5330,6 +5508,7 @@ void Player::HandleBaseModValue(BaseModGroup modGroup, BaseModType modType, floa
     else // PCT_MOD
         ApplyPercentModFloatVar(m_auraBaseMod[modGroup][modType], amount, apply);
 
+
     if (!CanModifyStats())
         return;
 
@@ -6391,6 +6570,7 @@ bool Player::UpdatePosition(float x, float y, float z, float orientation, bool t
     if (GetGroup())
         SetGroupUpdateFlag(GROUP_UPDATE_FLAG_POSITION);
 
+
     CheckAreaExploreAndOutdoor();
 
     return true;
@@ -6548,10 +6728,10 @@ uint32 Player::TeamForRace(uint8 race)
 
 void Player::setFactionForRace(uint8 race)
 {
-    m_team = TeamForRace(race);
+    SetBGTeam(TeamForRace(race));
 
     ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(race);
-    setFaction(rEntry ? rEntry->FactionID : 0);
+    setFaction(rEntry ? rEntry->FactionID : getFaction());
 }
 
 ReputationRank Player::GetReputationRank(uint32 faction) const
@@ -6653,6 +6833,27 @@ void Player::RewardReputation(Unit* victim, float rate)
     if (!Rep)
         return;
 
+    uint32 repfaction1 = Rep->RepFaction1;
+    uint32 repfaction2 = Rep->RepFaction2;
+    
+        if (!IsPlayingNative())
+         {
+        if (GetCFSTeam() == ALLIANCE)
+             {
+            if (repfaction1 == 729)
+                 repfaction1 = 730;
+            if (repfaction2 == 729)
+                 repfaction2 = 730;
+            }
+        else
+             {
+            if (repfaction1 == 730)
+                 repfaction1 = 729;
+            if (repfaction2 == 730)
+                 repfaction2 = 729;
+            }
+        }
+
     uint32 ChampioningFaction = 0;
 
     if (GetChampioningFaction())
@@ -6667,9 +6868,9 @@ void Player::RewardReputation(Unit* victim, float rate)
 
     uint32 team = GetTeam();
 
-    if (Rep->RepFaction1 && (!Rep->TeamDependent || team == ALLIANCE))
+    if (repfaction1 && (!Rep->TeamDependent || team == ALLIANCE))
     {
-        int32 donerep1 = CalculateReputationGain(REPUTATION_SOURCE_KILL, victim->getLevel(), Rep->RepValue1, ChampioningFaction ? ChampioningFaction : Rep->RepFaction1);
+        int32 donerep1 = CalculateReputationGain(REPUTATION_SOURCE_KILL, victim->getLevel(), Rep->RepValue1, ChampioningFaction ? ChampioningFaction : repfaction1);
         donerep1 = int32(donerep1 * rate);
 
         FactionEntry const* factionEntry1 = sFactionStore.LookupEntry(ChampioningFaction ? ChampioningFaction : Rep->RepFaction1);
@@ -6678,12 +6879,12 @@ void Player::RewardReputation(Unit* victim, float rate)
             GetReputationMgr().ModifyReputation(factionEntry1, donerep1);
     }
 
-    if (Rep->RepFaction2 && (!Rep->TeamDependent || team == HORDE))
+    if (repfaction2 && (!Rep->TeamDependent || team == HORDE))
     {
-        int32 donerep2 = CalculateReputationGain(REPUTATION_SOURCE_KILL, victim->getLevel(), Rep->RepValue2, ChampioningFaction ? ChampioningFaction : Rep->RepFaction2);
+        int32 donerep2 = CalculateReputationGain(REPUTATION_SOURCE_KILL, victim->getLevel(), Rep->RepValue2, ChampioningFaction ? ChampioningFaction : repfaction2);
         donerep2 = int32(donerep2 * rate);
 
-        FactionEntry const* factionEntry2 = sFactionStore.LookupEntry(ChampioningFaction ? ChampioningFaction : Rep->RepFaction2);
+        FactionEntry const* factionEntry2 = sFactionStore.LookupEntry(ChampioningFaction ? ChampioningFaction : repfaction2);
         uint32 current_reputation_rank2 = GetReputationMgr().GetRank(factionEntry2);
         if (factionEntry2 && current_reputation_rank2 <= Rep->ReputationMaxCap2)
             GetReputationMgr().ModifyReputation(factionEntry2, donerep2);
@@ -6778,7 +6979,7 @@ bool Player::RewardHonor(Unit* victim, uint32 groupsize, int32 honor, bool pvpto
         if (!victim || victim == this || victim->GetTypeId() != TYPEID_PLAYER)
             return false;
 
-        if (GetBGTeam() == victim->ToPlayer()->GetBGTeam())
+        if (GetTeam() == victim->ToPlayer()->GetTeam())
             return false;
 
         return true;
@@ -6790,6 +6991,7 @@ bool Player::RewardHonor(Unit* victim, uint32 groupsize, int32 honor, bool pvpto
 
     ObjectGuid victim_guid;
     uint32 victim_rank = 0;
+    uint32 rank_diff = 0;
 
     // need call before fields update to have chance move yesterday data to appropriate fields before today data change.
     UpdateHonorFields();
@@ -6832,16 +7034,79 @@ bool Player::RewardHonor(Unit* victim, uint32 groupsize, int32 honor, bool pvpto
             //  title[1..14]  -> rank[5..18]
             //  title[15..28] -> rank[5..18]
             //  title[other]  -> 0
-            if (victim_title == 0)
-                victim_guid.Clear();                     // Don't show HK: <rank> message, only log.
-            else if (victim_title < 15)
-                victim_rank = victim_title + 4;
-            else if (victim_title < 29)
-                victim_rank = victim_title - 14 + 4;
-            else
-                victim_guid.Clear();                     // Don't show HK: <rank> message, only log.
+                // PLAYER__FIELD_KNOWN_TITLES describe which titles player can use,
+                // so we must find biggest pvp title , even for killer to find extra honor value
+                uint32 vtitle = victim->GetUInt32Value(PLAYER__FIELD_KNOWN_TITLES);
+                //uint32 victim_title = 0;
+                uint32 ktitle = GetUInt32Value(PLAYER__FIELD_KNOWN_TITLES);
+                uint32 killer_title = 0;
+                if (PLAYER_TITLE_MASK_ALL_PVP & ktitle)
+                {
+                    for (int i = ((GetTeam() == ALLIANCE) ? 1:HKRANKMAX);i!=((GetTeam() == ALLIANCE) ? HKRANKMAX : (2*HKRANKMAX-1));i++)
+                    {
+                        if (ktitle & (1<<i))
+                            killer_title = i;
+                    }
+                }
+                if (PLAYER_TITLE_MASK_ALL_PVP & vtitle)
+                {
+                    for (int i = ((plrVictim->GetTeam() == ALLIANCE) ? 1:HKRANKMAX);i!=((plrVictim->GetTeam() == ALLIANCE) ? HKRANKMAX : (2*HKRANKMAX-1));i++)
+                    {
+                        if (vtitle & (1<<i))
+                            victim_title = i;
+                    }
+                }
+
+                // Get Killer titles, CharTitlesEntry::bit_index
+                // Ranks:
+                //  title[1..14]  -> rank[5..18]
+                //  title[15..28] -> rank[5..18]
+                //  title[other]  -> 0
+                if (victim_title == 0)
+                    victim_guid.Clear();                        // Don't show HK: <rank> message, only log.
+                else if (victim_title < HKRANKMAX)
+                    victim_rank = victim_title + 4;
+                else if (victim_title < (2*HKRANKMAX-1))
+                    victim_rank = victim_title - (HKRANKMAX-1) + 4;
+                else
+                    victim_guid.Clear();                        // Don't show HK: <rank> message, only log.
+
+                // now find rank difference
+                if (killer_title == 0 && victim_rank>4)
+                    rank_diff = victim_rank - 4;
+                else if (killer_title < HKRANKMAX)
+                    rank_diff = (victim_rank>(killer_title + 4))? (victim_rank - (killer_title + 4)) : 0;
+                else if (killer_title < (2*HKRANKMAX-1))
+                    rank_diff = (victim_rank>(killer_title - (HKRANKMAX-1) +4))? (victim_rank - (killer_title - (HKRANKMAX-1) + 4)) : 0;
+
+
+            honor_f = ceil(Trinity::Honor::hk_honor_at_level_f(k_level) * (v_level - k_grey) / (k_level - k_grey));
+            honor *= 1 + sWorld->getRate(RATE_PVP_RANK_EXTRA_HONOR)*(((float)rank_diff) / 10.0f);
+            // count the number of playerkills in one day
+            ApplyModUInt32Value(PLAYER_FIELD_KILLS, 1, true);
+            // and those in a lifetime
+            ApplyModUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, 1, true);
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EARN_HONORABLE_KILL);
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HK_CLASS, victim->getClass());
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HK_RACE, victim->getRace());
+            UpdateKnownTitles();
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL_AT_AREA, GetAreaId());
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL, 1, 0, victim);
+        }
+        else if (sWorld->getBoolConfig(CONFIG_GAIN_HONOR_GUARD) && victim->ToCreature()->IsGuard())
+        {
+            uint8 k_level = getLevel();
+            uint8 k_grey = Trinity::XP::GetGrayLevel(k_level);
+            uint8 v_level = victim->getLevel();
+
+            if (v_level <= k_grey)
+                return false;
+
+            uint32 victim_title = 0;
+            victim_guid = ObjectGuid::Empty;
+
+            honor_f = ceil(Trinity::Honor::hk_honor_at_level_f(k_level) * (v_level - k_grey) / (k_level - k_grey));
 
-            honor_f = std::ceil(Trinity::Honor::hk_honor_at_level_f(k_level) * (v_level - k_grey) / (k_level - k_grey));
 
             // count the number of playerkills in one day
             ApplyModUInt32Value(PLAYER_FIELD_KILLS, 1, true);
@@ -6853,6 +7118,29 @@ bool Player::RewardHonor(Unit* victim, uint32 groupsize, int32 honor, bool pvpto
             UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL_AT_AREA, GetAreaId());
             UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL, 1, 0, victim);
         }
+        else if (sWorld->getBoolConfig(CONFIG_GAIN_HONOR_ELITE) && victim->ToCreature()->isElite())
+        {
+            uint8 k_level = getLevel();
+            uint8 k_grey = Trinity::XP::GetGrayLevel(k_level);
+            uint8 v_level = victim->getLevel();
+
+            if (v_level <= k_grey)
+                return false;
+
+            uint32 victim_title = 0;
+            victim_guid = ObjectGuid::Empty;
+            honor_f = ceil(Trinity::Honor::hk_honor_at_level_f(k_level) * (v_level - k_grey) / (k_level - k_grey));
+            // count the number of playerkills in one day
+            ApplyModUInt32Value(PLAYER_FIELD_KILLS, 1, true);
+
+            // and those in a lifetime
+            ApplyModUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, 1, true);
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EARN_HONORABLE_KILL);
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HK_CLASS, victim->getClass());
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HK_RACE, victim->getRace());
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL_AT_AREA, GetAreaId());
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL, 1, 0, victim);
+        }
         else
         {
             if (!victim->ToCreature()->IsRacialLeader())
@@ -6946,6 +7234,7 @@ bool Player::RewardHonor(Unit* victim, uint32 groupsize, int32 honor, bool pvpto
         }
     }
 
+
     return true;
 }
 
@@ -6967,6 +7256,30 @@ void Player::SetArenaPoints(uint32 value)
         AddKnownCurrency(ITEM_ARENA_POINTS_ID);
 }
 
+void Player::UpdateKnownTitles()
+{
+    uint32 new_title = 0;
+    uint32 honor_kills = GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS);
+    uint32 old_title = GetUInt32Value(PLAYER_CHOSEN_TITLE);
+    RemoveFlag64(PLAYER__FIELD_KNOWN_TITLES,PLAYER_TITLE_MASK_ALL_PVP);
+    // if (honor_kills < 0)
+    //    return;
+    bool max_rank = ((honor_kills >= sWorld->pvp_ranks[HKRANKMAX-1]) ? true : false);
+    for (int i = HKRANK01; i != HKRANKMAX; ++i)
+    {
+        if (honor_kills < sWorld->pvp_ranks[i] || (max_rank))
+        {
+            new_title = ((max_rank) ? (HKRANKMAX-1) : (i-1));
+            if (new_title > 0)
+                new_title += ((GetTeam() == ALLIANCE) ? 0 : (HKRANKMAX-1));
+            break;
+        }
+    }
+    SetFlag64(PLAYER__FIELD_KNOWN_TITLES,uint64(1) << new_title);
+    if (old_title > 0 && old_title < (2*HKRANKMAX-1) && new_title > old_title)
+        SetUInt32Value(PLAYER_CHOSEN_TITLE,new_title);
+}
+
 void Player::ModifyHonorPoints(int32 value, SQLTransaction trans)
 {
     int32 newValue = int32(GetHonorPoints()) + value;
@@ -7058,6 +7371,7 @@ uint32 Player::GetZoneIdFromDB(ObjectGuid guid)
     stmt->setUInt32(0, guidLow);
     PreparedQueryResult result = CharacterDatabase.Query(stmt);
 
+
     if (!result)
         return 0;
     Field* fields = result->Fetch();
@@ -7406,6 +7720,7 @@ void Player::_ApplyItemMods(Item* item, uint8 slot, bool apply)
     if (proto->Socket[0].Color)                              //only (un)equipping of items with sockets can influence metagems, so no need to waste time with normal items
         CorrectMetaGemEnchants(slot, apply);
 
+
     if (attacktype < MAX_ATTACK)
         _ApplyWeaponDependentAuraMods(item, WeaponAttackType(attacktype), apply);
 
@@ -7438,6 +7753,20 @@ void Player::_ApplyItemBonuses(ItemTemplate const* proto, uint8 slot, bool apply
     if (only_level_scale && !ssv)
         return;
 
+    uint32 statcount = proto->StatsCount;
+    ReforgeData* reforgeData = NULL;
+    bool decreased = false;
+    if (statcount < MAX_ITEM_PROTO_STATS)
+    {
+        if (Item* invItem = GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+        {
+            if (reforgeMap.find(invItem->GetGUID().GetCounter()) != reforgeMap.end())
+            {
+                reforgeData = &reforgeMap[invItem->GetGUID().GetCounter()];
+                ++statcount;
+            }
+        }
+    }
     for (uint8 i = 0; i < MAX_ITEM_PROTO_STATS; ++i)
     {
         uint32 statType = 0;
@@ -7452,10 +7781,24 @@ void Player::_ApplyItemBonuses(ItemTemplate const* proto, uint8 slot, bool apply
         }
         else
         {
-            if (i >= proto->StatsCount)
+            if (i >= statcount)
                 continue;
             statType = proto->ItemStat[i].ItemStatType;
             val = proto->ItemStat[i].ItemStatValue;
+
+            if (reforgeData)
+            {
+                if(i == statcount-1)
+                {
+                    statType = reforgeData->increase;
+                    val = reforgeData->stat_value;
+                }
+                else if (!decreased && reforgeData->decrease == statType)
+                {
+                    val -= reforgeData->stat_value;
+                    decreased = true;
+                }
+            }
         }
 
         if (val == 0)
@@ -8699,10 +9042,12 @@ void Player::SendLoot(ObjectGuid guid, LootType loot_type)
     // need know merged fishing/corpse loot type for achievements
     loot->loot_type = loot_type;
 
+
     if (permission != NONE_PERMISSION)
     {
         SetLootGUID(guid);
 
+
         WorldPacket data(SMSG_LOOT_RESPONSE, (9 + 50));           // we guess size
         data << uint64(guid);
         data << uint8(loot_type);
@@ -11634,13 +11979,13 @@ InventoryResult Player::CanUseItem(ItemTemplate const* proto) const
     if (!proto)
         return EQUIP_ERR_ITEM_NOT_FOUND;
 
-    if ((proto->Flags2 & ITEM_FLAGS_EXTRA_HORDE_ONLY) && GetTeam() != HORDE)
+    if ((proto->Flags2 & ITEM_FLAGS_EXTRA_HORDE_ONLY) && GetCFSTeam() != HORDE)
         return EQUIP_ERR_YOU_CAN_NEVER_USE_THAT_ITEM;
 
-    if ((proto->Flags2 & ITEM_FLAGS_EXTRA_ALLIANCE_ONLY) && GetTeam() != ALLIANCE)
+    if ((proto->Flags2 & ITEM_FLAGS_EXTRA_ALLIANCE_ONLY) && GetCFSTeam() != ALLIANCE)
         return EQUIP_ERR_YOU_CAN_NEVER_USE_THAT_ITEM;
 
-    if ((proto->AllowableClass & getClassMask()) == 0 || (proto->AllowableRace & getRaceMask()) == 0)
+    if ((proto->AllowableClass & getClassMask()) == 0 || (proto->AllowableRace & getCFSRaceMask()) == 0)
         return EQUIP_ERR_YOU_CAN_NEVER_USE_THAT_ITEM;
 
     if (proto->RequiredSkill != 0)
@@ -12129,7 +12474,12 @@ void Player::SetVisibleItemSlot(uint8 slot, Item* pItem)
 {
     if (pItem)
     {
-        SetUInt32Value(PLAYER_VISIBLE_ITEM_1_ENTRYID + (slot * 2), pItem->GetEntry());
+        if (uint32 entry = TransmogDisplayVendorMgr::GetFakeEntry(pItem))
+            SetUInt32Value(PLAYER_VISIBLE_ITEM_1_ENTRYID + (slot * 2), entry);
+        else if (uint32 entry = sTransmogrification->GetFakeEntry(pItem))
+            SetUInt32Value(PLAYER_VISIBLE_ITEM_1_ENTRYID + (slot * 2), entry);
+        else
+            SetUInt32Value(PLAYER_VISIBLE_ITEM_1_ENTRYID + (slot * 2), pItem->GetEntry());
         SetUInt16Value(PLAYER_VISIBLE_ITEM_1_ENCHANTMENT + (slot * 2), 0, pItem->GetEnchantmentId(PERM_ENCHANTMENT_SLOT));
         SetUInt16Value(PLAYER_VISIBLE_ITEM_1_ENCHANTMENT + (slot * 2), 1, pItem->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT));
     }
@@ -12249,22 +12599,22 @@ void Player::RemoveItem(uint8 bag, uint8 slot, bool update)
             pItem->SendUpdateToPlayer(this);
     }
 }
-
+extern void RemoveReforge(Player* player, uint32 itemguid, bool update);
 // Common operation need to remove item from inventory without delete in trade, auction, guild bank, mail....
 void Player::MoveItemFromInventory(uint8 bag, uint8 slot, bool update)
 {
     if (Item* it = GetItemByPos(bag, slot))
     {
     // Prepatch by LordPsyan
-    // 01
+        RemoveReforge(this, it->GetGUID().GetCounter(), true);
     // 02
     // 03
     // 04
-    // 05
+        TransmogDisplayVendorMgr::DeleteFakeEntry(this, it);
     // 06
     // 07
     // 08
-    // 09
+        sTransmogrification->DeleteFakeEntry(this, it);
     // 10
     // 11
     // 12
@@ -15546,6 +15896,7 @@ bool Player::SatisfyQuestPrevChain(Quest const* qInfo, bool msg)
     {
         QuestStatusMap::const_iterator itr = m_QuestStatus.find(*iter);
 
+
         // If any of the previous quests in chain active, return false
         if (itr != m_QuestStatus.end() && itr->second.Status != QUEST_STATUS_NONE)
         {
@@ -16212,6 +16563,7 @@ void Player::KilledMonsterCredit(uint32 entry, ObjectGuid guid /*= ObjectGuid::E
 
                     uint32 reqkill = qInfo->RequiredNpcOrGo[j];
 
+
                     if (reqkill == real_entry)
                     {
                         uint32 reqkillcount = qInfo->RequiredNpcOrGoCount[j];
@@ -16240,6 +16592,7 @@ void Player::KilledPlayerCredit()
 {
     uint16 addkillcount = 1;
 
+
     for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
     {
         uint32 questid = GetQuestSlotQuestId(i);
@@ -16928,6 +17281,8 @@ bool Player::LoadFromDB(ObjectGuid guid, SQLQueryHolder *holder)
         CharacterDatabase.Execute(stmt);
         return false;
     }
+    // Cleanup old Wowarmory feeds
+    InitWowarmoryFeeds();
 
     // overwrite possible wrong/corrupted guid
     SetGuidValue(OBJECT_FIELD_GUID, guid);
@@ -16946,6 +17301,11 @@ bool Player::LoadFromDB(ObjectGuid guid, SQLQueryHolder *holder)
     bytes0 |= gender << 16;                                 // gender
     SetUInt32Value(UNIT_FIELD_BYTES_0, bytes0);
 
+    SetCFSRace(); //**** umisteni ****
+    m_team = TeamForRace(getCFSRace());
+    SetFakeRaceAndMorph(); // m_team must be set before this can be used.
+    setFactionForRace(getCFSRace());//Need to call it to initialize m_team (m_team can be calculated from race)
+
     // check if race/class combination is valid
     PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
     if (!info)
@@ -17014,9 +17374,7 @@ bool Player::LoadFromDB(ObjectGuid guid, SQLQueryHolder *holder)
     TC_LOG_DEBUG("entities.player.loading", "Load Basic value of player %s is: ", m_name.c_str());
     outDebugValues();
 
-    //Need to call it to initialize m_team (m_team can be calculated from race)
-    //Other way is to saves m_team into characters table.
-    setFactionForRace(getRace());
+   
 
     // load home bind and check in same time class/race pair, it used later for restore broken positions
     if (!_LoadHomeBind(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_HOME_BIND)))
@@ -17319,6 +17677,7 @@ bool Player::LoadFromDB(ObjectGuid guid, SQLQueryHolder *holder)
         }
     }
 
+
     SetMap(map);
     StoreRaidMapDifficulty();
 
@@ -17472,6 +17831,7 @@ bool Player::LoadFromDB(ObjectGuid guid, SQLQueryHolder *holder)
     LearnDefaultSkills();
     LearnCustomSpells();
 
+
     // must be before inventory (some items required reputation check)
     m_reputationMgr->LoadFromDB(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_REPUTATION));
 
@@ -17585,9 +17945,77 @@ bool Player::LoadFromDB(ObjectGuid guid, SQLQueryHolder *holder)
 
     _LoadEquipmentSets(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_EQUIPMENT_SETS));
 
+    // Loads the jail datas and if jailed it corrects the position to the corresponding jail
+    _LoadJail();
+
     return true;
 }
 
+void Player::_LoadJail(void)
+{
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    QueryResult result = CharacterDatabase.PQuery("SELECT * FROM `jail` WHERE `guid`='%u' LIMIT 1", GetGUID().GetCounter());
+    CharacterDatabase.CommitTransaction(trans);
+
+    if (!result)
+    {
+        m_jail_isjailed = false;
+        return;
+    }
+
+        Field *fields = result->Fetch();
+        m_jail_warning = true;
+        m_jail_isjailed = true;
+        m_jail_guid = fields[0].GetUInt32();
+        m_jail_char = fields[1].GetString();
+        m_jail_release = fields[2].GetUInt32();
+        m_jail_amnestietime = fields[3].GetUInt32();
+        m_jail_reason = fields[4].GetString();
+        m_jail_times = fields[5].GetUInt32();
+        m_jail_gmacc = fields[6].GetUInt32();
+        m_jail_gmchar = fields[7].GetString();
+        m_jail_lasttime = fields[8].GetString();
+        m_jail_duration = fields[9].GetUInt32();
+
+    if (m_jail_release == 0)
+    {
+        m_jail_isjailed = false;
+        return;
+    }
+
+    time_t localtime;
+    localtime = time(NULL);
+
+    if (m_jail_release <= localtime)
+    {
+        m_jail_isjailed = false;
+        m_jail_release = 0;
+
+        _SaveJail();
+
+        sWorld->SendWorldText(LANG_JAIL_CHAR_FREE, GetName().c_str());
+
+        CastSpell(this,8690,false);
+        return;
+    }
+
+    if (m_jail_isjailed)
+    {
+        if (m_team == ALLIANCE)
+        {
+            TeleportTo(sObjectMgr->m_jailconf_ally_m, sObjectMgr->m_jailconf_ally_x,
+                sObjectMgr->m_jailconf_ally_y, sObjectMgr->m_jailconf_ally_z, sObjectMgr->m_jailconf_ally_o);
+        }
+        else
+        {
+            TeleportTo(sObjectMgr->m_jailconf_horde_m, sObjectMgr->m_jailconf_horde_x,
+                sObjectMgr->m_jailconf_horde_y, sObjectMgr->m_jailconf_horde_z, sObjectMgr->m_jailconf_horde_o);
+        }
+         
+        sWorld->SendWorldText(LANG_JAIL_CHAR_TELE, GetName().c_str());
+    }
+}
+
 bool Player::isAllowedToLoot(const Creature* creature)
 {
     if (!creature->isDead() || !creature->IsDamageEnoughForLootingAndReward())
@@ -17674,6 +18102,7 @@ void Player::_LoadAuras(PreparedQueryResult result, uint32 timediff)
                                                     maxDuration, remainTime, remainCharges FROM character_aura WHERE guid = '%u'", GetGUID().GetCounter());
     */
 
+
     if (result)
     {
         do
@@ -18237,6 +18666,7 @@ void Player::_LoadQuestStatus(PreparedQueryResult result)
                 questStatusData.ItemCount[3] = fields[11].GetUInt16();
                 questStatusData.PlayerCount = fields[12].GetUInt16();
 
+
                 // add to quest log
                 if (slot < MAX_QUEST_LOG_SIZE && questStatusData.Status != QUEST_STATUS_NONE)
                 {
@@ -18382,6 +18812,7 @@ void Player::_LoadSeasonalQuestStatus(PreparedQueryResult result)
 {
     m_seasonalquests.clear();
 
+
     if (result)
     {
         do
@@ -18406,6 +18837,7 @@ void Player::_LoadMonthlyQuestStatus(PreparedQueryResult result)
 {
     m_monthlyquests.clear();
 
+
     if (result)
     {
         do
@@ -18892,7 +19324,7 @@ void Player::AddInstanceEnterTime(uint32 instanceId, time_t enterTime)
 
 bool Player::_LoadHomeBind(PreparedQueryResult result)
 {
-    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
+    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getCFSRace(), getClass());
     if (!info)
     {
         TC_LOG_ERROR("entities.player", "Player (Name %s) has incorrect race/class pair. Can't be loaded.", GetName().c_str());
@@ -18953,8 +19385,21 @@ bool Player::_LoadHomeBind(PreparedQueryResult result)
 /***                   SAVE SYSTEM                     ***/
 /*********************************************************/
 
+// Saves the jail datas (added by WarHead) edited by LordPsyan.
+void Player::_SaveJail(void)
+{
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    QueryResult result = CharacterDatabase.PQuery("SELECT `guid` FROM `jail` WHERE `guid`='%u' LIMIT 1", m_jail_guid);
+    if (!result) CharacterDatabase.PExecute("INSERT INTO `jail` VALUES ('%u','%s','%u', '%u','%s','%u','%u','%s',CURRENT_TIMESTAMP,'%u')", m_jail_guid, m_jail_char.c_str(), m_jail_release, m_jail_amnestietime, m_jail_reason.c_str(), m_jail_times, m_jail_gmacc, m_jail_gmchar.c_str(), m_jail_duration);
+    else CharacterDatabase.PExecute("UPDATE `jail` SET `release`='%u', `amnestietime`='%u',`reason`='%s',`times`='%u',`gmacc`='%u',`gmchar`='%s',`duration`='%u' WHERE `guid`='%u' LIMIT 1", m_jail_release, m_jail_amnestietime, m_jail_reason.c_str(), m_jail_times, m_jail_gmacc, m_jail_gmchar.c_str(), m_jail_duration, m_jail_guid);
+    CharacterDatabase.CommitTransaction(trans);
+}
+
 void Player::SaveToDB(bool create /*=false*/)
 {
+    // Jail: Prevent saving of jailed players
+    if (m_jail_isjailed) return;
+
     // delay auto save at any saves (manual, in code, or autosave)
     m_nextSave = sWorld->getIntConfig(CONFIG_INTERVAL_SAVE);
 
@@ -18985,7 +19430,7 @@ void Player::SaveToDB(bool create /*=false*/)
         stmt->setUInt32(index++, GetGUID().GetCounter());
         stmt->setUInt32(index++, GetSession()->GetAccountId());
         stmt->setString(index++, GetName());
-        stmt->setUInt8(index++, getRace());
+        stmt->setUInt8(index++, getCFSRace());
         stmt->setUInt8(index++, getClass());
         stmt->setUInt8(index++, GetByteValue(PLAYER_BYTES_3, 0));   // save gender from PLAYER_BYTES_3, UNIT_BYTES_0 changes with every transform effect
         stmt->setUInt8(index++, getLevel());
@@ -19010,6 +19455,7 @@ void Player::SaveToDB(bool create /*=false*/)
             transLowGUID = GetTransport()->GetGUID().GetCounter();
         stmt->setUInt32(index++, transLowGUID);
 
+
         std::ostringstream ss;
         ss << m_taxi;
         stmt->setString(index++, ss.str());
@@ -19090,7 +19536,7 @@ void Player::SaveToDB(bool create /*=false*/)
         // Update query
         stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHARACTER);
         stmt->setString(index++, GetName());
-        stmt->setUInt8(index++, getRace());
+        stmt->setUInt8(index++, getCFSRace());
         stmt->setUInt8(index++, getClass());
         stmt->setUInt8(index++, GetByteValue(PLAYER_BYTES_3, 0));   // save gender from PLAYER_BYTES_3, UNIT_BYTES_0 changes with every transform effect
         stmt->setUInt8(index++, getLevel());
@@ -19244,6 +19690,33 @@ void Player::SaveToDB(bool create /*=false*/)
 
     CharacterDatabase.CommitTransaction(trans);
 
+        /* World of Warcraft Armory */
+    // Place this code AFTER CharacterDatabase.CommitTransaction(); to avoid some character saving errors.
+    // Wowarmory feeds
+    if (sWorld->getBoolConfig(CONFIG_ARMORY_ENABLE))
+    {
+        std::ostringstream sWowarmory;
+        for (WowarmoryFeeds::iterator iter = m_wowarmory_feeds.begin(); iter < m_wowarmory_feeds.end(); ++iter) {
+            sWowarmory << "INSERT IGNORE INTO character_feed_log (guid,type,data,date,counter,difficulty,item_guid,item_quality) VALUES ";
+            //                      guid                    type                        data                    date                            counter                   difficulty                        item_guid                      item_quality
+            sWowarmory << "(" << (*iter).guid << ", " << (*iter).type << ", " << (*iter).data << ", " << uint64((*iter).date) << ", " << (*iter).counter << ", " << uint32((*iter).difficulty) << ", " << (*iter).item_guid << ", " << (*iter).item_quality <<  ");";
+            CharacterDatabase.PExecute(sWowarmory.str().c_str());
+            sWowarmory.str("");
+        }
+        // Clear old saved feeds from storage - they are not required for server core.
+        InitWowarmoryFeeds();
+        // Character stats
+        std::ostringstream ps;
+        time_t t = time(NULL);
+        CharacterDatabase.PExecute("DELETE FROM armory_character_stats WHERE guid = %u", GetGUID().GetCounter());
+        ps << "INSERT INTO armory_character_stats (guid, data, save_date) VALUES (" << GetGUID().GetCounter() << ", '";
+        for (uint16 i = 0; i < m_valuesCount; ++i)
+            ps << GetUInt32Value(i) << " ";
+        ps << "', " << uint64(t) << ");";
+        CharacterDatabase.PExecute(ps.str().c_str());
+    }
+    /* World of Warcraft Armory */
+
     // save pet (hunter pet level and experience and all type pets health/mana).
     if (Pet* pet = GetPet())
         pet->SavePetToDB(PET_SAVE_AS_CURRENT);
@@ -20472,6 +20945,7 @@ void Player::PetSpellInitialize()
     //Cooldowns
     pet->GetSpellHistory()->WritePacket<Pet>(data);
 
+
     GetSession()->SendPacket(&data);
 }
 
@@ -21165,6 +21639,7 @@ void Player::ContinueTaxiFlight()
     if (!mountDisplayId)
         return;
 
+
     uint32 path = m_taxi.GetCurrentTaxiPath();
 
     // search appropriate start path node
@@ -21213,6 +21688,7 @@ void Player::InitDataForForm(bool reapplyMods)
 {
     ShapeshiftForm form = GetShapeshiftForm();
 
+
     SpellShapeshiftEntry const* ssEntry = sSpellShapeshiftStore.LookupEntry(form);
     if (ssEntry && ssEntry->attackSpeed)
     {
@@ -21258,22 +21734,27 @@ void Player::InitDataForForm(bool reapplyMods)
 
 void Player::InitDisplayIds()
 {
-    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
+    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getCFSRace(), getClass());
     if (!info)
     {
         TC_LOG_ERROR("entities.player", "Player %s (%s) has incorrect race/class pair. Can't init display ids.", GetName().c_str(), GetGUID().ToString().c_str());
         return;
     }
 
+    bool isMorphed = GetNativeDisplayId() != GetDisplayId();
+
     uint8 gender = GetByteValue(PLAYER_BYTES_3, 0);
     switch (gender)
     {
         case GENDER_FEMALE:
-            SetDisplayId(info->displayId_f);
+            if (!isMorphed)
+                SetDisplayId(info->displayId_f);
             SetNativeDisplayId(info->displayId_f);
             break;
         case GENDER_MALE:
-            SetDisplayId(info->displayId_m);
+            if (!isMorphed)
+                if (!isMorphed)
+                    SetDisplayId(info->displayId_m);
             SetNativeDisplayId(info->displayId_m);
             break;
         default:
@@ -21364,23 +21845,29 @@ bool Player::BuyItemFromVendorSlot(ObjectGuid vendorguid, uint32 vendorslot, uin
         return false;
     }
 
-    if (!(pProto->AllowableClass & getClassMask()) && pProto->Bonding == BIND_WHEN_PICKED_UP && !IsGameMaster())
+    Creature* creature = GetNPCIfCanInteractWith(vendorguid, UNIT_NPC_FLAG_VENDOR);
+    if (!creature)
     {
-        SendBuyError(BUY_ERR_CANT_FIND_ITEM, NULL, item, 0);
+        TC_LOG_DEBUG("network", "WORLD: BuyItemFromVendor - %s not found or you can't interact with him.", vendorguid.ToString().c_str());
+        SendBuyError(BUY_ERR_DISTANCE_TOO_FAR, NULL, item, 0);
         return false;
     }
 
-    if (!IsGameMaster() && ((pProto->Flags2 & ITEM_FLAGS_EXTRA_HORDE_ONLY && GetTeam() == ALLIANCE) || (pProto->Flags2 == ITEM_FLAGS_EXTRA_ALLIANCE_ONLY && GetTeam() == HORDE)))
+    if (creature->GetScriptName() == "NPC_TransmogDisplayVendor")
+    {
+        TransmogDisplayVendorMgr::HandleTransmogrify(this, creature, vendorslot, item);
         return false;
+    }
 
-    Creature* creature = GetNPCIfCanInteractWith(vendorguid, UNIT_NPC_FLAG_VENDOR);
-    if (!creature)
+    if (!(pProto->AllowableClass & getClassMask()) && pProto->Bonding == BIND_WHEN_PICKED_UP && !IsGameMaster())
     {
-        TC_LOG_DEBUG("network", "WORLD: BuyItemFromVendor - %s not found or you can't interact with him.", vendorguid.ToString().c_str());
-        SendBuyError(BUY_ERR_DISTANCE_TOO_FAR, NULL, item, 0);
+        SendBuyError(BUY_ERR_CANT_FIND_ITEM, NULL, item, 0);
         return false;
     }
 
+    if (!IsGameMaster() && ((pProto->Flags2 & ITEM_FLAGS_EXTRA_HORDE_ONLY && GetTeam() == ALLIANCE) || (pProto->Flags2 == ITEM_FLAGS_EXTRA_ALLIANCE_ONLY && GetTeam() == HORDE)))
+        return false;
+
     if (!sConditionMgr->IsObjectMeetingVendorItemConditions(creature->GetEntry(), item, this, creature))
     {
         TC_LOG_DEBUG("condition", "BuyItemFromVendor: conditions not met for creature entry %u item %u", creature->GetEntry(), item);
@@ -21520,6 +22007,7 @@ uint32 Player::GetMaxPersonalArenaRatingRequirement(uint32 minarenaslot) const
     uint32 max_personal_rating = 0;
     for (uint8 i = minarenaslot; i < MAX_ARENA_SLOT; ++i)
     {
+        if(i == 2 && sWorld->getBoolConfig(CONFIG_ARENA_1V1_VENDOR_RATING) == false) continue;
         if (ArenaTeam* at = sArenaTeamMgr->GetArenaTeamById(GetArenaTeamId(i)))
         {
             uint32 p_rating = GetArenaPersonalRating(i);
@@ -21878,10 +22366,7 @@ void Player::SetBGTeam(uint32 team)
     SetByteValue(PLAYER_BYTES_3, 3, uint8(team == ALLIANCE ? 1 : 0));
 }
 
-uint32 Player::GetBGTeam() const
-{
-    return m_bgData.bgTeam ? m_bgData.bgTeam : GetTeam();
-}
+
 
 void Player::LeaveBattleground(bool teleportToEntryPoint)
 {
@@ -21968,7 +22453,7 @@ void Player::ReportedAfkBy(Player* reporter)
 
 WorldLocation Player::GetStartPosition() const
 {
-    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
+    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getCFSRace(), getClass());
     uint32 mapId = info->mapId;
     if (getClass() == CLASS_DEATH_KNIGHT && HasSpell(50977))
         mapId = 0;
@@ -21985,9 +22470,11 @@ bool Player::IsNeverVisible() const
     if (Unit::IsNeverVisible())
         return true;
 
+
     if (GetSession()->PlayerLogout() || GetSession()->PlayerLoading())
         return true;
 
+
     return false;
 }
 
@@ -22013,6 +22500,7 @@ bool Player::IsAlwaysDetectableFor(WorldObject const* seer) const
         if (IsGroupVisibleFor(seerPlayer))
             return !(seerPlayer->duel && seerPlayer->duel->startTime != 0 && seerPlayer->duel->opponent == this);
 
+
     return false;
 }
 
@@ -22423,10 +22911,13 @@ void Player::SendInitialPacketsBeforeAddToMap()
 
     SendEquipmentSetList();
 
+    float speedrate = sWorld->getFloatConfig(CONFIG_SPEED_GAME);
+    uint32 speedtime = ((sWorld->GetGameTime() - sWorld->GetUptime()) + (sWorld->GetUptime() * speedrate));
+
     data.Initialize(SMSG_LOGIN_SETTIMESPEED, 4 + 4 + 4);
-    data.AppendPackedTime(sWorld->GetGameTime());
-    data << float(0.01666667f);                             // game speed
-    data << uint32(0);                                      // added in 3.1.2
+    data.AppendPackedTime(speedtime);
+    data << float(0.01666667f) * speedrate; // game speed
+    data << uint32(0); // added in 3.1.2
     GetSession()->SendPacket(&data);
 
     GetReputationMgr().SendForceReactions();                // SMSG_SET_FORCED_REACTIONS
@@ -22654,7 +23145,7 @@ void Player::LearnCustomSpells()
     for (PlayerCreateInfoSpells::const_iterator itr = info->customSpells.begin(); itr != info->customSpells.end(); ++itr)
     {
         uint32 tspell = *itr;
-        TC_LOG_DEBUG("entities.player.loading", "PLAYER (Class: %u Race: %u): Adding initial spell, id = %u", uint32(getClass()), uint32(getRace()), tspell);
+        TC_LOG_DEBUG("entities.player.loading", "PLAYER (Class: %u Race: %u): Adding initial spell, id = %u", uint32(getClass()), uint32(getCFSRace()), tspell);
         if (!IsInWorld())                                    // will send in INITIAL_SPELLS in list anyway at map add
             AddSpell(tspell, true, true, true, false);
         else                                                // but send in normal spell in game learn case
@@ -23711,6 +24202,7 @@ int32 Player::CalculateCorpseReclaimDelay(bool load)
 
         uint64 count = 0;
 
+
         if ((pvp && sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVP)) ||
            (!pvp && sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVE)))
         {
@@ -24584,11 +25076,14 @@ void Player::_LoadSkills(PreparedQueryResult result)
                 TC_LOG_ERROR("entities.player", "Character %u has skill %u with value 0. Will be deleted.", GetGUID().GetCounter(), skill);
 
                 PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHARACTER_SKILL);
+                PreparedStatement* stmt2 = CharacterDatabase.GetPreparedStatement(CHAR_DEL_JAIL);
 
                 stmt->setUInt32(0, GetGUID().GetCounter());
                 stmt->setUInt16(1, skill);
 
                 CharacterDatabase.Execute(stmt);
+                CharacterDatabase.Execute(stmt2);
+
 
                 continue;
             }
@@ -26132,6 +26627,47 @@ void Player::_SaveInstanceTimeRestrictions(SQLTransaction& trans)
     }
 }
 
+/** World of Warcraft Armory **/
+void Player::InitWowarmoryFeeds() {
+    // Clear feeds
+    m_wowarmory_feeds.clear();
+}
+
+void Player::CreateWowarmoryFeed(uint32 type, uint32 data, uint32 item_guid, uint32 item_quality) {
+    /*
+        1 - TYPE_ACHIEVEMENT_FEED
+        2 - TYPE_ITEM_FEED
+        3 - TYPE_BOSS_FEED
+    */
+    if (GetGUID().GetCounter() == 0)
+    {
+        TC_LOG_DEBUG("server.loading", "[Wowarmory]: player is not initialized, unable to create log entry!");
+        return;
+    }
+    if (type <= 0 || type > 3)
+    {
+        TC_LOG_DEBUG("server.loading", "[Wowarmory]: unknown feed type: %d, ignore.", type);
+        return;
+    }
+    if (data == 0)
+    {
+        TC_LOG_DEBUG("server.loading", "[Wowarmory]: empty data (GUID: %u), ignore.", GetGUID().GetCounter());
+        return;
+    }
+    WowarmoryFeedEntry feed;
+    feed.guid = GetGUID().GetCounter();
+    feed.type = type;
+    feed.data = data;
+    feed.difficulty = type == 3 ? GetMap()->GetDifficulty() : 0;
+    feed.item_guid  = item_guid;
+    feed.item_quality = item_quality;
+    feed.counter = 0;
+    feed.date = time(NULL);
+    TC_LOG_DEBUG("server.loading", "[Wowarmory]: create wowarmory feed (GUID: %u, type: %d, data: %u).", feed.guid, feed.type, feed.data);
+    m_wowarmory_feeds.push_back(feed);
+}
+/** World of Warcraft Armory **/
+
 bool Player::IsInWhisperWhiteList(ObjectGuid guid)
 {
     for (GuidList::const_iterator itr = WhisperList.begin(); itr != WhisperList.end(); ++itr)
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index b7d7d81..67500ef 100644
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -29,6 +29,7 @@
 #include "SpellMgr.h"
 #include "SpellHistory.h"
 #include "Unit.h"
+#include "../../scripts/Custom/Transmogrification.h"
 #include "TradeData.h"
 
 #include <limits>
@@ -126,10 +127,31 @@ struct SpellModifier
     Aura* const ownerAura;
 };
 
+typedef std::unordered_map<ObjectGuid, uint32> TransmogMapType;
+
+#ifdef PRESETS
+typedef std::map<uint8, uint32> PresetslotMapType;
+struct PresetData
+{
+    std::string name;
+    PresetslotMapType slotMap; // slotMap[slotId] = entry
+};
+typedef std::map<uint8, PresetData> PresetMapType;
+#endif
+
+typedef std::unordered_map<ObjectGuid, uint32> TransmogMapType;
 typedef std::unordered_map<uint32, PlayerTalent*> PlayerTalentMap;
 typedef std::unordered_map<uint32, PlayerSpell*> PlayerSpellMap;
 typedef std::list<SpellModifier*> SpellModList;
 
+struct ReforgeData
+{
+    uint32 increase, decrease;
+    int32 stat_value;
+};
+
+typedef std::unordered_map<uint32, ReforgeData> ReforgeMapType;
+
 typedef std::unordered_map<uint32 /*instanceId*/, time_t/*releaseTime*/> InstanceTimeMap;
 
 enum TrainerSpellState
@@ -414,6 +436,27 @@ enum PlayerFlags
     PLAYER_FLAGS_UNK31             = 0x80000000
 };
 
+#define PLAYER_TITLE_MASK_ALLIANCE_PVP             \
+    (PLAYER_TITLE_PRIVATE | PLAYER_TITLE_CORPORAL |  \
+      PLAYER_TITLE_SERGEANT_A | PLAYER_TITLE_MASTER_SERGEANT | \
+      PLAYER_TITLE_SERGEANT_MAJOR | PLAYER_TITLE_KNIGHT | \
+      PLAYER_TITLE_KNIGHT_LIEUTENANT | PLAYER_TITLE_KNIGHT_CAPTAIN | \
+      PLAYER_TITLE_KNIGHT_CHAMPION | PLAYER_TITLE_LIEUTENANT_COMMANDER | \
+      PLAYER_TITLE_COMMANDER | PLAYER_TITLE_MARSHAL | \
+      PLAYER_TITLE_FIELD_MARSHAL | PLAYER_TITLE_GRAND_MARSHAL)
+
+#define PLAYER_TITLE_MASK_HORDE_PVP                           \
+    (PLAYER_TITLE_SCOUT | PLAYER_TITLE_GRUNT |  \
+      PLAYER_TITLE_SERGEANT_H | PLAYER_TITLE_SENIOR_SERGEANT | \
+      PLAYER_TITLE_FIRST_SERGEANT | PLAYER_TITLE_STONE_GUARD | \
+      PLAYER_TITLE_BLOOD_GUARD | PLAYER_TITLE_LEGIONNAIRE | \
+      PLAYER_TITLE_CENTURION | PLAYER_TITLE_CHAMPION | \
+      PLAYER_TITLE_LIEUTENANT_GENERAL | PLAYER_TITLE_GENERAL | \
+      PLAYER_TITLE_WARLORD | PLAYER_TITLE_HIGH_WARLORD)
+
+#define PLAYER_TITLE_MASK_ALL_PVP  \
+    (PLAYER_TITLE_MASK_ALLIANCE_PVP | PLAYER_TITLE_MASK_HORDE_PVP)
+
 // used for PLAYER__FIELD_KNOWN_TITLES field (uint64), (1<<bit_index) without (-1)
 // can't use enum for uint64 values
 #define PLAYER_TITLE_DISABLED              UI64LIT(0x0000000000000000)
@@ -1000,6 +1043,21 @@ struct TradeStatusInfo
     uint8 Slot;
 };
 
+/* World of Warcraft Armory */
+struct WowarmoryFeedEntry {
+    uint32 guid;         // Player GUID
+    time_t date;         // Log date
+    uint32 type;         // TYPE_ACHIEVEMENT_FEED, TYPE_ITEM_FEED, TYPE_BOSS_FEED
+    uint32 data;         // TYPE_ITEM_FEED: item_entry, TYPE_BOSS_FEED: creature_entry
+    uint32 item_guid;    // Can be 0
+    uint32 item_quality; // Can be 0
+    uint8  difficulty;   // Can be 0
+    int    counter;      // Can be 0
+};
+
+typedef std::vector<WowarmoryFeedEntry> WowarmoryFeeds;
+/* World of Warcraft Armory */
+
 class Player : public Unit, public GridObject<Player>
 {
     friend class WorldSession;
@@ -1009,6 +1067,36 @@ class Player : public Unit, public GridObject<Player>
         explicit Player(WorldSession* session);
         ~Player();
 
+        private:
+            bool m_ForgetBGPlayers;
+            bool m_ForgetInListPlayers;
+            uint8 m_FakeRace;
+            uint8 m_RealRace;
+            uint32 m_FakeMorph;
+            public:
+                typedef std::vector<uint64> FakePlayers;
+                void SendChatMessage(const char *format, ...);
+                void FitPlayerInTeam(bool action, Battleground* pBattleGround = NULL);          // void FitPlayerInTeam(bool action, Battleground* bg = NULL);
+                void DoForgetPlayersInList();
+                void DoForgetPlayersInBG(Battleground* pBattleGround);                                          // void DoForgetPlayersInBG(Battleground* bg);
+                uint8 getCFSRace() const { return m_RealRace; }
+                void SetCFSRace() { m_RealRace = GetByteValue(UNIT_FIELD_BYTES_0, 0); }; // SHOULD ONLY BE CALLED ON LOGIN
+                void SetFakeRace(); // SHOULD ONLY BE CALLED ON LOGIN
+                void SetFakeRaceAndMorph(); // SHOULD ONLY BE CALLED ON LOGIN
+                uint32 GetFakeMorph() { return m_FakeMorph; };
+                uint8 getFRace() const { return m_FakeRace; }
+                void SetForgetBGPlayers(bool value) { m_ForgetBGPlayers = value; }
+                bool ShouldForgetBGPlayers() { return m_ForgetBGPlayers; }
+                void SetForgetInListPlayers(bool value) { m_ForgetInListPlayers = value; }
+                bool ShouldForgetInListPlayers() { return m_ForgetInListPlayers; }
+                bool SendBattleGroundChat(uint32 msgtype, std::string message);
+                void MorphFit(bool value);
+                bool IsPlayingNative() const { return GetTeam() == m_team; }
+                uint32 GetCFSTeam() const { return m_team; }
+                uint32 GetTeam() const { return m_bgData.bgTeam && GetBattleground() ? m_bgData.bgTeam : m_team; }
+                bool SendRealNameQuery();
+                FakePlayers m_FakePlayers;
+
         void CleanupsBeforeDelete(bool finalCleanup = true) override;
 
         void AddToWorld() override;
@@ -1065,7 +1153,7 @@ class Player : public Unit, public GridObject<Player>
         PlayerSocial *GetSocial() { return m_social; }
 
         PlayerTaxi m_taxi;
-        void InitTaxiNodesForLevel() { m_taxi.InitTaxiNodesForLevel(getRace(), getClass(), getLevel()); }
+        void InitTaxiNodesForLevel() { m_taxi.InitTaxiNodesForLevel(getCFSRace(), getClass(), getLevel()); }
         bool ActivateTaxiPathTo(std::vector<uint32> const& nodes, Creature* npc = NULL, uint32 spellid = 0);
         bool ActivateTaxiPathTo(uint32 taxi_path_id, uint32 spellid = 0);
         void CleanupAfterTaxiFlight();
@@ -1096,6 +1184,12 @@ class Player : public Unit, public GridObject<Player>
         void SetCommandStatusOn(uint32 command) { _activeCheats |= command; }
         void SetCommandStatusOff(uint32 command) { _activeCheats &= ~command; }
 
+        // PlayedTimeReward
+        uint32 ptr_Interval;
+        uint32 ptr_Money;
+        uint32 ptr_Honor;
+        uint32 ptr_Arena;
+
         // Played Time Stuff
         time_t m_logintime;
         time_t m_Last_tick;
@@ -1829,8 +1923,7 @@ class Player : public Unit, public GridObject<Player>
         void CheckAreaExploreAndOutdoor(void);
 
         static uint32 TeamForRace(uint8 race);
-        uint32 GetTeam() const { return m_team; }
-        TeamId GetTeamId() const { return m_team == ALLIANCE ? TEAM_ALLIANCE : TEAM_HORDE; }
+        TeamId GetTeamId() const { return GetTeam() == ALLIANCE ? TEAM_ALLIANCE : TEAM_HORDE; }
         void setFactionForRace(uint8 race);
 
         void InitDisplayIds();
@@ -1867,6 +1960,7 @@ class Player : public Unit, public GridObject<Player>
         void ModifyHonorPoints(int32 value, SQLTransaction trans = SQLTransaction(nullptr));      //! If trans is specified, honor save query will be added to trans
         void ModifyArenaPoints(int32 value, SQLTransaction trans = SQLTransaction(nullptr));      //! If trans is specified, arena point save query will be added to trans
         uint32 GetMaxPersonalArenaRatingRequirement(uint32 minarenaslot) const;
+        void UpdateKnownTitles();
         void SetHonorPoints(uint32 value);
         void SetArenaPoints(uint32 value);
 
@@ -1979,7 +2073,6 @@ class Player : public Unit, public GridObject<Player>
         void SetBattlegroundEntryPoint();
 
         void SetBGTeam(uint32 team);
-        uint32 GetBGTeam() const;
 
         void LeaveBattleground(bool teleportToEntryPoint = true);
         bool CanJoinToBattleground(Battleground const* bg) const;
@@ -2010,6 +2103,25 @@ class Player : public Unit, public GridObject<Player>
 
         bool IsImmuneToEnvironmentalDamage();
         uint32 EnvironmentalDamage(EnviromentalDamage type, uint32 damage);
+        // Jail by WarHead edited by spgm
+        // ---------------
+        // Char datas...
+        bool m_jail_warning;
+        bool m_jail_amnestie;
+        bool m_jail_isjailed;           // Is this player jailed?
+        std::string m_jail_char;        // Name of jailed char
+        uint32 m_jail_guid;             // guid of the jailed char
+        uint32 m_jail_release;          // When is the player a free man/woman?
+        std::string m_jail_reason;      // Why was the char jailed?
+        uint32 m_jail_times;            // How often was the player jailed?
+        uint32 m_jail_amnestietime;
+        uint32 m_jail_gmacc;            // Used GM acc
+        std::string m_jail_gmchar;      // Used GM char
+        std::string m_jail_lasttime;    // Last jail time
+        uint32 m_jail_duration;         // Duration of the jail
+        // Load / save functions...
+        void _LoadJail(void);           // Loads the jail datas
+        void _SaveJail(void);           // Saves the jail datas
 
         /*********************************************************/
         /***               FLOOD FILTER SYSTEM                 ***/
@@ -2102,6 +2214,10 @@ class Player : public Unit, public GridObject<Player>
         void SendCinematicStart(uint32 CinematicSequenceId);
         void SendMovieStart(uint32 MovieId);
 
+        /* World of Warcraft Armory */
+        void CreateWowarmoryFeed(uint32 type, uint32 data, uint32 item_guid, uint32 item_quality);
+        void InitWowarmoryFeeds();
+        /* World of Warcraft Armory */
         /*********************************************************/
         /***                 INSTANCE SYSTEM                   ***/
         /*********************************************************/
@@ -2207,6 +2323,7 @@ class Player : public Unit, public GridObject<Player>
         void SetTitle(CharTitlesEntry const* title, bool lost = false);
 
         //bool isActiveObject() const { return true; }
+        ReforgeMapType reforgeMap; // reforgeMap[iGUID] = ReforgeData
         bool CanSeeSpellClickOn(Creature const* creature) const;
 
         uint32 GetChampioningFaction() const { return m_ChampioningFaction; }
@@ -2241,7 +2358,10 @@ class Player : public Unit, public GridObject<Player>
     // 04
     // 05
     // 06
-    // 07
+        TransmogMapType transmogMap; // transmogMap[iGUID] = entry
+#ifdef PRESETS
+        PresetMapType presetMap; // presetMap[presetId] = presetData
+#endif
     // 08
     // 09
     // 10
@@ -2579,6 +2699,8 @@ class Player : public Unit, public GridObject<Player>
         uint32 m_timeSyncTimer;
         uint32 m_timeSyncClient;
         uint32 m_timeSyncServer;
+        // World of Warcraft Armory Feeds
+        WowarmoryFeeds m_wowarmory_feeds;
 
         InstanceTimeMap _instanceResetTimes;
         uint32 _pendingBindId;
@@ -2606,7 +2728,8 @@ class Player : public Unit, public GridObject<Player>
         // 32
         // 33
         // 34
-        // 35
+    public :
+        QuestStatusSaveMap m_RewardedQuestsSave2;
         // 36
         // 37
         // 38
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
index 261f4fa..dd6e18f 100644
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -432,7 +432,14 @@ void Unit::DisableSpline()
 
 void Unit::resetAttackTimer(WeaponAttackType type)
 {
-    m_attackTimer[type] = uint32(GetAttackTime(type) * m_modAttackSpeedPct[type]);
+    if (GetTypeId() == TYPEID_PLAYER || (ToCreature()->GetOwner() && ToCreature()->GetOwner()->GetTypeId() == TYPEID_PLAYER))
+    {
+        m_attackTimer[type] = uint32(GetAttackTime(type) * m_modAttackSpeedPct[type] / sWorld->getFloatConfig(CONFIG_ATTACKSPEED_PLAYER));
+    }
+    else
+    {
+        m_attackTimer[type] = uint32(GetAttackTime(type) * m_modAttackSpeedPct[type] / sWorld->getFloatConfig(CONFIG_ATTACKSPEED_ALL));
+    }
 }
 
 float Unit::GetMeleeReach() const
@@ -707,8 +714,17 @@ uint32 Unit::DealDamage(Unit* victim, uint32 damage, CleanDamage const* cleanDam
 
         // in bg, count dmg if victim is also a player
         if (victim->GetTypeId() == TYPEID_PLAYER)
+        {
             if (Battleground* bg = killer->GetBattleground())
+            {
                 bg->UpdatePlayerScore(killer, SCORE_DAMAGE_DONE, damage);
+        /** World of Warcraft Armory **/
+                if (sWorld->getBoolConfig(CONFIG_ARMORY_ENABLE))
+                    if (Battleground *bgV = ((Player*)victim)->GetBattleground())
+                        bgV->UpdatePlayerScore(((Player*)victim), SCORE_DAMAGE_TAKEN, damage);
+                /** World of Warcraft Armory **/
+            }
+        }
 
         killer->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_DAMAGE_DONE, damage, 0, victim);
         killer->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_HIT_DEALT, damage);
@@ -9621,6 +9637,11 @@ int32 Unit::DealHeal(Unit* victim, uint32 addhealth)
     {
         player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_TOTAL_HEALING_RECEIVED, gain);
         player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_HEALING_RECEIVED, addhealth);
+        /** World of Warcraft Armory **/
+        if (sWorld->getBoolConfig(CONFIG_ARMORY_ENABLE))
+            if (Battleground *bgV = victim->ToPlayer()->GetBattleground())
+                bgV->UpdatePlayerScore((Player*)victim, SCORE_HEALING_TAKEN, gain);
+        /** World of Warcraft Armory **/
     }
 
     return gain;
@@ -9857,6 +9878,8 @@ int32 Unit::HealBySpell(Unit* victim, SpellInfo const* spellInfo, uint32 addHeal
     // calculate heal absorb and reduce healing
     CalcHealAbsorb(victim, spellInfo, addHealth, absorb);
 
+    sScriptMgr->ModifyHealRecieved(this, victim, addHealth);
+
     int32 gain = DealHeal(victim, addHealth);
     SendHealSpellLog(victim, spellInfo->Id, addHealth, uint32(addHealth - gain), absorb, critical);
     return gain;
@@ -15535,7 +15558,13 @@ void Unit::Kill(Unit* victim, bool durabilityLoss)
                 if (instanceMap->IsRaidOrHeroicDungeon())
                 {
                     if (creature->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_INSTANCE_BIND)
+                    {
                         ((InstanceMap*)instanceMap)->PermBindAllPlayers(creditedPlayer);
+                    /** World of Warcraft Armory **/
+                        if (sWorld->getBoolConfig(CONFIG_ARMORY_ENABLE))
+                            creditedPlayer->CreateWowarmoryFeed(3, creature->GetCreatureTemplate()->Entry, 0, 0);
+                        /** World of Warcraft Armory **/
+                    }
                 }
                 else
                 {
@@ -16861,6 +16890,21 @@ uint32 Unit::GetModelForTotem(PlayerTotemType totemType)
             }
             break;
         }
+        default: // One standard for other races.
+            {
+                switch (totemType)
+                    {
+                    case SUMMON_TYPE_TOTEM_FIRE:    // fire
+                        return 4589;
+                        case SUMMON_TYPE_TOTEM_EARTH:   // earth
+                            return 4588;
+                            case SUMMON_TYPE_TOTEM_WATER:   // water
+                                return 4587;
+                                case SUMMON_TYPE_TOTEM_AIR:     // air
+                                    return 4590;
+                                    }
+                break;
+                }
     }
     return 0;
 }
diff --git a/src/server/game/Entities/Unit/Unit.h b/src/server/game/Entities/Unit/Unit.h
index 90d312f..b9dbfe5 100644
--- a/src/server/game/Entities/Unit/Unit.h
+++ b/src/server/game/Entities/Unit/Unit.h
@@ -1311,8 +1311,10 @@ class Unit : public WorldObject
         uint8 getLevel() const { return uint8(GetUInt32Value(UNIT_FIELD_LEVEL)); }
         uint8 getLevelForTarget(WorldObject const* /*target*/) const override { return getLevel(); }
         void SetLevel(uint8 lvl);
-        uint8 getRace() const { return GetByteValue(UNIT_FIELD_BYTES_0, 0); }
+        uint8 getRace(bool forceoriginal = false) const;
+        uint8 getCFSRace() { return getRace(true); }
         uint32 getRaceMask() const { return 1 << (getRace()-1); }
+        uint32 getCFSRaceMask() const { return 1 << (getRace(true) - 1); }
         uint8 getClass() const { return GetByteValue(UNIT_FIELD_BYTES_0, 1); }
         uint32 getClassMask() const { return 1 << (getClass()-1); }
         uint8 getGender() const { return GetByteValue(UNIT_FIELD_BYTES_0, 2); }
diff --git a/src/server/game/Events/GameEventMgr.cpp b/src/server/game/Events/GameEventMgr.cpp
index b287178..50047ba 100644
--- a/src/server/game/Events/GameEventMgr.cpp
+++ b/src/server/game/Events/GameEventMgr.cpp
@@ -28,6 +28,7 @@
 #include "BattlegroundMgr.h"
 #include "UnitAI.h"
 #include "GameObjectAI.h"
+#include "IRCClient.h"
 
 bool GameEventMgr::CheckOneGameEvent(uint16 entry) const
 {
@@ -1087,6 +1088,12 @@ void GameEventMgr::ApplyNewEvent(uint16 event_id)
     uint8 announce = mGameEvent[event_id].announce;
     if (announce == 1 || (announce == 2 && sWorld->getBoolConfig(CONFIG_EVENT_ANNOUNCE)))
         sWorld->SendWorldText(LANG_EVENTMESSAGE, mGameEvent[event_id].description.c_str());
+       if ((sIRC->BOTMASK & 256) != 0 && sIRC->anchn.size() > 0)
+             {
+                 std::string ircchan = "#";
+                 ircchan += sIRC->anchn;
+                 sIRC->Send_IRC_Channel(ircchan, sIRC->MakeMsg("\00304,08\037/!\\\037\017\00304 Game Event \00304,08\037/!\\\037\017 %s", "%s", mGameEvent[event_id].description.c_str()), true);
+             }
 
     TC_LOG_INFO("gameevent", "GameEvent %u \"%s\" started.", event_id, mGameEvent[event_id].description.c_str());
 
diff --git a/src/server/game/Globals/ObjectMgr.cpp b/src/server/game/Globals/ObjectMgr.cpp
index d206409..95a169f 100644
--- a/src/server/game/Globals/ObjectMgr.cpp
+++ b/src/server/game/Globals/ObjectMgr.cpp
@@ -6505,6 +6505,121 @@ uint32 ObjectMgr::GeneratePetNumber()
     return ++_hiPetNumber;
 }
 
+// Loads the jail conf out of the database
+void ObjectMgr::LoadJailConf(void)
+{
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    QueryResult result = CharacterDatabase.PQuery("SELECT * FROM `jail_conf`");
+    CharacterDatabase.CommitTransaction(trans);
+
+    if (!result)
+    {
+        TC_LOG_ERROR("misc", GetTrinityStringForDBCLocale(LANG_JAIL_CONF_ERR1));
+        TC_LOG_ERROR("misc", GetTrinityStringForDBCLocale(LANG_JAIL_CONF_ERR2));
+
+        m_jailconf_max_jails    = 3;
+        m_jailconf_max_duration = 672;
+        m_jailconf_min_reason   = 25;
+        m_jailconf_warn_player  = 1;
+        m_jailconf_amnestie     = 180;
+
+        m_jailconf_ally_x       = -8673.43;
+        m_jailconf_ally_y       = 631.795;
+        m_jailconf_ally_z       = 96.9406;
+        m_jailconf_ally_o       = 2.1785;
+        m_jailconf_ally_m       = 0;
+
+        m_jailconf_horde_x      = 2179.85;
+        m_jailconf_horde_y      = -4763.96;
+        m_jailconf_horde_z      = 54.911;
+        m_jailconf_horde_o      = 4.44216;
+        m_jailconf_horde_m      = 1;
+
+        m_jailconf_ban          = 0;
+        m_jailconf_radius       = 10;
+
+        return;
+    }
+do
+{
+    Field *fields = result->Fetch();
+    m_jail_obt = fields[1].GetString();
+    if (m_jail_obt == "m_jailconf_max_jails")
+    {
+      m_jailconf_max_jails    = fields[2].GetUInt32();
+    }
+    if (m_jail_obt == "m_jailconf_max_duration")
+    {
+      m_jailconf_max_duration = fields[2].GetUInt32();
+    }
+    if (m_jail_obt == "m_jailconf_min_reason")
+    {
+      m_jailconf_min_reason   = fields[2].GetUInt32();
+    }
+    if (m_jail_obt == "m_jailconf_warn_player")
+    {
+      m_jailconf_warn_player  = fields[2].GetUInt32();
+    }
+    if (m_jail_obt == "m_jailconf_amnestie")
+    {
+      m_jailconf_amnestie     = fields[2].GetUInt32();
+    }
+    if (m_jail_obt == "m_jailconf_ally_x")
+    {
+      m_jailconf_ally_x       = fields[3].GetFloat();
+    }
+    if (m_jail_obt == "m_jailconf_ally_y")
+    {
+      m_jailconf_ally_y       = fields[3].GetFloat();
+    }
+    if (m_jail_obt == "m_jailconf_ally_z")
+    {
+      m_jailconf_ally_z       = fields[3].GetFloat();
+    }
+    if (m_jail_obt == "m_jailconf_ally_o")
+    {
+      m_jailconf_ally_o       = fields[3].GetFloat();
+    }
+    if (m_jail_obt == "m_jailconf_ally_m")
+    {
+      m_jailconf_ally_m       = fields[2].GetUInt32();
+    }
+    if (m_jail_obt == "m_jailconf_horde_x")
+    {
+      m_jailconf_horde_x      = fields[3].GetFloat();
+    }
+    if (m_jail_obt == "m_jailconf_horde_y")
+    {
+      m_jailconf_horde_y      = fields[3].GetFloat();
+    }
+    if (m_jail_obt == "m_jailconf_horde_z")
+    {
+      m_jailconf_horde_z      = fields[3].GetFloat();
+    }
+    if (m_jail_obt == "m_jailconf_horde_o")
+    {
+      m_jailconf_horde_o      = fields[3].GetFloat();
+    }
+    if (m_jail_obt == "m_jailconf_horde_m")
+    {
+      m_jailconf_horde_m      = fields[2].GetUInt32();
+    }
+    if (m_jail_obt == "m_jailconf_ban")
+    {
+      m_jailconf_ban = fields[2].GetUInt32();
+    }
+    if (m_jail_obt == "m_jailconf_radius")
+    {
+      m_jailconf_radius = fields[2].GetUInt32();
+    }
+}
+while (result->NextRow());
+
+    TC_LOG_INFO("server.loading", "");
+    TC_LOG_INFO("server.loading", GetTrinityStringForDBCLocale(LANG_JAIL_CONF_LOADED));
+    TC_LOG_INFO("server.loading", "");
+}
+
 uint32 ObjectMgr::GenerateCreatureSpawnId()
 {
     if (_creatureSpawnId >= uint32(0xFFFFFF))
diff --git a/src/server/game/Globals/ObjectMgr.h b/src/server/game/Globals/ObjectMgr.h
index ae12587..a79dc44 100644
--- a/src/server/game/Globals/ObjectMgr.h
+++ b/src/server/game/Globals/ObjectMgr.h
@@ -1043,6 +1043,29 @@ class ObjectMgr
         void LoadTrainerSpell();
         void AddSpellToTrainer(uint32 entry, uint32 spell, uint32 spellCost, uint32 reqSkill, uint32 reqSkillValue, uint32 reqLevel);
 
+        // Loads the jail conf out of the database
+        void LoadJailConf(void);
+
+        // Jail Config...
+        std::string m_jail_obt;
+        uint32 m_jailconf_max_jails;    // Jail times when the char will be deleted
+        uint32 m_jailconf_max_duration; // Max. jail duration in hours
+        uint32 m_jailconf_min_reason;   // Min. char length of the reason
+        uint32 m_jailconf_warn_player;  // Warn player every login if max_jails is nearly reached?
+        uint32 m_jailconf_amnestie;     // player amnestie
+        float m_jailconf_ally_x;        // Coords of the jail for the allies
+        float m_jailconf_ally_y;
+        float m_jailconf_ally_z;
+        float m_jailconf_ally_o;
+        uint32 m_jailconf_ally_m;
+        float m_jailconf_horde_x;       // Coords of the jail for the horde
+        float m_jailconf_horde_y;
+        float m_jailconf_horde_z;
+        float m_jailconf_horde_o;
+        uint32 m_jailconf_horde_m;
+        uint32 m_jailconf_ban;          // Ban acc if max. jailtimes is reached?
+        uint32 m_jailconf_radius;       // Radius in which a jailed char can walk
+
         std::string GeneratePetName(uint32 entry);
         uint32 GetBaseXP(uint8 level);
         uint32 GetXPForLevel(uint8 level) const;
diff --git a/src/server/game/Handlers/AuctionHouseHandler.cpp b/src/server/game/Handlers/AuctionHouseHandler.cpp
index f23888c..9f392b6 100644
--- a/src/server/game/Handlers/AuctionHouseHandler.cpp
+++ b/src/server/game/Handlers/AuctionHouseHandler.cpp
@@ -28,6 +28,7 @@
 #include "UpdateMask.h"
 #include "Util.h"
 #include "AccountMgr.h"
+#include "IRCClient.h"
 
 //void called when player click on auctioneer npc
 void WorldSession::HandleAuctionHelloOpcode(WorldPacket& recvData)
@@ -597,7 +598,8 @@ void WorldSession::HandleAuctionRemoveItem(WorldPacket& recvData)
     SendAuctionCommandResult(auction->Id, AUCTION_CANCEL, ERR_AUCTION_OK);
 
     // Now remove the auction
-
+    uint32 item;
+    recvData >> item;
     player->SaveInventoryAndGoldToDB(trans);
     auction->DeleteFromDB(trans);
     CharacterDatabase.CommitTransaction(trans);
diff --git a/src/server/game/Handlers/BattleGroundHandler.cpp b/src/server/game/Handlers/BattleGroundHandler.cpp
index bcc698d..9ef5b7b 100644
--- a/src/server/game/Handlers/BattleGroundHandler.cpp
+++ b/src/server/game/Handlers/BattleGroundHandler.cpp
@@ -37,7 +37,7 @@
 // Prepatch by LordPsyan
 // 01
 // 02
-// 03
+#include "../../scripts/Custom/npc_arena1v1.h"
 // 04
 // 05
 // 06
@@ -468,6 +468,10 @@ void WorldSession::HandleBattleFieldPortOpcode(WorldPacket &recvData)
         if (!_player->IsInvitedForBattlegroundQueueType(bgQueueTypeId))
             return;                                 // cheating?
 
+        // 1v1 Arena. Player can't join arena when forbidden talents are used.
+        if(bgQueueTypeId == BATTLEGROUND_QUEUE_5v5 && Arena1v1CheckTalents(_player) == false)
+            return;
+
         if (!_player->InBattleground())
             _player->SetBattlegroundEntryPoint();
 
@@ -584,7 +588,7 @@ void WorldSession::HandleBattlefieldStatusOpcode(WorldPacket & /*recvData*/)
             {
                 // this line is checked, i only don't know if GetStartTime is changing itself after bg end!
                 // send status in Battleground
-                sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, bg, i, STATUS_IN_PROGRESS, bg->GetEndTime(), bg->GetStartTime(), arenaType, _player->GetBGTeam());
+                sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, bg, i, STATUS_IN_PROGRESS, bg->GetEndTime(), bg->GetStartTime(), arenaType, _player->GetTeam());
                 SendPacket(&data);
                 continue;
             }
diff --git a/src/server/game/Handlers/CharacterHandler.cpp b/src/server/game/Handlers/CharacterHandler.cpp
index 1c31bf4..666ef40 100644
--- a/src/server/game/Handlers/CharacterHandler.cpp
+++ b/src/server/game/Handlers/CharacterHandler.cpp
@@ -1019,6 +1019,9 @@ void WorldSession::HandlePlayerLogin(LoginQueryHolder* holder)
     //
     // End of prepatch
     delete holder;
+
+    if (pCurrChar->GetTeam() != pCurrChar->GetCFSTeam())
+        pCurrChar->FitPlayerInTeam(pCurrChar->GetBattleground() && !pCurrChar->GetBattleground()->isArena() ? true : false, pCurrChar->GetBattleground());
 }
     // Prepatch by LordPsyan
     // 01
diff --git a/src/server/game/Handlers/ChatHandler.cpp b/src/server/game/Handlers/ChatHandler.cpp
index f7fd9c8..812f1ec 100644
--- a/src/server/game/Handlers/ChatHandler.cpp
+++ b/src/server/game/Handlers/ChatHandler.cpp
@@ -41,7 +41,7 @@
 // Prepatch by LordPsyan
 // 61
 // 62
-// 63
+#include "IRCClient.h"
 // 64
 // 65
 // 66
@@ -275,6 +275,10 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                 return;
             }
 
+            if (!GetPlayer()->IsGameMaster())
+                 if (GetPlayer()->SendBattleGroundChat(type, msg))
+                 return;
+
             if (type == CHAT_MSG_SAY)
                 sender->Say(msg, Language(lang));
             else if (type == CHAT_MSG_EMOTE)
@@ -453,6 +457,7 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
 
             if (ChannelMgr* cMgr = ChannelMgr::forTeam(sender->GetTeam()))
             {
+                sIRC->Send_WoW_IRC(sender, channel, msg);
                 if (Channel* chn = cMgr->GetChannel(channel, sender))
                 {
                     sScriptMgr->OnPlayerChat(sender, type, lang, msg, chn);
diff --git a/src/server/game/Handlers/MiscHandler.cpp b/src/server/game/Handlers/MiscHandler.cpp
index 758d5af..adef203 100644
--- a/src/server/game/Handlers/MiscHandler.cpp
+++ b/src/server/game/Handlers/MiscHandler.cpp
@@ -265,9 +265,10 @@ void WorldSession::HandleWhoOpcode(WorldPacket& recvData)
             continue;
 
         // check if target is globally visible for player
+        /* Remove check so Level 255 shows up in who list
         if (!target->IsVisibleGloballyFor(_player))
             continue;
-
+*/
         // check if target's level is in level range
         uint8 lvl = target->getLevel();
         if (lvl < level_min || lvl > level_max)
@@ -1446,6 +1447,22 @@ void WorldSession::HandleSetTitleOpcode(WorldPacket& recvData)
 
 void WorldSession::HandleTimeSyncResp(WorldPacket& recvData)
 {
+
+    Battleground* bg = _player->GetBattleground();
+    if (bg)
+        {
+        if (_player->ShouldForgetBGPlayers() && bg)
+             {
+            _player->DoForgetPlayersInBG(bg);
+            _player->SetForgetBGPlayers(false);
+            }
+        }
+    else if (_player->ShouldForgetInListPlayers())
+         {
+        _player->DoForgetPlayersInList();
+        _player->SetForgetInListPlayers(false);
+        }
+
     TC_LOG_DEBUG("network", "CMSG_TIME_SYNC_RESP");
 
     uint32 counter, clientTicks;
diff --git a/src/server/game/Handlers/PetitionsHandler.cpp b/src/server/game/Handlers/PetitionsHandler.cpp
index 781a478..c7a6905 100644
--- a/src/server/game/Handlers/PetitionsHandler.cpp
+++ b/src/server/game/Handlers/PetitionsHandler.cpp
@@ -941,7 +941,7 @@ void WorldSession::SendPetitionShowList(ObjectGuid guid)
     }
     else
     {
-        data << uint8(3);                                   // count
+        data << uint8(2);                                   // count
         // 2v2
         data << uint32(1);                                  // index
         data << uint32(ARENA_TEAM_CHARTER_2v2);             // charter entry
@@ -957,12 +957,14 @@ void WorldSession::SendPetitionShowList(ObjectGuid guid)
         data << uint32(3);                                  // unknown
         data << uint32(3);                                  // required signs?
         // 5v5
+        /* Disable purchase 5v5 petition - edit to 1v1 doesn't work (client prevent it)
         data << uint32(3);                                  // index
         data << uint32(ARENA_TEAM_CHARTER_5v5);             // charter entry
         data << uint32(CHARTER_DISPLAY_ID);                 // charter display id
         data << uint32(sWorld->getIntConfig(CONFIG_CHARTER_COST_ARENA_5v5)); // charter cost
         data << uint32(5);                                  // unknown
         data << uint32(5);                                  // required signs?
+        */
     }
 
     SendPacket(&data);
diff --git a/src/server/game/Handlers/QueryHandler.cpp b/src/server/game/Handlers/QueryHandler.cpp
index ebc9ebd..c1d33bd 100644
--- a/src/server/game/Handlers/QueryHandler.cpp
+++ b/src/server/game/Handlers/QueryHandler.cpp
@@ -45,6 +45,7 @@ void WorldSession::SendNameQueryOpcode(ObjectGuid guid)
     data << uint8(0);                               // name known
     data << nameData->Name;                         // played name
     data << uint8(0);                               // realm name - only set for cross realm interaction (such as Battlegrounds)
+    data << uint8(player ? player->getRace() : nameData->Race);
     data << uint8(nameData->Race);
     data << uint8(nameData->Sex);
     data << uint8(nameData->Class);
diff --git a/src/server/game/Handlers/SpellHandler.cpp b/src/server/game/Handlers/SpellHandler.cpp
index 0943d9d..a7d3cef 100644
--- a/src/server/game/Handlers/SpellHandler.cpp
+++ b/src/server/game/Handlers/SpellHandler.cpp
@@ -16,6 +16,7 @@
  * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include "../../scripts/Custom/TransmogDisplayVendorConf.h"
 #include "Common.h"
 #include "DBCStores.h"
 #include "WorldPacket.h"
@@ -26,6 +27,7 @@
 #include "Opcodes.h"
 #include "Spell.h"
 #include "Totem.h"
+#include "../../scripts/Custom/Transmogrification.h"
 #include "ScriptMgr.h"
 #include "GameObjectAI.h"
 #include "SpellAuraEffects.h"
@@ -632,7 +634,14 @@ void WorldSession::HandleMirrorImageDataRequest(WorldPacket& recvData)
             else if (*itr == EQUIPMENT_SLOT_BACK && player->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_HIDE_CLOAK))
                 data << uint32(0);
             else if (Item const* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, *itr))
-                data << uint32(item->GetTemplate()->DisplayInfoID);
+            {
+                if (uint32 entry = TransmogDisplayVendorMgr::GetFakeEntry(item))
+                    data << uint32(sObjectMgr->GetItemTemplate(entry)->DisplayInfoID);
+                else if (uint32 entry = sTransmogrification->GetFakeEntry(item))
+                    data << uint32(sObjectMgr->GetItemTemplate(entry)->DisplayInfoID);
+                else
+                    data << uint32(item->GetTemplate()->DisplayInfoID);
+            }
             else
                 data << uint32(0);
         }
diff --git a/src/server/game/Mails/Mail.cpp b/src/server/game/Mails/Mail.cpp
index b0e8a1e..05d7318 100644
--- a/src/server/game/Mails/Mail.cpp
+++ b/src/server/game/Mails/Mail.cpp
@@ -20,6 +20,7 @@
 #include "Mail.h"
 #include "Log.h"
 #include "World.h"
+#include "WorldSession.h"
 #include "ObjectMgr.h"
 #include "Player.h"
 #include "BattlegroundMgr.h"
@@ -281,3 +282,64 @@ void MailDraft::SendMailTo(SQLTransaction& trans, MailReceiver const& receiver,
         deleteIncludedItems(temp);
     }
 }
+
+void WorldSession::SendExternalMails()
+{
+    TC_LOG_DEBUG("entities.player.character", "External Mail> Sending mails in queue...");
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_GET_EXTERNAL_MAIL);
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+    if (!result)
+    {
+        TC_LOG_DEBUG("entities.player.character", "External Mail> No mails in queue...");
+        return;
+    }
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+    MailDraft* mail = NULL;
+
+    do
+    {
+        Field *fields = result->Fetch();
+        uint32 id = fields[0].GetUInt32();
+        uint32 receiver_guid = fields[1].GetUInt32();
+        std::string subject = fields[2].GetString();
+        std::string body = fields[3].GetString();
+        uint32 money = fields[4].GetUInt32();
+        uint32 itemId = fields[5].GetUInt32();
+        uint32 itemCount = fields[6].GetUInt32();
+
+        Player *receiver = ObjectAccessor::FindPlayer(ObjectGuid(HighGuid::Player, 0, (receiver_guid)));
+
+        mail = new MailDraft(subject, body);
+
+        if (money)
+        {
+            TC_LOG_DEBUG("entities.player.character", "External Mail> Adding money");
+            mail->AddMoney(money);
+        }
+
+        if (itemId)
+        {
+             TC_LOG_DEBUG("entities.player.character", "External Mail> Adding %u of item with id %u", itemCount, itemId);
+             if(Item* mailItem = Item::CreateItem(itemId, itemCount))
+             {
+                 mailItem->SaveToDB(trans);
+                 mail->AddItem(mailItem);
+             }
+        }
+
+        mail->SendMailTo(trans, receiver ? receiver : MailReceiver(receiver_guid), MailSender(MAIL_NORMAL, 0, MAIL_STATIONERY_GM), MAIL_CHECK_MASK_RETURNED);
+        delete mail;
+
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_EXTERNAL_MAIL);
+        stmt->setUInt32(0, id);
+        trans->Append(stmt);
+
+        TC_LOG_DEBUG("entities.player.character", "External Mail> Mail sent");
+   } while (result->NextRow());
+
+   CharacterDatabase.CommitTransaction(trans);
+   TC_LOG_DEBUG("entities.player.character", "External Mail> All Mails Sent...");
+}
\ No newline at end of file
diff --git a/src/server/game/Miscellaneous/Language.h b/src/server/game/Miscellaneous/Language.h
index c8d0a16..44211ce 100644
--- a/src/server/game/Miscellaneous/Language.h
+++ b/src/server/game/Miscellaneous/Language.h
@@ -800,7 +800,18 @@ enum TrinityStrings
     LANG_NPCINFO_SPELLCLICK             = 840,
     LANG_NPCINFO_MAILBOX                = 841,
     LANG_NPCINFO_PLAYER_VEHICLE         = 842,
-
+// Start AIO by LordPsyan
+    LANG_SOTA                           = 990,
+    LANG_AV                             = 991,
+    LANG_ARENA_3                        = 992,
+    LANG_ARENA_2                        = 993,
+    LANG_ARENA_1                        = 994,
+    LANG_RANDOM                         = 995,
+    LANG_EOTS                           = 996,
+    LANG_AB                             = 997,
+    LANG_WSG                            = 998,
+    LANG_WG                             = 999,
+// End AIO
     // Pinfo commands
     LANG_PINFO_PLAYER                   = 453,
     LANG_PINFO_GM_ACTIVE                = 548,
@@ -855,6 +866,42 @@ enum TrinityStrings
     LANG_RBAC_EMAIL_REQUIRED            = 881,
     // Room for in-game strings           882-999 not used
 
+    // Added by WarHead for the Jail edited by spgm
+    LANG_JAIL_YOURE_JAILED              = 950,  // "You are jailed by %s for %u hour(s)!"
+    LANG_JAIL_REASON                    = 951,  // "%s wrote this as reason: %s"
+    LANG_JAIL_WAS_JAILED                = 952,  // "%s was jailed by you for %u hour(s)!"
+    LANG_JAIL_YOURE_UNJAILED            = 953,  // "You was released out of the jail by %s."
+    LANG_JAIL_WAS_UNJAILED              = 954,  // "You have released %s out of the jail."
+    LANG_JAIL_NOREASON                  = 955,  // "No reason given or reason is < %u chars!"
+    LANG_JAIL_NONAME                    = 956,  // "No name given!"
+    LANG_JAIL_NOTIME                    = 957,  // "No time given!"
+    LANG_JAIL_VALUE                     = 958,  // "The jailtime must be between 1 and %u hours!"
+    LANG_JAIL_CHAR_NOTJAILED            = 959,  // "The character (%s) is not jailed!"
+    LANG_JAIL_DENIED                    = 960,  // "Command forbidden for jailed characters!"
+    LANG_JAIL_JAILED_H_INFO             = 961,  // "You have %u hour(s) left in the jail."
+    LANG_JAIL_JAILED_M_INFO             = 962,  // "You have %u minute(s) left in the jail."
+    LANG_JAIL_NOTJAILED_INFO            = 963,  // "You're a free woman / man. ;-)"
+    LANG_JAIL_GM_INFO                   = 964,  // "%s was %u times jailed and has %u minute(s) left. Last time jailed by %s. Last reason was: '%s'"
+    LANG_JAIL_GM_NOINFO                 = 965,  // "%s was never jailed."
+    LANG_JAIL_NO_JAIL                   = 966,  // "You can't jail yourself!"
+    LANG_JAIL_NO_UNJAIL                 = 967,  // "You can't unjail yourself!"
+    LANG_JAIL_WARNING                   = 968,  // "Be carefull! Only one more jailtime and your current character will be deleted!"
+    LANG_JAIL_ANNOUNCE1                 = 969,  // "The character '"
+    LANG_JAIL_ANNOUNCE2                 = 970,  // "' was jailed for "
+    LANG_JAIL_ANNOUNCE3                 = 971,  // " hour(s) by the GM character '"
+    LANG_JAIL_ANNOUNCE4                 = 972,  // "'. The reason is: "
+    LANG_JAIL_RELOAD                    = 973,  // "The jail configuration was reloaded."
+    LANG_JAIL_CONF_LOADED               = 974,  // ">> Jail config loaded."
+    LANG_JAIL_CONF_ERR1                 = 975,  // "Can't load jail config! Table empty or missed! Use jail_conf.sql!"
+    LANG_JAIL_CONF_ERR2                 = 976,  // "Set all jail config settings to default..."
+    LANG_JAIL_CHAR_TELE                 = 977,  // "The Character '%s' (GUID %u) is jailed and teleportet into the jail."
+    LANG_JAIL_CHAR_FREE                 = 978,  // "The Character '%s' (GUID %u) was released out of the jail."
+    LANG_JAIL_WRONG_NAME                = 979,  // "A character with this name doesn't exists!"
+    LANG_JAIL_WARNING_BAN               = 980,  // "Be carefull! Only one more jailtime and your account will be banned!"
+    LANG_JAIL_BAN_REASON                = 981,  // "Max. jailtimes reached!"
+    LANG_JAIL_BAN_BY                    = 982,  // "Robotron"
+    LANG_JAIL_AMNESTII                  = 983,  // "AMNESTII"
+
     // Level 4 (CLI only commands)
     LANG_COMMAND_EXIT                   = 1000,
     LANG_ACCOUNT_DELETED                = 1001,
@@ -1247,9 +1294,9 @@ enum TrinityStrings
     // 35
     // 36
     // 37
-    // 38
-    // 39
-    // 40
+   LANG_LOTTERY_ANNOUNCE_JACKPOT = 11010,
+   LANG_LOTTERY_ANNOUNCE_JACKPOT_M_PLAYERS = 11011,
+   LANG_LOTTERY_ANNOUNCE = 11012
     // Visit http://www.realmsofwarcraft.com/bb for forums and information
     //
     // End of prepatch
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
index 3640ce9..09441fe 100644
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -36,6 +36,9 @@ void AddSC_holiday_spell_scripts();
 
 void AddSC_SmartScripts();
 
+//TeleNPC2
+void AddSC_npc_teleport();
+
 //Commands
 void AddSC_account_commandscript();
 void AddSC_achievement_commandscript();
@@ -57,6 +60,7 @@ void AddSC_group_commandscript();
 void AddSC_guild_commandscript();
 void AddSC_honor_commandscript();
 void AddSC_instance_commandscript();
+void AddSC_jail_commandscript();
 void AddSC_learn_commandscript();
 void AddSC_lfg_commandscript();
 void AddSC_list_commandscript();
@@ -685,7 +689,6 @@ void AddSC_outdoorpvp_zm();
 // player
 void AddSC_chat_log();
 void AddSC_action_ip_logger();
-
 #endif
 
 void AddScripts()
@@ -747,6 +750,7 @@ void AddCommandScripts()
     AddSC_guild_commandscript();
     AddSC_honor_commandscript();
     AddSC_instance_commandscript();
+    AddSC_jail_commandscript();
     AddSC_learn_commandscript();
     AddSC_lookup_commandscript();
     AddSC_lfg_commandscript();
@@ -1411,43 +1415,53 @@ void AddBattlegroundScripts()
 
 #ifdef SCRIPTS
 /* This is where custom scripts' loading functions should be declared. */
-// start01
+    // All In One NPC
+    void AddSC_npc_all();
 // start02
 // start03
 // start04
-// start05
+// Arena Gambler
+void AddSC_ArenaGambler();
 // start06
 // start07
 // start08
-// start09
+    // Beastmaster
+    void AddSC_Npc_Beastmaster();
 // start10
 // start11
 // start12
-// start13
+    // Bounty Hunter
+    void AddSC_BountyHunter();
 // start14
 // start15
 // start16
-// start17
+    //GuildHouse NPC
+    void AddSC_guildmaster();
 // start18
 // start19
 // start20
-// start21
+// Killstreak
+void AddSC_PvP_System();
 // start22
 // start23
 // start24
-// start25
+    // Level NPC
+    void AddSC_levelnpc();
 // start26
 // start27
 // start28
-// start29
+    // Lottery NPC
+    void AddSC_npc_lottery();
 // start30
 // start31
 // start32
-// start33
+    // Buff NPC
+    void AddSC_Npc_Buff();
 // start34
 // start35
 // start36
-// start37
+    // Enchant NPC
+    void AddSC_npc_enchantment();
 // start38
 // start39
 // start40
@@ -1455,80 +1469,92 @@ void AddBattlegroundScripts()
 // start42
 // start43
 // start44
-// start45
+    // Profession Npc
+    void AddSC_professionnpc();
 // start46
 // start47
 // start48
-// start49
+// IceRune
+void AddSC_summon();
 // start50
 // start51
 // start52
-// start53
+// TeleNPC2
+void AddSC_npc_teleport();
 // start54
 // start55
 // start56
-// start57
+void AddSC_PWS_Transmogrification();
+void AddSC_CS_Transmogrification();
 // start58
 // start59
 // start60
-// start61
+// 1v1 Arena
+void AddSC_npc_1v1arena();
 // start62
 // start63
 // start64
 // start65
 // start66
 // start67
-// start68
+// Vote Rewarder NPC
+    void AddSC_npc_vote_rewarder();
 // start69
 // start70
 // start71
 // start72
-// start73
+// Reforging
+void AddSC_REFORGER_NPC();
 // start74
 // start75
 // start76
-// start77
+// Start Guild
+    void AddSC_gon_playerscripts();
 // start78
 // start79
 // start80
-// start81
+void AddSC_World_Chat();
 // start82
 // start83
 // start84
-// start85
+    //Vas AutoBalance
+    void AddSC_VAS_AutoBalance();
 // start86
 // start87
 // start88
-// start89
+void AddSC_accontmounts();
 // start90
 // start91
 // start92
-// start93
+void AddSC_announce_login();
 // start94
 // start95
 // start96
-// start97
+void AddSC_Arena_AntiDraw();
 // start98
 // start99
 // start100
-// start101
+void AddSC_login_script();
 // start102
 // start103
-// start104
+void AddSC_TemplateNPC();
 // start105
 // start106
 // start107
-// start108
+void AddSC_NPC_TransmogDisplayVendor();
+void AddSC_PhasedDueling();
+void AddSC_XpWeekend();
+void AddSC_System_Censure();
 // start109
 // start100
 // start111
 // start112
 // start113
-// start114
+void AddSC_npc_blood_money();
 // start115
 // start116
 // start117
-// start118
+void AddSC_LearnSpellsOnLevelUp();
 // start119
 // start120
 #endif
@@ -1537,43 +1563,53 @@ void AddCustomScripts()
 {
 #ifdef SCRIPTS
     /* This is where custom scripts should be added. */
-// end01
+    // All In One NPC
+    AddSC_npc_all();
 // end02
 // end03
 // end04
-// end05
+    // Arena Gambler
+    AddSC_ArenaGambler();
 // end06
 // end07
 // end08
-// end09
+    // Beastmaster
+    AddSC_Npc_Beastmaster();
 // end10
 // end11
 // end12
-// end13
+    // Bounty Hunter
+    AddSC_BountyHunter();
 // end14
 // end15
 // end16
-// end17
+    // GuildHouse NPC
+    AddSC_guildmaster();
 // end18
 // end19
 // end20
-// end21
+    // Killstreak
+    AddSC_PvP_System();
 // end22
 // end23
 // end24
-// end25
+    // Level NPC
+    AddSC_levelnpc();
 // end26
 // end27
 // end28
-// end29
+    // Lottery NPC
+    AddSC_npc_lottery();
 // end30
 // end31
 // end32
-// end33
+    // Buff NPC
+    AddSC_Npc_Buff();
 // end34
 // end35
 // end36
-// end37
+    // Enchant NPC
+    AddSC_npc_enchantment();
 // end38
 // end39
 // end40
@@ -1581,80 +1617,92 @@ void AddCustomScripts()
 // end42
 // end43
 // end44
-// end45
+    // Profession Npc
+    AddSC_professionnpc();
 // end46
 // end47
 // end48
-// end49
+    // IceRune
+    AddSC_summon();
 // end50
 // end51
 // end52
-// end53
+    // TeleNPC2
+    AddSC_npc_teleport();
 // end54
 // end55
 // end56
-// end57
+    AddSC_PWS_Transmogrification();
+    AddSC_CS_Transmogrification();
 // end58
 // end59
 // end60
-// end61
+// 1v1 Arena
+    AddSC_npc_1v1arena();
 // end62
 // end63
 // end64
 // end65
 // end66
 // end67
-// end68
+// Vote Rewarder NPC
+    AddSC_npc_vote_rewarder();
 // end69
 // end70
 // end71
 // end72
-// end73
+    // Reforging
+    AddSC_REFORGER_NPC();
 // end74
 // end75
 // end76
-// end77
+// Start Guild
+AddSC_gon_playerscripts();
 // end78
 // end79
 // end80
-// end81
+    AddSC_World_Chat();
 // end82
 // end83
 // end84
-// end85
+    //VAS AutoBalance
+    AddSC_VAS_AutoBalance();
 // end86
 // end87
 // end88
-// end89
+    AddSC_accontmounts();
 // end90
 // end91
 // end92
-// end93
+    AddSC_announce_login();
 // end94
 // end95
 // end96
-// end97
+    AddSC_Arena_AntiDraw();
 // end98
 // end99
-// end100
+    AddSC_System_Censure();
 // end101
 // end102
 // end103
-// end104
+    AddSC_TemplateNPC();
+    AddSC_login_script();
 // end105
 // end106
 // end107
-// end108
+    AddSC_NPC_TransmogDisplayVendor();
+    AddSC_PhasedDueling();
+    AddSC_XpWeekend();
 // end109
 // end100
 // end111
 // end112
 // end113
-// end114
+    AddSC_npc_blood_money();
 // end115
 // end116
 // end117
-// end118
+    AddSC_LearnSpellsOnLevelUp();
 // end119
 // end120
 #endif
diff --git a/src/server/game/Scripting/ScriptMgr.cpp b/src/server/game/Scripting/ScriptMgr.cpp
index 3fa16cf..0243336 100644
--- a/src/server/game/Scripting/ScriptMgr.cpp
+++ b/src/server/game/Scripting/ScriptMgr.cpp
@@ -23,6 +23,7 @@
 #include "ObjectMgr.h"
 #include "OutdoorPvPMgr.h"
 #include "ScriptLoader.h"
+#include "sc_npc_teleport.h"
 #include "ScriptSystem.h"
 #include "Transport.h"
 #include "Vehicle.h"
@@ -34,6 +35,7 @@
 #include "WorldPacket.h"
 #include "WorldSession.h"
 #include "Chat.h"
+#include "Creature.h"
 
 // namespace
 // {
@@ -253,6 +255,8 @@ void ScriptMgr::Initialize()
     uint32 oldMSTime = getMSTime();
 
     LoadDatabase();
+       // Load TeleNPC2 - maybe not the best place to load it ...
+       LoadNpcTele();
 
     TC_LOG_INFO("server.loading", "Loading C++ scripts");
 
@@ -283,10 +287,12 @@ void ScriptMgr::Unload()
     SCR_CLEAR(ServerScript);
     SCR_CLEAR(WorldScript);
     SCR_CLEAR(FormulaScript);
+    SCR_CLEAR(AllMapScript);
     SCR_CLEAR(WorldMapScript);
     SCR_CLEAR(InstanceMapScript);
     SCR_CLEAR(BattlegroundMapScript);
     SCR_CLEAR(ItemScript);
+    SCR_CLEAR(AllCreatureScript);
     SCR_CLEAR(CreatureScript);
     SCR_CLEAR(GameObjectScript);
     SCR_CLEAR(AreaTriggerScript);
@@ -685,6 +691,8 @@ void ScriptMgr::OnPlayerEnterMap(Map* map, Player* player)
     ASSERT(map);
     ASSERT(player);
 
+    FOREACH_SCRIPT(AllMapScript)->OnPlayerEnterAll(map, player);
+
     FOREACH_SCRIPT(PlayerScript)->OnMapChanged(player);
 
     SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsWorldMap);
@@ -705,6 +713,8 @@ void ScriptMgr::OnPlayerLeaveMap(Map* map, Player* player)
     ASSERT(map);
     ASSERT(player);
 
+    FOREACH_SCRIPT(AllMapScript)->OnPlayerLeaveAll(map, player);
+
     SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsWorldMap);
         itr->second->OnPlayerLeave(map, player);
     SCR_MAP_END;
@@ -894,10 +904,17 @@ void ScriptMgr::OnCreatureUpdate(Creature* creature, uint32 diff)
 {
     ASSERT(creature);
 
+    FOREACH_SCRIPT(AllCreatureScript)->OnAllCreatureUpdate(creature, diff);
+
     GET_SCRIPT(CreatureScript, creature->GetScriptId(), tmpscript);
     tmpscript->OnUpdate(creature, diff);
 }
 
+void ScriptMgr::Creature_SelectLevel(const CreatureTemplate *cinfo, Creature* creature)
+{
+    FOREACH_SCRIPT(AllCreatureScript)->Creature_SelectLevel(cinfo, creature);
+}
+
 bool ScriptMgr::OnGossipHello(Player* player, GameObject* go)
 {
     ASSERT(player);
@@ -908,6 +925,22 @@ bool ScriptMgr::OnGossipHello(Player* player, GameObject* go)
     return tmpscript->OnGossipHello(player, go);
 }
 
+void ScriptMgr::SetInitialWorldSettings()
+{
+    FOREACH_SCRIPT(WorldScript)->SetInitialWorldSettings();
+}
+
+float ScriptMgr::VAS_Script_Hooks()
+{
+    float VAS_Script_Hook_Version = 1.03f;
+
+//    TC_LOG_DEBUG(LOG_FILTER_WORLDSERVER, "------------------------------------------------------------");
+//    TC_LOG_DEBUG(LOG_FILTER_WORLDSERVER, "  Powered by {VAS} Script Hooks v%4.2f : Updated by Natfoth",VAS_Script_Hook_Version);
+//    TC_LOG_DEBUG(LOG_FILTER_WORLDSERVER, "--------------------------------------------------------------");
+
+    return VAS_Script_Hook_Version;
+}
+
 bool ScriptMgr::OnGossipSelect(Player* player, GameObject* go, uint32 sender, uint32 action)
 {
     ASSERT(player);
@@ -1232,6 +1265,14 @@ bool ScriptMgr::OnCriteriaCheck(uint32 scriptId, Player* source, Unit* target)
     return tmpscript->OnCheck(source, target);
 }
 
+//Called From Unit::DealDamage
+uint32 ScriptMgr::DealDamage(Unit* AttackerUnit, Unit *pVictim, uint32 damage, DamageEffectType damagetype)
+{
+    FOR_SCRIPTS_RET(UnitScript, itr, end, damage)
+        damage = itr->second->DealDamage(AttackerUnit, pVictim, damage, damagetype);
+    return damage;
+}
+
 // Player
 void ScriptMgr::OnPVPKill(Player* killer, Player* killed)
 {
@@ -1534,12 +1575,32 @@ SpellScriptLoader::SpellScriptLoader(const char* name)
     ScriptRegistry<SpellScriptLoader>::AddScript(this);
 }
 
+void ScriptMgr::ModifyHealRecieved(Unit* target, Unit* attacker, uint32& damage)
+{
+    FOREACH_SCRIPT(UnitScript)->ModifyHealRecieved(target, attacker, damage);
+}
+
+AllMapScript::AllMapScript(const char* name)
+    : ScriptObject(name)
+{
+    ScriptRegistry<AllMapScript>::AddScript(this);
+}
+
+
 ServerScript::ServerScript(const char* name)
     : ScriptObject(name)
 {
     ScriptRegistry<ServerScript>::AddScript(this);
 }
 
+AllCreatureScript::AllCreatureScript(const char* name)
+: ScriptObject(name)
+{
+    ScriptRegistry<AllCreatureScript>::AddScript(this);
+}
+
+
+
 WorldScript::WorldScript(const char* name)
     : ScriptObject(name)
 {
@@ -1703,10 +1764,12 @@ template class ScriptRegistry<SpellScriptLoader>;
 template class ScriptRegistry<ServerScript>;
 template class ScriptRegistry<WorldScript>;
 template class ScriptRegistry<FormulaScript>;
+template class ScriptRegistry<AllMapScript>;
 template class ScriptRegistry<WorldMapScript>;
 template class ScriptRegistry<InstanceMapScript>;
 template class ScriptRegistry<BattlegroundMapScript>;
 template class ScriptRegistry<ItemScript>;
+template class ScriptRegistry<AllCreatureScript>;
 template class ScriptRegistry<CreatureScript>;
 template class ScriptRegistry<GameObjectScript>;
 template class ScriptRegistry<AreaTriggerScript>;
diff --git a/src/server/game/Scripting/ScriptMgr.h b/src/server/game/Scripting/ScriptMgr.h
index 5dfc0be..a064c44 100644
--- a/src/server/game/Scripting/ScriptMgr.h
+++ b/src/server/game/Scripting/ScriptMgr.h
@@ -26,6 +26,7 @@
 #include "SharedDefines.h"
 #include "World.h"
 #include "Weather.h"
+#include "Unit.h"
 
 class AccountMgr;
 class AuctionHouseObject;
@@ -63,6 +64,7 @@ class WorldSession;
 
 struct AchievementCriteriaData;
 struct AuctionEntry;
+struct CreatureTemplate;
 struct ConditionSourceInfo;
 struct Condition;
 struct ItemTemplate;
@@ -266,6 +268,9 @@ class WorldScript : public ScriptObject
 
         // Called when the world is actually shut down.
         virtual void OnShutdown() { }
+
+        // Called at End of SetInitialWorldSettings.
+        virtual void SetInitialWorldSettings() { }
 };
 
 class FormulaScript : public ScriptObject
@@ -298,6 +303,21 @@ class FormulaScript : public ScriptObject
         virtual void OnGroupRateCalculation(float& /*rate*/, uint32 /*count*/, bool /*isRaid*/) { }
 };
 
+class AllMapScript : public ScriptObject
+{
+    protected:
+
+        AllMapScript(const char* name);
+
+    public:
+
+        // Called when a player enters any Map
+        virtual void OnPlayerEnterAll(Map* /*map*/, Player* /*player*/) { }
+
+        // Called when a player leave any Map
+        virtual void OnPlayerLeaveAll(Map* /*map*/, Player* /*player*/) { }
+};
+
 template<class TMap> class MapScript : public UpdatableScript<TMap>
 {
     MapEntry const* _mapEntry;
@@ -406,6 +426,13 @@ class UnitScript : public ScriptObject
 
         // Called when Spell Damage is being Dealt
         virtual void ModifySpellDamageTaken(Unit* /*target*/, Unit* /*attacker*/, int32& /*damage*/) { }
+
+        // Called when Heal is Recieved
+        virtual void ModifyHealRecieved(Unit* /*target*/, Unit* /*attacker*/, uint32& /*damage*/) { }
+
+        //VAS AutoBalance
+        virtual uint32 DealDamage(Unit* AttackerUnit, Unit *pVictim, uint32 damage, DamageEffectType damagetype) { return damage;}
+
 };
 
 class CreatureScript : public UnitScript, public UpdatableScript<Creature>
@@ -444,6 +471,21 @@ class CreatureScript : public UnitScript, public UpdatableScript<Creature>
         virtual CreatureAI* GetAI(Creature* /*creature*/) const { return NULL; }
 };
 
+class AllCreatureScript : public ScriptObject
+{
+    protected:
+
+        AllCreatureScript(const char* name);
+
+    public:
+
+        // Called from End of Creature Update.
+        virtual void OnAllCreatureUpdate(Creature* /*creature*/, uint32 /*diff*/) { }
+
+        // Called from End of Creature SelectLevel.
+        virtual void Creature_SelectLevel(const CreatureTemplate* /*cinfo*/, Creature* /*creature*/) { }
+};
+
 class GameObjectScript : public ScriptObject, public UpdatableScript<GameObject>
 {
     protected:
@@ -880,6 +922,10 @@ class ScriptMgr
         void Unload();
         void UnloadUnusedScripts();
 
+    public: /* {VAS} Script Hooks */
+
+        float VAS_Script_Hooks();
+
     public: /* SpellScriptLoader */
 
         void CreateSpellScripts(uint32 spellId, std::list<SpellScript*>& scriptVector);
@@ -906,6 +952,7 @@ class ScriptMgr
         void OnWorldUpdate(uint32 diff);
         void OnStartup();
         void OnShutdown();
+        void SetInitialWorldSettings();
 
     public: /* FormulaScript */
 
@@ -917,6 +964,11 @@ class ScriptMgr
         void OnGainCalculation(uint32& gain, Player* player, Unit* unit);
         void OnGroupRateCalculation(float& rate, uint32 count, bool isRaid);
 
+    public: /* AllScript */
+
+        void OnPlayerEnterMapAll(Map* map, Player* player);
+        void OnPlayerLeaveMapAll(Map* map, Player* player);
+
     public: /* MapScript */
 
         void OnCreateMap(Map* map);
@@ -939,6 +991,12 @@ class ScriptMgr
         bool OnItemExpire(Player* player, ItemTemplate const* proto);
         bool OnItemRemove(Player* player, Item* item);
 
+    public: /* AllCreatureScript */
+
+        void OnAllCreatureUpdate(Creature* creature, uint32 diff);
+        void Creature_SelectLevel(const CreatureTemplate *cinfo, Creature* creature);
+
+
     public: /* CreatureScript */
 
         bool OnDummyEffect(Unit* caster, uint32 spellId, SpellEffIndex effIndex, Creature* target);
@@ -1097,6 +1155,8 @@ class ScriptMgr
         void ModifyPeriodicDamageAurasTick(Unit* target, Unit* attacker, uint32& damage);
         void ModifyMeleeDamage(Unit* target, Unit* attacker, uint32& damage);
         void ModifySpellDamageTaken(Unit* target, Unit* attacker, int32& damage);
+        void ModifyHealRecieved(Unit* target, Unit* attacker, uint32& addHealth);
+        uint32 DealDamage(Unit* AttackerUnit, Unit *pVictim,uint32 damage,DamageEffectType damagetype);
 
     public: /* Scheduled scripts */
 
diff --git a/src/server/game/Server/WorldSession.h b/src/server/game/Server/WorldSession.h
index 2253b6b..d5e1046 100644
--- a/src/server/game/Server/WorldSession.h
+++ b/src/server/game/Server/WorldSession.h
@@ -377,6 +377,7 @@ class WorldSession
             }
         }
         //used with item_page table
+        static void SendExternalMails();
         bool SendItemInfo(uint32 itemid, WorldPacket data);
         //auction
         void SendAuctionHello(ObjectGuid guid, Creature* unit);
diff --git a/src/server/game/Spells/Spell.cpp b/src/server/game/Spells/Spell.cpp
index aed7c0d..313088e 100644
--- a/src/server/game/Spells/Spell.cpp
+++ b/src/server/game/Spells/Spell.cpp
@@ -4679,8 +4679,8 @@ SpellCastResult Spell::CheckCast(bool strict)
     }
 
     // Check global cooldown
-    if (strict && !(_triggeredCastFlags & TRIGGERED_IGNORE_GCD) && HasGlobalCooldown())
-        return SPELL_FAILED_NOT_READY;
+        if (strict && !(_triggeredCastFlags & TRIGGERED_IGNORE_GCD) && HasGlobalCooldown())
+            return SPELL_FAILED_NOT_READY;
 
     // only triggered spells can be processed an ended battleground
     if (!IsTriggered() && m_caster->GetTypeId() == TYPEID_PLAYER)
diff --git a/src/server/game/Spells/SpellEffects.cpp b/src/server/game/Spells/SpellEffects.cpp
index 40bd4e3..51f676e 100644
--- a/src/server/game/Spells/SpellEffects.cpp
+++ b/src/server/game/Spells/SpellEffects.cpp
@@ -5173,6 +5173,9 @@ void Spell::EffectTransmitted(SpellEffIndex effIndex)
                 case 3: lastSec = 17; break;
             }
 
+            if (sWorld->getBoolConfig(CONFIG_FAST_FISHING))
+                lastSec = 17;
+
             duration = duration - lastSec*IN_MILLISECONDS + FISHING_BOBBER_READY_TIME*IN_MILLISECONDS;
             break;
         }
diff --git a/src/server/game/Spells/SpellInfo.cpp b/src/server/game/Spells/SpellInfo.cpp
index 699e485..5f8f336 100644
--- a/src/server/game/Spells/SpellInfo.cpp
+++ b/src/server/game/Spells/SpellInfo.cpp
@@ -25,6 +25,7 @@
 #include "Battleground.h"
 #include "Vehicle.h"
 #include "Pet.h"
+#include "World.h"
 
 uint32 GetTargetFlagMask(SpellTargetObjectTypes objType)
 {
@@ -2114,7 +2115,10 @@ uint32 SpellInfo::CalcCastTime(Spell* spell /*= NULL*/) const
     if (HasAttribute(SPELL_ATTR0_REQ_AMMO) && (!IsAutoRepeatRangedSpell()))
         castTime += 500;
 
-    return (castTime > 0) ? uint32(castTime) : 0;
+    if (!sWorld->getBoolConfig(CONFIG_NO_CAST_TIME))
+        return (castTime > 0) ? uint32(castTime) : 0;
+    else
+        return 0;
 }
 
 uint32 SpellInfo::GetMaxTicks() const
diff --git a/src/server/game/TriniChat/IRCClient.cpp b/src/server/game/TriniChat/IRCClient.cpp
new file mode 100644
index 0000000..3c4b643
--- /dev/null
+++ b/src/server/game/TriniChat/IRCClient.cpp
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCClient.h"
+#include "World.h"
+#include "ObjectMgr.h"
+#include "MapManager.h"
+#include "Player.h"
+
+#ifdef WIN32
+    #define Delay(x) Sleep(x)
+#else
+    #define Delay(x) sleep(x / 1000)
+#endif
+// IRCClient Constructor
+IRCClient::IRCClient()
+{
+    for (int i = 0;i > 5;i++)
+        sIRC->Script_Lock[i] = false;
+}
+// IRCClient Destructor
+IRCClient::~IRCClient(){}
+
+void TrinityChatThread()
+{
+    //call irc bot
+    IRCClient* a = nullptr;
+    // run the bot within a thread
+    a->run();
+}
+
+// ZThread Entry This function is called when the thread is created in Master.cpp (trinitycore)
+void IRCClient::run()
+{
+//    iLog.WriteLog(" %s : ****** TrinityCore With TriniChat Has Been Started ******", iLog.GetLogDateTimeStr().c_str());
+
+    // before we begin we wait a few
+    // mangos is still starting up.
+    std::this_thread::sleep_for(std::chrono::milliseconds(500));
+    std::stringstream ss(sIRC->_bot_names);
+    string temp = "";
+    uint8 counter = 0;
+    for(uint8 i=0;i<sIRC->_bot_names.length();i++)
+    {
+        if(sIRC->_bot_names[i] == ',')
+        {
+            sIRC->_ignore_bots[counter] = temp;
+            temp = "";
+            counter++;
+        }
+        else
+        {
+            temp += sIRC->_bot_names[i];
+        }
+    }
+    // check for hanging name
+    sIRC->_ignore_bots[counter] = temp;
+    TC_LOG_INFO("server.loading", ">> TrinityChat Ignore Bots set.");
+    TC_LOG_ERROR("misc", "\n%s\n%s\n%s\n%s",
+        "***************************************",
+        "**   TriniChat2 Threaded IRC Client   **",
+        "**     With Enhanced GM Control.     **",
+        "***************************************");
+    TC_LOG_ERROR("misc", "****** TriniChat: %s ********", sIRC->_Mver.c_str());
+    int cCount = 1;
+    // Clean Up MySQL Tables
+    TC_LOG_ERROR("misc", "*** TriniChat: Cleaning Up Inchan Table*");
+    WorldDatabase.PExecute("DELETE FROM `irc_inchan`");
+    sIRC->_Max_Script_Inst = 0;
+    // Create a loop to keep the thread running untill active is set to false
+    while (sIRC->Active && !World::IsStopped())
+    {
+        // Initialize socket library
+        if (this->InitSock())
+        {
+            // Connect To The IRC Server
+            TC_LOG_ERROR("misc", "*** TriniChat: Connecting to %s Try # %d ******", sIRC->_Host.c_str(), cCount);
+           if (this->Connect(sIRC->_Host.c_str(), sIRC->_Port))
+           {
+               // On connection success reset the connection counter
+               cCount = 0;
+               TC_LOG_ERROR("misc", "*** TriniChat: Connected And Logging In*");
+                // Login to the IRC server
+                if (this->Login(sIRC->_Nick, sIRC->_User, sIRC->_Pass))
+                {
+                    TC_LOG_ERROR("misc", "*** TriniChat: Logged In And Running!! *");
+                    // While we are connected to the irc server keep listening for data on the socket
+                    while (sIRC->Connected && !World::IsStopped()){ sIRC->SockRecv(); }
+                }
+                TC_LOG_ERROR("misc", "*** TriniChat: Connection To IRC Server Lost! ***");
+            }
+            // When an error occures or connection lost cleanup
+            Disconnect();
+            // Increase the connection counter
+            cCount++;
+            // if MAX_CONNECT_ATTEMPT is reached stop trying
+            if (sIRC->_MCA != 0 && cCount == sIRC->_MCA)
+                sIRC->Active = false;
+            // If we need to reattempt a connection wait WAIT_CONNECT_TIME milli seconds before we try again
+            if (sIRC->Active)
+            {
+                std::this_thread::sleep_for(std::chrono::milliseconds(_wct));
+            }
+        }
+        else
+        {
+            // Socket could not initialize cancel
+            sIRC->Active = false;
+            TC_LOG_ERROR("misc", "** TriniChat: Could not initialize socket");
+        }
+    }
+    while (!World::IsStopped()){};
+}
+
+std::string IRCClient::GetChatLine(int nItem)
+{
+    return sIRC->ILINES[nItem];
+}
diff --git a/src/server/game/TriniChat/IRCClient.h b/src/server/game/TriniChat/IRCClient.h
new file mode 100644
index 0000000..a2e9327
--- /dev/null
+++ b/src/server/game/TriniChat/IRCClient.h
@@ -0,0 +1,291 @@
+/*
+* Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+*
+* Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
+
+#ifndef _IRC_CLIENT_H
+#define _IRC_CLIENT_H
+
+#include <boost/asio/io_service.hpp>
+#include <boost/asio/strand.hpp>
+#include "boost/thread.hpp"
+//#include "Player.h"
+#include "IRCLog.h"
+#include "IRCCmd.h"
+
+using namespace std;
+// The maximum ammount of channels used, must be >= config option
+#define MAX_CONF_CHANNELS 10
+#define MAX_CHAT_LINES 10
+#define MAX_CONF_BOTS 10
+// time we need to wait before we try another connecton attempt
+// Default is 30 seconds
+#define MAX_SCRIPT_INST 10
+// CLINES is used for the default chatlines
+// By using the GetChatLine function its easier and faster
+// to receieve the line you need.
+enum CLINES
+{
+    IRC_WOW = 0,
+    WOW_IRC = 1,
+    JOIN_WOW = 2,
+    JOIN_IRC = 3,
+    LEAVE_WOW = 4,
+    LEAVE_IRC = 5,
+    CHANGE_NICK = 6
+};
+// CACTION is used by the Handle_WoW_Channel function
+// this function is called in channel.h when a player
+// joins or leave a channel inside the client.
+enum CACTION
+{
+    CHANNEL_JOIN,
+    CHANNEL_LEAVE,
+};
+
+enum script_Names
+{
+    MCS_Players_Online = 0,
+};
+
+void TrinityChatThread();
+
+// IRCClient main class
+class IRCClient
+{
+
+public:
+    // IRCClient Constructor
+    IRCClient();
+    // IRCClient Destructor
+    ~IRCClient();
+    // ZThread Entry
+    void run();
+    static IRCClient* instance(boost::asio::io_service* ioService = nullptr)
+    {
+        static IRCClient instance;
+
+        if (ioService != nullptr)
+        {
+            instance._ioService = ioService;
+            instance._strand = new boost::asio::strand(*ioService);
+        }
+
+        return &instance;
+    }
+    // Send a message to the specified IRC channel
+    void Send_IRC_Channel(std::string sChannel, std::string sMsg, bool NoPrefix = false, std::string nType = "PRIVMSG");
+public:
+    // AH Function
+    void AHCancel(uint64 itmid, std::string itmnme, std::string plname, uint32 faction);
+    //bool BeenToGMI(float posx, float posy, std::string player, std::string from);
+    // IRCClient active
+    bool Active;
+    // Connected to IRC
+    bool Connected;
+    // Socket indentifier
+    int SOCKET;
+    fd_set sfdset;
+    // Send data to IRC, in addition the endline is added \n
+    bool SendIRC(std::string data);
+    // This function is called in ChatHandler.cpp and processes the chat from game to IRC
+    void Send_WoW_IRC(Player *plr, std::string Channel, std::string Msg);
+    // Sends a message to all players on the specified channel
+    void Send_WoW_Channel(const char *channel, std::string chat);
+    // Send a system message to all players
+    void Send_WoW_System(std::string Message);
+    // Send a message to the specified IRC channel
+    //void Send_IRC_Channel(std::string sChannel, std::string sMsg, bool NoPrefix = false, std::string nType = "PRIVMSG");
+    // Sends a message to all IRC Channels
+    void Send_IRC_Channels(std::string sMsg);
+    std::string MakeMsg(std::string msg, std::string var, std::string val)
+    {
+        std::size_t start = msg.find(var);
+        if (start != std::string::npos)
+            msg.replace(start, var.length(), val);
+        return msg;
+    }
+    void Send_WoW_Player(string sPlayer, string sMsg);
+    void Send_WoW_Player(Player *plr, string sMsg);
+
+    // This function is called in Channel.cpp and processes Join/leave messages
+    void Handle_WoW_Channel(std::string Channel, Player *plr, int nAction);
+    void ResetIRC();
+public:
+    void AutoJoinChannel(Player *plr);
+
+public:
+    bool Script_Lock[5];
+    bool _AmiOp;
+
+public:
+    string _Mver;
+    // IRC Server host
+    string _Host;
+    // IRC Server Port
+    int _Port;
+    // IRC Username
+    string _User;
+    // IRC Password
+    string _Pass;
+    // IRC Nickname
+    string _Nick;
+    //Password for in-game channel
+    std::string _irc_pass[MAX_CONF_CHANNELS];
+    // Authentication type
+    int _Auth;
+    string _Auth_Nick;
+    // IRC Connect code
+    string _ICC;
+    // IRC Default channel
+    string _defchan;
+    // IRC Leave Default channel
+    int _ldefc;
+    // Wait Connect Time
+    int _wct;
+    // Check if staff chat is enabled
+    int _staffLink;
+    // IRC Default Staff channel
+    string _staffChan;
+    // String that contains bot names
+    string _bot_names;
+    // Number of bots to ignore
+    string _ignore_bots[MAX_CONF_BOTS];
+    // Ticket Channel
+    string ticann;
+    // Ticket Channel Password
+    string ticannpw;
+    // Status Channel
+    string Status;
+    // Status Channel Password
+    string Statuspw;
+    // Announce Channel
+    string anchn;
+    // Announce Channel Password
+    string anchnpw;
+    // Auto-announce timer
+    int autoanc;
+    // IRC Channel count
+    int _chan_count;
+    // IRC Channel list
+    // Array to store our IRC channels
+    // each element will corrospond
+    // with _wow_chan array below.
+    std::string _irc_chan[MAX_CONF_CHANNELS];
+    // Game Channel list
+    std::string _wow_chan[MAX_CONF_CHANNELS];
+    // AutoJoin Options
+    int ajoin;
+    string ajchan;
+    // Online Command Max Results
+    int onlrslt;
+    // Channel OnJoin/Restart/Kick Messages
+    string JoinMsg;
+    string RstMsg;
+    string kikmsg;
+    // Misc Options
+    string ojGM1;
+    string ojGM2;
+    string ojGM3;
+    string ojGM4;
+    string logfile;
+    string logchan;
+    string logchanpw;
+    int logmask;
+    int games;
+    int gmlog;
+    // IRC Commands Security Level
+    int CACCT;
+    int CBAN;
+    int CCHAN;
+    int CCHAR;
+    int CFUN;
+    int CHELP;
+    int CINCHAN;
+    int CINFO;
+    int CITEM;
+    int CJAIL;
+    int CKICK;
+    int _KILL;
+    int CLEVEL;
+    int CLOOKUP;
+    int CMONEY;
+    int CMUTE;
+    int CONLINE;
+    int CPM;
+    int CRECONNECT;
+    int CRELOAD;
+    int CREVIVE;
+    int CSAVEALL;
+    int CSERVERCMD;
+    int CSHUTDOWN;
+    int CSPELL;
+    int CSYSMSG;
+    int CTELE;
+    int CTOP;
+    int CPLAYER;
+    int CWHO;
+    // BotMask
+    int BOTMASK;
+    // TicketMask
+    int TICMASK;
+    // Max connect attempt
+    int _MCA;
+    // Auto rejoin when kicked from irc
+    int _autojoinkick;
+    // IRC Command prefix
+    string _cmd_prefx;
+    int _op_gm;
+    int _op_gm_lev;
+    // Array that contains our chatlines from the conf file
+    // To increase this value change the MAX_CHAT_LINE define above
+    // Make sure the number of elements must match your items
+    // (remeber this starts at 0 so 0..9 is 10 items)
+    // and that you load the line in the LoadConfig function.
+    string ILINES[MAX_CHAT_LINES];
+    string GetChatLine(int nItem);
+
+    int _Max_Script_Inst;
+    // MAX_SCRIPT_INST
+
+    IRCLog iLog;
+
+private:
+    // Returns default chatline based on enum CLINES
+    // Initialize socket library
+    bool InitSock();
+    // Connect to IRC Server
+    bool Connect(const char *cHost, int nPort);
+    // Login to IRC Server
+    bool Login(std::string sNick, std::string sUser, std::string sPass);
+    // Send raw data to IRC
+    bool SendData(const char *data);
+    // Disconnect from IRC and cleanup socket
+    void Disconnect();
+    // Processes the data receieved from IRC
+    void Handle_IRC(std::string sData);
+    // Receieves data from the socket.
+    void SockRecv();
+
+    // add boost ioservice
+    boost::asio::io_service* _ioService;
+    boost::asio::strand* _strand;
+};
+
+#define sIRC IRCClient::instance()
+#endif
diff --git a/src/server/game/TriniChat/IRCCmd.cpp b/src/server/game/TriniChat/IRCCmd.cpp
new file mode 100644
index 0000000..260dee9
--- /dev/null
+++ b/src/server/game/TriniChat/IRCCmd.cpp
@@ -0,0 +1,857 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCCmd.h"
+#include "IRCClient.h"
+#include "Database/DatabaseEnv.h"
+#include "ObjectMgr.h"
+#include "AccountMgr.h"
+#include "MapManager.h"
+#include "World.h"
+// Constructor
+IRCCmd::IRCCmd(){}
+// Destructor
+IRCCmd::~IRCCmd(){}
+
+std::string IRCCmd::MakeUpper(std::string Channel)
+{
+    std::string tmpchan = Channel;
+    std::transform(tmpchan.begin(), tmpchan.end(), tmpchan.begin(), towupper);
+    return tmpchan;
+}
+bool IRCCmd::ParamsValid(_CDATA *CD, int pCnt)
+{
+    CD->PCOUNT = pCnt;
+    if (CD->PARAMS.size() == 0)
+        return false;
+    return ValidParams(CD->PARAMS, pCnt);
+}
+
+int IRCCmd::ParamsValid(_CDATA *CD, int pCnt, int rLev)
+{
+    //CD->PCOUNT = pCnt;
+    if (!CanUse(CD->USER, rLev))
+        return E_AUTH;
+    else if (pCnt == 0)
+        return E_OK;
+    else if (CD->PARAMS.size() == 0)
+        return E_SIZE;
+    else if (!ValidParams(CD->PARAMS, pCnt))
+        return E_SIZE;
+    return E_OK;
+}
+
+// This function checks if chat from irc is a command or not
+// return true on yes and false on no
+bool IRCCmd::IsValid(std::string USER, std::string FROM, std::string CHAT, std::string TYPE)
+{
+    // If the first line of our chat is the command prefix we have a command
+    if (CHAT.substr(0, 1) == sIRC->_cmd_prefx && CHAT.size() > 1)
+    {
+        _CDATA CDATA;
+        bool cValid    = false;
+        bool AuthValid = true;
+        bool dontlog   = true;
+        std::string* _PARAMS = getArray(CHAT, 2);
+        CDATA.USER      = USER;
+        CDATA.FROM      = FROM;
+        CDATA.TYPE      = TYPE;
+        CDATA.PCOUNT    = 0;
+        CDATA.CMD       = MakeUpper(_PARAMS[0].substr(1, _PARAMS[0].size() - 1));
+        CDATA.PARAMS    = _PARAMS[1];
+        if (CDATA.CMD == "LOGIN")
+        {
+            if (FROM == sIRC->_Nick)
+            {
+                if (ParamsValid(&CDATA, 2))
+                    Handle_Login(&CDATA);
+                else
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"login <Player> <Password>)", true, "ERROR");
+            }
+            else
+                sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Please Send A PM To Login!", true, "ERROR");
+            if (GetLevel(USER) >= sIRC->gmlog)
+                dontlog = false;
+            cValid = true;
+        }
+        else if (CDATA.CMD == "LOGOUT")
+        {
+            if (FROM == sIRC->_Nick)
+            {
+                Handle_Logout(&CDATA);
+            }
+            else
+                sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Please Send A PM To Logout!", true, "ERROR");
+            cValid = true;
+        }
+        else if (CDATA.CMD == "ACCT")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC->CACCT))
+            {
+                case E_OK:
+                    Account_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"acct <Player> <(un)lock/email/pass/rename/gmlevel>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "BAN")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC->CBAN))
+            {
+                case E_OK:
+                    Ban_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"ban <Player> <acct/ip>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "CHAN")
+        {
+            switch(ParamsValid(&CDATA, 1, sIRC->CCHAN))
+            {
+                case E_OK:
+                    Chan_Control(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"chan <op> <IRC User>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "CHAR")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC->CCHAR))
+            {
+                case E_OK:
+                    Char_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"char <Player> <mailcheat/taxicheat/maxskill/setskill/quest/mod>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "FUN")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC->CFUN))
+            {
+                case E_OK:
+                    Fun_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"fun <Player> <Sound/Say>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "HELP")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC->CHELP))
+            {
+                case E_OK:
+                    Help_IRC(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"help <Command>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "INCHAN")
+        {
+            switch(ParamsValid(&CDATA, 1, sIRC->CINCHAN))
+            {
+                case E_OK:
+                    Inchan_Server(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"inchan <Channel>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "INFO")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC->CINFO))
+            {
+                case E_OK:
+                    Info_Server(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"info)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "ITEM")
+        {
+            CDATA.PCOUNT = 3;
+            switch(ParamsValid(&CDATA, 2, sIRC->CITEM))
+            {
+                case E_OK:
+                    Item_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"item <Player> <add> <ItemID/[ItemName]> <Amount>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "JAIL")
+        {
+            CDATA.PCOUNT = 3;
+            switch(ParamsValid(&CDATA, 1, sIRC->CJAIL))
+            {
+                case E_OK:
+                    Jail_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"jail <Player> <release/Reason>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "KICK")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 1, sIRC->CKICK))
+            {
+                case E_OK:
+                    Kick_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"kick <Player> <Reason>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "KILL")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 1, sIRC->_KILL))
+            {
+                case E_OK:
+                    Kill_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"kill <Player> <Reason>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "LEVEL")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 2, sIRC->CLEVEL))
+            {
+                case E_OK:
+                    Level_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"level <Player> <NewLevel>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "LOOKUP")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 2, sIRC->CLOOKUP))
+            {
+                case E_OK:
+                    Lookup_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"lookup <acct/char/creature/faction/go/item/quest/skill/spell/tele> <ID/Name>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "MONEY")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 2, sIRC->CMONEY))
+            {
+                case E_OK:
+                    Money_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"money <Player> <(-)Money>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "MUTE")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC->CMUTE))
+            {
+                case E_OK:
+                    Mute_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"mute <Player> <release/TimeInMins> <Reason>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "ONLINE")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC->CONLINE))
+            {
+                case E_OK:
+                    Online_Players(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"online)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "PM")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC->CPM))
+            {
+                case E_OK:
+                    PM_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"pm <Player> <Message>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "RELOAD")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC->CRELOAD))
+            {
+                case E_OK:
+                    sIRC->Send_IRC_Channels("Reloading Configuration Options.");
+                    sWorld->LoadConfigSettings(true);
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "RECONNECT")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC->CRECONNECT))
+            {
+                case E_OK:
+                    sIRC->Send_IRC_Channels(sIRC->RstMsg);
+                    sIRC->ResetIRC();
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "RESTART")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC->CSHUTDOWN))
+            {
+                case E_OK:
+                    Restart_Trinity(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"server <setmotd/flusharenapoints/sec_number_for_restart>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "REVIVE")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 1, sIRC->CREVIVE))
+            {
+                case E_OK:
+                    Revive_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"revive <Player>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "SAVEALL")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC->CSAVEALL))
+            {
+                case E_OK:
+                    Saveall_Player(&CDATA);
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "SERVER")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 2, sIRC->CSERVERCMD))
+            {
+                case E_OK:
+                    Server(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"server <setmotd/flusharenapoints>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "SHUTDOWN")
+        {
+            switch(ParamsValid(&CDATA, 1, sIRC->CSHUTDOWN))
+            {
+                case E_OK:
+                    Shutdown_Trinity(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"shutdown <TimeInSeconds>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "SPELL")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC->CSPELL))
+            {
+                case E_OK:
+                    Spell_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"spell <Player> <Cast/Learn/UnLearn> <SpellID>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "SYSMSG")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 2, sIRC->CSYSMSG))
+            {
+                case E_OK:
+                    Sysmsg_Server(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"sysmsg <a/e/n/add/del/list> <Message>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "TELE")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC->CTELE))
+            {
+                case E_OK:
+                    Tele_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"tele <Player> <l/c/r/to/cr/go/homebind> <Loc.Name/MAPID X Y Z/Recall/Player/Creature GUID/GO GUID/Homebind>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "TOP")
+        {
+            CDATA.PCOUNT = 1;
+            switch(ParamsValid(&CDATA, 1, sIRC->CTOP))
+            {
+                case E_OK:
+                    Top_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"top <accttime/chartime/money> <limit>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "PLAYER")
+        {
+            CDATA.PCOUNT = 1;
+            switch(ParamsValid(&CDATA, 1, sIRC->CPLAYER))
+            {
+                case E_OK:
+                    Player_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC->_cmd_prefx+"player <PLAYER>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "WHO")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC->CWHO))
+            {
+                case E_OK:
+                    Who_Logged(&CDATA);
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        if (!AuthValid && IsLoggedIn(USER))
+            sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Access Denied! Your Security Level Is Too Low To Use This Command!", true, "ERROR");
+        if (cValid == false && (sIRC->BOTMASK & 4) != 0)
+            sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : Unknown Command!", true, "ERROR");
+        if (cValid && dontlog)
+        {
+            sIRC->iLog.WriteLog(" %s : [ %s(%d) ] Used Command: [ %s ] With Parameters: [ %s ]", sIRC->iLog.GetLogDateTimeStr().c_str(), CDATA.USER.c_str(), GetLevel(USER), CDATA.CMD.c_str(), CDATA.PARAMS.c_str());
+            if ((sIRC->logmask & 1) != 0)
+            {
+                std::string logchan = "#";
+                logchan += sIRC->logchan;
+                std::stringstream ss;
+                ss << sIRC->iLog.GetLogDateTimeStr() << ": [ " << CDATA.USER << "(" << GetLevel(USER) << ") ] Used Command: [ " << CDATA.CMD << " ] With Parameters: [" << CDATA.PARAMS << " ]";
+                sIRC->Send_IRC_Channel(logchan, ss.str().c_str(), true);
+            }
+        }
+        return cValid;
+    }
+    return false;
+}
+
+bool IRCCmd::CanUse(std::string USER, int nLevel)
+{
+    if (IsLoggedIn(USER))
+    {
+        if (GetLevel(USER) >= nLevel)
+            return true;
+        else
+            return false;
+    }
+    else if (nLevel == 0)
+    {
+        return true;
+    }
+    else
+        sIRC->Send_IRC_Channel(USER, "\0034[ERROR] : You Are Not Logged In!", true, "ERROR");
+    return false;
+}
+
+std::string IRCCmd::ChanOrPM(_CDATA *CD)
+{
+    if (CD->FROM == sIRC->_Nick)
+        return CD->USER;
+    else
+        return CD->FROM;
+}
+
+Player *IRCCmd::GetPlayer(std::string WHO)
+{
+    normalizePlayerName(WHO);
+    return ObjectAccessor::FindPlayerByName(WHO.c_str());
+}
+
+_client *IRCCmd::GetClient(std::string cname)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == cname)
+            return (*i);
+    }
+    return (NULL);
+}
+
+bool IRCCmd::IsLoggedIn(std::string USER)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == USER)
+            return true;
+    }
+    return false;
+}
+
+bool IRCCmd::AcctIsLoggedIn(std::string USER)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if (MakeUpper((*i)->UName) == MakeUpper(USER))
+            return true;
+    }
+    return false;
+}
+
+std::string IRCCmd::AcctIsBanned(std::string ACCT)
+{
+    uint32 acctid = AccountMgr::GetId(ACCT);
+    std::string banned = "NOTBANNED";
+    QueryResult result = LoginDatabase.PQuery("SELECT banreason FROM ip_banned WHERE ip=(SELECT last_ip FROM account WHERE id = '%i')", acctid);
+    if (result)
+    {
+        banned = (*result)[0].GetCString();
+
+        return "IP Banned. Reason:" + banned;
+    }
+    QueryResult result2 = LoginDatabase.PQuery("SELECT banreason FROM account_banned WHERE id='%i' AND active =1", acctid);
+    if (result2)
+    {
+        banned = (*result2)[0].GetCString();
+
+        return "Account Banned. Reason:" + banned;
+    }
+    return banned;
+}
+
+int IRCCmd::GetLevel(std::string sName)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == sName)
+            return (*i)->GMLevel;
+    }
+    return 0;
+}
+
+int IRCCmd::AcctLevel(std::string plnme)
+{
+    ObjectGuid guid = sObjectMgr->GetPlayerGUIDByName(plnme);
+    uint32 account_id = 0;
+    uint32 security = 0;
+    account_id = sObjectMgr->GetPlayerAccountIdByGUID(guid);
+    security = AccountMgr::GetSecurity(account_id);
+    return security;
+}
+
+std::string IRCCmd::GetAccName(std::string sName)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == sName)
+            return (*i)->UName;
+    }
+    return "";
+}
+
+std::string IRCCmd::GetNameFromAcct(std::string sName)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->UName == sName)
+            return (*i)->Name;
+    }
+    return "";
+}
+
+int IRCCmd::GetAcctIDFromName(std::string sName)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == sName)
+        {
+            uint32 acct_id = 0;
+            acct_id = AccountMgr::GetId((*i)->UName.c_str());
+            return acct_id;
+        }
+    }
+    return 0;
+}
+
+std::string IRCCmd::GetAcctNameFromID(uint32 acctid)
+{
+    QueryResult result = LoginDatabase.PQuery("SELECT username FROM account WHERE id = '%d'", acctid);
+    if (result)
+    {
+        std::string name = (*result)[0].GetCString();
+
+        return name;
+    }
+
+    return "";
+}
+
+std::string IRCCmd::GetIPFromPlayer(std::string player)
+{
+    QueryResult result = CharacterDatabase.PQuery("SELECT account FROM characters WHERE name = '%s'", player.c_str());
+    if (result)
+    {
+        std::string acctid = (*result)[0].GetCString();
+
+        QueryResult result2 = LoginDatabase.PQuery("SELECT last_ip FROM account WHERE id = '%s'", acctid.c_str());
+        if (result2)
+        {
+            std::string ip = (*result2)[0].GetCString();
+
+            return ip;
+        }
+    }
+
+    return "";
+}
+
+std::string IRCCmd::SecToDay(std::string secons)
+{
+    unsigned int seconds = atoi(secons.c_str());
+    unsigned int days = seconds / 86400;
+    unsigned int hours = seconds / 3600 % 24;
+    unsigned int mins = seconds / 60 % 60;
+    char tottime[1000];
+    sprintf(tottime, "%iDays:%iHours:%iMinutes", days, hours, mins);
+
+    return tottime;
+}
+
+bool IRCCmd::ValidParams(std::string PARAMS, int nCount)
+{
+    if (nCount == 1 && PARAMS.size() == 0)
+        return false;
+    int pcount = 0;
+    int p = -1;
+    for (int i = 0;i < nCount;i++)
+    {
+        p = PARAMS.find(" ", p + 1);
+        if (p == -1)
+            break;
+        else
+            pcount++;
+    }
+    nCount--;
+    if (pcount >= nCount)
+        return true;
+    else
+        return false;
+}
+
+std::string* IRCCmd::getArray(std::string PARAMS, int nCount)
+{
+    std::string *array = new std::string[nCount];
+    if (PARAMS.size() > 0)
+    {
+        size_t ps = 0;
+        size_t pc = -1;
+        for (int i = 0;i < nCount;i++)
+        {
+            pc = PARAMS.find(" ", pc + 1);
+            if (i + 1 == nCount && nCount != 1)
+            {
+                if (ps > 0 && pc > 0)
+                    array[i] = PARAMS.substr(ps, PARAMS.size() - ps);
+            }
+            else
+                array[i] = PARAMS.substr(ps, pc - ps);
+            ps = pc + 1;
+        }
+    }
+    return array;
+}
+
+std::string IRCCmd::MakeMsg(const char *sLine, ...)
+{
+    va_list ap;
+    char tmpoutp[1024];
+    va_start(ap, sLine);
+    vsnprintf(tmpoutp, 1024, sLine, ap);
+    va_end(ap);
+    std::string outp = tmpoutp;
+    return outp;
+}
diff --git a/src/server/game/TriniChat/IRCCmd.h b/src/server/game/TriniChat/IRCCmd.h
new file mode 100644
index 0000000..6921f8c
--- /dev/null
+++ b/src/server/game/TriniChat/IRCCmd.h
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _IRC_CMD_H
+#define _IRC_CMD_H
+
+#define MAX_CLIENTS 50
+//include boost
+#include "boost/thread.hpp"
+#include "boost/date_time.hpp"
+#include "Common.h"
+#include "Player.h"
+#include "ObjectAccessor.h"
+#include "BattlegroundMgr.h"
+
+struct ChannelUser
+{
+    int UserType;
+    std::string Name;
+    std::string UName;
+    int UserLevel;
+};
+
+struct _client
+{
+    bool        LoggedIn;
+    std::string Name;
+    std::string UName;
+    int         GMLevel;
+};
+struct _CDATA
+{
+    std::string CMD;
+    std::string USER;
+    std::string FROM;
+    std::string PARAMS;
+    std::string TYPE;
+    int PCOUNT;
+};
+enum APVERR
+{
+    E_OK,
+    E_SIZE,
+    E_AUTH,
+    E_IVALID,
+};
+enum ESOUNDS
+{
+    S_ENTERWORLD    = 602,
+    S_QUESTFAILED   = 847,
+    S_INVITE        = 880,
+    S_LEVELUP       = 888,
+    S_COINSOUND     = 895,
+    S_WHISPER       = 3081,
+    S_STEALTH       = 3325,
+};
+class IRCCmd
+{
+    public:
+        IRCCmd();
+        ~IRCCmd();
+
+        void    Handle_Logout(_CDATA *CD);
+        bool    IsLoggedIn(std::string USER);
+        bool    IsValid(std::string USER, std::string FROM, std::string CHAT, std::string TYPE);
+        bool    AcctIsLoggedIn(std::string USER);
+        _client *GetClient(std::string cname);
+
+    public:
+        static std::string MakeMsg(const char *sLine, ...);
+        static std::string ChanOrPM(_CDATA *CD);
+        int AcctLevel(std::string plnme);
+        int GetLevel(std::string sName);
+        std::string MakeUpper(std::string Channel);
+        std::string  AcctIsBanned(std::string ACCT);
+        std::list<_client*> _CLIENTS;
+        Player* GetPlayer(std::string WHO);
+
+    private:
+        // TriniChat Commands
+        void    Handle_Login(_CDATA *CD);
+        void    Account_Player(_CDATA *CD);
+        void    Ban_Player(_CDATA *CD);
+        void    Chan_Control(_CDATA *CD);
+        void    Char_Player(_CDATA *CD);
+        void    Fun_Player(_CDATA *CD);
+        void    Help_IRC(_CDATA *CD);
+        void    Inchan_Server(_CDATA *CD);
+        void    Info_Server(_CDATA *CD);
+        void    Item_Player(_CDATA *CD);
+        void    Jail_Player(_CDATA *CD);
+        void    Kick_Player(_CDATA *CD);
+        void    Kill_Player(_CDATA *CD);
+        void    Player_Player(_CDATA *CD);
+        void    Lookup_Player(_CDATA *CD);
+        void    Level_Player(_CDATA *CD);
+        void    Money_Player(_CDATA *CD);
+        void    Mute_Player(_CDATA *CD);
+        void    Online_Players(_CDATA *CD);
+        void    PM_Player(_CDATA *CD);
+        void    Restart_Trinity(_CDATA *CD);
+        void    Revive_Player(_CDATA *CD);
+        void    Saveall_Player(_CDATA *CD);
+        void    Server(_CDATA *CD);
+        void    Shutdown_Trinity(_CDATA *CD);
+        void    Spell_Player(_CDATA *CD);
+        void    Sysmsg_Server(_CDATA *CD);
+        void    Tele_Player(_CDATA *CD);
+        void    Top_Player(_CDATA *CD);
+        void    Who_Logged(_CDATA *CD);
+        bool    CanUse(std::string USER, int nLevel);
+        bool    ValidParams(std::string PARAMS, int nCount = 1);
+        bool    ParamsValid(_CDATA *CD, int pCnt);
+        int     ParamsValid(_CDATA *CD, int pCnt, int rLev);
+        std::string GetAccName(std::string sName);
+        std::string GetNameFromAcct(std::string sName);
+        std::string GetAcctNameFromID(uint32 acctid);
+        std::string GetIPFromPlayer(std::string player);
+        std::string SecToDay(std::string secons);
+        int GetAcctIDFromName(std::string sName);
+        std::string* getArray(std::string PARAMS, int nCount = 1);
+};
+inline void MakeLower(std::string& str)
+{
+    std::transform(str.begin(), str.end(), str.begin(), ::tolower);
+}
+#endif
diff --git a/src/server/game/TriniChat/IRCCmde.cpp b/src/server/game/TriniChat/IRCCmde.cpp
new file mode 100644
index 0000000..15e9c6e
--- /dev/null
+++ b/src/server/game/TriniChat/IRCCmde.cpp
@@ -0,0 +1,2353 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCCmd.h"
+#include <iostream>
+#include "IRCClient.h"
+#include "MCS_OnlinePlayers.h"
+#include "WorldPacket.h"
+#include "Database/DatabaseEnv.h"
+#include "Chat.h"
+#include "MapManager.h"
+#include "World.h"
+#include "Guild.h"
+#include "ObjectMgr.h"
+#include "AccountMgr.h"
+#include "Language.h"
+#include "SpellAuras.h"
+#include "Config.h"
+#include "ReputationMgr.h"
+#include "ArenaTeamMgr.h"
+#include "GitRevision.h"
+
+#define Send_Player(p, m)           sIRC->Send_WoW_Player(p, m)
+#define Send_IRCA(c, m, b, t)       sIRC->Send_IRC_Channel(c, m, b, t)
+
+#ifdef WIN32
+#define Delay(x) Sleep(x)
+#else
+#define Delay(x) sleep(x / 1000)
+#endif
+
+void IRCCmd::Handle_Login(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 2);
+    std::string isbanned = AcctIsBanned(_PARAMS[0]);
+    LoginDatabase.EscapeString(_PARAMS[0]);
+    LoginDatabase.EscapeString(_PARAMS[1]);
+    if (isbanned == "NOTBANNED")
+    {
+        if (!IsLoggedIn(CD->USER))
+        {
+            if (!AcctIsLoggedIn(_PARAMS[0].c_str()))
+            {
+                QueryResult result = LoginDatabase.PQuery("SELECT `gmlevel` FROM `account`, `account_access` WHERE `username`='%s' AND `account_access`.`id`=`account`.`id` AND `sha_pass_hash`=SHA1(CONCAT(UPPER(`username`),':',UPPER('%s')));", _PARAMS[0].c_str(), _PARAMS[1].c_str());
+                if (result)
+                {
+                    Field *fields = result->Fetch();
+                    int GMLevel = fields[0].GetUInt8();
+                    if (GMLevel >= 0)
+                    {
+                        _client *NewClient = new _client();
+                        NewClient->Name     = CD->USER;
+                        NewClient->UName    = MakeUpper(_PARAMS[0]);
+                        NewClient->GMLevel  = fields[0].GetUInt8();
+                        _CLIENTS.push_back(NewClient);
+                        Send_IRCA(CD->USER, MakeMsg("You Are Now Logged In As %s.", _PARAMS[0].c_str()), true, CD->TYPE);
+
+                        if (sIRC->_op_gm == 1 && GMLevel >= sIRC->_op_gm_lev)
+                        {
+                            for (int i=1;i < sIRC->_chan_count + 1;i++)
+                            sIRC->SendIRC("MODE #"+sIRC->_irc_chan[i]+" +o "+CD->USER);
+                        }
+                    }
+                }
+                else
+                    Send_IRCA(CD->USER, "Sorry, Your Username Or Password Is Incorrect. Please Try Again. ", true, "ERROR");
+            }
+            else
+                for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+                {
+                    if ((*i)->UName == _PARAMS[0])
+                        Send_IRCA(CD->USER, MakeMsg("%s Is Already Logged In With This Username. ", (*i)->Name.c_str()), true, "ERROR");
+                }
+        }
+        else
+            for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+            {
+                if ((*i)->Name == CD->USER)
+                    Send_IRCA(CD->USER, MakeMsg("You are already logged in as %s.", (*i)->UName.c_str()), true, "ERROR");
+            }
+    }
+    else
+         Send_IRCA(CD->USER, "Sorry, you are "+isbanned+" and can not log in.", true, "ERROR");
+}
+
+void IRCCmd::Handle_Logout(_CDATA *CD)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == CD->USER)
+        {
+            delete (*i);
+            i = _CLIENTS.erase(i);
+            Send_IRCA(CD->USER, "Successfully logged out", true, CD->TYPE);
+            return;
+        }
+    }
+    Send_IRCA(CD->USER, "Not logged in", true, "ERROR");
+}
+
+void IRCCmd::Account_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 3);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC->BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    normalizePlayerName(_PARAMS[0]);
+    ObjectGuid guid = sObjectMgr->GetPlayerGUIDByName(_PARAMS[0]);
+    int account_id = 0;
+    account_id = sObjectMgr->GetPlayerAccountIdByGUID(guid);
+    if (account_id)
+    {
+        if (account_id == GetAcctIDFromName(CD->USER) || GetLevel(CD->USER) >= sIRC->_op_gm_lev)
+        {
+            Player* plr = ObjectAccessor::FindPlayer(guid);
+            if (_PARAMS[1] == "lock")
+            {
+                LoginDatabase.PExecute("UPDATE `account` SET `locked` = '1' WHERE `id` = '%d'",account_id);
+                if (plr) Send_Player(plr, MakeMsg("Your Account Has Been Locked To Your Current IP By: %s", CD->USER.c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : Account Has Been Locked To Their Current IP Address.", true, CD->TYPE);
+            }
+            else if (_PARAMS[1] == "unlock")
+            {
+                LoginDatabase.PExecute("UPDATE `account` SET `locked` = '0' WHERE `id` = '%d'",account_id);
+                if (plr) Send_Player(plr, MakeMsg("Your Account Has Been UnLocked From The Associated IP By: %s", CD->USER.c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : Account Has Been UnLocked From The Associated IP Address.", true, CD->TYPE);
+            }
+            else if (_PARAMS[1] == "email")
+            {
+                LoginDatabase.PExecute("UPDATE `account` SET `email` = '%s' WHERE `id` = '%d'",_PARAMS[2].c_str() ,account_id);
+                if (plr) Send_Player(plr, MakeMsg("%s Has Changed Your EMail Adress To: %s", CD->USER.c_str(), _PARAMS[2].c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : EMail Address Successfully Changed To: "+_PARAMS[2], true, CD->TYPE);
+            }
+            else if (_PARAMS[1] == "pass")
+            {
+                LoginDatabase.PExecute("UPDATE `account` SET `sha_pass_hash` = SHA1(CONCAT(UPPER(`username`),':',UPPER('%s'))) WHERE `id` = '%d'",_PARAMS[2].c_str() ,account_id);
+                if (plr) Send_Player(plr, MakeMsg("%s Has Changed Your Password To: %s", CD->USER.c_str(), _PARAMS[2].c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : Password Successfully Changed To: "+_PARAMS[2], true, CD->TYPE);
+            }
+            else if (_PARAMS[1] == "rename")
+            {
+                if (plr)
+                {
+                    plr->SetAtLoginFlag(AT_LOGIN_RENAME);
+                    Send_Player(plr, MakeMsg("%s Has Requested You Change This Characters Name, Rename Will Be Forced On Next Login!", CD->USER.c_str()));
+                }
+                CharacterDatabase.PExecute("UPDATE `characters` SET `at_login` = `at_login` | '1' WHERE `guid` = '%u'", guid);
+                Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : Has Been Forced To Change Their Characters Name, Rename Will Be Forced On Next Login!", true, CD->TYPE);
+            }
+            else if (_PARAMS[1] == "gmlevel")
+            {
+                const char *cgmlevel = _PARAMS[2].c_str();
+                if (GetLevel(CD->USER) >= atoi(cgmlevel))
+                {
+                    LoginDatabase.PExecute("UPDATE `account_access` SET `gmlevel` = '%s' WHERE `id` = '%d'", _PARAMS[2].c_str(), account_id);
+                    Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : Has GM Level Successfully Changed To: "+_PARAMS[2], true, CD->TYPE);
+                }
+                else
+                {
+                    Send_IRCA(CD->USER, "The Specified GM Level Is Higher Than Your GM Level.", true, "ERROR");
+                }
+            }
+        }
+        else
+            Send_IRCA(CD->USER, "You Are Not A GM, You May Only Change Settings In Your Own Account.", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, "No such player - account lookup failed", true, "ERROR");
+}
+
+void IRCCmd::Ban_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 4);
+    std::string duration = SecToDay (_PARAMS[3].c_str());
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC->BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    if (_PARAMS[1] == "ip")
+    {
+        std::string ip = GetIPFromPlayer(_PARAMS[0]);
+        if (_PARAMS[2] == "")
+            _PARAMS[2] = "No Reason";
+        if (ip != "")
+        {
+            sWorld->BanAccount(BAN_IP, ip.c_str(), _PARAMS[3].c_str(), _PARAMS[2], CD->USER);
+            if (Player* plr = GetPlayer(_PARAMS[0]))
+                plr->GetSession()->KickPlayer();
+            Send_IRCA(ChanOrPM(CD), MakeMsg("[%s] Has Had Their IP Address Banned. [%s] Reason: %s Duration: %s",_PARAMS[0].c_str() ,ip.c_str() , _PARAMS[2].c_str(), _PARAMS[3].c_str()), true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "Can not locate IP-address for that charactername", true, "ERROR");
+    }
+    if (_PARAMS[1] == "acct")
+    {
+
+        if (_PARAMS[2] == "")
+            _PARAMS[2] = "No reason";
+        if (_PARAMS[3] == "")//set standard bantime to 1 day
+            _PARAMS[3] = "1d";
+        QueryResult result = LoginDatabase.PQuery("SELECT id FROM `account` WHERE username = '%s'", _PARAMS[0].c_str());
+        if (result)
+        {
+            sWorld->BanAccount(BAN_ACCOUNT, _PARAMS[0].c_str(), _PARAMS[3].c_str(), _PARAMS[2], CD->USER);
+            Send_IRCA(ChanOrPM(CD), MakeMsg("[%s] has been account-banned. Reason: %s Duration: %s",_PARAMS[0].c_str(), _PARAMS[2].c_str(), _PARAMS[3].c_str()),  true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "Can not find any accounts for that accountname", true, "ERROR");
+
+    }
+    if (_PARAMS[1] == "unban")
+    {
+        std::string unbani = _PARAMS[0];
+        if (atoi(unbani.c_str()) > 0)
+        {
+            LoginDatabase.PExecute("DELETE FROM ip_banned WHERE ip = '%s'", _PARAMS[0].c_str());
+            Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Has Been Removed From The IP Ban List.", _PARAMS[0].c_str()), true, CD->TYPE);
+        }
+        else
+        {
+            QueryResult result = LoginDatabase.PQuery("SELECT id FROM `account` WHERE username = '%s'", _PARAMS[0].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string id = fields[0].GetString();
+
+                LoginDatabase.PExecute("DELETE FROM account_banned WHERE id = %s", id.c_str());
+
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Has Been Removed From The Account Ban List.", _PARAMS[0].c_str()), true, CD->TYPE);
+
+            }
+            else
+                Send_IRCA(CD->USER, "I Cannot Locate An Account Or IP Address For The Paramaters Given.", true, "ERROR");
+        }
+    }
+}
+
+void IRCCmd::Char_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 5);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC->BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    normalizePlayerName(_PARAMS[0]);
+    ObjectGuid guid = sObjectMgr->GetPlayerGUIDByName(_PARAMS[0]);
+    Player* plr = ObjectAccessor::FindPlayer(guid);
+    if (plr)
+    {
+        if (_PARAMS[1] == "mapcheat")
+        {
+            bool explore = false;
+            if (_PARAMS[2] != "0")
+                explore = true;
+            for (uint8 i=0; i<64; i++)
+            {
+                if (_PARAMS[2] != "0")
+                    plr->SetFlag(PLAYER_EXPLORED_ZONES_1+i,0xFFFFFFFF);
+                else
+                    plr->SetFlag(PLAYER_EXPLORED_ZONES_1+i,0);
+            }
+            if (explore)
+            {
+                Send_Player(plr, MakeMsg("All Your Zones Have Been Set To Explored By: %s", CD->USER.c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Now Explored All Zones.", true, CD->TYPE);
+            }
+            else
+            {
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Now Had All Zones Set To Un-Explored.", true, CD->TYPE);
+                Send_Player(plr, MakeMsg("All Your Zones Have Been Set To Un-Explored By: %s", CD->USER.c_str()));
+            }
+        }
+        if (_PARAMS[1] == "taxicheat")
+        {
+            if (_PARAMS[2] != "0")
+            {
+                plr->SetTaxiCheater(true);
+                Send_Player(plr, MakeMsg("Taxi Node Cheat Has Been Enabled By: %s", CD->USER.c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Taxi Node Cheat Has Been Enabled.", true, CD->TYPE);
+            }
+            else
+            {
+                plr->SetTaxiCheater(false);
+                Send_Player(plr, MakeMsg("Taxi Node Cheat Has Been Disabled By: %s", CD->USER.c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Taxi Node Cheat Has Been Disabled.", true, CD->TYPE);
+            }
+        }
+        if (_PARAMS[1] == "maxskill")
+        {
+            plr->UpdateSkillsToMaxSkillsForLevel();
+            Send_Player(plr, MakeMsg("Your Skills Have Been Maxed Out By: %s", CD->USER.c_str()));
+            Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Skills Have Been Maxed Out.", true, CD->TYPE);
+        }
+        if (_PARAMS[1] == "setskill")
+        {
+            uint32 skill = atoi(_PARAMS[2].c_str());
+            uint32 step = atoi(_PARAMS[3].c_str());
+            uint32 level = atol(_PARAMS[4].c_str());
+            int32 max   = _PARAMS[5].c_str() ? atol (_PARAMS[5].c_str()) : plr->GetPureMaxSkillValue(skill);
+            SkillLineEntry const* skilllookup = sSkillLineStore.LookupEntry(skill);
+            //if skillid entered is not a number and greater then 0 then the command is being used wrong
+            if (skill > 0)
+            {
+                //does the skill even exist
+                if (skilllookup)
+                {
+                    //does player have the skill yet
+                    if (plr->GetSkillValue(skill))
+                    {
+                        plr->SetSkill(skill,step,level,max);
+                        Send_Player(plr, MakeMsg("Skill: %s Has Been Set To Level: %i Max: %i By: %s",skilllookup->name[0], level, max, CD->USER.c_str()));
+                        Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Has Had Skill: %s Set To Level: %d Max: %d",_PARAMS[0].c_str() , skilllookup->name[0], level, max), true, CD->TYPE);
+                    }
+                    else
+                        Send_IRCA(CD->USER, MakeMsg("Player Does Not Have The %s Skill Yet.", skilllookup->name[0]), true, "ERROR");
+                }
+                else
+                    Send_IRCA(CD->USER, "That Skill ID Does Not Exist.", true, "ERROR");
+            }
+            else
+                Send_IRCA(CD->USER, "The Skill ID Entered Is Invalid.", true, "ERROR");
+        }
+        if (_PARAMS[1] == "combatstop")
+        {
+            if (!plr->IsInCombat())
+            {
+                plr->CombatStop();
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Was Dropped From Combat",_PARAMS[0].c_str()), true, CD->TYPE);
+            }else
+            {
+                Send_IRCA(CD->USER, "Specified Player Is Not In Combat.", true, "ERROR");
+            }
+        }
+        if (_PARAMS[1] == "quest")
+        {
+            std::string s_param  = _PARAMS[3];
+            std::string QName = "";
+            char *args = (char*)s_param.c_str();
+            uint32 qId = 0;
+            if (args[0]=='[')
+            {
+                char* cQName = strtok((char*)args, "]");
+                if (cQName && cQName[0])
+                {
+                    QName = cQName+1;
+                    WorldDatabase.EscapeString(QName);
+                    QueryResult result = WorldDatabase.PQuery("SELECT id FROM quest_template WHERE name = '%s'", QName.c_str());
+                    if (!result)
+                    {
+                        Send_IRCA(CD->USER, "Quest Not Found!", true, "ERROR");
+                        return;
+                    }
+                    qId = result->Fetch()->GetUInt16();
+
+                }
+            }
+            else
+            {
+                qId = atoi(args);
+                QueryResult result = WorldDatabase.PQuery("SELECT title FROM quest_template WHERE id = '%d'", qId);
+                if (!result)
+                {
+                    Send_IRCA(CD->USER, "Quest Not Found!", true, "ERROR");
+                    return;
+                }
+                QName = result->Fetch()->GetString();
+
+            }
+            if (_PARAMS[2] == "add")
+            {
+                QueryResult item_max = WorldDatabase.PQuery("SELECT MAX(entry) FROM item_template");
+                Quest const* pQuest = sObjectMgr->GetQuestTemplate(qId);
+                for (uint32 id = 0; id < item_max->Fetch()->GetUInt32(); id++)
+                {
+                    ItemTemplate const *pProto = sObjectMgr->GetItemTemplate(id);
+                    if (!pProto)
+                        continue;
+
+                    if (pProto->StartQuest == qId)
+                    {
+                        Send_IRCA(CD->USER, MakeMsg("This Quest Requires Activation By Item %d, Add It To The Player And Start Quest Manually.", pProto->ItemId),true, "ERROR");
+                    }
+                }
+
+                if (plr->CanAddQuest(pQuest, true))
+                {
+                    plr->AddQuest(pQuest, NULL);
+                    Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Had Quest [%s] Added To Quest Log.", _PARAMS[0].c_str(), QName.c_str()), true, "ERROR");
+                }
+                else
+                {
+                    Send_IRCA(CD->USER, "Cannot Add Quest To Player, He Either Has No Space Or He Already Has The Quest In His Quest Log.", true, "ERROR");
+                }
+            }
+            if (_PARAMS[2] == "complete")
+            {
+                Quest const* pQuest = sObjectMgr->GetQuestTemplate(qId);
+                if (plr->GetQuestStatus(qId) == QUEST_STATUS_NONE)
+                {
+                    Send_IRCA(CD->USER, "Player Does Not Have This Quest In Quest Log, Cannot Complete It.", true, "ERROR");
+                }
+                else
+                {
+                    for (uint8 x = 0; x < QUEST_OBJECTIVES_COUNT; ++x)
+                    {
+                        uint32 id = pQuest->RequiredItemId[x];
+                        uint32 count = pQuest->RequiredItemCount[x];
+                        if (!id || !count)
+                            continue;
+                        uint32 curItemCount = plr->GetItemCount(id,true);
+                        ItemPosCountVec dest;
+                        uint8 msg = plr->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, id, count-curItemCount);
+                        if (msg == EQUIP_ERR_OK)
+                        {
+                            Item* item = plr->StoreNewItem(dest, id, true);
+                            plr->SendNewItem(item,count-curItemCount,true,false);
+                        }
+                    }
+
+                    for (uint8 i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+                    {
+                        uint32 creature = pQuest->RequiredNpcOrGo[i];
+                        uint32 creaturecount = pQuest->RequiredNpcOrGoCount[i];
+                        /*if (uint32 spell_id = pQuest->RequiredSpellCast[i])
+                        {
+                            for (uint16 z = 0; z < creaturecount; ++z)
+                                plr->CastedCreatureOrGO(creature,0,spell_id);
+                        }
+                        else */
+                        if (creature > 0)
+                        {
+                            if (CreatureTemplate const* cInfo = sObjectMgr->GetCreatureTemplate(creature))
+                                for (uint16 z = 0; z < creaturecount; ++z)
+                                    plr->KilledMonster(cInfo,ObjectGuid::Empty);
+                        }
+                        /*else if (creature < 0)
+                        {
+                            for (uint16 z = 0; z < creaturecount; ++z)
+                                plr->CastedCreatureOrGO(creature,0,0);
+                        }*/
+                    }
+
+                    if (uint32 repFaction = pQuest->GetRepObjectiveFaction())
+                    {
+                        uint32 repValue = pQuest->GetRepObjectiveValue();
+                        uint32 curRep = plr->GetReputationMgr().GetReputation(repFaction);
+                        if (curRep < repValue)
+                        {
+                            FactionEntry const *factionEntry = sFactionStore.LookupEntry(repFaction);
+                            plr->GetReputationMgr().SetReputation(factionEntry,repValue);
+                        }
+                    }
+
+                    int32 ReqOrRewMoney = pQuest->GetRewOrReqMoney();
+                    if (ReqOrRewMoney < 0)
+                        plr->ModifyMoney(-ReqOrRewMoney);
+
+                    plr->CompleteQuest(qId);
+                    Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Quest [%s] Status Set To Complete.", _PARAMS[0].c_str(), QName.c_str()), true, CD->TYPE);
+                }
+            }
+        }
+        if (_PARAMS[1] == "mod")
+        {
+            /*if (_PARAMS[2] == "rep") TODO
+            {
+                uint32 factionId = atoi((char*)_PARAMS[3].c_str());
+                FactionEntry const *factionEntry = sFactionStore.LookupEntry(factionId);
+                if (!factionEntry)
+                {
+                    Send_IRCA(CD->USER, "No Faction With That Name Exists.", true, "ERROR");
+                }
+                else
+                {
+                    int32 amount = atol((char*)_PARAMS[4].c_str());
+                    if (amount > -39000 && amount < 43000)
+                    {
+                        plr->SetFactionReputation(factionId,amount);
+                        Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Reputation With Faction %s Set To %s.", _PARAMS[0].c_str(), _PARAMS[3].c_str(), _PARAMS[4].c_str()), true, CD->TYPE);
+                    }
+                    else
+                    {
+                        Send_IRCA(CD->USER, "Reputation Value Incorrect. Must Be Between -39000 and 43000.", true, "ERROR");
+                    }
+                }
+            }*/
+            if (_PARAMS[2] == "morph")
+            {
+                uint16 display_id = (uint16)atoi((char*)_PARAMS[3].c_str());
+                plr->SetDisplayId(display_id);
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Has Been Morphed Into DisplayID: %s.", _PARAMS[0].c_str(), _PARAMS[3].c_str()), true, CD->TYPE);
+            }
+            else
+            {
+                Send_IRCA(CD->USER, "Valid Parameters Are: morph <displayid>, reputation <faction><value>.", true, "ERROR");
+            }
+        }
+    }
+    else
+        Send_IRCA(CD->USER, "No Character With That Name Exists.", true, "ERROR");
+}
+
+void IRCCmd::Fun_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 3);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC->BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        if (_PARAMS[1] == "say")
+        {
+            plr->Say(_PARAMS[2], LANG_UNIVERSAL);
+            Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Was Forced To Say: "+_PARAMS[2]+".", true, CD->TYPE);
+        }
+        if (_PARAMS[1] == "sound")
+        {
+            uint32 sndid = atoi(_PARAMS[2].c_str());
+            plr->PlayDirectSound(sndid , plr->ToPlayer());
+            Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Just Heard Sound ID: "+_PARAMS[2]+".", true, CD->TYPE);
+        }
+    }
+    else
+        Send_IRCA(CD->USER, "Player Not Online!", true, "ERROR");
+}
+
+void IRCCmd::Help_IRC(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 1);
+    QueryResult result = WorldDatabase.PQuery("SELECT `Command`, `Description`, `gmlevel` FROM `irc_commands`");
+    if (result)
+    {
+        if (IsLoggedIn(CD->USER))
+        {
+            if (_PARAMS[0] == "")
+            {
+                QueryResult result = WorldDatabase.PQuery("SELECT * FROM `irc_commands` WHERE `gmlevel` <= %u ORDER BY `Command`", GetLevel(CD->USER));
+                if (result)
+                {
+                    std::string output = "\002TriniChat IRC Commands:\017 ";
+                    for (uint64 i=0; i < result->GetRowCount(); i++)
+                    {
+                        Field *fields = result->Fetch();
+                        output += fields[0].GetString() + ", ";
+                        result->NextRow();
+                    }
+
+                    Send_IRCA(CD->USER, output, true, CD->TYPE.c_str());
+                }
+            }
+            else
+            {
+                QueryResult result = WorldDatabase.PQuery("SELECT `Description`, `gmlevel` FROM `irc_commands` WHERE `Command` = '%s'", _PARAMS[0].c_str());
+                if (result)
+                {
+                    Field *fields = result->Fetch();
+                    if (fields[1].GetInt32() > GetLevel(CD->USER))
+                    {
+                        Send_IRCA(CD->USER, "You Do Not Have Access To That Command, So No Help Is Available.", true, CD->TYPE.c_str());
+                        return;
+                    }
+                    if (result)
+                    {
+                        std::string cmdhlp = fields[0].GetString();
+
+                        Send_IRCA(CD->USER, cmdhlp, true, CD->TYPE.c_str());
+                    }
+                }
+                else
+                    Send_IRCA(CD->USER, "No Such Command Exists, Please Check The Spelling And Try Again.", true, "ERROR");
+            }
+        }
+        else if (!IsLoggedIn(CD->USER))
+        {
+            if (_PARAMS[0] == "")
+            {
+                QueryResult result = WorldDatabase.PQuery("SELECT * FROM `irc_commands` WHERE `gmlevel` = 0 ORDER BY `Command`");
+                if (result)
+                {
+                    std::string output = "\002TriniChat IRC Commands:\017 ";
+                    for (uint64 i=0; i < result->GetRowCount(); i++)
+                    {
+                        Field *fields = result->Fetch();
+                        output += fields[0].GetString() + ", ";
+                        result->NextRow();
+                    }
+
+                    Send_IRCA(CD->USER, output, true, CD->TYPE.c_str());
+                    Send_IRCA(CD->USER, "You Are Currently Not Logged In, Please Login To See A Complete List Of Commands Available To You.", true, CD->TYPE.c_str());
+                }
+            }
+            else
+            {
+                QueryResult result = WorldDatabase.PQuery("SELECT `Description`, `gmlevel` FROM `irc_commands` WHERE `Command` = '%s'", _PARAMS[0].c_str());
+                if (result)
+                {
+                    Field *fields = result->Fetch();
+                    if (fields[1].GetUInt32() > 0)
+                    {
+                        Send_IRCA(CD->USER, "You Do Not Have Access To That Command, So No Help Is Available.", true, CD->TYPE.c_str());
+                        return;
+                    }
+                    std::string cmdhlp = fields[0].GetString();
+
+                    Send_IRCA(CD->USER, cmdhlp, true, CD->TYPE.c_str());
+                }
+                else
+                    Send_IRCA(CD->USER, "No Such Command Exists, Please Check The Spelling And Try Again.", true, "ERROR");
+            }
+        }
+    }
+    else
+        Send_IRCA(CD->USER, "Database Error! Please Make Sure You Used irc_commands.sql, You Must Have A Table In Your World Database (irc_commands)!", true, "ERROR");
+}
+
+void IRCCmd::Inchan_Server(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 1);
+    if (_PARAMS[0] == "")
+    {
+        Send_IRCA(CD->USER, "Syntax Error! ("+sIRC->_cmd_prefx+"inchan <ChannelName>)", true, "ERROR");
+        return;
+    }
+    QueryResult result = WorldDatabase.PQuery("SELECT * FROM `irc_inchan` WHERE `channel` = '%s' ORDER BY `name`", _PARAMS[0].c_str());
+    if (result)
+    {
+        Field *fields = result->Fetch();
+        std::string output = "\0031Players In The \xF["+fields[2].GetString()+"] \0031Channel:\017 ";
+        for (uint64 i=0; i < result->GetRowCount(); i++)
+        {
+            output += fields[1].GetString() + ", ";
+            result->NextRow();
+        }
+
+        Send_IRCA(ChanOrPM(CD), output, true, CD->TYPE);
+    }
+    else
+        Send_IRCA(ChanOrPM(CD), "\0031No Players Are Currently In \xF["+_PARAMS[0]+"] \0031Channel!", true, CD->TYPE.c_str());
+}
+
+void IRCCmd::Info_Server(_CDATA *CD)
+{
+    char clientsNum [50];
+    sprintf(clientsNum, "%u", sWorld->GetActiveSessionCount());
+    char maxClientsNum [50];
+    sprintf(maxClientsNum, "%u", sWorld->GetMaxActiveSessionCount());
+    char ircupdt [50];
+    sprintf(ircupdt, "%u", sWorld->GetUpdateTime());
+    std::string str = secsToTimeString(sWorld->GetUptime());
+    std::string svnrev = GitRevision::GetFullVersion();
+
+    float rdm = (sConfigMgr->GetFloatDefault("Rate.Drop.Money", 1.0f));
+    float rxk = (sConfigMgr->GetFloatDefault("Rate.XP.Kill", 1.0f));
+    float rxq = (sConfigMgr->GetFloatDefault("Rate.XP.Quest", 1.0f));
+    Send_IRCA(ChanOrPM(CD), "\00310Number Of Players Online: \xF"+(std::string)clientsNum+" | \00310Max Since Last Restart: \xF"+(std::string)maxClientsNum+" |\00310 UpTime: \xF"+str, true, CD->TYPE);
+    Send_IRCA(ChanOrPM(CD), "\00310Server: \xF"+svnrev+" |\00310 Update Time: \xF"+(std::string)ircupdt, true, CD->TYPE);
+    Send_IRCA(ChanOrPM(CD), MakeMsg("\00310Server Rates - \xF[Monster XP: %u][Quest XP: %u][Money Drop Rate: %u]", int(rxk), int(rxq), int(rdm)), true, CD->TYPE);
+    Send_IRCA(ChanOrPM(CD), "\00310MotD: \xF"+(std::string)sWorld->GetMotd(), true, CD->TYPE);
+
+}
+
+void IRCCmd::Item_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 3);
+
+    normalizePlayerName(_PARAMS[0]);
+    Player *chr = GetPlayer(_PARAMS[0].c_str());
+    if (_PARAMS[1] == "add")
+    {
+        std::string s_param  = _PARAMS[2];
+
+        char *args = (char*)s_param.c_str();
+        uint32 itemId = 0;
+        if (args[0]=='[')
+        {
+            char* citemName = strtok((char*)args, "]");
+            if (citemName && citemName[0])
+            {
+                std::string itemName = citemName+1;
+                WorldDatabase.EscapeString(itemName);
+                QueryResult result = WorldDatabase.PQuery("SELECT entry FROM item_template WHERE name = '%s'", itemName.c_str());
+                if (!result)
+                {
+                    Send_IRCA(CD->USER, "Item Not Found!", true, "ERROR");
+                    return;
+                }
+                itemId = result->Fetch()->GetUInt16();
+
+            }
+            else
+            {
+                Send_IRCA(CD->USER, "Syntax Error! ("+sIRC->_cmd_prefx+"item <Player> <add> [Exact Item Name] <Amount>)", true, "ERROR");
+                return;
+            }
+        }
+        else
+        {
+            std::string itemName = s_param;
+            WorldDatabase.EscapeString(itemName);
+            QueryResult result = WorldDatabase.PQuery("SELECT entry FROM item_template WHERE name = '%s'", itemName.c_str());
+            if (result)
+            {
+                itemId = result->Fetch()->GetUInt16();
+            }
+
+
+            char* cId = strtok(args, " ");
+            if (!cId)
+            {
+                Send_IRCA(CD->USER, "Syntax Error! ("+sIRC->_cmd_prefx+"item <Player> <add> <ItemID> <Amount>)", true, "ERROR");
+                return;
+            }
+            itemId = atol(cId);
+        }
+            char* ccount = strtok(NULL, " ");
+            int32 count = 1;
+            if (ccount) { count = atol(ccount); }
+            Player* plTarget = chr;
+        if (!plTarget)
+        {
+            Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Not Online!", true, "ERROR");
+            return;
+        }
+        //Subtract
+        if (count < 0)
+        {
+            plTarget->DestroyItemCount(itemId, -count, true, false);
+            char itemid2[255];
+            sprintf(itemid2,"%d",itemId);
+            std::string itake = " \00313["+ _PARAMS[0] +"] :\0031Has Had Item \xF" +itemid2+ " \0031Taken From Them!";
+            Send_IRCA(ChanOrPM(CD), itake, true, CD->TYPE);
+            return;
+        }
+        //Adding items
+        uint32 noSpaceForCount = 0;
+
+        // check space and find places
+        ItemPosCountVec dest;
+        uint8 msg = plTarget->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, count, &noSpaceForCount);
+        if (msg == EQUIP_ERR_INVENTORY_FULL)                   // convert to possibel store amount
+            count -= noSpaceForCount;
+        else if (msg != EQUIP_ERR_OK)                          // other error, can't add
+        {
+            char s_countForStore[255];
+            sprintf(s_countForStore,"%d",count);
+            std::string ierror = " \00313["+ _PARAMS[0] +"] : Could Not Create All Items! " +s_countForStore+ " Item(s) Were Not Created!";
+            Send_IRCA(ChanOrPM(CD), ierror, true, CD->TYPE);
+            return;
+        }
+        Item* item = plTarget->StoreNewItem(dest, itemId, true, Item::GenerateItemRandomPropertyId(itemId));
+        if (count > 0 && item)
+        {
+                plTarget->SendNewItem(item,count,true,false);
+                QueryResult result = WorldDatabase.PQuery("SELECT name FROM item_template WHERE entry = %d", itemId);
+                char* dbitemname = NULL;
+                if (result)
+                {
+                    dbitemname = (char*)result->Fetch()->GetCString();
+                }
+                std::string iinfo = " \00313[" + _PARAMS[0] + "] : Has Been Given Item "+dbitemname+". From: "+CD->USER.c_str()+".";
+                Send_IRCA(ChanOrPM(CD), iinfo, true, CD->TYPE);
+
+        }
+        if (noSpaceForCount > 0)
+        {
+            char s_countForStore[255];
+            sprintf(s_countForStore,"%d",noSpaceForCount);
+            std::string ierror = " \00313["+ _PARAMS[0] +"] : Could Not Create All Items! " +s_countForStore+ " Item(s) Were Not Created!";
+            Send_IRCA(ChanOrPM(CD), ierror, true, CD->TYPE);
+            return;
+        }
+    }
+    else
+    {
+        Send_IRCA(CD->USER, "Syntax Error! ("+sIRC->_cmd_prefx+"item <Player> <add> <ItemID> <Amount>)", true, "ERROR");
+        return;
+    }
+}
+
+void IRCCmd::Jail_Player(_CDATA *CD)
+{
+    if (ValidParams(CD->PARAMS, 1))
+    {
+        std::string* _PARAMS = getArray(CD->PARAMS, 2);
+        if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC->BOTMASK & 512)!= 0)
+        {
+            Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+            return;
+        }
+        if (Player *plr = GetPlayer(_PARAMS[0]))
+        {
+            std::string sReason = "";
+            if (_PARAMS[1] == "release")
+            {
+                float rposx, rposy, rposz, rposo = 0;
+                uint32 rmapid = 0;
+                CharacterDatabase.EscapeString(_PARAMS[0]);
+                QueryResult result = CharacterDatabase.PQuery("SELECT `mapId`, `posX`, `posY`, `posZ` FROM `character_homebind` WHERE `guid` = '" UI64FMTD "'", plr->GetGUID());
+                if (result)
+                {
+                    Field *fields = result->Fetch();
+                    rmapid = fields[0].GetUInt16();
+                    rposx = fields[1].GetFloat();
+                    rposy = fields[2].GetFloat();
+                    rposz = fields[3].GetFloat();
+
+                    plr->SetMovement(MOVE_UNROOT);
+                    plr->TeleportTo(rmapid, rposx, rposy, rposz, rposo);
+                    plr->RemoveAurasDueToSpell(42201);
+                    plr->RemoveAurasDueToSpell(23775);
+                    plr->RemoveAurasDueToSpell(9454);
+                    Send_Player(plr, MakeMsg("You Have Been Released By: %s.", CD->USER.c_str()));
+                    sReason = " \00313["+_PARAMS[0]+"] : Has Been Released By: "+CD->USER+".";
+                    Send_IRCA(ChanOrPM(CD), sReason, true, CD->TYPE);
+                }
+            }
+            else
+            {
+                if (_PARAMS[1] == "")
+                    _PARAMS[1] = "No Reason Given.";
+                plr->TeleportTo(13, 0, 0, 0, 0);
+                plr->SetMovement(MOVE_ROOT);
+                plr->CastSpell(plr, 42201, true);
+                plr->CastSpell(plr, 23775, true);
+                plr->CastSpell(plr, 9454, true);
+                Send_Player(plr, MakeMsg("You Have Been Jailed By: %s. Reason: %s.", CD->USER.c_str(), _PARAMS[1].c_str()));
+                sReason = " \00313["+_PARAMS[0]+"] : Has Been Jailed By: "+CD->USER+". Reason: "+_PARAMS[1]+".";
+                Send_IRCA(ChanOrPM(CD), sReason, true, CD->TYPE);
+            }
+        }
+        else
+            Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Not Online!", true, "ERROR");
+    }
+}
+
+void IRCCmd::Kick_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC->BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    if (_PARAMS[1] == "")
+        _PARAMS[1] = "No Reason Given.";
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        plr->GetSession()->KickPlayer();
+        Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Been Kicked By: "+CD->USER+". Reason: "+_PARAMS[1]+".", true, CD->TYPE);
+        if (sWorld->getBoolConfig(CONFIG_SHOW_KICK_IN_WORLD))
+            sIRC->Send_WoW_System("Player|cffff0000 "+_PARAMS[0]+"|r kicked by|cffff0000 "+CD->USER+"|r. Reason:|cffff0000"+_PARAMS[1]+"|r.");
+    }
+    else
+        Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Not Online!", true, "ERROR");
+}
+
+void IRCCmd::Kill_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC->BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        if (plr->IsAlive())
+        {
+            plr->DealDamage(plr, plr->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+            plr->SaveToDB();
+            if (_PARAMS[1] == "")
+                _PARAMS[1] = "No Reason Given.";
+            Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Has Been Killed By: %s.", _PARAMS[0].c_str(), CD->USER.c_str()) +  +  + " Reason: "+_PARAMS[1]+".", true, CD->TYPE);
+            Send_Player(plr, MakeMsg("You Have Been Killed By: %s. Reason: %s.", CD->USER.c_str(), _PARAMS[1].c_str()));
+        }
+        else
+            Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Already Dead!", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Not Online!", true, "ERROR");
+}
+
+void IRCCmd::Player_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    uint32 plguid = atoi(_PARAMS[0].c_str());
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC->BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    if (sObjectMgr->GetPlayerGUIDByName(_PARAMS[0].c_str()))
+        plguid = sObjectMgr->GetPlayerGUIDByName(_PARAMS[0].c_str());
+    if (plguid > 0)
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT guid, account, name, race, class, online, level,  xp, money, totalHonorPoints, totaltime FROM characters WHERE guid =%i", plguid);
+        uint32 latency = 0;
+        ObjectGuid plguidnew = ObjectGuid(HighGuid::Player, plguid);
+        Player *chr = ObjectAccessor::FindPlayer(plguidnew);
+        if (chr)
+        {
+            latency = chr->GetSession()->GetLatency();
+        }
+        char templatency [100];
+        sprintf(templatency, "%ums", latency);
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            std::string pguid = fields[0].GetString();
+            std::string pacct = fields[1].GetString();
+            std::string pname = fields[2].GetString();
+            uint32 praceid = fields[3].GetUInt32();
+            uint32 pclassid = fields[4].GetUInt32();
+            std::string ponline = (fields[5].GetInt32() == 1 ? "\x3\x30\x33Online" : "\x3\x30\x34Offline\xF");
+            std::string plevel = fields[6].GetString();
+            std::string pxp = fields[7].GetString();
+            unsigned int money = fields[8].GetInt32();
+            std::string honor = fields[9].GetString();
+            std::string totaltim = SecToDay(fields[10].GetString());
+
+            std::string sqlquery = "SELECT `gmlevel` FROM `account_access` WHERE `id` = '" + pacct + "';";
+            QueryResult gmresult = LoginDatabase.Query(sqlquery.c_str());
+            std::string pgmlvl = "0";
+            if (gmresult)
+            {
+                Field *fields2 = gmresult->Fetch();
+                pgmlvl = fields2[0].GetString();
+            }
+
+            if (uint32(atoi(plevel.c_str())) < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+                plevel += " (" + pxp + ")";
+            unsigned int gold = money / 10000;
+            unsigned int silv = (money % 10000) / 100;
+            unsigned int cop = (money % 10000) % 100;
+            char tempgold [100];
+            sprintf(tempgold, "\x2\x3\x30\x37%ug \x3\x31\x34%us \x3\x30\x35%uc\xF", gold, silv, cop);
+            if (ponline == "\x3\x30\x33Online")
+            {
+                Player * plr = ObjectAccessor::FindPlayerByName(pname.c_str());
+                if (plr)
+                {
+                    AreaTableEntry const* area = GetAreaEntryByAreaID(plr->GetAreaId());
+                    ponline += " in " + (std::string) area->area_name[sWorld->GetDefaultDbcLocale()];
+                    if (area->zone != 0)
+                    {
+                        AreaTableEntry const* zone = GetAreaEntryByAreaID(area->zone);
+                        ponline += " (" + (std::string)zone->area_name[sWorld->GetDefaultDbcLocale()] + ")";
+                    }
+                }
+            }
+            std::string pinfo  = "\00310About Player: \xF"+pname+" |\00310 GM Level: \xF"+pgmlvl+" |\00310 AcctID: \xF"+pacct+" |\00310 CharID: \xF"+pguid+" |\00310 Played Time: \xF"+totaltim.c_str()+" |\00310 Latency: \xF"+templatency;
+            std::string pinfo2 = "\00310Race: \xF"+(std::string)GetRaceName(praceid, 0)+" |\00310 Class: \xF" + (std::string)GetClassName(pclassid, 0)+" |\00310 Level: \xF"+plevel+" |\00310 Money: \xF"+tempgold+"|\00310 Status: \xF"+ponline+" |\00310 Honor: \xF"+honor;
+            // pinfo3 = " :" + " \x2Honor Kills:\x2\x3\x31\x30 " + hk;
+            Send_IRCA(ChanOrPM(CD),pinfo , true, CD->TYPE);
+            Send_IRCA(ChanOrPM(CD),pinfo2 , true, CD->TYPE);
+            // Send_IRCA(ChanOrPM(CD),pinfo3 , true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "Unknown Character ID. (GUID)" ,true, "ERROR");
+    }
+    else
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT guid, account, name FROM characters WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[0].c_str());
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            std::string items = "\x2 Character Search Results:\x3\x31\x30 ";
+            for (uint64 i=0; i < result->GetRowCount(); i++)
+            {
+                std::string guid = fields[0].GetString();
+                std::string account = fields[1].GetString();
+                std::string name = fields[2].GetString();
+                MakeUpper(name);
+                items.append(name+"(Account:"+account+" - GUID:"+guid+")\0031 | \xF");
+                result->NextRow();
+            }
+
+            Send_IRCA(ChanOrPM(CD), items, true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "Unknown Character. I Cant Find Any Characters With Those Search Terms." ,true, "ERROR");
+    }
+
+}
+
+void IRCCmd::Lookup_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (_PARAMS[0] == "acct")
+    {
+        uint32 acctid = atoi(_PARAMS[1].c_str());
+        if (AccountMgr::GetId(_PARAMS[1]))
+            acctid = AccountMgr::GetId(_PARAMS[1]);
+        if (acctid > 0)
+        {
+            std::string DateTime = "%a, %b %d, %Y - %h:%i%p";
+            QueryResult result = LoginDatabase.PQuery("SELECT `account`.`id`, username, last_ip, (SELECT banreason FROM account_banned WHERE `account`.`id` = id LIMIT 1) as banned, (SELECT banreason FROM ip_banned WHERE ip = last_ip) as bannedip,(SELECT active FROM account_banned WHERE `account`.`id` = id) as banactive, (SELECT( unbandate - unix_timestamp( now() ) ) FROM account_banned WHERE `account`.`id` = id) as remainingtime, DATE_FORMAT(last_login, '%s') FROM `account` WHERE `account`.`id` =%d" ,DateTime.c_str(), acctid);
+            if (result)
+            {
+                Field *fields = result->Fetch();
+
+                uint32 id = fields[0].GetUInt32();
+                std::string usrname = fields[1].GetString();
+                std::string lastip = fields[2].GetString();
+                std::string banreason = fields[3].GetString();
+                std::string banreasonip = fields[4].GetString();
+                uint32 banactive = (fields[5].GetInt32() == 1 ? 1 : 0);
+                std::string TimeLeft = SecToDay(fields[6].GetString());
+                std::string lastlogin = fields[7].GetString();
+
+                QueryResult chars = CharacterDatabase.PQuery("SELECT guid, name, (SELECT SUM(totaltime) FROM characters WHERE account = %d) AS tottime FROM characters WHERE account = %u", id, id);
+                std::string characters = "None";
+                std::string totaccttime = "Never Logged In";
+                if (chars)
+                {
+                    characters = "";
+                    Field *fields = chars->Fetch();
+                    totaccttime = SecToDay(fields[2].GetString());
+                    for (uint64 i=0; i < chars->GetRowCount(); i++)
+                    {
+                        std::string guid = fields[0].GetString();
+                        std::string charname = fields[1].GetString();
+                       characters.append(charname+"("+guid+"), ");
+                        chars->NextRow();
+                    }
+
+                }
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\00310Username: \xF %s | \00310AccountID: \xF %d | \00310Last IP: \xF %s | \00310Last Login: \xF %s", usrname.c_str(), id, lastip.c_str(), lastlogin.c_str()), true, CD->TYPE);
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\00310Total play time: \xF %s | \00310Characters:  \xF %s ", totaccttime.c_str(), characters.c_str()), true, CD->TYPE);
+                if (banreason.length() > 1)
+                    Send_IRCA(ChanOrPM(CD), MakeMsg("\0035Account banned : \xF %s | \0035Ban Active: \xF %u | \0035Ban Time: \xF %s", banreason.c_str(), banactive, TimeLeft.c_str()), true, CD->TYPE);
+                if (banreasonip.length() > 1)
+                    Send_IRCA(ChanOrPM(CD), MakeMsg("\0034This User Has An IP Ban. Ban Reason: %s", banreasonip.c_str()), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Account ID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult result = LoginDatabase.PQuery("SELECT id, username FROM `account` WHERE username LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string accts = "\002Account Search Results:\x3\x31\x30 ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string acctid = fields[0].GetString();
+                    std::string acctname = fields[1].GetString();
+                    accts.append(acctname+"("+acctid+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+
+                Send_IRCA(ChanOrPM(CD), accts, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Username. I Cant Find Any Users With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "char")
+    {
+        uint32 plguid = atoi(_PARAMS[1].c_str());
+        if (sObjectMgr->GetPlayerGUIDByName(_PARAMS[1].c_str()))
+            plguid = sObjectMgr->GetPlayerGUIDByName(_PARAMS[1].c_str());
+        if (plguid > 0)
+        {
+            QueryResult result = CharacterDatabase.PQuery("SELECT guid, account, name, race, class, online, SUBSTRING_INDEX(SUBSTRING_INDEX(`level`, ' ' , 35), ' ' , -1) AS level,  SUBSTRING_INDEX(SUBSTRING_INDEX(`xp`, ' ' , 927), ' ' , -1) AS xp, SUBSTRING_INDEX(SUBSTRING_INDEX(money, ' ' , 1462), ' ' , -1) AS gold, SUBSTRING_INDEX(SUBSTRING_INDEX(`totalHonorPoints`, ' ' , 1454), ' ' , -1) AS Honor, totaltime FROM characters WHERE guid =%i", plguid);
+            uint32 latency = 0;
+            ObjectGuid plguidnew = ObjectGuid(HighGuid::Player, plguid);
+            Player *chr = ObjectAccessor::FindPlayer(plguidnew);
+            if (chr)
+            {
+                latency = chr->GetSession()->GetLatency();
+            }
+            char templatency [100];
+            sprintf(templatency, "%ums", latency);
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string pguid = fields[0].GetString();
+                std::string pacct = fields[1].GetString();
+                std::string pname = fields[2].GetString();
+                uint32 praceid = fields[3].GetUInt32();
+                uint32 pclassid = fields[4].GetUInt32();
+                std::string ponline = (fields[5].GetInt32() == 1 ? "\x3\x30\x33Online" : "\x3\x30\x34Offline\xF");
+                std::string plevel = fields[6].GetString();
+                std::string pxp = fields[7].GetString();
+                unsigned int money = fields[8].GetInt32();
+                std::string honor = fields[9].GetString();
+                std::string totaltim = SecToDay(fields[10].GetString());
+
+                std::string sqlquery = "SELECT `gmlevel` FROM `account_access` WHERE `id` = '" + pacct + "';";
+                QueryResult gmresult = LoginDatabase.Query(sqlquery.c_str());
+                std::string pgmlvl = "0";
+                if (gmresult)
+                {
+                    Field *fields = result->Fetch();
+                    pgmlvl = fields[0].GetString();
+                }
+
+                ChrRacesEntry const* prace = sChrRacesStore.LookupEntry(praceid);
+                ChrClassesEntry const* pclass = sChrClassesStore.LookupEntry(pclassid);
+
+                if (uint32(atoi(plevel.c_str())) < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+                    plevel += " (" + pxp + ")";
+                unsigned int gold = money / 10000;
+                unsigned int silv = (money % 10000) / 100;
+                unsigned int cop = (money % 10000) % 100;
+                char tempgold [100];
+                sprintf(tempgold, "\x2\x3\x30\x37%ug \x3\x31\x34%us \x3\x30\x35%uc\xF", gold, silv, cop);
+                if (ponline == "\x3\x30\x33Online")
+                {
+                    Player * plr = ObjectAccessor::FindPlayerByName(pname.c_str());
+                    if (plr)
+                    {
+                        AreaTableEntry const* area = GetAreaEntryByAreaID(plr->GetAreaId());
+                        ponline += " in " + (std::string) area->area_name[sWorld->GetDefaultDbcLocale()];
+                        if (area->zone != 0)
+                        {
+                            AreaTableEntry const* zone = GetAreaEntryByAreaID(area->zone);
+                            ponline += " (" + (std::string)zone->area_name[sWorld->GetDefaultDbcLocale()] + ")";
+                        }
+                    }
+                }
+                std::string pinfo  = "\x2 About Player:\x3\x31\x30 " +pname+ "\xF |\x2 GM Level:\x3\x31\x30 " +pgmlvl+ "\xF |\x2 AcctID:\x3\x31\x30 " +pacct+ "\xF |\x2 CharID:\x3\x31\x30 " +pguid+ " \xF |\x2 Played Time:\x2\x3\x31\x30 " +totaltim.c_str()+" \xF |\x2 Latency:\x2\x3\x31\x30 "+templatency;
+                std::string pinfo2 = "\x2 Race:\x2\x3\x31\x30 " + (std::string)prace->name[sWorld->GetDefaultDbcLocale()] + "\xF |\x2 Class:\x2\x3\x31\x30 " + (std::string)pclass->name[sWorld->GetDefaultDbcLocale()] + "\xF |\x2 Level:\x2\x3\x31\x30 " + plevel + "\xF |\x2 Money:\x2 " + tempgold + "\xF |\x2 Status:\x2 " + ponline;
+                // pinfo3 = " :" + " \x2Honor Kills:\x2\x3\x31\x30 " + hk;
+                Send_IRCA(ChanOrPM(CD),pinfo , true, CD->TYPE);
+                Send_IRCA(ChanOrPM(CD),pinfo2 , true, CD->TYPE);
+                // Send_IRCA(ChanOrPM(CD),pinfo3 , true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Character ID. (GUID)" ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult result = CharacterDatabase.PQuery("SELECT guid, account, name FROM characters WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string items = "\x2 Character Search Results:\x3\x31\x30 ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string guid = fields[0].GetString();
+                    std::string account = fields[1].GetString();
+                    std::string name = fields[2].GetString();
+                    MakeUpper(name);
+                    items.append(name+"(Account:"+account+" - GUID:"+guid+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+
+                Send_IRCA(ChanOrPM(CD), items, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Character. I Cant Find Any Characters With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "creature")
+    {
+        std::string creature = _PARAMS[1];
+        if (atoi(creature.c_str()) > 0)
+        {
+            WorldDatabase.EscapeString(_PARAMS[1]);
+            QueryResult result = WorldDatabase.PQuery("SELECT entry, name, minlevel,maxlevel, faction_A,  (SELECT count(guid) FROM creature WHERE id = '%s') as spawns FROM creature_template WHERE entry = '%s';", _PARAMS[1].c_str(), _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+
+                uint32 entry = fields[0].GetUInt32();
+                std::string name = fields[1].GetString();
+                uint32 minlevel = fields[2].GetUInt32();
+                uint32 maxlevel = fields[3].GetUInt32();
+                uint32 faction = fields[4].GetUInt32();
+                uint32 spawns = fields[5].GetUInt32();
+
+
+               Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Name:\x3\x31\x30 %s \xF|\x2 CreatureID:\x3\x31\x30 %d", name.c_str(), entry), true, CD->TYPE);
+               Send_IRCA(ChanOrPM(CD), MakeMsg("\x2minlevel:\x3\x31\x30 %d \xF|\x2 maxlevel:\x3\x31\x30 %d \xF|\x2 Faction:\x3\x31\x30 %d \xF|\x2 Spawns:\x3\x31\x30 %d", minlevel, maxlevel, faction, spawns), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Creature ID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult result = WorldDatabase.PQuery("SELECT entry, name FROM creature_template WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string items = "\002Creature Search Results:\x3\x31\x30 ";
+                //Send_IRCA(ChanOrPM(CD), "", true, CD->TYPE);
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string CreatureID = fields[0].GetString();
+                    std::string Name = fields[1].GetString();
+                    items.append(Name+"("+CreatureID+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+
+                Send_IRCA(ChanOrPM(CD), items, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Creature. I Cant Find Any Creatures With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "faction")
+    {
+        std::string faction = _PARAMS[1];
+        if (atoi(faction.c_str()) > 0)
+        {
+            FactionEntry const *factionEntry = sFactionStore.LookupEntry(atoi(faction.c_str()));
+            if (factionEntry)
+            {
+                std::string name = factionEntry->name[sWorld->GetDefaultDbcLocale()];
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2 Faction:\x3\x31\x30 %s \xF|\x2 FactionID:\x3\x31\x30 %s",name.c_str(), faction.c_str()), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown FactionID." ,true, "ERROR");
+
+        }
+        else
+        {
+            uint32 counter = 0;
+            std::string factions = "\002Faction Search Results:\x3\x31\x30 ";
+            for (uint32 id = 0; id < sFactionStore.GetNumRows(); id++)
+            {
+                FactionEntry const *factionEntry = sFactionStore.LookupEntry(id);
+                if (factionEntry)
+                {
+                    MakeLower(_PARAMS[1]);
+                    std::string name = factionEntry->name[sWorld->GetDefaultDbcLocale()];
+                    MakeLower(name);
+                    if (name.find(_PARAMS[1]) != std::string::npos && counter < 10)
+                    {
+                        char factionid[100];
+                        sprintf(factionid, "%d", id);
+                        factions.append(name+"("+factionid+")\xF | \x3\x31\x30\x2");
+                        ++counter;
+                    }
+                }
+            }
+            if (counter == 0)
+                factions.append("No Factions Found.");
+            Send_IRCA(ChanOrPM(CD), factions, true, CD->TYPE);
+        }
+    }
+    if (_PARAMS[0] == "go")
+    {
+        std::string gobject = _PARAMS[1];
+        if (atoi(gobject.c_str()) > 0)
+        {
+            WorldDatabase.EscapeString(_PARAMS[1]);
+            QueryResult result = WorldDatabase.PQuery("SELECT entry, type, displayId, name, faction, (SELECT count(*) FROM gameobject WHERE id = '%s') as spawns FROM gameobject_template WHERE entry = '%s';", _PARAMS[1].c_str(), _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+
+                uint32 entry = fields[0].GetUInt32();
+                uint32 type = fields[1].GetUInt32();
+                uint32 modelid = fields[2].GetUInt32();
+                std::string name = fields[3].GetString();
+                uint32 faction = fields[4].GetUInt32();
+                uint32 spawns = fields[5].GetUInt32();
+
+
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2GO Name:\x3\x31\x30 %s \xF|\x2 GameobjectID:\x3\x31\x30 %d \xF|\x2 DisplayID:\x3\x31\x30 %d \xF|\x2 Spawns:\x3\x31\x30 %d", name.c_str(), entry, modelid, spawns), true, CD->TYPE);
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Type:\x3\x31\x30 %d \xF|\x2 Faction:\x3\x31\x30 %d", type, faction), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown GameObject ID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult result = WorldDatabase.PQuery("SELECT entry, name FROM gameobject_template WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string gos = "\002Gameobject Search Results:\x3\x31\x30 ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string GOID = fields[0].GetString();
+                    std::string GoName = fields[1].GetString();
+                    gos.append(GoName+"("+GOID+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+
+                Send_IRCA(ChanOrPM(CD), gos, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Game Object. I Cant Find Any Game Object's With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "item")
+    {
+        std::string item = _PARAMS[1];
+        if (atoi(item.c_str()) > 0)
+        {
+            QueryResult result = WorldDatabase.PQuery("SELECT entry, name, displayid, (SELECT count(*) FROM creature_loot_template WHERE item = '%s') as loot FROM `item_template` WHERE entry = %s", _PARAMS[1].c_str(), _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                QueryResult result2 = CharacterDatabase.PQuery("SELECT count(*) FROM `character_inventory` WHERE item_template = %s", _PARAMS[1].c_str());
+                Field *fields2 = result2->Fetch();
+                uint32 charcnt = fields2[0].GetUInt32();
+
+
+                uint32 ItemID = fields[0].GetUInt32();
+                std::string ItmName = fields[1].GetString();
+                uint32 DisplayID = fields[2].GetUInt32();
+                uint32 loots = 0;
+                loots = fields[3].GetUInt32();
+
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Item:\x3\x31\x30 %s \xF|\x2 ItemID:\x3\x31\x30 %d \xF|\x2 DisplayID:\x3\x31\x30 %d \xF|\x2 Owned By:\x3\x31\x30 %d players \xF|\x2 Dropped By:\x3\x31\x30 %d creatures", ItmName.c_str(), ItemID, DisplayID, charcnt, loots), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown ItemID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult result = WorldDatabase.PQuery("SELECT entry, name FROM `item_template` WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string items = "\002Item Search Results:\x3\x31\x30 ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string ItemID = fields[0].GetString();
+                    std::string ItemName = fields[1].GetString();
+                    items.append(ItemName+"("+ItemID+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+
+                Send_IRCA(ChanOrPM(CD), items, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Item. I Cant Find Any Items With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "quest")
+    {
+        std::string quest = _PARAMS[1];
+        if (atoi(quest.c_str()) > 0)
+        {
+            WorldDatabase.EscapeString(_PARAMS[1]);
+            QueryResult result = WorldDatabase.PQuery("SELECT id, Title FROM quest_template WHERE id = '%s';", _PARAMS[1].c_str(), _PARAMS[1].c_str());
+            if (result)
+            {
+                QueryResult result2 = CharacterDatabase.PQuery("SELECT count(*) FROM character_queststatus WHERE quest = '%s' AND status = '1';", _PARAMS[1].c_str());
+                Field *fields2 = result2->Fetch();
+                uint32 status = fields2[0].GetUInt32();
+
+
+                Field *fields = result->Fetch();
+                uint32 entry = fields[0].GetUInt32();
+                std::string name = fields[1].GetString();
+
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Quest Name:\x3\x31\x30 %s \xF|\x2 QuestID:\x3\x31\x30 %d \xF|\x2 Completed:\x3\x31\x30 %d times", name.c_str(), entry, status), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Quest ID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult result = WorldDatabase.PQuery("SELECT id, Title FROM quest_template WHERE Title LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string quests = "\002Quest Search Results:\x3\x31\x30 ";
+                //Send_IRCA(ChanOrPM(CD), "", true, CD->TYPE);
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string QuestID = fields[0].GetString();
+                    std::string QuestName = fields[1].GetString();
+                    quests.append(QuestName+"("+QuestID+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+
+                Send_IRCA(ChanOrPM(CD), quests, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Quest. I Cant Find Any Quest's With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "skill")
+    {
+        std::string skill = _PARAMS[1];
+        if (atoi(skill.c_str()) > 0)
+        {
+            SkillLineEntry const *skillInfo = sSkillLineStore.LookupEntry(atoi(skill.c_str()));
+            if (skillInfo)
+            {
+                std::string name = skillInfo->name[sWorld->GetDefaultDbcLocale()];
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Skill:\x3\x31\x30 %s \xF|\x2 SkillID:\x3\x31\x30 %s",name.c_str(), skill.c_str()), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown SkillID." ,true, "ERROR");
+
+        }
+        else
+        {
+            uint32 counter = 0;
+            std::string skills = "\002Skill Search Results:\x3\x31\x30 ";
+            for (uint32 id = 0; id < sSkillLineStore.GetNumRows(); id++)
+            {
+                SkillLineEntry const *skillInfo = sSkillLineStore.LookupEntry(id);
+                if (skillInfo)
+                {
+                    MakeLower(_PARAMS[1]);
+                    std::string name = skillInfo->name[sWorld->GetDefaultDbcLocale()];
+                    MakeLower(name);
+                    if (name.find(_PARAMS[1]) != std::string::npos && counter < 10)
+                    {
+                        char skillid[100];
+                        sprintf(skillid, "%d", id);
+                        skills.append(name+"("+skillid+")\xF | \x3\x31\x30\x2");
+                        ++counter;
+                    }
+                }
+            }
+            if (counter == 0)
+                skills.append("No Skills Found.");
+            Send_IRCA(ChanOrPM(CD), skills, true, CD->TYPE);
+        }
+    }
+    if (_PARAMS[0] == "spell")
+    {
+        std::string spell = _PARAMS[1];
+        if (atoi(spell.c_str()) > 0)
+        {
+            SpellEntry const *spellInfo = sSpellStore.LookupEntry(atoi(spell.c_str()));
+            if (spellInfo)
+            {
+                std::string name = spellInfo->SpellName[sWorld->GetDefaultDbcLocale()];
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Spell:\x3\x31\x30 %s \xF|\x2 SpellID:\x3\x31\x30 %s",name.c_str(), spell.c_str()), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown SpellID." ,true, "ERROR");
+
+        }
+        else
+        {
+            uint32 counter = 0;
+            std::string spells = "\002Spell Search Results:\x3\x31\x30 ";
+            for (uint32 id = 0; id < sSpellStore.GetNumRows(); id++)
+            {
+                SpellEntry const *spellInfo = sSpellStore.LookupEntry(id);
+                if (spellInfo)
+                {
+                    MakeLower(_PARAMS[1]);
+                    std::string name = spellInfo->SpellName[sWorld->GetDefaultDbcLocale()];
+                    MakeLower(name);
+                    if (name.find(_PARAMS[1]) != std::string::npos && counter < 10)
+                    {
+                        char itemid[100];
+                        sprintf(itemid, "%d", id);
+                        spells.append(name+"("+itemid+")\xF | \x3\x31\x30\x2");
+                        ++counter;
+                    }
+                }
+            }
+            if (counter == 0)
+                spells.append("No Spells Found.");
+            Send_IRCA(ChanOrPM(CD), spells, true, CD->TYPE);
+        }
+    }
+    if (_PARAMS[0] == "tele")
+    {
+        std::string tele = _PARAMS[1];
+        if (atoi(tele.c_str()) > 0)
+        {
+            QueryResult result = WorldDatabase.PQuery("SELECT * FROM `game_tele` WHERE id = %s", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+
+                uint32 teleid = fields[0].GetUInt32();
+                uint32 pos_x = fields[1].GetUInt32();
+                uint32 pos_y = fields[2].GetUInt32();
+                uint32 pos_z = fields[3].GetUInt32();
+                uint32 oriet = fields[4].GetUInt32();
+                uint32 map = fields[5].GetUInt32();
+                std::string telname = fields[6].GetString();
+
+
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Tele Name:\x3\x31\x30 %s \xF|\x2 TeleID:\x3\x31\x30 %d \xF|\x2 Coordinates:\x3\x31\x30 [X: %d, Y: %d, Z: %d, MAP: %d, Orientation: %d]", telname.c_str(), teleid, pos_x, pos_y, pos_z, map, oriet), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Teleport Location ID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult result = WorldDatabase.PQuery("SELECT id, name FROM `game_tele` WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string teles = "\002Tele Location Search Results:\x3\x31\x30 ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string TeleID = fields[0].GetString();
+                    std::string TeleName = fields[1].GetString();
+                    teles.append(TeleName+"("+TeleID+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+                Send_IRCA(ChanOrPM(CD), teles, true, CD->TYPE);
+
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Item. I Cant Find Any Items With Those Search Terms." ,true, "ERROR");
+        }
+    }
+}
+
+void IRCCmd::Level_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC->BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    std::string player  = _PARAMS[0];
+    normalizePlayerName(player);
+    ObjectGuid guid = sObjectMgr->GetPlayerGUIDByName(player.c_str());
+    std::string s_newlevel  = _PARAMS[1];
+    uint8 i_newlvl = atoi(s_newlevel.c_str());
+    if (!guid)
+    {
+        Send_IRCA(CD->USER, "Player Not Found!", true, "ERROR");
+        return;
+    } else if (i_newlvl < 1 || i_newlvl > sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+    {
+        Send_IRCA(CD->USER, MakeMsg("Level Must Be Between 1 And %i!",sConfigMgr->GetIntDefault("MaxPlayerLevel", 80)), true, "ERROR");
+        return;
+    } else
+    {
+        Player *chr = ObjectAccessor::FindPlayer(guid);
+        ObjectGuid level = ObjectGuid::Empty;
+        int32 i_oldlvl = chr ? chr->getLevel() : Player::GetLevelFromDB(level);
+
+        if (chr)
+        {
+            chr->GiveLevel(i_newlvl);
+            chr->InitTalentForLevel();
+            chr->SetUInt32Value(PLAYER_XP,0);
+            WorldPacket data;
+            std::stringstream ss;
+            ChatHandler CH(chr->GetSession());
+            if (i_oldlvl == i_newlvl)
+                //CH.FillSystemMessageData(&data, "Your level progress has been reset.");
+                CH.BuildChatPacket(data, CHAT_MSG_SYSTEM, LANG_UNIVERSAL, NULL, NULL, "Your level progress has been reset.");
+            else
+            if (i_oldlvl < i_newlvl)
+            {
+                          ss << "You have been leveled up" << i_newlvl-i_oldlvl;
+                          //CH.FillSystemMessageData(&data, ss.str().c_str());
+                          CH.BuildChatPacket(data, CHAT_MSG_SYSTEM, LANG_UNIVERSAL, NULL, NULL, ss.str().c_str());
+                        }
+            else if (i_oldlvl > i_newlvl)
+                        {
+                         ss << "You have been leveled down" << i_newlvl-i_oldlvl;
+                         //CH.FillSystemMessageData(&data, ss.str().c_str());
+                         CH.BuildChatPacket(data, CHAT_MSG_SYSTEM, LANG_UNIVERSAL, NULL, NULL, ss.str().c_str());
+                         chr->GetSession()->SendPacket(&data);
+                        }
+        }
+        else
+        {
+            Send_IRCA(CD->USER, "" + _PARAMS[0] + " Is Not Online! Setting new level in DB.", true, "ERROR");
+            CharacterDatabase.PExecute("UPDATE characters SET level = '%u', xp = 0 WHERE guid = '%u'", i_newlvl, guid);
+        }
+    }
+    Send_IRCA(ChanOrPM(CD), "\00313[" + _PARAMS[0]+ "] : Has Been Leveled To " + _PARAMS[1] + ". By: "+CD->USER+".", true, CD->TYPE);
+}
+
+void IRCCmd::Money_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 2);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC->BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    std::string player  = _PARAMS[0];
+    normalizePlayerName(player);
+    ObjectGuid guid = sObjectMgr->GetPlayerGUIDByName(player.c_str());
+
+    std::string s_money  = _PARAMS[1];
+    int32 money = atoi(s_money.c_str());
+    unsigned int gold = money / 10000;
+    unsigned int silv = (money % 10000) / 100;
+    unsigned int cop = (money % 10000) % 100;
+    char tempgold [100];
+    sprintf(tempgold, "\x2\x3\x30\x37%ug \x3\x31\x34%us \x3\x30\x35%uc\xF", gold, silv, cop);
+    if (!guid)
+    {
+        Send_IRCA(CD->USER, "Player Not Found!", true, "ERROR");
+        return;
+    }
+    else
+    {
+        Player *chr = ObjectAccessor::FindPlayer(guid);
+        uint32 moneyuser = 0;
+        if (chr)
+            moneyuser = chr->GetMoney();
+        else {
+        CharacterDatabase.EscapeString(player);
+        std::string sqlquery = "SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(money, ' ' , 1462), ' ' , -1) AS `gold` FROM `characters` WHERE `name` = '"+player+"';";
+        QueryResult result = CharacterDatabase.Query(sqlquery.c_str());
+            Field *fields = result->Fetch();
+            moneyuser = fields[0].GetInt32();
+
+        }
+            int32 addmoney = money;
+            int32 newmoney = moneyuser + addmoney;
+            char s_newmoney[255];
+            sprintf(s_newmoney,"%d",newmoney);
+            if (addmoney < 0)
+            {
+                TC_LOG_ERROR("misc", "USER1: %i, ADD: %i, DIF: %i\\n", moneyuser, addmoney, newmoney);
+                if (newmoney <= 0)
+                {
+                    Send_IRCA(ChanOrPM(CD), "\00313["+player+"] : Has Had All Money Taken By: "+CD->USER.c_str()+".", true, CD->TYPE);
+                    if (chr)
+                    {
+                        chr->SetMoney(0);
+                        Send_Player(chr, MakeMsg("You Have Been Liquidated By: %s. Total Money Is Now 0.", CD->USER.c_str()));
+                    }
+                    else
+                        CharacterDatabase.PExecute("UPDATE `characters` SET money=concat(substring_index(name,' ',1462-1),' ','%u',' ', right(name,length(name)-length(substring_index(name,' ',1462))-1)) where guid='%u'",newmoney, guid);
+                }
+                else
+                {
+                    Send_IRCA(ChanOrPM(CD), "\00313["+player+"] : Has Had ("+s_money+"\00313) Taken From Them By: "+CD->USER.c_str()+".", true, CD->TYPE);
+                    if (chr)
+                    {
+                        chr->SetMoney(newmoney);
+                        Send_Player(chr, MakeMsg("You Have Had %s Copper Taken From You By: %s.", _PARAMS[1].c_str(), CD->USER.c_str()));
+                    }
+                    else
+                        CharacterDatabase.PExecute("UPDATE `characters` SET money=concat(substring_index(name,' ',1462-1),' ','%u',' ', right(name,length(name)-length(substring_index(name,' ',1462))-1)) where guid='%u'",newmoney, guid);
+                }
+            }
+            else
+            {
+                Send_IRCA(ChanOrPM(CD), "\00313["+player+"] : Has Been Given ("+tempgold+"\00313) From: "+CD->USER.c_str()+".", true, CD->TYPE);
+                if (chr)
+                {
+                    chr->ModifyMoney(addmoney);
+                    Send_Player(chr, MakeMsg("You Have Been Given %s Copper. From: %s.", _PARAMS[1].c_str(), CD->USER.c_str()));
+                }
+                else
+                    CharacterDatabase.PExecute("UPDATE `characters` SET money=concat(substring_index(name,' ',1462-1),' ','%u',' ', right(name,length(name)-length(substring_index(name,' ',1462))-1)) where guid='%u'",newmoney, guid);
+            }
+    }
+}
+
+void IRCCmd::Mute_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 3);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC->BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    normalizePlayerName(_PARAMS[0]);
+    ObjectGuid guid = sObjectMgr->GetPlayerGUIDByName(_PARAMS[0]);
+    if (guid)
+    {
+        if (_PARAMS[1] == "release")
+        {
+            Player* plr = ObjectAccessor::FindPlayer(guid);
+            uint32 account_id = 0;
+            account_id = sObjectMgr->GetPlayerAccountIdByGUID(guid);
+            LoginDatabase.PExecute("UPDATE `account` SET `mutetime` = '0', `mutereason` = '', `muteby` = '' WHERE `id` = '%d'",account_id);
+            Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Been UnMuted By: "+CD->USER+"." , true, CD->TYPE);
+            if (plr)
+            {
+                plr->GetSession()->m_muteTime = 0;
+                Send_Player(plr, MakeMsg("You Have Been UnMuted By: %s.", CD->USER.c_str()));
+            }
+        }
+        else
+        {
+            if (_PARAMS[2] == "")
+                _PARAMS[2] = "No Reason Given";
+            Player* plr = ObjectAccessor::FindPlayer(guid);
+            time_t mutetime = time(NULL) + atoi(_PARAMS[1].c_str())*60;
+            std::string By = "IRC:";
+            By += CD->USER.c_str();
+            uint32 account_id = 0;
+            account_id = sObjectMgr->GetPlayerAccountIdByGUID(guid);
+            if (plr)
+                plr->GetSession()->m_muteTime = mutetime;
+            PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_UPD_MUTE_TIME);
+            stmt->setInt64(0, mutetime);
+            stmt->setString(1, _PARAMS[2].c_str());
+            stmt->setString(2, By.c_str());
+            stmt->setUInt32(3, account_id);
+            LoginDatabase.Execute(stmt);
+            Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Been Muted By: "+CD->USER+". For: "+_PARAMS[1]+" Minutes. Reason: "+_PARAMS[2] , true, CD->TYPE);
+            if (plr)
+                Send_Player(plr, MakeMsg("You Have Been Muted By: %s. For: %s Minutes. Reason: %s", CD->USER.c_str(), _PARAMS[1].c_str(), _PARAMS[2].c_str()));
+        }
+    }
+    else
+        Send_IRCA(CD->USER, "Player Does Not Exist!", true, "ERROR");
+}
+
+void IRCCmd::Online_Players(_CDATA *CD)
+{
+        sIRC->Script_Lock[MCS_Players_Online] = true;
+        boost::thread script([CD](){
+            mcs_OnlinePlayers mcs(CD);
+            mcs.run();
+        });
+}
+
+void IRCCmd::PM_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 2);
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        if (plr->isAcceptWhispers())
+        {
+            std::string sMsg = MakeMsg("|cffFE87FD[<IRC>%s] Whispers: %s|r", CD->USER.c_str(), _PARAMS[1].c_str());
+            WorldPacket data(SMSG_MESSAGECHAT, 200);
+            data << (uint8)CHAT_MSG_SYSTEM;
+            data << (uint32)LANG_UNIVERSAL;
+            data << (uint64)plr->GetGUID();
+            data << (uint32)0;
+            data << (uint64)plr->GetGUID();
+            data << (uint32)(sMsg.length()+1);
+            data << sMsg;
+            data << (uint8)0;
+            plr->GetSession()->SendPacket(&data);
+            plr->PlayDirectSound(3081, plr->ToPlayer());
+            Send_IRCA(ChanOrPM(CD), "\00313To ["+_PARAMS[0]+"] : "+_PARAMS[1]+".", true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "Is Not Accepting Private Messages!", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, "Player not online!", true, "ERROR");
+}
+
+void IRCCmd::Restart_Trinity(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 1);
+    if (_PARAMS[0] == "cancel")
+    {
+        sWorld->ShutdownCancel();
+        Send_IRCA(ChanOrPM(CD), "\0034Server Restart Has Been Cancelled.", true, CD->TYPE);
+    }
+
+    int32 i_time = atoi(_PARAMS[0].c_str());
+    if (i_time < 0)
+    {
+        Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Please Enter A Number! And No Negative Numbers! "+_PARAMS[0]+" Seconds!?", true, CD->TYPE);
+        return;
+    }
+    if (i_time >= 1)
+    {
+        Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Has Requested Server To Restart In "+_PARAMS[0]+" Seconds!", true, CD->TYPE);
+        sWorld->ShutdownServ(i_time,SHUTDOWN_MASK_RESTART, RESTART_EXIT_CODE);
+        Delay(i_time*1000);
+        Send_IRCA(ChanOrPM(CD), "\0034Server Will Now Restart.. Be Back In A Flash!", true, CD->TYPE);
+    }
+}
+
+void IRCCmd::Revive_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        if (plr->isDead())
+        {
+            plr->ResurrectPlayer(0.5f);
+            plr->SpawnCorpseBones();
+            plr->SaveToDB();
+            sIRC->Send_IRC_Channel(ChanOrPM(CD), " \00313["+_PARAMS[0]+"] : Has Been Revived By: " + CD->USER, true, CD->TYPE);
+            Send_Player(plr, MakeMsg("You Have Been Revived By: %s.", CD->USER.c_str()));
+        }
+        else
+            Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Not Dead!", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Not Online!", true, "ERROR");
+}
+
+void IRCCmd::Saveall_Player(_CDATA *CD)
+{
+    ObjectAccessor::SaveAllPlayers();
+    Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Has Saved All Players!", true, CD->TYPE);
+}
+
+void IRCCmd::Server(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (_PARAMS[0] == "setmotd")
+    {
+        sWorld->SetMotd(_PARAMS[1]);
+        Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Has Set New Message Of The Day To: "+_PARAMS[1], true, CD->TYPE);
+    }
+    if (_PARAMS[0] == "flusharenapoints")
+    {
+        sArenaTeamMgr->DistributeArenaPoints();
+    }
+}
+
+void IRCCmd::Shutdown_Trinity(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 1);
+    if (_PARAMS[0] == "cancel")
+    {
+        sWorld->ShutdownCancel();
+        Send_IRCA(ChanOrPM(CD), "\0034Server Shutdown Has Been Cancelled.", true, CD->TYPE);
+    }
+
+    int32 i_time = atoi(_PARAMS[0].c_str());
+    if (i_time < 0)
+    {
+        Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Please Enter A Number! And No Negative Numbers! "+_PARAMS[0]+" Seconds!?", true, CD->TYPE);
+        return;
+    }
+    if (i_time >= 1)
+    {
+        Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Has Requested Server To Be Shut Down In "+_PARAMS[0]+" Seconds!", true, CD->TYPE);
+        sWorld->ShutdownServ(i_time, SHUTDOWN_MASK_IDLE , SHUTDOWN_EXIT_CODE);
+        Delay(i_time*1000);
+        Send_IRCA(ChanOrPM(CD), "\0034Server Will Now Shut Down.. Good Bye!", true, CD->TYPE);
+    }
+}
+
+void IRCCmd::Spell_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 3);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC->BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    uint32 spell = atoi(_PARAMS[2].c_str());
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spell);
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        if (spellInfo)
+        {
+            std::string name = spellInfo->SpellName[sWorld->GetDefaultDbcLocale()];
+            if (_PARAMS[1] == "cast")
+            {
+                plr->CastSpell(plr, spell, true);
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Had Spell "+name+" Casted On Them.", true, CD->TYPE);
+            }
+            if (_PARAMS[1] == "learn")
+            {
+                plr->LearnSpell(spell, true);
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Learned Spell "+name+".", true, CD->TYPE);
+            }
+            if (_PARAMS[1] == "unlearn")
+            {
+                plr->RemoveSpell(spell);
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Unlearned Spell "+name+".", true, CD->TYPE);
+            }
+        }
+        else
+            Send_IRCA(CD->USER, "Incorrect Spell ID!", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, "Player Not Online!", true, "ERROR");
+}
+
+void IRCCmd::Sysmsg_Server(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    std::string ircchan = "#";
+    ircchan += sIRC->anchn;
+    if (_PARAMS[0] == "a")
+    {
+        std::string str = _PARAMS[1];
+        std::string ancmsg = MakeMsg("\00304,08\037/!\\\037\017\00304 System Message \00304,08\037/!\\\037\017 %s",_PARAMS[1].c_str());
+        sWorld->SendWorldText(6620,str.c_str());
+        sIRC->Send_IRC_Channel(ircchan, ancmsg, true);
+    }
+    else if (_PARAMS[0] == "e")
+    {
+        std::string str = _PARAMS[1];
+        std::string notstr = "[Server Event]: " + _PARAMS[1];
+        std::string notmsg = MakeMsg("\00304,08\037/!\\\037\017\00304 Server Event \00304,08\037/!\\\037\017 %s",_PARAMS[1].c_str());
+        WorldPacket data(SMSG_NOTIFICATION, (notstr.size()+1));
+        data << notstr;
+        WorldPacket data2(SMSG_PLAY_SOUND,32);
+        data2 << (uint32)1400;
+        sWorld->SendGlobalMessage(&data2);
+        sWorld->SendGlobalMessage(&data);
+        sWorld->SendWorldText(6621,str.c_str());
+        sIRC->Send_IRC_Channel(ircchan, notmsg, true);
+    }
+    else if (_PARAMS[0] == "n")
+    {
+        std::string str = "Global notify: " + _PARAMS[1];
+        std::string notmsg = MakeMsg("\00304,08\037/!\\\037\017\00304 Global Notify \00304,08\037/!\\\037\017 %s",_PARAMS[1].c_str());
+        WorldPacket data(SMSG_NOTIFICATION, (str.size()+1));
+        data << str;
+        sWorld->SendGlobalMessage(&data);
+        sIRC->Send_IRC_Channel(ircchan, notmsg, true);
+    }
+    else if (_PARAMS[0] == "gm")
+    {
+        std::string str = "GM Announcement: " + _PARAMS[1];
+        WorldPacket data(SMSG_NOTIFICATION, (str.size()+1));
+        data << str;
+        sWorld->SendGlobalGMMessage(&data);
+
+    }
+    else if (_PARAMS[0] == "add")
+    {
+        WorldDatabase.PExecute("INSERT INTO irc_autoannounce (message, addedby) VALUES ('%s', '%s')", _PARAMS[1].c_str(), CD->USER.c_str());
+        std::string str = _PARAMS[1];
+        std::string ancmsg = MakeMsg("\00304,08\037/!\\\037\017\00304 Automatic System Message \00304,08\037/!\\\037\017 %s",_PARAMS[1].c_str());
+        sWorld->SendWorldText(6622,str.c_str());
+        sIRC->Send_IRC_Channel(ircchan, ancmsg, true);
+    }
+    else if (_PARAMS[0] == "del")
+    {
+        WorldDatabase.PExecute("DELETE FROM irc_autoannounce WHERE id = %s", _PARAMS[1].c_str());
+        Send_IRCA(ChanOrPM(CD), MakeMsg("Deleted Automatic Announcement Message ID: %s", _PARAMS[1].c_str()), true, CD->TYPE);
+    }
+    else if (_PARAMS[0] == "list")
+    {
+        QueryResult result = WorldDatabase.PQuery("SELECT * FROM irc_autoannounce LIMIT 5;", _PARAMS[1].c_str());
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            for (uint64 i=0; i < result->GetRowCount(); i++)
+            {
+                std::string id = fields[0].GetString();
+                std::string message = fields[1].GetString();
+                std::string addedby = fields[2].GetString();
+                Send_IRCA(ChanOrPM(CD), MakeMsg("ID: %s - Added By: %s - Message: %s", id.c_str(), addedby.c_str(), message.c_str()), true, CD->TYPE);
+                result->NextRow();
+            }
+        }
+        else
+            Send_IRCA(CD->USER, "No Auto Announce Messages Are In The Database.", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, "Please Use (a-Announce)(n-Notify)(e-Event) As Second Parameter!", true, "ERROR");
+}
+
+void IRCCmd::Tele_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 4);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC->BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    bool DoTeleport = false;
+    float pX, pY, pZ, pO = 0;
+    uint32 mapid = 0;
+    std::string rMsg = " Teleport Failed!";
+    std::string wMsg = "Invalid Tele Location";
+    Player* plr = GetPlayer(_PARAMS[0]);
+    if (plr)
+    {
+        if (plr->IsInFlight() || plr->IsInCombat())
+        {
+            Send_IRCA(CD->USER, MakeMsg("%s Is Busy And Cannot Be Teleported! They Could Be In Combat, Or Flying.",_PARAMS[0].c_str()), true, "ERROR");
+            return;
+        }
+    }
+    if (_PARAMS[1] == "l" || _PARAMS[1].size() > 2)
+    {
+        if (_PARAMS[1].size() > 1)
+            _PARAMS[2] = _PARAMS[1];
+        WorldDatabase.EscapeString(_PARAMS[2]);
+        QueryResult result = WorldDatabase.PQuery("SELECT position_x, position_y, position_z, orientation, map FROM game_tele WHERE name='%s';", _PARAMS[2].c_str());
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            pX = fields[0].GetFloat();
+            pY = fields[1].GetFloat();
+            pZ = fields[2].GetFloat();
+            pO = fields[3].GetFloat();
+            mapid = fields[4].GetUInt16();
+
+            rMsg = MakeMsg(" \00313[%s] : Teleported To %s! By: %s.",
+                _PARAMS[0].c_str(),
+                _PARAMS[2].c_str(),
+                CD->USER.c_str());
+            wMsg = MakeMsg("You Have Been Teleported To %s By: %s.",
+                _PARAMS[2].c_str(),
+                CD->USER.c_str());
+            DoTeleport = true;
+        }
+        else
+        {
+            WorldDatabase.EscapeString(_PARAMS[2]);
+            QueryResult result = WorldDatabase.PQuery("SELECT name FROM game_tele WHERE name LIKE '%%%s%%' LIMIT 7;", _PARAMS[2].c_str());
+            if (result)
+            {
+                std::string telename = "<> ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    Field *fields = result->Fetch();
+                    telename.append(fields[0].GetString());
+                    result->NextRow();
+                    telename.append(" <> ");
+                }
+
+                Send_IRCA(CD->USER, "I Cannot Find Location: "+_PARAMS[2]+" . Perhaps One Of These Will Work For You.", true, "ERROR");
+                Send_IRCA(CD->USER, telename, true, "ERROR");
+                return;
+            }
+            else
+                Send_IRCA(CD->USER, "Location Not Found! Nothing Even Close Found!", true, "ERROR");
+                return;
+        }
+    }
+    else if (_PARAMS[1] == "c")
+    {
+        std::string* _PARAMSA = getArray(_PARAMS[2], 4);
+        pX = atof(_PARAMSA[1].c_str());
+        pY = atof(_PARAMSA[2].c_str());
+        pZ = atof(_PARAMSA[3].c_str());
+        mapid = atoi(_PARAMSA[0].c_str());
+        rMsg = MakeMsg(" \00313[%s] : Teleported To Map: %s. Position: X(%s) Y(%s) Z(%s)! By: %s.",
+            _PARAMS[0].c_str(),
+            _PARAMSA[0].c_str(),
+            _PARAMSA[1].c_str(),
+            _PARAMSA[2].c_str(),
+            _PARAMSA[3].c_str(),
+            CD->USER.c_str());
+        wMsg = MakeMsg("You Have Been Teleported To Map: %s. Position: X(%s) Y(%s) Z(%s)! By: %s.",
+            _PARAMSA[0].c_str(),
+            _PARAMSA[1].c_str(),
+            _PARAMSA[2].c_str(),
+            _PARAMSA[3].c_str(),
+            CD->USER.c_str());
+        DoTeleport = true;
+    }
+    else if (_PARAMS[1] == "r")
+    {
+        if (plr)
+        {
+            pX = plr->m_recallX;
+            pY = plr->m_recallY;
+            pZ = plr->m_recallZ;
+            pO = plr->m_recallO;
+            mapid = plr->m_recallMap;
+            rMsg = MakeMsg(" \00313[%s] : Has Been Recalled To Their Previous Location.",
+                _PARAMS[0].c_str());
+            wMsg = MakeMsg("You Have Been Recalled To Your Previous Location. By: %s",
+                CD->USER.c_str());
+            DoTeleport = true;
+        }
+        else
+        {
+            Send_IRCA(CD->USER, MakeMsg("\00313[%s] : Cannot Be Recalled, They Are Not Online.", _PARAMS[0].c_str()), true, "ERROR");
+            return;
+        }
+
+    }
+    else if (_PARAMS[1] == "to")
+    {
+        Player* plr2 = GetPlayer(_PARAMS[2]);
+        if (plr2)
+        {
+            plr2->GetContactPoint(plr, pX, pY, pZ);
+            mapid = plr2->GetMapId();
+        }
+        else
+        {
+            if (ObjectGuid guid = sObjectMgr->GetPlayerGUIDByName(_PARAMS[2].c_str()))
+            {
+                bool in_flight;
+                Player::LoadPositionFromDB(mapid, pX, pY, pZ, pO, in_flight, guid);
+            }
+            else
+            {
+                Send_IRCA(CD->USER, "Second Player Not Found!", true, "ERROR");
+                return;
+            }
+        }
+        rMsg = MakeMsg(" \00313[%s] : Teleported To Player: [%s] By: %s.",
+            _PARAMS[0].c_str(),
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        wMsg = MakeMsg("You Are Being Teleported To: %s. By: %s.",
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        DoTeleport = true;
+    }
+    else if (_PARAMS[1] == "cr")
+    {
+      QueryResult result = WorldDatabase.PQuery("SELECT position_x,position_y,position_z,orientation,map FROM creature WHERE guid ='%s' LIMIT 1", _PARAMS[2].c_str());
+      if (!result)
+      {
+          Send_IRCA(CD->USER, "Creature GUID not found", true, "ERROR");
+      }
+      else
+      {
+        Field *fields = result->Fetch();
+        pX = fields[0].GetFloat();
+        pY = fields[1].GetFloat();
+        pZ = fields[2].GetFloat();
+        pO = fields[3].GetFloat();
+        mapid = fields[4].GetUInt16();
+
+        rMsg = MakeMsg(" \00313[%s] : Teleported To Creature: [%s] By: %s.",
+            _PARAMS[0].c_str(),
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        wMsg = MakeMsg("You Are Being Teleported To: %s. By: %s.",
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        DoTeleport = true;
+
+      }
+    }
+    else if (_PARAMS[1] == "go")
+    {
+      QueryResult result = WorldDatabase.PQuery("SELECT position_x,position_y,position_z,orientation,map FROM gameobject WHERE guid ='%s' LIMIT 1", _PARAMS[2].c_str());
+      if (!result)
+      {
+          Send_IRCA(CD->USER, "GO GUID not found", true, "ERROR");
+      }
+      else
+      {
+        Field *fields = result->Fetch();
+        pX = fields[0].GetFloat();
+        pY = fields[1].GetFloat();
+        pZ = fields[2].GetFloat();
+        pO = fields[3].GetFloat();
+        mapid = fields[4].GetUInt16();
+
+        rMsg = MakeMsg(" \00313[%s] : Teleported To Gameobject: [%s] By: %s.",
+            _PARAMS[0].c_str(),
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        wMsg = MakeMsg("You Are Being Teleported To: %s. By: %s.",
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        DoTeleport = true;
+
+      }
+    }
+    else if (_PARAMS[1] == "homebind")
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT posX,posY,posZ,mapId FROM `character_homebind` WHERE guid = '%d'", plr->GetGUID());
+        if (!result)
+        {
+          Send_IRCA(CD->USER, "Unexpected Error Loading Homebind Location", true, "ERROR");
+        }
+        else
+        {
+            Field *fields = result->Fetch();
+            pX = fields[0].GetFloat();
+            pY = fields[1].GetFloat();
+            pZ = fields[2].GetFloat();
+            pO = 1;
+            mapid = fields[3].GetUInt16();
+
+            rMsg = MakeMsg(" \00313[%s] : Teleported To Homebind Location By: %s.",
+                _PARAMS[0].c_str(),
+                CD->USER.c_str());
+            wMsg = MakeMsg("You Are Being Teleported To Your Homebind Location By: %s.",
+            CD->USER.c_str());
+            DoTeleport = true;
+
+        }
+
+    }
+    if (DoTeleport)
+    {
+        if (MapManager::IsValidMapCoord(mapid, pX ,pY ,pZ))
+        {
+                //if player is online teleport them in real time, if not set the DB to our coordinates.
+                if (plr)
+                {
+                    plr->SaveRecallPosition();
+                    plr->TeleportTo(mapid, pX, pY, pZ, pO);
+                    sIRC->Send_IRC_Channel(ChanOrPM(CD), rMsg, true, CD->TYPE);
+                    Send_Player(plr, wMsg);
+                }
+                else
+                {
+                    ObjectGuid guid = sObjectMgr->GetPlayerGUIDByName(_PARAMS[0]);
+                    WorldLocation loc;
+                    loc.WorldRelocate(mapid,pX,pY,pZ,0.0f);
+                    sIRC->Send_IRC_Channel(ChanOrPM(CD), rMsg + " \0034*Offline Tele.* ", true, CD->TYPE);
+                }
+        }
+        else
+            Send_IRCA(CD->USER, "Invalid Location!", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, "Invalid Paramaters, Please Try Again [ "+sIRC->_cmd_prefx+"help tele ] For More Information. ", true, "ERROR");
+}
+
+void IRCCmd::Top_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 2);
+    uint32 limitr = 10;
+    if (atoi(_PARAMS[1].c_str()) > 0 && GetLevel(CD->USER) >= sIRC->_op_gm_lev)
+        limitr = atoi(_PARAMS[1].c_str());
+    if (_PARAMS[0] == "accttime")
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT account, name, (SUM(totaltime)) AS combinetime FROM characters GROUP BY account ORDER BY combinetime DESC LIMIT 0, %d ", limitr);
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            std::string tptime = MakeMsg("\x2 Top%d Accounts By Played Time:\x3\x31\x30 ", limitr);
+            for (uint64 i=0; i < result->GetRowCount(); i++)
+            {
+                uint32 account = fields[0].GetUInt32();
+                std::string PlName = GetAcctNameFromID(account);
+                std::string Time = SecToDay(fields[2].GetString());
+                uint32 rank = i+1;
+                tptime.append(MakeMsg("[%u]%s %s \xF| \x3\x31\x30\x2", rank, PlName.c_str(), Time.c_str()));
+                result->NextRow();
+            }
+
+            Send_IRCA(ChanOrPM(CD), tptime, true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "No Accounts Returned." ,true, "ERROR");
+    }
+    if (_PARAMS[0] == "chartime")
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT name, totaltime FROM characters ORDER BY totaltime DESC LIMIT 0, %d ", limitr);
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            std::string tptime = MakeMsg("\x2 Top%d Characters By Played Time:\x3\x31\x30 ", limitr);
+            for (uint64 i=0; i < result->GetRowCount(); i++)
+            {
+                std::string Name = fields[0].GetString();
+                std::string Time = SecToDay(fields[1].GetString());
+                uint32 rank = i+1;
+                tptime.append(MakeMsg("[%u]%s %s \xF| \x3\x31\x30\x2", rank, Name.c_str(), Time.c_str()));
+                result->NextRow();
+            }
+
+            Send_IRCA(ChanOrPM(CD), tptime, true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "No Characters Returned." ,true, "ERROR");
+    }
+    if (_PARAMS[0] == "money")
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT name, money FROM characters ORDER BY money DESC LIMIT 0, %d ", limitr);
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            std::string tptime = MakeMsg("\x2 Top%d Characters By Money:\x3\x31\x30 ", limitr);
+            for (uint64 i=0; i < result->GetRowCount(); i++)
+            {
+                std::string Name = fields[0].GetString();
+                unsigned int money = fields[1].GetInt32();
+
+                uint32 rank = i+1;
+
+                unsigned int gold = money / 10000;
+                unsigned int silv = (money % 10000) / 100;
+                unsigned int cop = (money % 10000) % 100;
+                char tempgold [100];
+                sprintf(tempgold, "\x2\x3\x30\x37%ug \x3\x31\x34%us \x3\x30\x35%uc\xF", gold, silv, cop);
+
+                tptime.append(MakeMsg("[%u]%s %s \xF| \x3\x31\x30\x2", rank, Name.c_str(), tempgold));
+                result->NextRow();
+            }
+
+            Send_IRCA(ChanOrPM(CD), tptime, true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "No Characters Returned." ,true, "ERROR");
+    }
+
+}
+
+void IRCCmd::Chan_Control(_CDATA *CD)
+{
+
+    std::string* _PARAMS = getArray(CD->PARAMS, 2);
+
+    if (CD->FROM == sIRC->_Nick)
+    {
+        Send_IRCA(CD->USER, "\0034[ERROR] : You Cannot Use This Command Through A PM Yet.", true, "ERROR");
+        return;
+    }
+
+    if (_PARAMS[0] == "op")
+    {
+        if (_PARAMS[1].length() > 1)
+            sIRC->SendIRC("MODE "+CD->FROM+" +o "+_PARAMS[1]);
+        else
+            sIRC->SendIRC("MODE "+CD->FROM+" +o "+CD->USER);
+    }
+
+    if (_PARAMS[0] == "deop")
+    {
+        if (_PARAMS[1].length() > 1)
+            sIRC->SendIRC("MODE "+CD->FROM+" -o "+_PARAMS[1]);
+        else
+            sIRC->SendIRC("MODE "+CD->FROM+" -o "+CD->USER);
+    }
+
+    if (_PARAMS[0] == "voice")
+    {
+        if (_PARAMS[1].length() > 1)
+            sIRC->SendIRC("MODE "+CD->FROM+" +v "+_PARAMS[1]);
+        else
+            sIRC->SendIRC("MODE "+CD->FROM+" +v "+CD->USER);
+    }
+    if (_PARAMS[0] == "devoice")
+    {
+        if (_PARAMS[1].length() > 1)
+            sIRC->SendIRC("MODE "+CD->FROM+" -v "+_PARAMS[1]);
+        else
+            sIRC->SendIRC("MODE "+CD->FROM+" -v "+CD->USER);
+    }
+};
+void IRCCmd::Who_Logged(_CDATA *CD)
+{
+    std::string OPS = "";
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        OPS.append(MakeMsg(" \002[GM:%d IRC: %s - WoW: %s]\002 ", (*i)->GMLevel, (*i)->Name.c_str(), (*i)->UName.c_str()));
+    }
+    Send_IRCA(ChanOrPM(CD), OPS, true, CD->TYPE);
+}
diff --git a/src/server/game/TriniChat/IRCFunc.h b/src/server/game/TriniChat/IRCFunc.h
new file mode 100644
index 0000000..f780dd7
--- /dev/null
+++ b/src/server/game/TriniChat/IRCFunc.h
@@ -0,0 +1,292 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _IRC_CLIENT_FUNC
+#define _IRC_CLIENT_FUNC
+
+std::string GetUser(std::string szU)
+{
+    int pos = szU.find("!");
+    return szU.substr(0, pos);
+}
+// Delink will remove anything considered "non chat" from a string
+std::string Delink(std::string msg)
+{
+    std::size_t pos;
+
+        while((pos = msg.find("|Htrade")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Hglyph")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Hitem")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Henchant")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+        //msg.replace(find2, 2, "\x2");
+    }
+    while((pos = msg.find("|Hquest")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Hspell")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Htalent")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Hachievement")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Htrade")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    return msg;
+}
+
+// This function converts the characters used by the client to identify colour to IRC format.
+std::string WoWcol2IRC(std::string msg)
+{
+    std::size_t pos;
+    char IRCCol[17][6] = { "\xF", "\xF", "\x3\x31\x34", "\x3\x30\x33", "\x3\x31\x32", "\x3\x30\x36", "\x3\x30\x37", "\x3\x30\x34", "\x3\x30\x34", "\x3\x31\x34", "\x3\x31\x32", "\x3\x30\x37", "\x3\x30\x34", "\x3\x30\x33", "\x3\x31\x32", "\x3\x31\x32", "\x3\x30\x37"};
+    char WoWCol[17][12] = { "|r", "|cffffffff", "|cff9d9d9d", "|cff1eff00", "|cff0070dd", "|cffa335ee", "|cffff8000", "|cffe6cc80", "|cffffd000", "|cff808080", "|cff71d5ff", "|cffffff00", "|cffff2020", "|cff40c040", "|cff4e96f7", "|cff71d5ff", "|cffff8040"};
+    for (int i=0; i<=15; i++)
+    {
+        while ((pos = msg.find(WoWCol[i])) != std::string::npos)
+        {
+            if (i == 0)
+                msg.replace(pos, 2, IRCCol[i]);
+            else
+                msg.replace(pos, 11, IRCCol[i]);
+        }
+    }
+    return msg;
+}
+
+// This function converts the characters used by IRC to identify colour to a format the client can understand.
+std::string IRCcol2WoW(std::string msg)
+{
+    std::size_t pos;
+    char IRCCol[18][4] = { "\x3\x30", "\x3\x31", "\x3\x32", "\x3\x33", "\x3\x34", "\x3\x35", "\x3\x36", "\x3\x37", "\x3\x38", "\x3\x39", "\x3\x31\x30", "\x3\x31\x31", "\x3\x31\x32", "\x3\x31\x33", "\x3\x31\x34", "\x3\x31\x35", "\x3\x30\x37", "\x3\x30\x37"};
+    char IRCCol2[10][4] = { "\x3\x30\x30", "\x3\x30\x31", "\x3\x30\x32", "\x3\x30\x33", "\x3\x30\x34", "\x3\x30\x35", "\x3\x30\x36", "\x3\x30\x37", "\x3\x30\x38", "\x3\x30\x39"};
+    char WoWcol[18][12] = { "|cffffffff", "|cff000000", "|cff00007f", "|cff009300", "|cffff0000", "|cff7f0000", "|cff9c009c", "|cfffc9300", "|cffffff00", "|cff00fc00", "|cff009393", "|cff00ffff", "|cff0000fc", "|cffff00ff", "|cff7f7f7f", "|cffd2d2d2", "|cff808080", "|cff71d5ff"};
+    for (int i=15; i>=0; i--)
+    {
+        if (i<10)
+        {
+            while ((pos = msg.find(IRCCol2[i])) != std::string::npos)
+            {
+                msg.replace(pos, 3, WoWcol[i]);
+            }
+            while ((pos = msg.find(IRCCol[i])) != std::string::npos)
+            {
+                msg.replace(pos, 2, WoWcol[i]);
+            }
+
+        }
+        else
+        {
+            while ((pos = msg.find(IRCCol[i])) != std::string::npos)
+            {
+                msg.replace(pos, 3, WoWcol[i]);
+            }
+        }
+
+        // Remove Bold, Reverse, Underline from IRC
+        char Checker[3][3] = {"\x2","\x16","\x1F"}; // This is the Hex part not Dec. In Decimal its (2,22,31)
+        for (int I=0; I < 3; I++)
+        {
+            while ((pos = msg.find(Checker[I])) != std::string::npos)
+            {
+                msg.replace(pos, 1, "");
+            }
+        }
+        // Finished Removing !
+
+    }
+
+    while ((pos = msg.find("\x3")) != std::string::npos)
+    {
+        msg.replace(pos, 1, "|r");
+    }
+    while ((pos = msg.find("\xF")) != std::string::npos)
+    {
+        msg.replace(pos, 1, "|r");
+    }
+
+    return msg;
+}
+
+// This function compares 2 strings
+int nocase_cmp(const string & s1, const string& s2)
+{
+    string::const_iterator it1=s1.begin();
+    string::const_iterator it2=s2.begin();
+
+    //stop when either string's end has been reached
+    while ((it1!=s1.end()) && (it2!=s2.end()))
+    {
+        if (::toupper(*it1) != ::toupper(*it2))              //letters differ?
+            // return -1 to indicate smaller than, 1 otherwise
+            return (::toupper(*it1)  < ::toupper(*it2)) ? -1 : 1;
+        //proceed to the next character in each string
+        ++it1;
+        ++it2;
+    }
+    size_t size1=s1.size(), size2=s2.size();                // cache lengths
+    //return -1,0 or 1 according to strings' lengths
+    if (size1==size2)
+        return 0;
+    return (size1<size2) ? -1 : 1;
+}
+
+std::string MakeMsgA(const char *sLine, ...)
+{
+    va_list ap;
+    char tmpoutp[1024];
+    va_start(ap, sLine);
+    vsnprintf(tmpoutp, 1024, sLine, ap);
+    va_end(ap);
+    std::string outp = tmpoutp;
+    return outp;
+}
+
+std::string MakeMsgP(int CLINE, std::string Msg, Player *plr)
+{
+    std::string sMsg = sIRC->MakeMsg(sIRC->GetChatLine(CLINE), "$Msg", Msg);
+    if (plr->GetTeam() == 67)
+        sMsg = sIRC->MakeMsg(sMsg, "$Name", MakeMsgA("\0034%s\003", plr->GetName().c_str()));
+    else if (plr->GetTeam() == 469)
+        sMsg = sIRC->MakeMsg(sMsg, "$Name", MakeMsgA("\00312%s\003", plr->GetName().c_str()));
+    if (plr->isAFK())
+        sMsg = sIRC->MakeMsg(sMsg, "$Tag", "<AFK>");
+    else if (plr->isDND())
+        sMsg = sIRC->MakeMsg(sMsg, "$Tag", "<DND>");
+    else
+        sMsg = sIRC->MakeMsg(sMsg, "$Tag", "");
+    sMsg = sIRC->MakeMsg(sMsg, "$Level", MakeMsgA("%d", plr->getLevel()));
+    if (plr->getClass() == 1)
+        sMsg = sIRC->MakeMsg(sMsg, "$Class", MakeMsgA("\0035WR\003"));
+    else if (plr->getClass() == 2)
+        sMsg = sIRC->MakeMsg(sMsg, "$Class", MakeMsgA("\00313PA\003"));
+    else if (plr->getClass() == 3)
+        sMsg = sIRC->MakeMsg(sMsg, "$Class", MakeMsgA("\0033HU\003"));
+    else if (plr->getClass() == 4)
+        sMsg = sIRC->MakeMsg(sMsg, "$Class", MakeMsgA("\00310RO\003"));
+    else if (plr->getClass() == 5)
+        sMsg = sIRC->MakeMsg(sMsg, "$Class", MakeMsgA("\00314PR\003"));
+    else if (plr->getClass() == 6)
+        sMsg = sIRC->MakeMsg(sMsg, "$Class", MakeMsgA("\0034DK\003"));
+    else if (plr->getClass() == 7)
+        sMsg = sIRC->MakeMsg(sMsg, "$Class", MakeMsgA("\00312SH\003"));
+    else if (plr->getClass() == 8)
+        sMsg = sIRC->MakeMsg(sMsg, "$Class", MakeMsgA("\00311MA\003"));
+    else if (plr->getClass() == 9)
+        sMsg = sIRC->MakeMsg(sMsg, "$Class", MakeMsgA("\0036WL\003"));
+    else if (plr->getClass() == 11)
+        sMsg = sIRC->MakeMsg(sMsg, "$Class", MakeMsgA("\0037DR\003"));
+    sMsg = Delink(sMsg);
+    sMsg = WoWcol2IRC(sMsg);
+    return sMsg;
+}
+
+// This function checks if a channel exists in out configuration
+// TriniChat supports as many channels as you like
+bool Channel_Valid(std::string Channel)
+{
+    for (int i=1;i < sIRC->_chan_count + 1;i++)
+    {
+        if (nocase_cmp(sIRC->_wow_chan[i], Channel)==0)
+            return true;
+    }
+    return false;
+}
+
+std::string GetWoWChannel(std::string Channel)
+{
+    for (int i=1;i < sIRC->_chan_count + 1;i++)
+    {
+        if ("#" + sIRC->_irc_chan[i] == Channel)
+            return sIRC->_wow_chan[i];
+    }
+    return "";
+}
+
+std::string GetIRCChannel(std::string Channel)
+{
+    for (int i=1;i < sIRC->_chan_count + 1;i++)
+    {
+        if (sIRC->_wow_chan[i] == Channel)
+            return sIRC->_irc_chan[i];
+    }
+    return "";
+}
+
+std::string* getArray(std::string PARAMS, int nCount, std::string)
+{
+    std::string *array = new std::string[nCount];
+    if (PARAMS.size() > 0)
+    {
+        size_t ps = 0;
+        size_t pc = -1;
+        for (int i = 0;i < nCount;i++)
+        {
+            pc = PARAMS.find(" ", pc + 1);
+            if (i + 1 == nCount && nCount != 1)
+            {
+                if (ps > 0 && pc > 0)
+                    array[i] = PARAMS.substr(ps, PARAMS.size() - ps);
+            }
+            else
+                array[i] = PARAMS.substr(ps, pc - ps);
+            ps = pc + 1;
+        }
+    }
+    return array;
+}
+#endif
diff --git a/src/server/game/TriniChat/IRCIO.cpp b/src/server/game/TriniChat/IRCIO.cpp
new file mode 100644
index 0000000..efa1b0c
--- /dev/null
+++ b/src/server/game/TriniChat/IRCIO.cpp
@@ -0,0 +1,529 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCClient.h"
+#include "IRCCmd.h"
+#include "IRCFunc.h"
+#include "Language.h"
+#include "ObjectAccessor.h"
+#include "ObjectMgr.h"
+#include "WorldPacket.h"
+#include "ChannelMgr.h"
+#include "Config.h"
+#include "Channel.h"
+#include "World.h"
+
+IRCCmd Command;
+void IRCClient::Handle_IRC(std::string sData)
+{
+    // If first 5 chars are ERROR then something is wrong
+    // either link is being closed, nickserv ghost command, etc...
+    if (sData.substr(0, 5) == "ERROR")
+    {
+        Disconnect();
+        return;
+    }
+    if (sData.substr(0, 4) == "PING")
+    {
+        // if the first 4 characters contain PING
+        // the server is checking if we are still alive
+        // sen back PONG back plus whatever the server send with it
+        SendIRC("PONG " + sData.substr(4, sData.size() - 4));
+    }
+    else
+    {
+        // if the first line contains : its an irc message
+        // such as private messages channel join etc.
+        if (sData.substr(0, 1) == ":")
+        {
+            // find the spaces in the receieved line
+            size_t p1 = sData.find(" ");
+            size_t p2 = sData.find(" ", p1 + 1);
+            // because the irc protocol uses simple spaces
+            // to seperate data we can easy pick them out
+            // since we know the position of the spaces
+            std::string USR = sData.substr(1, p1 - 1);
+            std::string CMD = sData.substr(p1 + 1, p2 - p1 - 1);
+            // trasform the commands to lowercase to make sure they always match
+            std::transform(CMD.begin(), CMD.end(), CMD.begin(), towlower);
+            // Extract the username from the first part
+            std::string szUser = GetUser(USR);
+            // if we receieved the internet connect code
+            // we know for sure that were in and we can
+            // authenticate ourself.
+            if (CMD == sIRC->_ICC)
+            {
+                // _Auth is defined in trinitycore.conf (irc.auth)
+                // 0 do not authenticate
+                // 1 use nickserv
+                // 2 use quakenet
+                // aditionally you can provide you own authentication method here
+                switch(sIRC->_Auth)
+                {
+                    case 1:
+                        SendIRC("PRIVMSG nickserv :IDENTIFY " + sIRC->_Pass);
+                        break;
+                    case 2:
+                        SendIRC("PRIVMSG nickserv :IDENTIFY " + sIRC->_Auth_Nick + " " + sIRC->_Pass);
+                        break;
+                    case 3:
+                        SendIRC("PRIVMSG Q@CServe.quakenet.org :AUTH " + sIRC->_Nick + " " + sIRC->_Pass);
+                        break;
+                    case 4:
+                        SendIRC("PRIVMSG Q@CServe.quakenet.org :AUTH " + sIRC->_Auth_Nick + " " + sIRC->_Pass);
+                        break;
+                }
+                // if we join a default channel leave this now.
+                if (sIRC->_ldefc==1)
+                    SendIRC("PART #" + sIRC->_defchan);
+                // Loop thru the channel array and send a command to join them on IRC.
+                for (int i=1;i < sIRC->_chan_count + 1;i++)
+                {
+                        if (sIRC->_irc_pass[i].size() > 0)
+                                SendIRC("JOIN #" + sIRC->_irc_chan[i] + " " + sIRC->_irc_pass[i]);
+                        else
+                        SendIRC("JOIN #" + sIRC->_irc_chan[i]);
+                }
+                // See if there's a log channel available, if so: join it.
+                if (sIRC->logchan.size() > 0)
+                {
+                    if (sIRC->logchanpw.size() > 0)
+                        SendIRC("JOIN #" + sIRC->logchan + " " + sIRC->logchanpw);
+                    else
+                        SendIRC("JOIN #" + sIRC->logchan);
+                }
+                // See if there's a Status channel available, if so: join it.
+                if (sIRC->Status.size() > 0)
+                {
+                    if (sIRC->Statuspw.size() > 0)
+                        SendIRC("JOIN #" + sIRC->Status + " " + sIRC->Statuspw);
+                    else
+                        SendIRC("JOIN #" + sIRC->Status);
+                }
+                // See if there's a Ticket channel available, if so: join it.
+                if (sIRC->ticann.size() > 0)
+                {
+                    if (sIRC->ticannpw.size() > 0)
+                        SendIRC("JOIN #" + sIRC->ticann + " " + sIRC->ticannpw);
+                    else
+                        SendIRC("JOIN #" + sIRC->ticann);
+                }
+                // See if there's an Announce channel available, if so: join it.
+                if (sIRC->anchn.size() > 0)
+                {
+                    if (sIRC->anchnpw.size() > 0)
+                        SendIRC("JOIN #" + sIRC->anchn + " " + sIRC->anchnpw);
+                    else
+                        SendIRC("JOIN #" + sIRC->anchn);
+                }
+            }
+            // someone joined the channel this could be the bot or another user
+            if (CMD == "join")
+            {
+                size_t p = sData.find(":", p1);
+                std::string CHAN = sData.substr(p + 1, sData.size() - p - 2);
+                // if the user is us it means we join the channel
+                if ((szUser == sIRC->_Nick))
+                {
+                    // its us that joined the channel
+                    Send_IRC_Channel(CHAN, MakeMsg(MakeMsg(sIRC->JoinMsg, "$Ver", sIRC->_Mver.c_str()), "$Trigger", sIRC->_cmd_prefx.c_str()), true);
+                }
+                else
+                {
+                    // if the user is not us its someone else that joins
+                    // so we construct a message and send this to the clients.
+                    // TriniChat now uses Send_WoW_Channel to send to the client
+                    // this makes TriniChat handle the packets instead of previously the world.
+                    if ((sIRC->BOTMASK & 2) != 0)
+                        Send_WoW_Channel(GetWoWChannel(CHAN).c_str(), IRCcol2WoW(MakeMsg(MakeMsg(GetChatLine(JOIN_IRC), "$Name", szUser), "$Channel", GetWoWChannel(CHAN))));
+                }
+            }
+            // someone on irc left or quit the channel
+            if (CMD == "part" || CMD == "quit")
+            {
+                size_t p3 = sData.find(" ", p2 + 1);
+                std::string CHAN = sData.substr(p2 + 1, p3 - p2 - 1);
+                // Logout IRC Nick From TriniChat If User Leaves Or Quits IRC.
+                if (Command.IsLoggedIn(szUser))
+                {
+                    _CDATA CDATA;
+                    CDATA.USER      = szUser;
+                    Command.Handle_Logout(&CDATA);
+                }
+                // Construct a message and inform the clients on the same channel.
+                if ((sIRC->BOTMASK & 2) != 0)
+                    Send_WoW_Channel(GetWoWChannel(CHAN).c_str(), IRCcol2WoW(MakeMsg(MakeMsg(GetChatLine(LEAVE_IRC), "$Name", szUser), "$Channel", GetWoWChannel(CHAN))));
+            }
+            // someone changed their nick
+            if (CMD == "nick" && (sIRC->BOTMASK & 128) != 0)
+            {
+                MakeMsg(MakeMsg(GetChatLine(CHANGE_NICK), "$Name", szUser), "$NewName", sData.substr(sData.find(":", p2) + 1));
+                // If the user is logged in and changes their nick
+                // then we want to either log them out or update
+                // their nick in the bot. I chose to update the bots user list.
+                if (Command.IsLoggedIn(szUser))
+                {
+                    std::string NewNick = sData.substr(sData.find(":", p2) + 1);
+                    // On freenode I noticed the server sends an extra character
+                    // at the end of the string, so we need to erase the last
+                    // character of the string. if you have a problem with getting
+                    // the last letter of your nick erased, then remove the - 1.
+                    NewNick.erase(NewNick.length() - 1, 1);
+
+                    for (std::list<_client*>::iterator i=Command._CLIENTS.begin(); i!=Command._CLIENTS.end();i++)
+                    {
+                        if ((*i)->Name == szUser)
+                        {
+                            (*i)->Name     = NewNick;
+                            sIRC->Send_IRC_Channel(NewNick.c_str(), "I Noticed You Changed Your Nick, I Have Updated My Internal Database Accordingly.", true, "NOTICE");
+
+                            // Figure why not output to the logfile, makes tracing problems easier.
+                            sIRC->iLog.WriteLog(" %s : %s Changed Nick To: %s", sIRC->iLog.GetLogDateTimeStr().c_str(), szUser.c_str(), NewNick.c_str());
+                        }
+                    }
+                }
+
+            }
+            // someone was kicked from irc
+            if (CMD == "kick")
+            {
+                // extract the details
+                size_t p3 = sData.find(" ", p2 + 1);
+                size_t p4 = sData.find(" ", p3 + 1);
+                std::string CHAN = sData.substr(p2 + 1, p3 - p2 - 1);
+                std::string WHO = sData.substr(p3 + 1, p4 - p3 - 1);
+                std::string BY = sData.substr(p4 + 1, sData.size() - p4 - 1);
+                // if the one kicked was us
+                if (WHO == sIRC->_Nick)
+                {
+                    // and autojoin is enabled
+                    // return to the channel
+                    if (sIRC->_autojoinkick == 1)
+                    {
+                        SendIRC("JOIN " + CHAN);
+                        Send_IRC_Channel(CHAN, sIRC->kikmsg, true);
+                    }
+                }
+                else
+                {
+                    // if it is not us who was kicked we need to inform the clients someone
+                    // was removed from the channel
+                    // construct a message and send it to the players.
+                    Send_WoW_Channel(GetWoWChannel(CHAN).c_str(), "<IRC>[" + WHO + "]: Was Kicked From " + CHAN + " By: " + szUser);
+                }
+            }
+            // a private chat message was receieved.
+            if (CMD == "privmsg" || CMD == "notice")
+            {
+                // extract the values
+                size_t p = sData.find(" ", p2 + 1);
+                std::string FROM = sData.substr(p2 + 1, p - p2 - 1);
+                std::string CHAT = sData.substr(p + 2, sData.size() - p - 3);
+                // if this is our username it means we recieved a PM
+                if (FROM == sIRC->_Nick)
+                {
+                    if (CHAT.find("\001VERSION\001") < CHAT.size())
+                    {
+                        Send_IRC_Channel(szUser, MakeMsg("\001VERSION TriniChat %s ?2008-2009 |Death|, Cybrax, Machiavelli\001", "%s" , sIRC->_Mver.c_str()), true, "PRIVMSG");
+                    }
+                    // a pm is required for certain commands
+                    // such as login. to validate the command
+                    // we send it to the command class wich handles
+                    // evrything else.
+                    Command.IsValid(szUser, FROM, CHAT, CMD);
+                }
+                else
+                {
+                    // if our name is not in it, it means we receieved chat on one of the channels
+                    // magchat is in. the first thing we do is check if it is a command or not
+                    if (!Command.IsValid(szUser, FROM, CHAT, CMD))
+                    {
+                        std::string fixStaffChan = "#"+sIRC->_staffChan;
+                        bool ignored = false;
+                        switch(sIRC->_staffLink)
+                        {
+                            case 1:
+                                if(fixStaffChan == FROM)
+                                {
+                                    for(uint8 i = 0;i<MAX_CONF_BOTS; i++)
+                                    {
+                                        if(sIRC->_ignore_bots[i] != "")
+                                        {
+                                            if(Command.MakeUpper(sIRC->_ignore_bots[i]) == Command.MakeUpper(szUser))
+                                                ignored = true;
+                                        }
+                                    }
+                                    if(!ignored)
+                                    {
+                                        szUser = "<IRC>"+szUser;
+                                        //setup gm chat
+                                        sWorld->SendGMText(LANG_GM_ANNOUNCE_COLOR, szUser.c_str(), CHAT.c_str());
+                                    }
+                                }
+                                else
+                                {
+                                    for(uint8 i = 0;i<MAX_CONF_BOTS; i++)
+                                    {
+                                        if(sIRC->_ignore_bots[i] != "")
+                                        {
+                                            if(Command.MakeUpper(sIRC->_ignore_bots[i]) == Command.MakeUpper(szUser))
+                                                ignored = true;
+                                        }
+                                    }
+                                    if(!ignored)
+                                    {
+                                        Send_WoW_Channel(GetWoWChannel(FROM).c_str(), IRCcol2WoW(MakeMsg(MakeMsg(GetChatLine(IRC_WOW), "$Name", szUser), "$Msg", CHAT)));
+                                    }
+                                }
+                                break;
+                            case 0:
+                                Send_WoW_Channel(GetWoWChannel(FROM).c_str(), IRCcol2WoW(MakeMsg(MakeMsg(GetChatLine(IRC_WOW), "$Name", szUser), "$Msg", CHAT)));
+                                break;
+                        }
+                    }
+                    // if we indeed receieved a command we do not want to display this to the players
+                    // so only incanse the isvalid command returns false it will be sent to all player.
+                    // the isvalid function will automaitcly process the command on true.
+                }
+            }
+            if (CMD == "mode")
+            {
+                // extract the mode details
+                size_t p3 = sData.find(" ", p2 + 1);
+                size_t p4 = sData.find(" ", p3 + 1);
+                size_t p5 = sData.find(" ", p4 + 1);
+                std::string CHAN = sData.substr(p2 + 1, p3 - p2 - 1);
+                std::string MODE = sData.substr(p3 + 1, p4 - p3 - 1);
+                std::string NICK = sData.substr(p4 + 1, p5 - p4 - 1);
+                _AmiOp = false;
+                //A mode was changed on us
+                if (NICK.c_str() == sIRC->_Nick)
+                    _AmiOp = true;
+
+            }
+        }
+    }
+}
+
+// This function is called in Channel.h
+// based on nAction it will inform the people on
+// irc when someone leaves one of the game channels.
+// nAction is based on the struct CACTION
+void IRCClient::Handle_WoW_Channel(std::string Channel, Player *plr, int nAction)
+{
+    // make sure that we are connected
+    if (sIRC->Connected && (sIRC->BOTMASK & 1)!= 0)
+    {
+        if (Channel_Valid(Channel))
+        {
+            std::string GMRank = "";
+            std::string pname = plr->GetName().c_str();
+            bool DoGMAnnounce = false;
+            if (plr->GetSession()->GetSecurity() > 0 && (sIRC->BOTMASK & 8)!= 0)
+                DoGMAnnounce = true;
+            if (plr->IsGameMaster() && (sIRC->BOTMASK & 16)!= 0)
+                DoGMAnnounce = true;
+            if (DoGMAnnounce)
+            {
+                switch(plr->GetSession()->GetSecurity())    //switch case to determine what rank the "gm" is
+                {
+                    case SEC_PLAYER: GMRank = ""; break;
+                    case SEC_MODERATOR: GMRank = "\0037" + sIRC->ojGM1; break;
+                    case SEC_GAMEMASTER: GMRank = "\0037" + sIRC->ojGM2; break;
+                    case SEC_ADMINISTRATOR: GMRank = "\0037" + sIRC->ojGM3; break;
+                    case SEC_CONSOLE: GMRank = "\0037" + sIRC->ojGM4; break;
+                }
+            }
+            std::string ChatTag = "";
+            switch (plr->GetTeam())
+            {
+                case 67:ChatTag.append("\0034");break;      //horde
+                case 469:ChatTag.append("\00312");break;    //alliance
+            }
+            std::string query = "INSERT INTO `irc_inchan` VALUES (%d,'"+pname+"','"+Channel+"')";
+            std::string lchan = "DELETE FROM `irc_inchan` WHERE `guid` = %d AND `channel` = '"+Channel+"'";
+            switch(nAction)
+            {
+                case CHANNEL_JOIN:
+                    Send_IRC_Channel(GetIRCChannel(Channel), MakeMsg(MakeMsg(MakeMsg(GetChatLine(JOIN_WOW), "$Name", ChatTag + plr->GetName().c_str()), "$Channel", Channel), "$GM", GMRank));
+                    WorldDatabase.PExecute(lchan.c_str(), plr->GetGUID());
+                    WorldDatabase.PExecute(query.c_str(), plr->GetGUID());
+                    break;
+                case CHANNEL_LEAVE:
+                    Send_IRC_Channel(GetIRCChannel(Channel), MakeMsg(MakeMsg(MakeMsg(GetChatLine(LEAVE_WOW), "$Name", ChatTag + plr->GetName().c_str()), "$Channel", Channel), "$GM", GMRank));
+                    WorldDatabase.PExecute(lchan.c_str(), plr->GetGUID());
+                    break;
+            }
+        }
+    }
+}
+
+// This function sends chat to a irc channel or user
+// to prevent the # beeing appended to send a msg to a user
+// set the NoPrefix to true
+void IRCClient::Send_IRC_Channel(std::string sChannel, std::string sMsg, bool NoPrefix, std::string nType)
+{
+    std::string mType = "PRIVMSG";
+    if (Command.MakeUpper(nType.c_str()) == "NOTICE")
+        mType = "NOTICE";
+    if (Command.MakeUpper(nType.c_str()) == "ERROR" && (sIRC->BOTMASK & 32)!= 0)
+        mType = "NOTICE";
+    if (sIRC->Connected)
+    {
+        if (NoPrefix)
+            SendIRC(mType + " " + sChannel + " :" + sMsg);
+        else
+            SendIRC(mType + " #" + sChannel + " :" + sMsg);
+    }
+}
+
+// This function sends a message to all irc channels
+// that TriniChat has in its configuration
+void IRCClient::Send_IRC_Channels(std::string sMsg)
+{
+    for (int i=1;i < sIRC->_chan_count + 1;i++)
+        Send_IRC_Channel(sIRC->_irc_chan[i], sMsg);
+}
+
+// This function is called in ChatHandler.cpp, any channel chat from wow will come
+// to this function, validates the channel and constructs a message that is send to IRC
+void IRCClient::Send_WoW_IRC(Player *plr, std::string Channel, std::string Msg)
+{
+    // Check if the channel exist in our configuration
+    if (Channel_Valid(Channel) && Msg.substr(0, 1) != ".")
+        Send_IRC_Channel(GetIRCChannel(Channel), MakeMsgP(WOW_IRC, Msg, plr));
+}
+
+void IRCClient::Send_WoW_Player(std::string sPlayer, std::string sMsg)
+{
+    normalizePlayerName(sPlayer);
+    if (Player* plr = ObjectAccessor::FindPlayerByName(sPlayer.c_str()))
+        Send_WoW_Player(plr, sMsg);
+}
+
+void IRCClient::Send_WoW_Player(Player *plr, string sMsg)
+{
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+    data << (uint8)CHAT_MSG_SYSTEM;
+    data << (uint32)LANG_UNIVERSAL;
+    data << (uint64)plr->GetGUID();
+    data << (uint32)0;
+    data << (uint64)plr->GetGUID();
+    data << (uint32)(sMsg.length()+1);
+    data << sMsg;
+    data << (uint8)0;
+    plr->GetSession()->SendPacket(&data);
+}
+
+// This function will construct and send a packet to all players
+// on the given channel ingame. (previuosly found in world.cpp)
+// it loops thru all sessions and checks if they are on the channel
+// if so construct a packet and send it.
+void IRCClient::Send_WoW_Channel(const char *channel, std::string chat)
+{
+    if (!(strlen(channel) > 0))
+        return;
+
+    #ifdef USE_UTF8
+        std::string chat2 = chat;
+        if (ConvertUTF8(chat2.c_str(), chat2))
+            chat = chat2;
+    #endif
+
+    HashMapHolder<Player>::MapType const& m = ObjectAccessor::GetPlayers();
+    for (HashMapHolder<Player>::MapType::const_iterator itr = m.begin(); itr != m.end(); ++itr)
+    {
+        if (itr->second && itr->second->GetSession()->GetPlayer() && itr->second->GetSession()->GetPlayer()->IsInWorld())
+        {
+            if (ChannelMgr* cMgr = ChannelMgr::forTeam(itr->second->GetSession()->GetPlayer()->GetTeam()))
+            {
+                if (cMgr->GetChannel(channel, itr->second->GetSession()->GetPlayer()))
+                {
+                    WorldPacket data;
+                    data.Initialize(SMSG_MESSAGECHAT);
+                    data << (uint8)CHAT_MSG_CHANNEL;
+                    data << (uint32)LANG_UNIVERSAL;
+                    data << (uint64)0;
+                    data << (uint32)0;
+                    data << channel;
+                    data << (uint64)0;
+                    data << (uint32) (strlen(chat.c_str()) + 1);
+                    data << IRCcol2WoW(chat.c_str());
+                    data << (uint8)0;
+                    itr->second->GetSession()->SendPacket(&data);
+                }
+            }
+        }
+    }
+}
+
+void IRCClient::Send_WoW_System(std::string Message)
+{
+    HashMapHolder<Player>::MapType const& m = ObjectAccessor::GetPlayers();
+    for (HashMapHolder<Player>::MapType::const_iterator itr = m.begin(); itr != m.end(); ++itr)
+    {
+        if (itr->second && itr->second->GetSession()->GetPlayer() && itr->second->GetSession()->GetPlayer()->IsInWorld())
+        {
+            WorldPacket data;
+            data.Initialize(CHAT_MSG_SYSTEM);
+            data << (uint8)CHAT_MSG_SYSTEM;
+            data << (uint32)LANG_UNIVERSAL;
+            data << (uint64)0;
+            data << (uint32)0;
+            data << (uint64)0;
+            data << (uint32) (strlen(Message.c_str()) + 1);
+            data << Message.c_str();
+            data << (uint8)0;
+            itr->second->GetSession()->SendPacket(&data);
+        }
+    }
+}
+void IRCClient::ResetIRC()
+{
+    SendData("QUIT");
+    Disconnect();
+}
+
+#define CHAT_INVITE_NOTICE 0x18
+
+// this function should be called on player login Player::AddToWorld
+void IRCClient::AutoJoinChannel(Player *plr)
+{
+    // this will work if at least 1 player is logged in regrdless if he is on the channel or not
+    // the first person that login empty server is the one with bad luck and wont be invited,
+    // if at least 1 player is online the player will be inited to the chanel
+
+    std::string m_name = sIRC->ajchan;
+    WorldPacket data;
+    data.Initialize(SMSG_CHANNEL_NOTIFY, 1+m_name.size()+1);
+    data << uint8(CHAT_INVITE_NOTICE);
+    data << m_name.c_str();
+
+    HashMapHolder<Player>::MapType const& m = ObjectAccessor::GetPlayers();
+    for (HashMapHolder<Player>::MapType::const_iterator itr = m.begin(); itr != m.end(); ++itr)
+    {
+        if (itr->second && itr->second->GetSession()->GetPlayer() && itr->second->GetSession()->GetPlayer()->IsInWorld())
+        {
+            data << uint64(itr->second->GetGUID());
+            break;
+        }
+    }
+    plr->GetSession()->SendPacket(&data);
+}
diff --git a/src/server/game/TriniChat/IRCLog.cpp b/src/server/game/TriniChat/IRCLog.cpp
new file mode 100644
index 0000000..5fa5f32
--- /dev/null
+++ b/src/server/game/TriniChat/IRCLog.cpp
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCLog.h"
+#include "Config.h"
+#include "IRCClient.h"
+#include <stdarg.h>
+#include "World.h"
+
+IRCLog::IRCLog()
+{
+    std::string logsDir = sConfigMgr->GetStringDefault("LogsDir","");
+    std::string ircLogName = logsDir + "/IRC_";
+    std::string ircLogTimestamp = GetLogDateStr();
+        ircLogName += ircLogTimestamp +".log";
+    ircLogfile.open (ircLogName.c_str(), std::ios::app);
+}
+
+IRCLog::~IRCLog()
+{
+    ircLogfile.close();
+}
+// Was added because using the time for logs is very annoying... one log per day.. much cleaner looking..
+std::string IRCLog::GetLogDateStr() const
+{
+    time_t t = time(NULL);
+    tm* aTm = localtime(&t);
+    //       YYYY   year
+    //       MM     month (2 digits 01-12)
+    //       DD     day (2 digits 01-31)
+    //       HH     hour (2 digits 00-23)
+    //       MM     minutes (2 digits 00-59)
+    //       SS     seconds (2 digits 00-59)
+    char buf[20];
+    snprintf(buf,20,"%04d-%02d-%02d",aTm->tm_year+1900,aTm->tm_mon+1,aTm->tm_mday);
+    return std::string(buf);
+}
+
+std::string IRCLog::GetLogDateTimeStr() const
+{
+    time_t t = time(NULL);
+    tm* aTm = localtime(&t);
+    //       YYYY   year
+    //       MM     month (2 digits 01-12)
+    //       DD     day (2 digits 01-31)
+    //       HH     hour (2 digits 00-23)
+    //       MM     minutes (2 digits 00-59)
+    //       SS     seconds (2 digits 00-59)
+    char buf[30];
+    snprintf(buf,30,"[ %04d-%02d-%02d ] [ %02d:%02d:%02d ]",aTm->tm_year+1900,aTm->tm_mon+1,aTm->tm_mday,aTm->tm_hour,aTm->tm_min,aTm->tm_sec);
+    return std::string(buf);
+}
+
+void IRCLog::WriteLog(const char *what, ...)
+{
+    va_list ap;
+    char tmpoutp[1024];
+    va_start(ap, what);
+    vsnprintf(tmpoutp, 1024, what, ap);
+    va_end(ap);
+    ircLogfile << tmpoutp;
+    ircLogfile << "\n";
+    ircLogfile.flush();
+}
diff --git a/src/server/game/TriniChat/IRCLog.h b/src/server/game/TriniChat/IRCLog.h
new file mode 100644
index 0000000..ac6dff0
--- /dev/null
+++ b/src/server/game/TriniChat/IRCLog.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _IRC_LOG_H
+#define _IRC_LOG_H
+
+#include "Common.h"
+#include <fstream>
+
+class IRCLog
+{
+    public:
+        IRCLog();
+        ~IRCLog();
+
+    public:
+        void WriteLog(const char *what, ...);
+        std::string GetLogDateStr() const;
+        std::string GetLogDateTimeStr() const;
+    private:
+        std::ofstream ircLogfile;
+};
+#endif
diff --git a/src/server/game/TriniChat/IRCSock.cpp b/src/server/game/TriniChat/IRCSock.cpp
new file mode 100644
index 0000000..e3bde2b
--- /dev/null
+++ b/src/server/game/TriniChat/IRCSock.cpp
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCClient.h"
+#define MAXDATASIZE 512
+#include <fcntl.h>
+
+#include <stdio.h>
+#include <sys/types.h>
+
+
+#define _UNICODE
+
+#ifdef _MBCS
+#undef _MBCS
+#endif
+
+bool IRCClient::InitSock()
+{
+    #ifdef _WIN32
+    WSADATA wsaData;                                        //WSAData
+    if (WSAStartup(MAKEWORD(2,0),&wsaData) != 0)
+    {
+        TC_LOG_ERROR("misc", "IRC Error: Winsock Initialization Error");
+        return false;
+    }
+    #endif
+    if ((sIRC->SOCKET = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)
+    {
+        TC_LOG_ERROR("misc", "IRC Error: Socket Error");
+        return false;
+    }
+    int on = 1;
+    if (setsockopt (sIRC->SOCKET, SOL_SOCKET, SO_REUSEADDR, (const char*) &on, sizeof (on)) == -1)
+    {
+        TC_LOG_ERROR("misc", "IRC Error: Invalid Socket");
+        return false;
+    }
+    #ifdef _WIN32
+    u_long iMode = 0;
+    ioctlsocket(sIRC->SOCKET, FIONBIO, &iMode);
+    #else
+    fcntl(sIRC->SOCKET, F_SETFL, O_NONBLOCK);                // set to non-blocking
+    fcntl(sIRC->SOCKET, F_SETFL, O_ASYNC);                   // set to asynchronous I/O
+    #endif
+    return true;
+}
+
+bool IRCClient::Connect(const char *cHost, int nPort)
+{
+    sIRC->Connected = false;
+    struct hostent *he;
+    if ((he=gethostbyname(cHost)) == NULL)
+    {
+        TC_LOG_ERROR("misc", "IRCLIENT: Could not resolve host: %s", cHost);
+        return false;
+    }
+    struct sockaddr_in their_addr;
+    their_addr.sin_family = AF_INET;
+    their_addr.sin_port = htons(nPort);
+    their_addr.sin_addr = *((struct in_addr *)he->h_addr);
+    memset(&(their_addr.sin_zero), '\0', 8);
+    if (::connect(sIRC->SOCKET, (struct sockaddr *)&their_addr, sizeof(struct sockaddr)) == -1)
+    {
+        TC_LOG_ERROR("misc", "IRCLIENT: Cannot connect to %s", cHost);
+        return false;
+    }
+    sIRC->Connected = true;
+    return true;
+}
+
+bool IRCClient::Login(std::string sNick, std::string sUser, std::string sPass)
+{
+    char hostname[128];
+    gethostname(hostname, sizeof(hostname));
+    if (SendIRC("HELLO"))
+        if (SendIRC("PASS " + sPass))
+            if (SendIRC("NICK " + sNick))
+                if (SendIRC("USER " + sUser + " " + (std::string)hostname + " TriniChat :TriniChat "+sIRC->_Mver.c_str()))
+                    return true;
+    return false;
+}
+
+bool IRCClient::SendData(const char *data)
+{
+    if (sIRC->Connected)
+    {
+        if (send(sIRC->SOCKET, data, strlen(data), 0) == -1)
+        {
+            TC_LOG_ERROR("misc", "IRC Error: Socket Receieve ** \n");
+            return false;
+        }
+    }
+    return true;
+}
+
+bool IRCClient::SendIRC(std::string data)
+{
+    std::string RealData = data + "\n";
+    return SendData(RealData.c_str());
+}
+
+void IRCClient::Disconnect()
+{
+    if (sIRC->SOCKET)
+    {
+        #ifdef _WIN32
+        closesocket(sIRC->SOCKET);
+        #else
+        close(sIRC->SOCKET);
+        #endif
+    }
+}
+
+void IRCClient::SockRecv()
+{
+    char szBuffer[MAXDATASIZE];
+
+    memset(szBuffer, 0, MAXDATASIZE);
+
+    int nBytesRecv = ::recv(sIRC->SOCKET, szBuffer, MAXDATASIZE - 1, 0);
+    if (nBytesRecv == -1)
+    {
+        TC_LOG_ERROR("misc", "Connection lost.");
+        sIRC->Connected = false;
+    }
+    else
+    {
+        if (-1 == nBytesRecv)
+        {
+            TC_LOG_ERROR("misc", "Error occurred while receiving from socket.");
+        }
+        else
+        {
+            std::string reply;
+            std::istringstream iss(szBuffer);
+            while (getline(iss, reply))
+            {
+                Handle_IRC(reply);
+            }
+        }
+    }
+}
diff --git a/src/server/game/TriniChat/MCS_OnlinePlayers.cpp b/src/server/game/TriniChat/MCS_OnlinePlayers.cpp
new file mode 100644
index 0000000..5bc8074
--- /dev/null
+++ b/src/server/game/TriniChat/MCS_OnlinePlayers.cpp
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "MCS_OnlinePlayers.h"
+
+#include "MapManager.h"
+#include "ObjectMgr.h"
+#include "Config.h"
+#include "WorldSession.h"
+
+mcs_OnlinePlayers::mcs_OnlinePlayers() { CD = NULL; }
+
+mcs_OnlinePlayers::mcs_OnlinePlayers(_CDATA *_CD)
+{
+    //create a new instance of data struct and copy its data
+    CD = new _CDATA();
+    CD->CMD = _CD->CMD;
+    CD->FROM = _CD->FROM;
+    CD->PARAMS = _CD->PARAMS;
+    CD->PCOUNT = _CD->PCOUNT;
+    CD->USER = _CD->USER;
+    CD->TYPE = _CD->TYPE;
+}
+
+mcs_OnlinePlayers::~mcs_OnlinePlayers()
+{
+    if (CD)
+        delete CD;
+}
+
+void mcs_OnlinePlayers::run()
+{
+    int OnlineCount = 0;
+    std::string IRCOut = "";
+    HashMapHolder<Player>::MapType const& m = ObjectAccessor::GetPlayers();
+    for (HashMapHolder<Player>::MapType::const_iterator itr = m.begin(); itr != m.end(); ++itr)
+    {
+        if (itr->second && itr->second->GetSession()->GetPlayer() && itr->second->GetSession()->GetPlayer()->IsInWorld())
+        {
+            OnlineCount++;
+            Player *plr = itr->second->GetSession()->GetPlayer();
+            std::string ChatTag = " ";
+            switch(plr->GetSession()->GetSecurity())
+            {
+                case SEC_PLAYER: ChatTag.append(""); break;
+                case SEC_MODERATOR: ChatTag.append("\0037" + sIRC->ojGM1); break;
+                case SEC_GAMEMASTER: ChatTag.append("\0037" + sIRC->ojGM2); break;
+                case SEC_ADMINISTRATOR: ChatTag.append("\0037" + sIRC->ojGM3); break;
+                case SEC_CONSOLE: ChatTag.append("\0037" + sIRC->ojGM4); break;
+            }
+            if (plr->isAFK())
+                ChatTag.append("\002\0037<AFK>\003\002");
+            else if (plr->isDND())
+                ChatTag.append("\002\0037<DND>\003\002");
+            switch (plr->GetTeam())
+            {
+                case 67:ChatTag.append("\0034");break;      //horde
+                case 469:ChatTag.append("\00312");break;    //alliance
+            }
+
+            IRCOut.append(IRCCmd::MakeMsg("%s\002%s\003\017\002(%d)\002\017", ChatTag.c_str(), plr->GetName().c_str(), plr->getLevel()));
+
+            // after XX players have been added to the string
+            // output to irc and reset for the next XX
+            if (OnlineCount % sIRC->onlrslt == 0)
+            {
+                sIRC->Send_IRC_Channel(IRCCmd::ChanOrPM(CD), IRCCmd::MakeMsg("\002 %s", IRCOut.c_str()), true, CD->TYPE.c_str());
+                IRCOut = "";
+                std::this_thread::sleep_for(std::chrono::milliseconds(1000));
+            }
+        }
+    }
+    // Remainder in IRCOUT && Total plyersonline
+    sIRC->Send_IRC_Channel(IRCCmd::ChanOrPM(CD), IRCCmd::MakeMsg("\002Players Online(%d):\017 %s", OnlineCount, IRCOut.c_str()), true, CD->TYPE);
+
+    sIRC->Script_Lock[MCS_Players_Online] = false;
+}
diff --git a/src/server/game/TriniChat/MCS_OnlinePlayers.h b/src/server/game/TriniChat/MCS_OnlinePlayers.h
new file mode 100644
index 0000000..700d730
--- /dev/null
+++ b/src/server/game/TriniChat/MCS_OnlinePlayers.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _IRC_CLIENT_ONLINE
+#define _IRC_CLIENT_ONLINE
+
+#include "IRCClient.h"
+#include "IRCCmd.h"
+
+class mcs_OnlinePlayers
+{
+    public:
+        mcs_OnlinePlayers();
+        mcs_OnlinePlayers(_CDATA *_CD);
+        ~mcs_OnlinePlayers();
+        void run();
+    public:
+        _CDATA *CD;
+};
+
+#endif
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index e1fc737..6d9b6e9 100644
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -67,11 +67,11 @@
 // Prepatch by LordPsyan
 // 01
 // 02
-// 03
+#include "IRCClient.h"
 // 04
 // 05
 // 06
-// 07
+#include "../../scripts/Custom/TemplateNPC.h"
 // 08
 // 09
 // 10
@@ -871,6 +871,18 @@ void World::LoadConfigSettings(bool reload)
         TC_LOG_ERROR("server.loading", "MinPetitionSigns (%i) must be in range 0..9. Set to 9.", m_int_configs[CONFIG_MIN_PETITION_SIGNS]);
         m_int_configs[CONFIG_MIN_PETITION_SIGNS] = 9;
     }
+    rate_values[RATE_PVP_RANK_EXTRA_HONOR] = sConfigMgr->GetFloatDefault("PvPRank.Rate.ExtraHonor", 1);
+    std::string s_pvp_ranks = sConfigMgr->GetStringDefault("PvPRank.HKPerRank", "10,50,100,200,450,750,1300,2000,3500,6000,9500,15000,21000,30000");
+    char *c_pvp_ranks = const_cast<char*>(s_pvp_ranks.c_str());
+    for (int i = 0; i !=HKRANKMAX; i++)
+    {
+        if (i==0)
+            pvp_ranks[0] = 0;
+        else if (i==1)
+            pvp_ranks[1] = atoi(strtok (c_pvp_ranks, ","));
+        else
+            pvp_ranks[i] = atoi(strtok (NULL, ","));
+    }
 
     m_int_configs[CONFIG_GM_LOGIN_STATE]        = sConfigMgr->GetIntDefault("GM.LoginState", 2);
     m_int_configs[CONFIG_GM_VISIBLE_STATE]      = sConfigMgr->GetIntDefault("GM.Visible", 2);
@@ -1075,8 +1087,18 @@ void World::LoadConfigSettings(bool reload)
     m_float_configs[CONFIG_ARENA_LOSE_RATING_MODIFIER]               = sConfigMgr->GetFloatDefault("Arena.ArenaLoseRatingModifier", 24.0f);
     m_float_configs[CONFIG_ARENA_MATCHMAKER_RATING_MODIFIER]         = sConfigMgr->GetFloatDefault("Arena.ArenaMatchmakerRatingModifier", 24.0f);
 
+    m_bool_configs[CONFIG_ARENA_1V1_ENABLE]                             = sConfigMgr->GetBoolDefault("Arena.1v1.Enable", true);
+    m_bool_configs[CONFIG_ARENA_1V1_ANNOUNCER]                         = sConfigMgr->GetBoolDefault("Arena.1v1.Announcer", false);
+    m_int_configs[CONFIG_ARENA_1V1_MIN_LEVEL]                         = sConfigMgr->GetIntDefault("Arena.1v1.MinLevel", 80);
+    m_int_configs[CONFIG_ARENA_1V1_COSTS]                             = sConfigMgr->GetIntDefault("Arena.1v1.Costs", 400000);
+    m_bool_configs[CONFIG_ARENA_1V1_VENDOR_RATING]                     = sConfigMgr->GetBoolDefault("Arena.1v1.VendorRating", false);
+    m_float_configs[CONFIG_ARENA_1V1_ARENAPOINTS_MULTI]                 = sConfigMgr->GetFloatDefault("Arena.1v1.ArenaPointsMulti", 0.64f);
+    m_bool_configs[CONFIG_ARENA_1V1_BLOCK_FORBIDDEN_TALENTS]         = sConfigMgr->GetBoolDefault("Arena.1v1.BlockForbiddenTalents", true);
+
     m_bool_configs[CONFIG_OFFHAND_CHECK_AT_SPELL_UNLEARN]            = sConfigMgr->GetBoolDefault("OffhandCheckAtSpellUnlearn", true);
 
+    m_bool_configs[CROSSFACTION_SYSTEM_BATTLEGROUNDS] = sConfigMgr->GetBoolDefault("CrossFactionSystem.Battlegrounds", true);
+
     m_int_configs[CONFIG_CREATURE_PICKPOCKET_REFILL] = sConfigMgr->GetIntDefault("Creature.PickPocketRefillDelay", 10 * MINUTE);
 
     if (int32 clientCacheId = sConfigMgr->GetIntDefault("ClientCacheVersion", 0))
@@ -1143,24 +1165,28 @@ void World::LoadConfigSettings(bool reload)
     // Prepatch by LordPsyan
     // 01
     // 02
-    // 03
+    m_float_configs[CONFIG_SPEED_GAME] = sConfigMgr->GetFloatDefault("Custom.SpeedGame", 1.0f);
+    m_bool_configs[CONFIG_NO_CAST_TIME] = sConfigMgr->GetBoolDefault("Custom.NoCastTime", false);
+    m_bool_configs[CONFIG_HURT_IN_REAL_TIME] = sConfigMgr->GetBoolDefault("Custom.HurtInRealTime", false);
     // 04
     // 05
     // 06
-    // 07
+    m_bool_configs[CONFIG_FAST_FISHING] = sConfigMgr->GetBoolDefault("Custom.FastFishing", false);
     // 08
     // 09
     // 10
-    // 11
+    m_bool_configs[CONFIG_GAIN_HONOR_GUARD] = sConfigMgr->GetBoolDefault("Custom.GainHonorOnGuardKill", false);
+    m_bool_configs[CONFIG_GAIN_HONOR_ELITE] = sConfigMgr->GetBoolDefault("Custom.GainHonorOnEliteKill", false);
     // 12
     // 13
     // 14
-    // 15
+    m_float_configs[CONFIG_ATTACKSPEED_PLAYER] = sConfigMgr->GetFloatDefault("Custom.AttackSpeedForPlayer", 1.0f);
+    m_float_configs[CONFIG_ATTACKSPEED_ALL] = sConfigMgr->GetFloatDefault("Custom.AttackSpeedForMobs", 1.0f);
     // 16
     // 17
     // 18
     // 19
-    // 20
+    m_float_configs[CONFIG_RESPAWNSPEED] = sConfigMgr->GetFloatDefault("Custom.RespawnSpeed", 1.0f);
     // Visit http://www.realmsofwarcraft.com/bb for forums and information
     //
     // End of prepatch
@@ -1297,14 +1323,38 @@ void World::LoadConfigSettings(bool reload)
         m_timers[WUPDATE_AUTOBROADCAST].Reset();
     }
 
+    /** World of Warcraft Armory **/
+    m_bool_configs[CONFIG_ARMORY_ENABLE] = sConfigMgr->GetBoolDefault("Armory.Enable", true);
+    /** World of Warcraft Armory **/
+
     // MySQL ping time interval
     m_int_configs[CONFIG_DB_PING_INTERVAL] = sConfigMgr->GetIntDefault("MaxPingTime", 30);
 
+     // External Mail
+    m_bool_configs[CONFIG_EXTERNAL_MAIL_ENABLE] = sConfigMgr->GetBoolDefault("External.Mail.Enable", false);
+    m_int_configs[CONFIG_EXTERNAL_MAIL_INTERVAL] = sConfigMgr->GetIntDefault("External.Mail.Interval", 1);
+
     // misc
     m_bool_configs[CONFIG_PDUMP_NO_PATHS] = sConfigMgr->GetBoolDefault("PlayerDump.DisallowPaths", true);
     m_bool_configs[CONFIG_PDUMP_NO_OVERWRITE] = sConfigMgr->GetBoolDefault("PlayerDump.DisallowOverwrite", true);
     m_bool_configs[CONFIG_UI_QUESTLEVELS_IN_DIALOGS] = sConfigMgr->GetBoolDefault("UI.ShowQuestLevelsInDialogs", false);
 
+    //VAS
+    m_int_configs[VAS_VasDebug] = sConfigMgr->GetIntDefault ("VAS.AutoBalance.Debug", 1);
+    m_int_configs[VAS_AutoInstance] = sConfigMgr->GetIntDefault ("VAS.AutoBalance.AutoInstance", 1);
+    m_int_configs[VAS_PlayerChangeNotify] = sConfigMgr->GetIntDefault ("VAS.AutoBalance.PlayerChangeNotify", 1);
+
+    m_float_configs[VAS_Config_xPlayer] = sConfigMgr->GetFloatDefault("VAS.AutoBalance.XPlayer", 1.0f);
+    m_float_configs[VAS_Min_D_Mod] = sConfigMgr->GetFloatDefault("Min.D.Mod", 0.10f);
+    m_float_configs[VAS_Min_HP_Mod] = sConfigMgr->GetFloatDefault("Min.HP.Mod", 0.20f);
+
+    std::string VAS_AutoBalance_40_Name = sConfigMgr->GetStringDefault("VAS.AutoBalance.40.Name", "");
+    std::string VAS_AutoBalance_25_Name = sConfigMgr->GetStringDefault("VAS.AutoBalance.25.Name", "");
+    std::string VAS_AutoBalance_20_Name = sConfigMgr->GetStringDefault("VAS.AutoBalance.20.Name", "");
+    std::string VAS_AutoBalance_10_Name = sConfigMgr->GetStringDefault("VAS.AutoBalance.10.Name", "");
+    std::string VAS_AutoBalance_5_Name = sConfigMgr->GetStringDefault("VAS.AutoBalance.5.Name", "");
+    std::string VAS_AutoBalance_2_Name = sConfigMgr->GetStringDefault("VAS.AutoBalance.2.Name", "");
+
     // Wintergrasp battlefield
     m_bool_configs[CONFIG_WINTERGRASP_ENABLE] = sConfigMgr->GetBoolDefault("Wintergrasp.Enable", false);
     m_int_configs[CONFIG_WINTERGRASP_PLR_MAX] = sConfigMgr->GetIntDefault("Wintergrasp.PlayerMax", 100);
@@ -1365,6 +1415,168 @@ void World::LoadConfigSettings(bool reload)
     // call ScriptMgr if we're reloading the configuration
     if (reload)
         sScriptMgr->OnConfigLoad(reload);
+    sScriptMgr->OnConfigLoad(reload);
+
+    // IRC Configurations.
+    int ConfCnt = 0;
+    sIRC->_chan_count = 0;
+    if (sConfigMgr->GetIntDefault("irc.active", 1) == 1)
+      sIRC->Active = true;
+    else
+      sIRC->Active = false;
+
+    sIRC->_Host = sConfigMgr->GetStringDefault("irc.host", "irc.freenode.net");
+    if (sIRC->_Host.size() > 0)
+        ConfCnt++;
+    sIRC->_Mver = "Version 4.1";
+    sIRC->_Port = sConfigMgr->GetIntDefault("irc.port", 6667);
+    sIRC->_User = sConfigMgr->GetStringDefault("irc.user", "TriniChat");
+    sIRC->_Pass = sConfigMgr->GetStringDefault("irc.pass", "Services Password");
+    sIRC->_Nick = sConfigMgr->GetStringDefault("irc.nick", "TriniChat");
+    sIRC->_Auth = sConfigMgr->GetIntDefault("irc.auth", 0);
+    sIRC->_Auth_Nick = sConfigMgr->GetStringDefault("irc.auth.nick", "AuthNick");
+    sIRC->_ICC = sConfigMgr->GetStringDefault("irc.icc", "001");
+    sIRC->_defchan = sConfigMgr->GetStringDefault("irc.defchan", "lobby");
+    sIRC->_ldefc = sConfigMgr->GetIntDefault("irc.ldef", 0);
+    sIRC->_wct = sConfigMgr->GetIntDefault("irc.wct", 30000);
+    sIRC->ajoin = sConfigMgr->GetIntDefault("irc.ajoin", 0);
+    sIRC->_staffLink = sConfigMgr->GetIntDefault("irc.staff_link", 1);
+    sIRC->_staffChan = sConfigMgr->GetStringDefault("irc.staff_chan", "staff");
+    sIRC->_bot_names = sConfigMgr->GetStringDefault("irc.ignore_bots", "");
+    sIRC->ajchan = sConfigMgr->GetStringDefault("irc.ajchan", "world");
+    sIRC->onlrslt = sConfigMgr->GetIntDefault("irc.online.result", 10);
+    sIRC->BOTMASK = sConfigMgr->GetIntDefault("Botmask", 0);
+    sIRC->TICMASK = sConfigMgr->GetIntDefault("Ticketmask", 0);
+    sIRC->logfile = sConfigMgr->GetStringDefault("irc.logfile.prefix", "IRC_");
+    sIRC->logmask = sConfigMgr->GetIntDefault("irc.logmask", 0);
+    sIRC->logchan = sConfigMgr->GetStringDefault("irc.logchannel","");
+    sIRC->logchanpw = sConfigMgr->GetStringDefault("irc.logchannelpw","");
+    for (int i = 1; i < MAX_CONF_CHANNELS;i++)
+    {
+        std::ostringstream ss;
+        ss << i;
+        std::string ci = "irc.chan_" + ss.str();
+        std::string pw = "irc.pass_" + ss.str();
+        std::string t_chan = sConfigMgr->GetStringDefault(ci.c_str(), "");
+        if (t_chan.size() > 0)
+        {
+            sIRC->_chan_count++;
+            sIRC->_irc_chan[sIRC->_chan_count] = t_chan;
+            sIRC->_irc_pass[sIRC->_chan_count] = sConfigMgr->GetStringDefault(pw.c_str(), t_chan.c_str());
+            ci = "wow.chan_" + ss.str();
+            sIRC->_wow_chan[sIRC->_chan_count] = sConfigMgr->GetStringDefault(ci.c_str(), t_chan.c_str());
+        }
+    }
+    sIRC->JoinMsg = sConfigMgr->GetStringDefault("irc.joinmsg", "TriniChat $Ver for Trinitycore 3.3.x");
+    sIRC->RstMsg  = sConfigMgr->GetStringDefault("irc.rstmsg", "TriniChat Is Restarting, I Will Be Right Back!");
+    sIRC->kikmsg = sConfigMgr->GetStringDefault("irc.kickmsg", "Do Not Kick Me Again, Severe Actions Will Be Taken!");
+
+    // IRC LINES
+    sIRC->ILINES[WOW_IRC] = sConfigMgr->GetStringDefault("chat.wow_irc", "\003<WoW>[\002$Name($Level)\002\003] $Msg");
+    sIRC->ILINES[IRC_WOW] = sConfigMgr->GetStringDefault("chat.irc_wow", "\003<IRC>[$Name]: $Msg");
+    sIRC->ILINES[JOIN_WOW] = sConfigMgr->GetStringDefault("chat.join_wow", "\00312>>\00304 $Name \003Joined The Channel!");
+    sIRC->ILINES[JOIN_IRC] = sConfigMgr->GetStringDefault("chat.join_irc", "\003[$Name]: Has Joined IRC!");
+    sIRC->ILINES[LEAVE_WOW] = sConfigMgr->GetStringDefault("chat.leave_wow", "\00312<<\00304 $Name \003Left The Channel!");
+    sIRC->ILINES[LEAVE_IRC] = sConfigMgr->GetStringDefault("chat.leave_irc", "\003[$Name]: Has Left IRC!");
+    sIRC->ILINES[CHANGE_NICK] = sConfigMgr->GetStringDefault("chat.change_nick", "\003<> $Name Is Now Known As $NewName!");
+
+    // TriniChat Options
+    sIRC->_MCA = sConfigMgr->GetIntDefault("irc.maxattempt", 10);
+    sIRC->_autojoinkick = sConfigMgr->GetIntDefault("irc.autojoin_kick", 1);
+    sIRC->_cmd_prefx = sConfigMgr->GetStringDefault("irc.command_prefix", ".");
+
+    sIRC->_op_gm = sConfigMgr->GetIntDefault("irc.op_gm_login", 0);
+    sIRC->_op_gm_lev = sConfigMgr->GetIntDefault("irc.op_gm_level", 3);
+
+    // Misc Options
+    sIRC->games = sConfigMgr->GetIntDefault("irc.fun.games", 0);
+    sIRC->gmlog = sConfigMgr->GetIntDefault("irc.gmlog", 1);
+    sIRC->Status = sConfigMgr->GetStringDefault("irc.StatusChannel", "");
+    sIRC->Statuspw = sConfigMgr->GetStringDefault("irc.StatusChannelPW","");
+    sIRC->anchn = sConfigMgr->GetStringDefault("irc.AnnounceChannel", "");
+    sIRC->anchnpw = sConfigMgr->GetStringDefault("irc.AnnounceChannelPW","");
+    sIRC->ticann = sConfigMgr->GetStringDefault("irc.Tickets", "");
+    sIRC->ticannpw = sConfigMgr->GetStringDefault("irc.TicketsPW","");
+    sIRC->autoanc = sConfigMgr->GetIntDefault("irc.auto.announce", 30);
+    sIRC->ojGM1 = sConfigMgr->GetStringDefault("irc.gm1", "[Moderator]");
+    sIRC->ojGM2 = sConfigMgr->GetStringDefault("irc.gm2", "[GameMaster]");
+    sIRC->ojGM3 = sConfigMgr->GetStringDefault("irc.gm3", "[Developer]");
+    sIRC->ojGM4 = sConfigMgr->GetStringDefault("irc.gm4", "[Owner]");
+    // REQUIRED GM LEVEL
+    QueryResult result = WorldDatabase.PQuery("SELECT `Command`, `gmlevel` FROM `irc_commands` ORDER BY `Command`");
+    if (result)
+    {
+        Field *fields = result->Fetch();
+        for (uint64 i=0; i < result->GetRowCount(); i++)
+        {
+            //TODO: ELSEIF? STRCMP?
+            std::string command = fields[0].GetCString();
+            uint32 gmlvl = fields[1].GetUInt32();
+            if (command == "acct") sIRC->CACCT = gmlvl;
+            if (command == "ban") sIRC->CBAN = gmlvl;
+            if (command == "char") sIRC->CCHAN = gmlvl;
+            if (command == "char") sIRC->CCHAR = gmlvl;
+            if (command == "fun") sIRC->CFUN = gmlvl;
+            if (command == "help") sIRC->CHELP = gmlvl;
+            if (command == "inchan") sIRC->CINCHAN = gmlvl;
+            if (command == "info") sIRC->CINFO = gmlvl;
+            if (command == "item") sIRC->CITEM = gmlvl;
+            if (command == "jail") sIRC->CJAIL = gmlvl;
+            if (command == "kick") sIRC->CKICK = gmlvl;
+            if (command == "kill") sIRC->_KILL = gmlvl;
+            if (command == "level") sIRC->CLEVEL = gmlvl;
+            if (command == "lookup") sIRC->CLOOKUP = gmlvl;
+            if (command == "money") sIRC->CMONEY = gmlvl;
+            if (command == "mute") sIRC->CMUTE = gmlvl;
+            if (command == "online") sIRC->CONLINE = gmlvl;
+            if (command == "pm") sIRC->CPM = gmlvl;
+            if (command == "reconnect") sIRC->CRECONNECT = gmlvl;
+            if (command == "reload") sIRC->CRELOAD = gmlvl;
+            if (command == "restart") sIRC->CSHUTDOWN = gmlvl;
+            if (command == "revive") sIRC->CREVIVE = gmlvl;
+            if (command == "saveall") sIRC->CSAVEALL = gmlvl;
+            if (command == "server") sIRC->CSERVERCMD = gmlvl;
+            if (command == "shutdown") sIRC->CSHUTDOWN = gmlvl;
+            if (command == "spell") sIRC->CSPELL = gmlvl;
+            if (command == "sysmsg") sIRC->CSYSMSG = gmlvl;
+            if (command == "tele") sIRC->CTELE = gmlvl;
+            if (command == "top") sIRC->CTOP = gmlvl;
+            if (command == "who") sIRC->CWHO = gmlvl;
+            result->NextRow();
+        }
+    }
+    else
+    {
+        sIRC->CACCT     = 3;
+        sIRC->CBAN      = 3;
+        sIRC->CCHAN     = 3;
+        sIRC->CCHAR     = 3;
+        sIRC->CFUN      = 3;
+        sIRC->CHELP     = 3;
+        sIRC->CINCHAN   = 3;
+        sIRC->CINFO     = 3;
+        sIRC->CITEM     = 3;
+        sIRC->CJAIL     = 3;
+        sIRC->CKICK     = 3;
+        sIRC->_KILL     = 3;
+        sIRC->CLEVEL    = 3;
+        sIRC->CLOOKUP   = 3;
+        sIRC->CMONEY    = 3;
+        sIRC->CMUTE     = 3;
+        sIRC->CONLINE   = 3;
+        sIRC->CPM       = 3;
+        sIRC->CRECONNECT= 3;
+        sIRC->CRELOAD   = 3;
+        sIRC->CREVIVE   = 3;
+        sIRC->CSAVEALL  = 3;
+        sIRC->CSERVERCMD= 3;
+        sIRC->CSHUTDOWN = 3;
+        sIRC->CSPELL    = 3;
+        sIRC->CSYSMSG   = 3;
+        sIRC->CTELE     = 3;
+        sIRC->CTOP      = 3;
+        sIRC->CWHO      = 3;
+    }
 }
 
 extern void LoadGameObjectModelList(std::string const& dataPath);
@@ -1390,6 +1602,7 @@ void World::SetInitialWorldSettings()
 
     ///- Initialize config settings
     LoadConfigSettings();
+    TC_LOG_ERROR("misc" "Loading TrinityCore configuration settings...","");
 
     ///- Initialize Allowed Security Level
     LoadDBAllowedSecurityLevel();
@@ -1816,6 +2029,10 @@ void World::SetInitialWorldSettings()
     TC_LOG_INFO("server.loading", "Returning old mails...");
     sObjectMgr->ReturnOrDeleteOldMails(false);
 
+    // Loads the jail conf out of the database
+    TC_LOG_INFO("server.loading", "Loading JailConfing...");    
+    sObjectMgr->LoadJailConf();
+
     TC_LOG_INFO("server.loading", "Loading Autobroadcasts...");
     LoadAutobroadcasts();
 
@@ -1854,6 +2071,9 @@ void World::SetInitialWorldSettings()
     LoginDatabase.PExecute("INSERT INTO uptime (realmid, starttime, uptime, revision) VALUES(%u, %u, 0, '%s')",
                             realmID, uint32(m_startTime), GitRevision::GetFullVersion());       // One-time query
 
+    static uint32 autoanc = 1;
+    autoanc = sIRC->autoanc;
+
     m_timers[WUPDATE_WEATHERS].SetInterval(1*IN_MILLISECONDS);
     m_timers[WUPDATE_AUCTIONS].SetInterval(MINUTE*IN_MILLISECONDS);
     m_timers[WUPDATE_AUCTIONS_PENDING].SetInterval(250);
@@ -1871,6 +2091,8 @@ void World::SetInitialWorldSettings()
 
     m_timers[WUPDATE_PINGDB].SetInterval(getIntConfig(CONFIG_DB_PING_INTERVAL)*MINUTE*IN_MILLISECONDS);    // Mysql ping time in minutes
 
+    m_timers[WUPDATE_AUTOANC].SetInterval(autoanc*MINUTE*1000);
+
     //to set mailtimer to return mails every day between 4 and 5 am
     //mailtimer is increased when updating auctions
     //one second is 1000 -(tested on win system)
@@ -1878,7 +2100,9 @@ void World::SetInitialWorldSettings()
     tm localTm;
     localtime_r(&m_gameTime, &localTm);
     mail_timer = ((((localTm.tm_hour + 20) % 24)* HOUR * IN_MILLISECONDS) / m_timers[WUPDATE_AUCTIONS].GetInterval());
-                                                            //1440
+
+    extmail_timer.SetInterval(m_int_configs[CONFIG_EXTERNAL_MAIL_INTERVAL] * MINUTE * IN_MILLISECONDS);
+
     mail_timer_expires = ((DAY * IN_MILLISECONDS) / (m_timers[WUPDATE_AUCTIONS].GetInterval()));
     TC_LOG_INFO("server.loading", "Mail timer set to: " UI64FMTD ", mail return is called every " UI64FMTD " minutes", uint64(mail_timer), uint64(mail_timer_expires));
 
@@ -1896,6 +2120,9 @@ void World::SetInitialWorldSettings()
     // Delete all characters which have been deleted X days before
     Player::DeleteOldCharacters();
 
+    TC_LOG_INFO("server.loading", "Loading VAS Autobalance...");
+    sScriptMgr->SetInitialWorldSettings();
+
     TC_LOG_INFO("server.loading", "Initialize AuctionHouseBot...");
     sAuctionBot->Initialize();
 
@@ -1950,6 +2177,25 @@ void World::SetInitialWorldSettings()
 
     LoadCharacterInfoStore();
 
+    TC_LOG_INFO("server.loading", "Loading Template Talents...");
+    sTemplateNpcMgr->LoadTalentsContainer();
+
+    // Load templates for Template NPC #2
+    TC_LOG_INFO("server.loading", "Loading Template Glyphs...");
+    sTemplateNpcMgr->LoadGlyphsContainer();
+
+    // Load templates for Template NPC #3
+    TC_LOG_INFO("server.loading", "Loading Template Gear for Humans...");
+    sTemplateNpcMgr->LoadHumanGearContainer();
+
+    // Load templates for Template NPC #4
+    TC_LOG_INFO("server.loading", "Loading Template Gear for Alliances...");
+    sTemplateNpcMgr->LoadAllianceGearContainer();
+
+    // Load templates for Template NPC #5
+    TC_LOG_INFO("server.loading", "Loading Template Gear for Hordes...");
+    sTemplateNpcMgr->LoadHordeGearContainer();
+
     uint32 startupDuration = GetMSTimeDiffToNow(startupBegin);
 
     TC_LOG_INFO("server.worldserver", "World initialized in %u minutes %u seconds", (startupDuration / 60000), ((startupDuration % 60000) / 1000));
@@ -2110,6 +2356,17 @@ void World::Update(uint32 diff)
     if (m_gameTime > m_NextGuildReset)
         ResetGuildCap();
 
+     // Handle external mail
+    if (sWorld->getBoolConfig(CONFIG_EXTERNAL_MAIL_ENABLE))
+    {
+        extmail_timer.Update(diff);
+        if (extmail_timer.Passed())
+        {
+            WorldSession::SendExternalMails();
+            extmail_timer.Reset();
+        }
+    }
+
     /// <ul><li> Handle auctions when the timer has passed
     if (m_timers[WUPDATE_AUCTIONS].Passed())
     {
@@ -2254,6 +2511,12 @@ void World::Update(uint32 diff)
         WorldDatabase.KeepAlive();
     }
 
+    if (m_timers[WUPDATE_AUTOANC].Passed())
+    {
+        m_timers[WUPDATE_AUTOANC].Reset();
+        SendRNDBroadcastIRC();
+    }
+
     // update the instance reset times
     sInstanceSaveMgr->Update();
 
@@ -2871,6 +3134,20 @@ void World::SendAutoBroadcast()
     TC_LOG_DEBUG("misc", "AutoBroadcast: '%s'", msg.c_str());
 }
 
+void World::SendRNDBroadcastIRC()
+{
+    std::string msg;
+    QueryResult result = WorldDatabase.PQuery("SELECT `message` FROM `irc_autoannounce` ORDER BY RAND() LIMIT 1");
+    if (!result)
+        return;
+    msg = result->Fetch()[0].GetString();
+
+    sWorld->SendWorldText(6612,msg.c_str());
+    std::string ircchan = "#";
+    ircchan += sIRC->anchn;
+    sIRC->Send_IRC_Channel(ircchan, sIRC->MakeMsg("\00304,08\037/!\\\037\017\00304 Automatic System Message \00304,08\037/!\\\037\017 %s", "%s", msg.c_str()), true);
+}
+
 void World::UpdateRealmCharCount(uint32 accountId)
 {
     PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_COUNT);
diff --git a/src/server/game/World/World.h b/src/server/game/World/World.h
index 7a3e56c..fdcfca7 100644
--- a/src/server/game/World/World.h
+++ b/src/server/game/World/World.h
@@ -76,6 +76,7 @@ enum WorldTimers
     WUPDATE_EVENTS,
     WUPDATE_CLEANDB,
     WUPDATE_AUTOBROADCAST,
+    WUPDATE_AUTOANC,
     WUPDATE_MAILBOXQUEUE,
     WUPDATE_DELETECHARS,
     WUPDATE_AHBOT,
@@ -87,6 +88,7 @@ enum WorldTimers
 enum WorldBoolConfigs
 {
     CONFIG_DURABILITY_LOSS_IN_PVP = 0,
+    CROSSFACTION_SYSTEM_BATTLEGROUNDS,
     CONFIG_ADDON_CHANNEL,
     CONFIG_ALLOW_PLAYER_COMMANDS,
     CONFIG_CLEAN_CHARACTER_DB,
@@ -132,6 +134,10 @@ enum WorldBoolConfigs
     CONFIG_ARENA_QUEUE_ANNOUNCER_PLAYERONLY,
     CONFIG_ARENA_SEASON_IN_PROGRESS,
     CONFIG_ARENA_LOG_EXTENDED_INFO,
+    CONFIG_ARENA_1V1_ENABLE,
+    CONFIG_ARENA_1V1_ANNOUNCER,
+    CONFIG_ARENA_1V1_VENDOR_RATING,
+    CONFIG_ARENA_1V1_BLOCK_FORBIDDEN_TALENTS,
     CONFIG_OFFHAND_CHECK_AT_SPELL_UNLEARN,
     CONFIG_VMAP_INDOOR_CHECK,
     CONFIG_START_ALL_SPELLS,
@@ -148,6 +154,7 @@ enum WorldBoolConfigs
     CONFIG_DELETE_CHARACTER_TICKET_TRACE,
     CONFIG_DBC_ENFORCE_ITEM_ATTRIBUTES,
     CONFIG_PRESERVE_CUSTOM_CHANNELS,
+    CONFIG_ARMORY_ENABLE,
     CONFIG_PDUMP_NO_PATHS,
     CONFIG_PDUMP_NO_OVERWRITE,
     CONFIG_QUEST_IGNORE_AUTO_ACCEPT,
@@ -164,7 +171,8 @@ enum WorldBoolConfigs
     // Prepatch by LordPsyan
     // 01
     // 02
-    // 03
+    CONFIG_NO_CAST_TIME,
+    CONFIG_HURT_IN_REAL_TIME,
     // 04
     // 05
     // 06
@@ -172,7 +180,7 @@ enum WorldBoolConfigs
     // 08
     // 09
     // 10
-    // 11
+    CONFIG_FAST_FISHING,
     // 12
     // 13
     // 14
@@ -180,7 +188,9 @@ enum WorldBoolConfigs
     // 16
     // 17
     // 18
-    // 19
+    CONFIG_GAIN_HONOR_GUARD,
+    CONFIG_GAIN_HONOR_ELITE,
+    CONFIG_EXTERNAL_MAIL_ENABLE,
     // 20
     // Visit http://www.realmsofwarcraft.com/bb for forums and information
     //
@@ -206,6 +216,9 @@ enum WorldFloatConfigs
     CONFIG_CREATURE_FAMILY_ASSISTANCE_RADIUS,
     CONFIG_THREAT_RADIUS,
     CONFIG_CHANCE_OF_GM_SURVEY,
+    VAS_Config_xPlayer,
+    VAS_Min_D_Mod,
+    VAS_Min_HP_Mod,
     CONFIG_STATS_LIMITS_DODGE,
     CONFIG_STATS_LIMITS_PARRY,
     CONFIG_STATS_LIMITS_BLOCK,
@@ -217,19 +230,20 @@ enum WorldFloatConfigs
     // Prepatch by LordPsyan
     // 21
     // 22
-    // 23
+    CONFIG_SPEED_GAME,
     // 24
     // 25
     // 26
-    // 27
+    CONFIG_ATTACKSPEED_PLAYER,
+    CONFIG_ATTACKSPEED_ALL,
     // 28
     // 29
     // 30
-    // 31
+    CONFIG_RESPAWNSPEED,
     // 32
     // 33
     // 34
-    // 35
+    CONFIG_ARENA_1V1_ARENAPOINTS_MULTI,
     // 36
     // 37
     // 38
@@ -363,6 +377,8 @@ enum WorldIntConfigs
     CONFIG_ARENA_START_RATING,
     CONFIG_ARENA_START_PERSONAL_RATING,
     CONFIG_ARENA_START_MATCHMAKER_RATING,
+    CONFIG_ARENA_1V1_MIN_LEVEL,
+    CONFIG_ARENA_1V1_COSTS,
     CONFIG_MAX_WHO,
     CONFIG_HONOR_AFTER_DUEL,
     CONFIG_PVP_TOKEN_MAP_TYPE,
@@ -399,6 +415,9 @@ enum WorldIntConfigs
     CONFIG_WARDEN_CLIENT_BAN_DURATION,
     CONFIG_WARDEN_NUM_MEM_CHECKS,
     CONFIG_WARDEN_NUM_OTHER_CHECKS,
+    VAS_VasDebug,
+    VAS_AutoInstance,
+    VAS_PlayerChangeNotify,
     CONFIG_WINTERGRASP_PLR_MAX,
     CONFIG_WINTERGRASP_PLR_MIN,
     CONFIG_WINTERGRASP_PLR_MIN_LVL,
@@ -418,6 +437,7 @@ enum WorldIntConfigs
     CONFIG_BIRTHDAY_TIME,
     CONFIG_CREATURE_PICKPOCKET_REFILL,
     CONFIG_AHBOT_UPDATE_INTERVAL,
+    CONFIG_EXTERNAL_MAIL_INTERVAL,
     CONFIG_CHARTER_COST_GUILD,
     CONFIG_CHARTER_COST_ARENA_2v2,
     CONFIG_CHARTER_COST_ARENA_3v3,
@@ -511,6 +531,7 @@ enum Rates
     RATE_CORPSE_DECAY_LOOTED,
     RATE_INSTANCE_RESET_TIME,
     RATE_TARGET_POS_RECALCULATION_RANGE,
+    RATE_PVP_RANK_EXTRA_HONOR,
     RATE_DURABILITY_LOSS_ON_DEATH,
     RATE_DURABILITY_LOSS_DAMAGE,
     RATE_DURABILITY_LOSS_PARRY,
@@ -522,6 +543,26 @@ enum Rates
     MAX_RATES
 };
 
+enum HonorKillPvPRank
+{
+    HKRANK00,
+    HKRANK01,
+    HKRANK02,
+    HKRANK03,
+    HKRANK04,
+    HKRANK05,
+    HKRANK06,
+    HKRANK07,
+    HKRANK08,
+    HKRANK09,
+    HKRANK10,
+    HKRANK11,
+    HKRANK12,
+    HKRANK13,
+    HKRANK14,
+    HKRANKMAX
+};
+
 /// Can be used in SMSG_AUTH_RESPONSE packet
 enum BillingPlanFlags
 {
@@ -651,6 +692,9 @@ class World
         void AddSession(WorldSession* s);
         void SendAutoBroadcast();
         bool RemoveSession(uint32 id);
+
+        void SendRNDBroadcastIRC();
+
         /// Get the number of current active sessions
         void UpdateMaxSessionCounters();
         const SessionMap& GetAllSessions() const { return m_sessions; }
@@ -716,6 +760,14 @@ class World
         /// Get the path where data (dbc, maps) are stored on disk
         std::string const& GetDataPath() const { return m_dataPath; }
 
+     /// Return the Mob IDs to be Autobalanced
+        std::string GetVAS40() const { return VAS_AutoBalance_40_Name; }
+        std::string GetVAS25() const { return VAS_AutoBalance_25_Name; }
+        std::string GetVAS20() const { return VAS_AutoBalance_20_Name; }
+        std::string GetVAS10() const { return VAS_AutoBalance_10_Name; }
+        std::string GetVAS5() const { return VAS_AutoBalance_5_Name; }
+        std::string GetVAS2() const { return VAS_AutoBalance_2_Name; }
+
         /// When server started?
         time_t const& GetStartTime() const { return m_startTime; }
         /// What time is it?
@@ -750,6 +802,8 @@ class World
         bool SendZoneMessage(uint32 zone, WorldPacket* packet, WorldSession* self = nullptr, uint32 team = 0);
         void SendZoneText(uint32 zone, const char *text, WorldSession* self = nullptr, uint32 team = 0);
 
+        uint32 pvp_ranks[HKRANKMAX];
+
         /// Are we in the middle of a shutdown?
         bool IsShuttingDown() const { return m_ShutdownTimer > 0; }
         uint32 GetShutDownTimeLeft() const { return m_ShutdownTimer; }
@@ -891,6 +945,14 @@ class World
         uint32 m_ShutdownTimer;
         uint32 m_ShutdownMask;
 
+        std::string VAS_AutoBalance_40_Name;
+        std::string VAS_AutoBalance_25_Name;
+        std::string VAS_AutoBalance_20_Name;
+        std::string VAS_AutoBalance_10_Name;
+        std::string VAS_AutoBalance_5_Name;
+        std::string VAS_AutoBalance_2_Name;
+        std::string VAS_color;
+
         uint32 m_CleaningFlags;
 
         bool m_isClosed;
@@ -898,6 +960,7 @@ class World
         time_t m_startTime;
         time_t m_gameTime;
         IntervalTimer m_timers[WUPDATE_COUNT];
+        IntervalTimer extmail_timer;
         time_t mail_timer;
         time_t mail_timer_expires;
         uint32 m_updateTime, m_updateTimeSum;
diff --git a/src/server/scripts/CMakeLists.txt b/src/server/scripts/CMakeLists.txt
index 8b62e7d..f81e704 100644
--- a/src/server/scripts/CMakeLists.txt
+++ b/src/server/scripts/CMakeLists.txt
@@ -22,6 +22,9 @@ include(Commands/CMakeLists.txt)
 
 set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
+  Custom/npc_teleport.cpp
+  ../game/AI/ScriptedAI/sc_npc_teleport.cpp
+  ../game/AI/ScriptedAI/sc_npc_teleport.h
   ../game/AI/ScriptedAI/ScriptedEscortAI.cpp
   ../game/AI/ScriptedAI/ScriptedCreature.cpp
   ../game/AI/ScriptedAI/ScriptedFollowerAI.cpp
@@ -117,6 +120,7 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/game/Spells
   ${CMAKE_SOURCE_DIR}/src/server/game/Spells/Auras
   ${CMAKE_SOURCE_DIR}/src/server/game/Texts
+  ${CMAKE_SOURCE_DIR}/src/server/game/TriniChat
   ${CMAKE_SOURCE_DIR}/src/server/game/Tickets
   ${CMAKE_SOURCE_DIR}/src/server/game/Tools
   ${CMAKE_SOURCE_DIR}/src/server/game/Warden
diff --git a/src/server/scripts/Commands/cs_jail.cpp b/src/server/scripts/Commands/cs_jail.cpp
new file mode 100644
index 0000000..60e1812
--- /dev/null
+++ b/src/server/scripts/Commands/cs_jail.cpp
@@ -0,0 +1,390 @@
+/*
+ * Copyright (C) 2008-2015 TrinityCore <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+    /* Jail by LordPsyan (Original script by Warhead) */
+
+#include "Common.h"
+#include "Chat.h"
+#include "Language.h"
+#include "Pet.h"
+#include "Player.h"
+#include "ObjectMgr.h"
+#include "ScriptMgr.h"
+#include "AccountMgr.h"
+#include "World.h"
+#include "Player.h"
+#include "WorldSession.h"
+#include "DatabaseEnv.h"
+#include "AccountMgr.h"
+#include "CellImpl.h"
+#include "GridNotifiersImpl.h"
+#include "Log.h"
+#include "ChatLink.h"
+
+class jail_commandscript : public CommandScript
+{
+public:
+    jail_commandscript() : CommandScript("jail_commandscript") { }
+
+    std::vector<ChatCommand> GetCommands() const override
+    {
+        static std::vector<ChatCommand> jailCommandTable =
+        {
+            { "player",      rbac::RBAC_PERM_COMMAND_JAIL_INFO,   false, &HandleJailPlayerCommand, "" }, // 901
+            { "info",        rbac::RBAC_PERM_COMMAND_JAIL_INFO,   false, &HandleJailInfoCommand,   "" }, // 902
+            { "release",     rbac::RBAC_PERM_COMMAND_JAIL_UN,     false, &HandleUnJailCommand,     "" }, // 903
+            { "reload",      rbac::RBAC_PERM_COMMAND_JAIL_RELOAD, false, &HandleJailReloadCommand, "" }, // 904
+        };
+        static std::vector<ChatCommand> commandTable =
+        {
+            { "jail",   rbac::RBAC_PERM_COMMAND_JAIL,   false, NULL, "", jailCommandTable },
+        };
+        return commandTable;
+    }
+    static bool HandleJailPlayerCommand(ChatHandler* handler, char const* args)
+    {
+    std::string cname, announce, ban_reason, ban_by;
+    time_t localtime;
+    localtime = time(NULL);
+
+    char *charname = strtok((char*)args, " ");
+    if (charname == NULL)
+    {
+        handler->PSendSysMessage(LANG_JAIL_NONAME);
+        return true;
+    } else cname = charname;
+
+    char *timetojail = strtok(NULL, " ");
+    if (timetojail == NULL)
+    {
+        handler->PSendSysMessage(LANG_JAIL_NOTIME);
+        return true;
+    }
+
+    uint32 jailtime = (uint32) atoi((char*)timetojail);
+    if (jailtime < 1 || jailtime > sObjectMgr->m_jailconf_max_duration)
+    {
+        handler->PSendSysMessage(LANG_JAIL_VALUE, sObjectMgr->m_jailconf_max_duration);
+        return true;
+    }
+
+    char *reason = strtok(NULL, "\0");
+    std::string jailreason;
+    if (reason == NULL || strlen((const char*)reason) < sObjectMgr->m_jailconf_min_reason)
+    {
+        handler->PSendSysMessage(LANG_JAIL_NOREASON, sObjectMgr->m_jailconf_min_reason);
+        return true;
+    } else jailreason = reason;
+
+    ObjectGuid GUID = sObjectMgr->GetPlayerGUIDByName(cname.c_str());
+    if (GUID == 0)
+    {
+        handler->PSendSysMessage(LANG_JAIL_WRONG_NAME);
+        return true;
+    }
+
+    Player *chr = ObjectAccessor::FindPlayer(GUID);
+    if (!chr)
+    {
+        ObjectGuid::LowType jail_guid = GUID.GetCounter();
+        std::string jail_char = cname;
+        bool jail_isjailed = true;
+        uint32 jail_release = localtime + (jailtime * 60 * 60);
+        uint32 jail_amnestietime = localtime +(60* 60 * 24 * sObjectMgr->m_jailconf_amnestie);
+        std::string jail_reason = jailreason;
+        uint32 jail_times = 0;
+
+        SQLTransaction trans = CharacterDatabase.BeginTransaction();
+        QueryResult result = CharacterDatabase.PQuery("SELECT * FROM `jail` WHERE `guid`='%u' LIMIT 1", jail_guid);
+        CharacterDatabase.CommitTransaction(trans);
+
+        if (!result)
+        {
+            jail_times = 1;
+        }
+        else
+        {
+            Field *fields = result->Fetch();
+            jail_times = fields[5].GetUInt32()+1;
+        }
+
+        uint32 jail_gmacc = handler->GetSession()->GetAccountId();
+        std::string jail_gmchar = handler->GetSession()->GetPlayerName();
+
+        SQLTransaction trans2 = CharacterDatabase.BeginTransaction();
+        if (!result) CharacterDatabase.PExecute("INSERT INTO `jail` VALUES ('%u','%s','%u','%u','%s','%u','%u','%s',CURRENT_TIMESTAMP,'%u')", jail_guid, jail_char.c_str(), jail_release, jail_amnestietime, jail_reason.c_str(), jail_times, jail_gmacc, jail_gmchar.c_str(), jailtime);
+        else CharacterDatabase.PExecute("UPDATE `jail` SET `release`='%u', `amnestietime`='%u',`reason`='%s',`times`='%u',`gmacc`='%u',`gmchar`='%s',`duration`='%u' WHERE `guid`='%u' LIMIT 1", jail_release, jail_amnestietime, jail_reason.c_str(), jail_times, jail_gmacc, jail_gmchar.c_str(), jailtime, jail_guid);
+        CharacterDatabase.CommitTransaction(trans2);
+
+        handler->PSendSysMessage(LANG_JAIL_WAS_JAILED, cname.c_str(), jailtime);
+
+        announce = handler->GetTrinityString(LANG_JAIL_ANNOUNCE1);
+        announce += cname;
+        announce += handler->GetTrinityString(LANG_JAIL_ANNOUNCE2);
+        announce += timetojail;
+        announce += handler->GetTrinityString(LANG_JAIL_ANNOUNCE3);
+        announce += handler->GetSession()->GetPlayerName();
+        announce += handler->GetTrinityString(LANG_JAIL_ANNOUNCE4);
+        announce += jail_reason;
+
+        sWorld->SendServerMessage(SERVER_MSG_STRING, announce.c_str());
+
+        if ((sObjectMgr->m_jailconf_max_jails == jail_times) && !sObjectMgr->m_jailconf_ban)
+        {
+            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHECK_GUID);
+            stmt->setUInt32(0, GUID);
+            PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+            if (!result)
+            {
+                handler->PSendSysMessage(LANG_NO_PLAYER, cname.c_str());
+                return true;
+            }
+
+            Field *fields = result->Fetch();
+
+            Player::DeleteFromDB(GUID, fields[1].GetUInt32());
+        }
+        else if ((sObjectMgr->m_jailconf_max_jails == jail_times) && sObjectMgr->m_jailconf_ban)
+        {
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            QueryResult result = CharacterDatabase.PQuery("SELECT * FROM `characters` WHERE `guid`='%u' LIMIT 1", ObjectGuid::LowType(GUID.GetCounter()));
+            CharacterDatabase.CommitTransaction(trans);
+
+            if (!result)
+            {
+                handler->PSendSysMessage(LANG_NO_PLAYER, cname.c_str());
+                return true;
+            }
+            Field *fields = result->Fetch();
+            uint32 acc_id = fields[1].GetUInt32();
+
+            SQLTransaction trans2 = LoginDatabase.BeginTransaction();
+            result = LoginDatabase.PQuery("SELECT * FROM `account` WHERE `id`='%u' LIMIT 1", acc_id);
+            LoginDatabase.CommitTransaction(trans2);
+
+            if (!result)
+            {
+                handler->PSendSysMessage(LANG_NO_PLAYER, cname.c_str());
+                return true;
+            }
+            ban_reason = handler->GetTrinityString(LANG_JAIL_BAN_REASON);
+            ban_by = handler->GetTrinityString(LANG_JAIL_BAN_BY);
+
+            SQLTransaction trans3 = LoginDatabase.BeginTransaction();
+            LoginDatabase.PExecute("INSERT IGNORE INTO `account_banned` (`id`,`bandate`,`bannedby`,`banreason`) VALUES ('%u',UNIX_TIMESTAMP,'%s','%s')", acc_id, ban_by.c_str(), ban_reason.c_str());
+            LoginDatabase.CommitTransaction(trans3);
+
+        }
+        return true;
+    }
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    QueryResult result = CharacterDatabase.PQuery("SELECT * FROM `characters` WHERE `guid`='%u' LIMIT 1", chr->GetGUID().GetCounter());
+    CharacterDatabase.CommitTransaction(trans);
+
+    if (!result)
+    {
+        handler->PSendSysMessage(LANG_NO_PLAYER, cname.c_str());
+        return true;
+    }
+
+    Field *fields = result->Fetch();
+
+    if (chr->GetName() == handler->GetSession()->GetPlayerName())
+    {
+        handler->PSendSysMessage(LANG_JAIL_NO_JAIL);
+        return true;
+    }
+
+        chr->SaveToDB();
+
+        chr->m_jail_guid = fields[0].GetUInt32();
+        chr->m_jail_char = fields[3].GetString();
+        chr->m_jail_isjailed = true;
+        chr->m_jail_release = localtime + (jailtime * 60 * 60);
+        chr->m_jail_amnestietime = localtime +(60* 60 * 24 * sObjectMgr->m_jailconf_amnestie);
+        chr->m_jail_reason = jailreason;
+        chr->m_jail_times = chr->m_jail_times+1;
+        chr->m_jail_gmacc = handler->GetSession()->GetAccountId();
+        chr->m_jail_gmchar = handler->GetSession()->GetPlayerName();
+        chr->m_jail_duration = jailtime;
+
+        chr->_SaveJail();
+
+        handler->PSendSysMessage(LANG_JAIL_WAS_JAILED, fields[3].GetString().c_str(), jailtime);
+        handler->PSendSysMessage(LANG_JAIL_YOURE_JAILED, handler->GetSession()->GetPlayerName(), jailtime);
+        handler->PSendSysMessage(LANG_JAIL_REASON, handler->GetSession()->GetPlayerName(), jailreason.c_str());
+
+        announce = handler->GetTrinityString(LANG_JAIL_ANNOUNCE1);
+        announce += fields[3].GetString();
+        announce += handler->GetTrinityString(LANG_JAIL_ANNOUNCE2);
+        announce += timetojail;
+        announce += handler->GetTrinityString(LANG_JAIL_ANNOUNCE3);
+        announce += handler->GetSession()->GetPlayerName();
+        announce += handler->GetTrinityString(LANG_JAIL_ANNOUNCE4);
+        announce += chr->m_jail_reason;
+
+        sWorld->SendServerMessage(SERVER_MSG_STRING, announce.c_str());
+
+    if (sObjectMgr->m_jailconf_max_jails == chr->m_jail_times)
+    {
+        chr->GetSession()->KickPlayer();
+        Player::DeleteFromDB(ObjectGuid(HighGuid::Player, fields[0].GetUInt32()), fields[1].GetUInt32(), true, true);
+    }
+    else if ((sObjectMgr->m_jailconf_max_jails == chr->m_jail_times) && sObjectMgr->m_jailconf_ban)
+    {
+        uint32 acc_id = chr->GetSession()->GetAccountId();
+        ban_reason = handler->GetTrinityString(LANG_JAIL_BAN_REASON);
+        ban_by = handler->GetTrinityString(LANG_JAIL_BAN_BY);
+
+        SQLTransaction trans = LoginDatabase.BeginTransaction();
+        LoginDatabase.PExecute("INSERT IGNORE INTO `account_banned` (`id`,`bandate`,`bannedby`,`banreason`) VALUES ('%u',UNIX_TIMESTAMP,'%s','%s')", acc_id, ban_by.c_str(), ban_reason.c_str());
+        LoginDatabase.CommitTransaction(trans);
+
+        chr->GetSession()->LogoutPlayer(false);
+    }
+    else chr->GetSession()->LogoutPlayer(false);
+    return true;
+    }
+    
+    static bool HandleJailInfoCommand(ChatHandler* handler, char const* args)
+    {
+    time_t localtime;
+    localtime = time(NULL);
+    Player *chr = handler->GetSession()->GetPlayer();
+
+    if (chr->m_jail_release > 0)
+    {
+        uint32 min_left = (uint32)floor(float(chr->m_jail_release - localtime) / 60);
+
+        if (min_left <= 0)
+        {
+            chr->m_jail_release = 0;
+            chr->_SaveJail();
+            handler->PSendSysMessage(LANG_JAIL_NOTJAILED_INFO);
+            return true;
+        }
+        else
+        {
+            if (min_left >= 60) handler->PSendSysMessage(LANG_JAIL_JAILED_H_INFO, (uint32)floor(float(chr->m_jail_release - localtime) / 60 / 60));
+            else handler->PSendSysMessage(LANG_JAIL_JAILED_M_INFO, min_left);
+            handler->PSendSysMessage(LANG_JAIL_REASON, chr->m_jail_gmchar.c_str(), chr->m_jail_reason.c_str());
+
+            return true;
+        }
+    }
+    else
+    {
+        handler->PSendSysMessage(LANG_JAIL_NOTJAILED_INFO);
+        return true;
+    }
+    return false;
+    }
+
+    static bool HandleUnJailCommand(ChatHandler* handler, char const* args)
+    {
+    char *charname = strtok((char*)args, " ");
+    std::string cname;
+
+    if (charname == NULL) return false;
+    else cname = charname;
+
+    ObjectGuid GUID = sObjectMgr->GetPlayerGUIDByName(cname.c_str());
+    Player *chr = ObjectAccessor::FindPlayer(GUID);
+
+    if (chr)
+    {
+        if (chr->GetName() == handler->GetSession()->GetPlayerName())
+        {
+            handler->PSendSysMessage(LANG_JAIL_NO_UNJAIL);
+            return true;
+        }
+
+        if (chr->m_jail_isjailed)
+        {
+            chr->m_jail_isjailed = false;
+            chr->m_jail_release = 0;
+            chr->m_jail_times = chr->m_jail_times-1;
+
+            chr->_SaveJail();
+
+            if (chr->m_jail_times == 0)
+            {
+                SQLTransaction trans = CharacterDatabase.BeginTransaction();
+                CharacterDatabase.PQuery("DELETE FROM `jail` WHERE `guid`='%u' LIMIT 1", chr->GetGUID().GetCounter());
+                CharacterDatabase.CommitTransaction(trans);
+            }
+
+            handler->PSendSysMessage(LANG_JAIL_WAS_UNJAILED, cname.c_str());
+            handler->PSendSysMessage(LANG_JAIL_YOURE_UNJAILED);    
+            chr->CastSpell(chr,8690,false);
+            //chr->GetSession()->LogoutPlayer(false);
+        } else handler->PSendSysMessage(LANG_JAIL_CHAR_NOTJAILED, cname.c_str());
+        return true;
+    }
+    else
+    {
+        SQLTransaction trans = CharacterDatabase.BeginTransaction();
+        QueryResult jresult = CharacterDatabase.PQuery("SELECT * FROM `jail` WHERE `guid`='%u' LIMIT 1", ObjectGuid::LowType(GUID.GetCounter()));
+        CharacterDatabase.CommitTransaction(trans);
+
+        if (!jresult)
+        {
+            handler->PSendSysMessage(LANG_JAIL_CHAR_NOTJAILED, cname.c_str());
+            return true;
+        }
+        else
+        {
+            Field *fields = jresult->Fetch();
+            uint32 jail_times = fields[4].GetUInt32()-1;
+
+            if (jail_times == 0)
+            {
+                SQLTransaction trans = CharacterDatabase.BeginTransaction();
+                CharacterDatabase.PQuery("DELETE FROM `jail` WHERE `guid`='%u' LIMIT 1", fields[0].GetUInt32());
+                CharacterDatabase.CommitTransaction(trans);
+            }
+            else
+            {
+                SQLTransaction trans = CharacterDatabase.BeginTransaction();
+                CharacterDatabase.PQuery("UPDATE `jail` SET `release`='0',`times`='%u' WHERE `guid`='%u' LIMIT 1", jail_times, fields[0].GetUInt32());
+                CharacterDatabase.CommitTransaction(trans);
+            }
+
+            handler->PSendSysMessage(LANG_JAIL_WAS_UNJAILED, cname.c_str());
+            return true;
+        }
+
+    }
+    return true;
+    }
+
+    static bool HandleJailReloadCommand(ChatHandler* handler, char const* args)
+    {
+    sObjectMgr->LoadJailConf();
+    handler->PSendSysMessage(LANG_JAIL_RELOAD);
+    return true;
+    }
+};
+
+void AddSC_jail_commandscript()
+{
+    new jail_commandscript();
+}
+
+        
\ No newline at end of file
diff --git a/src/server/scripts/Commands/cs_message.cpp b/src/server/scripts/Commands/cs_message.cpp
index 69ff04f..9fdfad5 100644
--- a/src/server/scripts/Commands/cs_message.cpp
+++ b/src/server/scripts/Commands/cs_message.cpp
@@ -28,6 +28,7 @@ EndScriptData */
 #include "Language.h"
 #include "Player.h"
 #include "ObjectMgr.h"
+#include "IRCClient.h"
 
 class message_commandscript : public CommandScript
 {
@@ -123,6 +124,12 @@ public:
             name = session->GetPlayer()->GetName();
 
         sWorld->SendGMText(LANG_GM_ANNOUNCE_COLOR, name.c_str(), args);
+        //send to irc
+        if(sIRC->_staffLink == 1)
+        {
+            std::string sMsg = "[<WoW>"+name+"]: "+args;
+            sIRC->Send_IRC_Channel(sIRC->_staffChan, sMsg, false, "PRIVMSG");
+        }
         return true;
     }
     // global announce
@@ -131,6 +138,13 @@ public:
         if (!*args)
             return false;
 
+        if ((sIRC->BOTMASK & 256) != 0 && sIRC->anchn.size() > 0)
+        {
+            std::string ircchan = "#";
+            ircchan += sIRC->anchn;
+            sIRC->Send_IRC_Channel(ircchan, sIRC->MakeMsg("\00304,08\037/!\\\037\017\00304 System Message \00304,08\037/!\\\037\017 %s", "%s", args), true);
+        }
+
         char buff[2048];
         sprintf(buff, handler->GetTrinityString(LANG_SYSTEMMESSAGE), args);
         sWorld->SendServerMessage(SERVER_MSG_STRING, buff);
@@ -150,6 +164,12 @@ public:
     {
         if (!*args)
             return false;
+        if ((sIRC->BOTMASK & 256) != 0 && sIRC->anchn.size() > 0)
+        {
+            std::string ircchan = "#";
+            ircchan += sIRC->anchn;
+            sIRC->Send_IRC_Channel(ircchan, sIRC->MakeMsg("\00304,08\037/!\\\037\017\00304 Global Notify \00304,08\037/!\\\037\017 %s", "%s", args), true);
+        }
 
         std::string str = handler->GetTrinityString(LANG_GLOBAL_NOTIFY);
         str += args;
diff --git a/src/server/scripts/Custom/ArenaGambler.cpp b/src/server/scripts/Custom/ArenaGambler.cpp
new file mode 100644
index 0000000..366b473
--- /dev/null
+++ b/src/server/scripts/Custom/ArenaGambler.cpp
@@ -0,0 +1,308 @@
+/*
+ * Author: Xees
+ * FileName: ArenaGambler.cpp
+ * Description: This file is used to script the npc for the Arena Gambling System
+ * Version: 1.9
+ * Status: functional
+*/
+
+#include "ArenaGamblingSystem.h"
+#include "ScriptMgr.h"
+#include "Player.h"
+
+class ArenaGambler : public CreatureScript
+{
+    public:
+        ArenaGambler() : CreatureScript(ARENA_GAMBLER_SCRIPT_NAME) {}
+        bool OnGossipHello(Player *pPlayer, Creature *pCreature)
+        {
+            switch (urand(0,6))
+            {
+                case 0: pCreature->Say("|cffbbbbbbWelcome ye great warrior , fight to the last for the Lich King!",LANG_UNIVERSAL,pPlayer); break;
+                case 1: pCreature->Say("|cffbbbbbbOnly great warriors are welcome!",LANG_UNIVERSAL,pPlayer); break;
+                case 2: pCreature->Say("|cffbbbbbbMere mortals cannot be gods!",LANG_UNIVERSAL,pPlayer); break;
+                case 3: pCreature->Say("|cffbbbbbbGreat warrior , you seek to duel!",LANG_UNIVERSAL,pPlayer); break;
+                case 4: pCreature->Say("|cffbbbbbbDeath and glory await!",LANG_UNIVERSAL,pPlayer); break;
+                case 5: pCreature->Say("|cffbbbbbbBegone, weaklings are unwelcome!",LANG_UNIVERSAL,pPlayer); break;
+                case 6: pCreature->Say("|cffbbbbbbDeath and honor!",LANG_UNIVERSAL,pPlayer); break;
+            }
+                pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_ITEM, ARENA_GAMBLER_MENU_MAIN, GOSSIP_ACTION_INFO_DEF + 1, "", false);
+                pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+
+            return true;
+        }
+
+        bool OnGossipSelect(Player *pPlayer, Creature *pCreature, uint32 sender, uint32 action)
+        {
+            pPlayer->PlayerTalkClass->ClearMenus();
+            switch(sender)
+            {
+                case ARENA_GAMBLER_MENU_MAIN:
+                {
+                    if(GamblerMatchData *matchData = sGamblingSystem->GetMatchDataBy(pPlayer))
+                    {
+                            if(matchData->MatchStarted())
+                                return true;
+                            if(matchData->GetItemIdBy(pPlayer) == 0) // if there is match data, but no item was bet
+                                pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM,    ARENA_GAMBLER_TEXT_BET_ITEM,            ARENA_GAMBLER_MENU_BET_ITEM,            GOSSIP_ACTION_INFO_DEF + 1, ARENA_GAMBLER_TEXT_BET_ITEM_CODE_TEXT, 0, true);
+                            if(matchData->GetItemIdBy(pPlayer) != 0 && matchData->GetItemCountBy(pPlayer) == 0) // if there is match data and an item, but no amount was entered
+                            pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM,    ARENA_GAMBLER_TEXT_BET_ITEM_AMOUNT,    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT,    GOSSIP_ACTION_INFO_DEF + 1, "", false);
+                            if(matchData->GetChallengerItemId() && matchData->GetDefenderItemId() && matchData->GetItemCountBy(pPlayer) != 0 &&  matchData->HasSetReady(pPlayer) == false) // if everything checks out, but player is not yet ready.
+                                pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_ACCEPT,    ARENA_GAMBLER_TEXT_ACCEPT_CHALLENGE,    ARENA_GAMBLER_MENU_ACCEPT_CHALLENGE,    GOSSIP_ACTION_INFO_DEF + 1, "", false);
+                            if(matchData->GetChallengerGUID() == pPlayer->GetGUID().GetCounter())
+                                pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_CANCEL,    ARENA_GAMBLER_TEXT_CANCEL_CHALLENGE,    ARENA_GAMBLER_MENU_CANCEL_CHALLENGE,    GOSSIP_ACTION_INFO_DEF + 1, "", false);
+                            else
+                                pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_DECLINE,    ARENA_GAMBLER_TEXT_DECLINE_CHALLENGE,    ARENA_GAMBLER_MENU_DECLINE_CHALLENGE,    GOSSIP_ACTION_INFO_DEF + 1, "", false);
+                        }
+                        else // if no match data was found
+                        {
+                            pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_CHALLENGE, ARENA_GAMBLER_TEXT_CHALLENGE, ARENA_GAMBLER_MENU_CHALLENGE_PLAYER, GOSSIP_ACTION_INFO_DEF + 1, ARENA_GAMBLER_TEXT_CHALLENGE_CODE_TEXT, 0, true);
+                        }
+                        pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_EXIT, ARENA_GAMBLER_TEXT_EXIT, ARENA_GAMBLER_MENU_EXIT, GOSSIP_ACTION_INFO_DEF + 1, "", false);
+                        pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+
+                }break;
+                case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT:
+                {
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_1, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_1, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_10, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_10, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_20, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_20, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_30, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_30, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_40, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_40, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_50, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_50, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_100, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_100, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_200, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_200, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_300, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_300, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_500, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_500, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_1000, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_1000, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_EXIT, ARENA_GAMBLER_TEXT_EXIT, ARENA_GAMBLER_MENU_EXIT, GOSSIP_ACTION_INFO_DEF + 1, "", false);
+                    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+                }break;
+                    case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_1:
+                    {
+                        if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 1) == false)
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                        else
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                        pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+                    case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_10:
+                    {
+                        if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 10) == false)
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                        else
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                        pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+                    case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_20:
+                    {
+                        if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 20) == false)
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                        else
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                        pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+                    case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_30:
+                    {
+                        if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 30) == false)
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                        else
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                        pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+                    case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_40:
+                    {
+                        if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 40) == false)
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                        else
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                        pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+                    case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_50:
+                {
+                    if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 50) == false)
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                }break;
+                case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_100:
+                {
+                    if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 100) == false)
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                }break;
+                case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_200:
+                {
+                    if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 200) == false)
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                }break;
+                case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_300:
+                {
+                    if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 300) == false)
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                }break;
+                case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_500:
+                {
+                    if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 500) == false)
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                }break;
+                case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_1000:
+                {
+                    if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 1000) == false)
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                }break;
+                case ARENA_GAMBLER_MENU_ACCEPT_CHALLENGE:
+                    {
+                        sGamblingSystem->AcceptChallenge(pPlayer);
+                        pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+                case ARENA_GAMBLER_MENU_CANCEL_CHALLENGE:
+                case ARENA_GAMBLER_MENU_DECLINE_CHALLENGE:
+                    {
+                    sGamblingSystem->CancelChallenge(pPlayer);
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+                case ARENA_GAMBLER_MENU_EXIT:{
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+            }
+
+            return true;
+        }
+
+        bool OnGossipSelectCode(Player *pPlayer, Creature *pCreature, uint32 sender, uint32 action, const char *pCode)
+        {
+            switch(sender)
+            {
+                case ARENA_GAMBLER_MENU_CHALLENGE_PLAYER:
+                {
+                    if(Player* pDefender = ObjectAccessor::FindPlayerByName(pCode))
+                    {
+                        if(sGamblingSystem->CanHaveMatch(pPlayer, pDefender) == false)
+                        {
+                            // General Error Message: Match not possible because:
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_MATCH_NOT_POSSIBLE);
+                            // Reason is: no gamemasters
+                            if(pPlayer->GetSession()->GetSecurity() > 0 || pDefender->GetSession()->GetSecurity() > 0)
+                            {
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_NO_GMS_ALLOWED);
+                            }
+                            // Reason is: you cannot duel your self!
+                            if(pPlayer->GetSession()->GetAccountId() == pDefender->GetSession()->GetAccountId())
+                            {
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_SAME_ACC_ID);
+                            }
+                            // Reason is: multiboxing is not allowed, or players have the same ip.
+                            if(pPlayer->GetSession()->GetRemoteAddress().compare(pDefender->GetSession()->GetRemoteAddress()) == 0)
+                            {
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_MULTI_BOX);
+                            }
+                            // Reason is: your level is smaller than the minimum level required
+                            uint32 m_minRequiredLevel = 0;
+                            if(pPlayer->getLevel() <= m_minRequiredLevel || pDefender->getLevel() <= m_minRequiredLevel )
+                            {
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_LOW_LEVEL);
+                            }
+                            // Reason is: you are requesting a duel from someone who already is in a duel.
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_LOW_LEVEL);
+                            // Reason is: level diffrance is too high
+                            uint32 levelDiff = 0;
+                            if(pPlayer->getLevel() > pDefender->getLevel())
+                            {
+                                levelDiff = pPlayer->getLevel() - pDefender->getLevel();
+                            }
+                            else
+                            {
+                                levelDiff = pDefender->getLevel() - pPlayer->getLevel();
+                            }
+                            return true;
+                        }
+                        sGamblingSystem->SetupMatch(pPlayer, pDefender);
+                        pPlayer->GetSession()->SendAreaTriggerMessage(ARENA_GAMBLER_MSG_CHALLENGE_ISSUED, pDefender);
+                        pDefender->GetSession()->SendAreaTriggerMessage(ARENA_GAMBLER_MSG_CHALLENGED, pPlayer);
+                        OnGossipSelect(pPlayer, pCreature, ARENA_GAMBLER_MENU_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
+                    }
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_PLAYER_NOT_FOUND);
+                }break;
+
+                case ARENA_GAMBLER_MENU_BET_ITEM:
+                {
+                    if(sGamblingSystem->AddItemForMatch(pPlayer, pCode) == false)
+                        pPlayer->GetSession()->SendAreaTriggerMessage(ARENA_GAMBLER_MSG_ITEM_ADD_FAILED);
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_ADD_SUCCESS);
+                    OnGossipSelect(pPlayer, pCreature, ARENA_GAMBLER_MENU_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
+                }break;
+            }
+            return true;
+        }
+};
+
+// Arena Records GameObject
+class ArenaRecords : public GameObjectScript
+{ public:
+    ArenaRecords() : GameObjectScript(ARENA_RECORDS_SCRIPT_NAME) { }
+    bool OnGossipHello(Player* pPlayer, GameObject* pGo)
+    {
+        if(QueryResult queryResult = CharacterDatabase.PQuery("SELECT `playerGUID`,`duelsLost`,`duelsWon`,`duelsRefused`,`duelsTotal` FROM `custom_duel_statistics` WHERE `playerGUID` = '%u'", pPlayer->GetGUID().GetCounter()))
+        {
+            uint32 playerGUID = queryResult->Fetch()[0].GetUInt32();
+            uint32 duelsLost = queryResult->Fetch()[1].GetUInt32();
+            uint32 duelsWon = queryResult->Fetch()[2].GetUInt32();
+            uint32 duelsRefused = queryResult->Fetch()[3].GetUInt32();
+            uint32 duelsTotal = queryResult->Fetch()[4].GetUInt32();
+
+            std::ostringstream Lost;
+            std::ostringstream Won;
+            std::ostringstream Refused;
+            std::ostringstream Total;
+
+            Lost << MSG_COLOR_SUBWHITE << "You have Lost : " << MSG_COLOR_LIGHTBLUE <<  duelsLost << " Duel(s)." ;
+            Won << MSG_COLOR_SUBWHITE << "You have Won : " << MSG_COLOR_LIGHTBLUE <<  duelsWon << " Duel(s)." ;
+            Refused << MSG_COLOR_SUBWHITE << "You have Refused : " << MSG_COLOR_LIGHTBLUE <<  duelsRefused << " Duel(s)." ;
+            Total << MSG_COLOR_SUBWHITE << "You have Fought : " << MSG_COLOR_LIGHTBLUE <<  duelsTotal << " Duel(s)." ;
+
+            ChatHandler(pPlayer->GetSession()).SendSysMessage(Lost.str( ).c_str( ));
+            ChatHandler(pPlayer->GetSession()).SendSysMessage(Won.str( ).c_str( ));
+            ChatHandler(pPlayer->GetSession()).SendSysMessage(Refused.str( ).c_str( ));
+            ChatHandler(pPlayer->GetSession()).SendSysMessage(Total.str( ).c_str( ));
+        }
+        else
+        {
+            switch (urand(0,5))
+            {
+            case 0: pPlayer->Say("I never fought once , i should be ashamed.",LANG_UNIVERSAL,pPlayer);break;
+            case 1: pPlayer->Say("This book does not hold any records of me!",LANG_UNIVERSAL,pPlayer);break;
+            case 2: pPlayer->Say("i have never challenged anyone here!",LANG_UNIVERSAL,pPlayer);break;
+            case 3: pPlayer->Say("I should first challenge someone!",LANG_UNIVERSAL,pPlayer);break;
+            case 4: pPlayer->Say("No Wins, No losses",LANG_UNIVERSAL,pPlayer);break;
+            case 5: pPlayer->Say("I should hide in a cave, i don't deserve to be here!",LANG_UNIVERSAL,pPlayer);break;
+            }
+        }
+        return true;
+    }
+};
+
+void AddSC_ArenaGambler()
+{
+    sGamblingSystem->Initalize();
+    new ArenaGambler();
+    new ArenaRecords();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/ArenaGamblingSystem.cpp b/src/server/scripts/Custom/ArenaGamblingSystem.cpp
new file mode 100644
index 0000000..eba6f78
--- /dev/null
+++ b/src/server/scripts/Custom/ArenaGamblingSystem.cpp
@@ -0,0 +1,723 @@
+/*
+ * Author: Xees
+ * FileName: ArenaGamblingSystem.cpp
+ * Description: This file is used to script the Arena Gambling System
+ * Version: 1.9
+ * Status: functional
+*/
+
+#include "ArenaGamblingSystem.h"
+
+using namespace std;
+
+const char *GamblerPlayerStatFields[GAMBLER_PLAYER_STAT_MAX] =
+{
+    "playerGUID",
+    "duelsLost",
+    "duelsWon",
+    "duelsRefused",
+    "duelsTotal"
+};
+
+GamblingSystem::GamblingSystem() : WorldScript(GAMBLER_SYSTEM_SCRIPT_NAME)
+{
+    m_checkMatches.SetInterval(GAMBLER_SYSTEM_INTERVAL_TELE_CHECK);
+}
+
+GamblingSystem::~GamblingSystem()
+{
+    AcquireMatchLock();
+    GamblerMatchMap::iterator Itr;
+    for(Itr = m_matchStorage.begin(); Itr != m_matchStorage.end(); ++Itr)
+        delete Itr->second;
+    m_matchStorage.clear();
+    ReleaseMatchLock();
+}
+
+// Creation
+void GamblingSystem::Initalize()
+{
+    LoadConfigData();
+    _loadPastMatches();
+    new GamblerDuelScript();
+}
+
+// Events
+// Called on every world tick (don't execute too heavy code here).
+void GamblingSystem::OnUpdate(uint32 diff)
+{
+    if(m_checkMatches.GetCurrent() >= 0)
+        m_checkMatches.Update(diff);
+    else
+        m_checkMatches.SetCurrent(0);
+    if(m_checkMatches.Passed())
+        m_checkMatches.Reset();
+
+    AcquireMatchLock();
+    GamblerMatchMap::iterator Itr;
+    for(Itr = m_matchStorage.begin(); Itr != m_matchStorage.end(); ++Itr)
+    {
+        if(Itr->second->GetMatchStatus() != GAMBLER_MATCH_STATUS_TELEPORT)
+            continue;
+
+        Player *pChallenger = ObjectAccessor::FindPlayer(ObjectGuid(HighGuid::Player, Itr->second->GetChallengerGUID()));
+        Player *pDefender    = ObjectAccessor::FindPlayer(ObjectGuid(HighGuid::Player,Itr->second->GetDefenderGUID()));
+
+        if(pChallenger == NULL || pDefender == NULL)
+            continue;
+        if(pChallenger->IsBeingTeleported() || pChallenger->IsLoading() || pDefender->IsBeingTeleported() || pDefender->IsLoading())
+            continue;
+
+        pChallenger->CastSpell(pDefender, 7266, true);
+        Itr->second->SetMatchStatus(GAMBLER_MATCH_STATUS_RUNNING);
+    }
+    ReleaseMatchLock();
+}
+
+// Database Interaction
+void GamblingSystem::LoadConfigData()
+{
+    m_minRequiredLevel = 255;
+    m_maxLevelDiff       = 5;
+    m_maxBet           = 100;
+    m_awardFled           = false;
+    m_enableGM           = false;
+    m_enableSameip       = false;
+    m_enableLimits       = false;
+    m_onlyCurrency       = false;
+    m_equalDuels       = false;
+    if(QueryResult queryResult = CharacterDatabase.Query("SELECT `optionIndex`, `optionValue` FROM `custom_duel_config`"))
+    {
+        do
+        {
+            Field *Fields = queryResult->Fetch();
+            switch(Fields[0].GetUInt32())
+            {
+                case GAMBLER_CONFIG_OPTION_MAPID:                m_arenaCoords.m_mapId        = Fields[1].GetUInt32();    break;
+                case GAMBLER_CONFIG_OPTION_COORDSX:                m_arenaCoords.m_positionX    = Fields[1].GetFloat();        break;
+                case GAMBLER_CONFIG_OPTION_COORDSY:                m_arenaCoords.m_positionY    = Fields[1].GetFloat();        break;
+                case GAMBLER_CONFIG_OPTION_COORDSZ:                m_arenaCoords.m_positionZ    = Fields[1].GetFloat();        break;
+                case GAMBLER_CONFIG_OPTION_COORDSO:                m_arenaCoords.m_orientation    = Fields[1].GetFloat();        break;
+                case GAMBLER_CONFIG_OPTION_MIN_REQUIREDLEVEL:    m_minRequiredLevel            = Fields[1].GetUInt32();    break;
+                case GAMBLER_CONFIG_OPTION_MAX_LEVELDIFF:        m_maxLevelDiff                = Fields[1].GetUInt32();    break;
+                case GAMBLER_CONFIG_OPTION_AWARD_FLED:            m_awardFled                    = Fields[1].GetBool();        break;
+                case GAMBLER_CONFIG_OPTION_MAX_BET:
+                    m_maxBet                    = Fields[1].GetUInt32();
+                    if(m_maxBet > GAMBLER_SYSTEM_TOTAL_MAX_BET){
+                        m_maxBet = GAMBLER_SYSTEM_TOTAL_MAX_BET;
+                    }
+                break;
+                case GAMBLER_CONFIG_OPTION_ENABLE_GM:            m_enableGM                    = Fields[1].GetBool();        break;
+                case GAMBLER_CONFIG_OPTION_ENABLE_SAMEIP:        m_enableSameip                = Fields[1].GetBool();        break;
+                case GAMBLER_CONFIG_OPTION_ENABLE_LIMITS:        m_enableLimits                = Fields[1].GetBool();        break;
+                case GAMBLER_CONFIG_OPTION_ONLY_CURRENCY:        m_onlyCurrency                = Fields[1].GetBool();        break;
+                case GAMBLER_CONFIG_OPTION_EQUAL_DUELS:            m_equalDuels                = Fields[1].GetBool();        break;
+            }
+        }while(queryResult->NextRow());
+    }
+    else
+        TC_LOG_ERROR("Arena", "GamblingSystem: Unable to load duel_config, result was not returned");
+    if(QueryResult queryResult = CharacterDatabase.Query("SELECT MAX(`matchId`) FROM `custom_duel_storage`"))
+        m_highMatchId = queryResult->Fetch()[0].GetUInt32();
+    else
+        m_highMatchId = 0;
+}
+
+void GamblingSystem::_loadPastMatches()
+{
+    if(QueryResult queryResult = CharacterDatabase.Query("SELECT * FROM `custom_duel_storage`"))
+    {
+        do
+        {
+            GamblerMatchData *matchData = new GamblerMatchData(queryResult->Fetch());
+            if(matchData->GetMatchWinner() == 0)
+            {
+                _createItemAndMailToPlayer(NULL, matchData->GetChallengerGUID(), matchData->GetChallengerItemId(), matchData->GetChallengerItemCount(), GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_INCOMPLETE);
+                _createItemAndMailToPlayer(NULL, matchData->GetDefenderGUID(), matchData->GetDefenderItemId(), matchData->GetDefenderItemCount(), GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_INCOMPLETE);
+                continue;
+            }
+            AcquireMatchLock();
+            m_matchStorage.insert(make_pair(matchData->GetMatchId(), matchData));
+            ReleaseMatchLock();
+        }while(queryResult->NextRow());
+    }
+    CharacterDatabase.PExecute("DELETE FROM `custom_duel_storage` WHERE `matchWinner` = '0'");
+}
+
+void GamblingSystem::_saveCurrentMatchProgress(GamblerMatchData *matchData)
+{
+    if(QueryResult queryResult = CharacterDatabase.PQuery("SELECT * FROM `custom_duel_storage` WHERE `matchId` = '%u'", matchData->GetMatchId()))
+        CharacterDatabase.PExecute("UPDATE `custom_duel_storage` SET `matchWinner` = '%u'", matchData->GetMatchWinner());
+    else
+        CharacterDatabase.PExecute("INSERT INTO `custom_duel_storage` VALUES ('%u', '%u', '%u', '%u', '%u', '%u', '%u', NOW(), '%u')", matchData->GetMatchId(), matchData->GetChallengerGUID(), matchData->GetDefenderGUID(), matchData->GetChallengerItemId(),matchData->GetChallengerItemCount(), matchData->GetDefenderItemId(),matchData->GetDefenderItemCount(), matchData->GetMatchWinner());
+}
+
+void GamblingSystem::_updatePlayerStats(uint32 playerGUID, GamblerPlayerStatIndex statIndex, uint32 statIncreaseValue)
+{
+    if(statIndex > GAMBLER_PLAYER_STAT_MAX)
+    {
+        TC_LOG_ERROR("Arena", "GamblingSystem: _updatePlayerStats statIndex out of range");
+        return;
+    }
+    if(QueryResult queryResult = CharacterDatabase.PQuery("SELECT `%s` FROM `custom_duel_statistics` WHERE `%s` = '%u'", GamblerPlayerStatFields[statIndex], GamblerPlayerStatFields[GAMBLER_PLAYER_STAT_GUID], playerGUID))
+        CharacterDatabase.PExecute("UPDATE `custom_duel_statistics` SET `%s` = '%u' WHERE `%s` = '%u'", GamblerPlayerStatFields[statIndex], queryResult->Fetch()[0].GetUInt32()+statIncreaseValue, GamblerPlayerStatFields[GAMBLER_PLAYER_STAT_GUID], playerGUID);
+    else
+        CharacterDatabase.PExecute("INSERT INTO `custom_duel_statistics` (`%s`,`%s`) VALUES('%u', '%u')", GamblerPlayerStatFields[GAMBLER_PLAYER_STAT_GUID], GamblerPlayerStatFields[statIndex], playerGUID, statIncreaseValue);
+}
+
+// Match Data Retrieval
+GamblerMatchData *GamblingSystem::GetMatchDataBy(Player *pPlayer)
+{
+    AcquireMatchLock();
+    GamblerMatchMap::iterator Itr;
+    for(Itr = m_matchStorage.begin(); Itr != m_matchStorage.end(); ++Itr)
+    {
+        if(Itr->second->GetChallengerGUID() == pPlayer->GetGUID().GetCounter() || Itr->second->GetDefenderGUID() == pPlayer->GetGUID().GetCounter())
+        {
+            // Match is over, old data
+            if(Itr->second->GetMatchWinner())
+                continue;
+            ReleaseMatchLock();
+            return Itr->second;
+        }
+    }
+    ReleaseMatchLock();
+    return NULL;
+}
+
+// Match Requirements Checking
+bool GamblingSystem::CanHaveMatch(Player *pChallenger, Player *pDefender)
+{
+    // if same ip dueling is enabled in configuration
+    if(m_enableSameip == 1){
+        // no multibox or dueling with same ip
+        if(pChallenger->GetSession()->GetRemoteAddress().compare(pDefender->GetSession()->GetRemoteAddress()) == 0)
+            return false;
+    }
+
+    // if gm dueling is enabled in configuration
+    if(m_enableGM == 1){
+        // No gamemasters
+         if(pChallenger->GetSession()->GetSecurity() > 0 || pDefender->GetSession()->GetSecurity() > 0)
+            return false;
+    }
+
+    // no dueling on the same account
+    if(pChallenger->GetSession()->GetAccountId() == pDefender->GetSession()->GetAccountId())
+        return false;
+
+    // no dueling if any of the players are logging out!
+    if(pChallenger->GetSession()->isLogingOut() || pDefender->GetSession()->isLogingOut())
+        return false;
+
+    // No dueling if player already has a duel record in progress
+    if(GetMatchDataBy(pChallenger) || GetMatchDataBy(pDefender))
+        return false;
+
+    // No dueling if you don't meet the level requirement in the database
+    uint32 m_minRequiredLevel = 0;
+    if(pChallenger->getLevel() <= m_minRequiredLevel || pDefender->getLevel() <= m_minRequiredLevel)
+        return false;
+
+    // No dueling if your level differance is bigger than specified in the database
+    uint32 levelDiff = 0;
+    if(pChallenger->getLevel() > pDefender->getLevel())
+        levelDiff = pChallenger->getLevel() - pDefender->getLevel();
+    else
+        levelDiff = pDefender->getLevel() - pChallenger->getLevel();
+    if(levelDiff > m_maxLevelDiff)
+        return false;
+
+    return true;
+}
+
+// Match Setup
+void GamblingSystem::SetupMatch(Player *pChallenger, Player *pDefender)
+{
+    GamblerMatchData *matchData = new GamblerMatchData(_generateMatchId(), pChallenger->GetGUID().GetCounter(), pDefender->GetGUID().GetCounter());
+    AcquireMatchLock();
+    m_matchStorage.insert(make_pair(matchData->GetMatchId(), matchData));
+    ReleaseMatchLock();
+}
+
+std::string GamblingSystem::GetQualityColor(int32 qualityType) const
+{
+    switch(qualityType)
+    {
+        case ITEM_QUALITY_NORMAL:
+        {
+            return QUALITY_NORMAL;
+        }break;
+        case ITEM_QUALITY_UNCOMMON:
+        {
+            return QUALITY_UNCOMMON;
+        }break;
+        case ITEM_QUALITY_RARE:
+        {
+            return QUALITY_RARE;
+        }break;
+        case ITEM_QUALITY_EPIC:
+        {
+            return QUALITY_EPIC;
+        }break;
+        case ITEM_QUALITY_LEGENDARY:
+        {
+            return QUALITY_LEGENDARY;
+        }break;
+        case ITEM_QUALITY_ARTIFACT:
+        {
+            return QUALITY_ARTIFACT;
+        }break;
+        case ITEM_QUALITY_HEIRLOOM:
+        {
+            return QUALITY_HEIRLOOM;
+        }break;
+        default :
+        {
+            return QUALITY_POOR;
+        }break;
+    }
+    return 0;
+}
+
+bool GamblingSystem::AddItemForMatch(Player *pPlayer, std::string itemName)
+{
+    GamblerMatchData *matchData = GetMatchDataBy(pPlayer);
+    if(matchData == NULL)
+        return false;
+
+    WorldDatabase.EscapeString(itemName);
+    if(QueryResult queryResult = WorldDatabase.PQuery("SELECT `entry` FROM `item_template` WHERE `name` = '%s'", itemName.c_str()))
+    {
+        uint32 itemId = queryResult->Fetch()[0].GetUInt32();
+
+        ItemTemplate const *itemProto = sObjectMgr->GetItemTemplate(itemId);
+        if(Item *pItem = pPlayer->GetItemByEntry(itemId))
+        {
+            // if its currency
+            if(itemProto->BagFamily & BAG_FAMILY_MASK_CURRENCY_TOKENS)
+            {
+                if(pItem == NULL)
+                    return false;
+            }else{ // if its a normal item, check if its valid.
+                if(_checkItemValidity(pItem) == false)
+                    return false;
+            }
+
+            if(m_enableLimits == 1){ // if item limits are enabled, check them.
+                if(_checkWithinLimits(pItem) == false)
+                    return false;
+            }
+
+            if(m_onlyCurrency == 1){ // if only currency is allowed, check the item proto, temporary.
+                if(itemProto->BagFamily & BAG_FAMILY_MASK_CURRENCY_TOKENS){}else{return false;}
+            }
+
+            if(matchData->IsChallenger(pPlayer)){
+                matchData->SetChallengerItemId(itemId);
+            }
+            else{
+                matchData->SetDefenderItemId(itemId);
+            }
+            return true;
+        }
+    }
+    return false;
+}
+
+bool GamblingSystem::AddItemAmountForMatch(Player *pPlayer, uint32 amount)
+{
+    GamblerMatchData *matchData = GetMatchDataBy(pPlayer);
+    if(matchData == NULL)
+        return false;
+
+    uint32 itemId = matchData->GetItemIdBy(pPlayer);
+    ItemTemplate const *itemProto = sObjectMgr->GetItemTemplate(itemId);
+
+    if(Item *pItem = pPlayer->GetItemByEntry(itemId))
+    {
+        // if duels must be equal, then challenger item count must equal defender item count.
+        if(m_equalDuels == 1){
+            // if the player is challenger and his amount is not equal to the defender's item count, return false.
+            if(matchData->IsChallenger(pPlayer) && matchData->GetDefenderItemCount() != 0 && amount != matchData->GetDefenderItemCount())
+                return false;
+            // if the player is defender and his amount is not equal to challenger's item count, return false.
+            else if(matchData->IsDefender(pPlayer)  && matchData->GetChallengerItemCount() != 0 && amount != matchData->GetChallengerItemCount())
+                return false;
+        }
+
+        if(amount > m_maxBet)
+            return false;
+
+        if(!pPlayer->HasItemCount(itemId,amount))
+            return false;
+
+        if(matchData->IsChallenger(pPlayer)){
+            matchData->SetChallengerItemCount(amount);
+        }
+        else{
+            matchData->SetDefenderItemCount(amount);
+        }
+
+        Player *secondPlayer = NULL;
+        if(matchData->IsChallenger(pPlayer))
+            secondPlayer = ObjectAccessor::FindPlayer(ObjectGuid(HighGuid::Player, matchData->GetDefenderGUID()));
+        else
+            secondPlayer = ObjectAccessor::FindPlayer(ObjectGuid(HighGuid::Player, matchData->GetChallengerGUID()));
+        if(secondPlayer)
+            secondPlayer->GetSession()->SendAreaTriggerMessage("|cffffffffThe player |cff00ccff%s |cffffffffhas bet |cff00ccff%u|cffffffffx of the item |%s|Hitem:%u:0:0:0:0:0:0:0:%u|h[%s]|h|r", pPlayer, amount, GetQualityColor(itemProto->Quality).c_str(),  pItem->GetEntry(), pPlayer->getLevel(),  itemProto->Name1.c_str());
+        return true;
+    }
+    return false;
+}
+
+void GamblingSystem::AcceptChallenge(Player *pPlayer)
+{
+    GamblerMatchData *matchData = GetMatchDataBy(pPlayer);
+    if(matchData == NULL)
+        return;
+    if(matchData->IsChallenger(pPlayer))
+        matchData->SetChallengerReady(true);
+    else
+        matchData->SetDefenderReady(true);
+    if(matchData->GetChallengerReady() && matchData->GetDefenderReady())
+    {
+        Player *secondPlayer = NULL;
+
+        if(matchData->IsChallenger(pPlayer)){
+            secondPlayer = ObjectAccessor::FindPlayer(ObjectGuid(HighGuid::Player,matchData->GetDefenderGUID()));}
+        else{
+            secondPlayer = ObjectAccessor::FindPlayer(ObjectGuid(HighGuid::Player,matchData->GetChallengerGUID()));}
+
+        // Don't start the duel if there is no second player
+        if(secondPlayer == NULL)
+        {
+            ChatHandler(pPlayer->GetSession()).PSendSysMessage(GAMBLER_SYSTEM_MSG_CANT_LOCATE_PLAYER);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+        // Don't start the duel if they are already in a duel
+        if(secondPlayer->duel || pPlayer->duel)
+        {
+            SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_CANT_START_DUEL);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+        // Don't start the duel if they are already InCombat
+        if(secondPlayer->IsInCombat() || pPlayer->IsInCombat())
+        {
+            SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_CANT_START_DUEL);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+        // Don't start the duel if the players are logging out
+        if(secondPlayer->GetSession()->isLogingOut() || pPlayer->GetSession()->isLogingOut())
+        {
+            SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_CANT_START_LOGGING);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+
+        uint32 itemId1 = matchData->IsChallenger(pPlayer) ? matchData->GetChallengerItemId() : matchData->GetDefenderItemId();
+        uint32 itemId2 = matchData->IsChallenger(secondPlayer) ? matchData->GetChallengerItemId() : matchData->GetDefenderItemId();
+
+        uint32 amount1 = matchData->IsChallenger(pPlayer) ? matchData->GetChallengerItemCount() : matchData->GetDefenderItemCount();
+        uint32 amount2 = matchData->IsChallenger(secondPlayer) ? matchData->GetChallengerItemCount() : matchData->GetDefenderItemCount();
+
+        ItemTemplate const *Proto1 = sObjectMgr->GetItemTemplate(itemId1);
+        ItemTemplate const *Proto2 = sObjectMgr->GetItemTemplate(itemId2);
+
+        if(Proto1->BagFamily & BAG_FAMILY_MASK_CURRENCY_TOKENS || Proto2->BagFamily & BAG_FAMILY_MASK_CURRENCY_TOKENS){
+            // Missing data here, not important.
+        }else if(_checkItemValidity(pPlayer->GetItemByEntry(itemId1)) == false || _checkItemValidity(secondPlayer->GetItemByEntry(itemId2)) == false){
+            SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_ITEM_VALIDATE_FAIL);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+
+        // Don't start the duel if the players don't have the item in inventory
+        if(pPlayer->GetItemCount(itemId1) == 0 || secondPlayer->GetItemCount(itemId2) == 0)
+        {
+            SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_ITEM_NO_INV);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+
+        // Don't start the duel if the players don't have the amount of items betted
+        if(!pPlayer->GetItemCount(itemId1, amount1)  || !secondPlayer->GetItemCount(itemId2, amount2))
+        {
+            SendMessageToPlayers(matchData, ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+
+        // Don't start the duel if the players have betted more than the maximum specified in configuration
+        if(pPlayer->GetItemCount(amount1) > m_maxBet || secondPlayer->GetItemCount(amount2) > m_maxBet)
+        {
+            SendMessageToPlayers(matchData, ARENA_GAMBLER_MSG_BET_ADD_FAILED, m_maxBet);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+
+        _saveCurrentMatchProgress(matchData);
+        _updatePlayerStats(pPlayer->GetGUID().GetCounter(), GAMBLER_PLAYER_STAT_DUELS_TOTAL, 1);
+        _updatePlayerStats(secondPlayer->GetGUID().GetCounter(), GAMBLER_PLAYER_STAT_DUELS_TOTAL, 1);
+
+        pPlayer->DestroyItemCount(itemId1, amount1, true, true);
+        secondPlayer->DestroyItemCount(itemId2, amount2, true, true);
+
+        pPlayer->SaveToDB();
+        secondPlayer->SaveToDB();
+
+        SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_MATCH_STARTING);
+
+        pPlayer->SetBattlegroundEntryPoint();
+        secondPlayer->SetBattlegroundEntryPoint();
+        pPlayer->TeleportTo(m_arenaCoords.GetMapId(), m_arenaCoords.GetPositionX(), m_arenaCoords.GetPositionY(), m_arenaCoords.GetPositionZ(), m_arenaCoords.GetOrientation());
+        secondPlayer->TeleportTo(m_arenaCoords.GetMapId(), m_arenaCoords.GetPositionX(), m_arenaCoords.GetPositionY(), m_arenaCoords.GetPositionZ(), m_arenaCoords.GetOrientation());
+        matchData->SetMatchStatus(GAMBLER_MATCH_STATUS_TELEPORT);
+    }
+    else
+        SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_ACCEPTED_CHALLENGE, pPlayer);
+}
+
+void GamblingSystem::CancelChallenge(Player *pPlayer)
+{
+    GamblerMatchData *matchData = GetMatchDataBy(pPlayer);
+    if(matchData == NULL)
+        return;
+    SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_CANCELED, pPlayer, matchData->GetChallengerGUID() == pPlayer->GetGUID().GetCounter() ? GAMBLER_SYSTEM_MSG_CANCELED_1 : GAMBLER_SYSTEM_MSG_CANCELED_2);
+    if(matchData->IsDefender(pPlayer))
+        _updatePlayerStats(pPlayer->GetGUID().GetCounter(), GAMBLER_PLAYER_STAT_DUELS_REFUSED, 1);
+    _deleteMatchData(matchData->GetMatchId());
+}
+
+// Match Completion
+void GamblingSystem::HandleMatchComplete(Player *pWinner, Player *pLoser, GamblerMatchData *matchData, DuelCompleteType completeType)
+{
+    uint32 itemId1 = matchData->IsChallenger(pWinner) ? matchData->GetChallengerItemId() : matchData->GetDefenderItemId();
+    uint32 itemId2 = matchData->IsChallenger(pLoser) ? matchData->GetChallengerItemId() : matchData->GetDefenderItemId();
+    uint32 amount1 = matchData->IsChallenger(pWinner) ? matchData->GetChallengerItemCount() : matchData->GetDefenderItemCount();
+    uint32 amount2 = matchData->IsChallenger(pLoser) ? matchData->GetChallengerItemCount() : matchData->GetDefenderItemCount();
+    switch(completeType)
+    {
+        case DUEL_INTERRUPTED:
+        {
+            _createItemAndMailToPlayer(pWinner, pWinner->GetGUID().GetCounter(), itemId1, amount1, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_INCOMPLETE);
+            _createItemAndMailToPlayer(pLoser, pLoser->GetGUID().GetCounter(), itemId2, amount2, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_INCOMPLETE);
+            SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_DUEL_INTERRUPTED);
+        }break;
+        case DUEL_WON:
+        {
+            _createItemAndMailToPlayer(pWinner, pWinner->GetGUID().GetCounter(), itemId1, amount1, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_WON);
+            _createItemAndMailToPlayer(pWinner, pWinner->GetGUID().GetCounter(), itemId2, amount2, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_WON);
+            SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_DUEL_WON, pWinner);
+        }break;
+        case DUEL_FLED:
+        {
+            if(m_awardFled)
+            {
+                _createItemAndMailToPlayer(pWinner, pWinner->GetGUID().GetCounter(), itemId1, amount1, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_WON);
+                _createItemAndMailToPlayer(pWinner, pWinner->GetGUID().GetCounter(), itemId2, amount2, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_WON);
+                SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_DUEL_WON, pWinner);
+
+            }else{
+                _createItemAndMailToPlayer(pWinner, pWinner->GetGUID().GetCounter(), itemId1, amount1, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_INCOMPLETE);
+                _createItemAndMailToPlayer(pLoser, pLoser->GetGUID().GetCounter(), itemId2, amount2, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_INCOMPLETE);
+                SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_DUEL_FLED_NON_AWARD);
+            }
+        }break;
+    }
+    _updatePlayerStats(pWinner->GetGUID().GetCounter(), GAMBLER_PLAYER_STAT_DUELS_WON, 1);
+    _updatePlayerStats(pLoser->GetGUID().GetCounter(), GAMBLER_PLAYER_STAT_DUELS_LOST, 1);
+    matchData->SetMatchWinner(pWinner->GetGUID().GetCounter());
+    _saveCurrentMatchProgress(matchData);
+    _deleteMatchData(matchData->GetMatchId());
+    pWinner->TeleportToBGEntryPoint();
+    pLoser->TeleportToBGEntryPoint();
+}
+
+// Match Data
+void GamblingSystem::_deleteMatchData(Player *pPlayer)
+{
+    AcquireMatchLock();
+    GamblerMatchMap::iterator Itr;
+    for(Itr = m_matchStorage.begin(); Itr != m_matchStorage.end(); ++Itr)
+    {
+        if(Itr->second->GetChallengerGUID() == pPlayer->GetGUID().GetCounter() || Itr->second->GetDefenderGUID() == pPlayer->GetGUID().GetCounter())
+        {
+            delete Itr->second;
+            m_matchStorage.erase(Itr);
+            break;
+        }
+    }
+    ReleaseMatchLock();
+}
+
+bool GamblingSystem::_checkItemValidity(Item *pItem)
+{
+    if(pItem == NULL || pItem->IsSoulBound() || pItem->IsBoundAccountWide() || pItem->IsBoundByEnchant())
+        return false;
+    return true;
+}
+
+bool GamblingSystem::_checkWithinLimits(Item *pItem)
+{
+    /*
+    * Here you can add your items that you want players to be able to use in the system. this is temporary.
+    * uint32 GAMBLER_SYSTEM_ITEM_LIMITS [] = {ITEMID1,ITEMID2,ITEMID3};
+    */
+    uint32 GAMBLER_SYSTEM_ITEM_LIMITS [] = {20559};
+    for (uint32 i = 0; i < sizeof(GAMBLER_SYSTEM_ITEM_LIMITS)/sizeof(uint32); ++i){
+        if (pItem->GetEntry() == GAMBLER_SYSTEM_ITEM_LIMITS[i])
+            return true;
+    }
+    return false;
+}
+
+void GamblingSystem::_deleteMatchData(uint32 matchId)
+{
+    AcquireMatchLock();
+    GamblerMatchMap::iterator Itr = m_matchStorage.find(matchId);
+    if(Itr != m_matchStorage.end())
+        m_matchStorage.erase(Itr);
+    ReleaseMatchLock();
+}
+
+uint32 GamblingSystem::_generateMatchId()
+{
+    m_highMatchId++;
+    return m_highMatchId;
+}
+
+// Messaging
+void GamblingSystem::SendMessageToPlayers(GamblerMatchData *matchData, const char *msgToSend, ...)
+{
+    Player *pChallenger = ObjectAccessor::FindPlayer(ObjectGuid(HighGuid::Player,matchData->GetChallengerGUID()));
+    Player *pDefender    = ObjectAccessor::FindPlayer(ObjectGuid(HighGuid::Player,matchData->GetDefenderGUID()));
+
+    char Result[1024];
+    va_list List;
+    va_start(List, msgToSend);
+    vsnprintf(Result, 1024, msgToSend, List);
+    va_end(List);
+
+    if(pChallenger)
+        ChatHandler(pChallenger->GetSession()).PSendSysMessage(Result);
+    if(pDefender)
+        ChatHandler(pDefender->GetSession()).PSendSysMessage(Result);
+}
+
+// Mail System
+void GamblingSystem::_createItemAndMailToPlayer(Player *pPlayer, uint32 playerGUID, uint32 itemId, uint32 amount, std::string mailMessage)
+{
+    MailSender toSend(MAIL_NORMAL, playerGUID, GAMBLER_SYSTEM_MAIL_TYPE);
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    MailDraft mailDraft(GAMBLER_SYSTEM_MSG_MAIL_SUBJECT, mailMessage.c_str());
+
+    // extract items
+    typedef std::pair<uint32, uint32> ItemPair;
+    typedef std::list< ItemPair > ItemPairs;
+    ItemPairs items;
+    ItemTemplate const* item_proto = sObjectMgr->GetItemTemplate(itemId);
+    while (amount > item_proto->GetMaxStackSize())
+    {
+        items.push_back(ItemPair(itemId, item_proto->GetMaxStackSize()));
+        amount -= item_proto->GetMaxStackSize();
+    }
+    items.push_back(ItemPair(itemId, amount));
+
+    // TODO: items to be send is higher than the maximum items that a mail can hold!, security measure.
+    if (items.size() > MAX_MAIL_ITEMS){}
+
+    for(ItemPairs::const_iterator itr = items.begin(); itr != items.end(); ++itr)
+    {
+        if (Item* pItem = Item::CreateItem(itr->first, itr->second,pPlayer))
+        {
+           pItem->SaveToDB(trans);   // save for prevent lost at next mail load, if send fail then item will deleted
+           mailDraft.AddItem(pItem);
+        }
+    }
+
+    if(pPlayer){
+        mailDraft.SendMailTo(trans, MailReceiver(pPlayer), toSend);
+    }
+    else{
+        mailDraft.SendMailTo(trans, MailReceiver(playerGUID), toSend);
+    }
+    CharacterDatabase.CommitTransaction(trans);
+}
+
+// Called when a duel begins, check if both players have match data with each other
+void GamblerDuelScript::OnDuelRequest(Player *pDefender, Player *pChallenger)
+{
+    // To make sure we have the players and bug reporting
+    if(pDefender == NULL || pChallenger == NULL){
+        TC_LOG_ERROR("Arena", "GamblerDuelScript: OnDuelEnd pDefender or pChallenger is NULL!");
+        return;}
+
+    GamblerMatchData *ChallengerMatchData = sGamblingSystem->GetMatchDataBy(pChallenger);
+    GamblerMatchData *DefenderMatchData = sGamblingSystem->GetMatchDataBy(pDefender);
+
+    // if challenger or defender has no existing match data, return.
+    if(ChallengerMatchData == NULL || DefenderMatchData == NULL){
+        return;
+    }// if challenger or defender has match data existing
+    else{
+        // if challenger's match id is not the same as the defender, and they both have match data.
+        // then challenger has requested duel from someone else with match data.
+        if(ChallengerMatchData->GetMatchId() != DefenderMatchData->GetMatchId()){
+            ChatHandler(pChallenger->GetSession()).SendSysMessage(ARENA_GAMBLER_MSG_NOT_SAME_PLAYER);
+            sGamblingSystem->CancelChallenge(pChallenger);
+        }
+        // if the challenger has not set ready, or the defender has not set ready!
+        if(ChallengerMatchData->HasSetReady(pChallenger) == false || ChallengerMatchData->HasSetReady(pDefender) == false){
+            ChatHandler(pChallenger->GetSession()).SendSysMessage(ARENA_GAMBLER_MSG_NOT_READY);
+            sGamblingSystem->CancelChallenge(pChallenger);
+        }
+        // if challenger has no item id set, or defender has no item id set!
+        if(ChallengerMatchData->GetChallengerItemId() == 0 || ChallengerMatchData->GetDefenderItemId() == 0){
+            ChatHandler(pChallenger->GetSession()).SendSysMessage(ARENA_GAMBLER_MSG_NO_ITEM);
+            sGamblingSystem->CancelChallenge(pChallenger);
+        }
+        // if challenger has not set item count yet, or defender has not set item count yet!
+        if(ChallengerMatchData->GetChallengerItemCount() == 0 || ChallengerMatchData->GetDefenderItemCount() == 0){
+            ChatHandler(pChallenger->GetSession()).SendSysMessage(ARENA_GAMBLER_MSG_NO_AMOUNT);
+            sGamblingSystem->CancelChallenge(pChallenger);
+        }
+
+    }
+}
+
+// Called when a duel ends, check if there is a match running or not.
+void GamblerDuelScript::OnDuelEnd(Player *pWinner, Player *pLoser, DuelCompleteType type)
+{
+    // To make sure we have the players and bug reporting
+    if(pWinner == NULL || pLoser == NULL){
+        TC_LOG_ERROR("Arena", "GamblerDuelScript: OnDuelEnd pWinner or pLoser is NULL!");
+        return;}
+
+    GamblerMatchData *WinnerData = sGamblingSystem->GetMatchDataBy(pWinner);
+    GamblerMatchData *LoserData = sGamblingSystem->GetMatchDataBy(pLoser);
+
+    if(WinnerData == NULL || LoserData == NULL){
+        return;}
+    else if(WinnerData->GetMatchId() == LoserData->GetMatchId()){
+    sGamblingSystem->HandleMatchComplete(pWinner, pLoser, WinnerData, type);
+    }
+}
+
+// Called when a player logsout, if a player exists, check match data, if it started, if yes then complete the duel
+void GamblerDuelScript::OnLogout(Player *pPlayer)
+{
+    // To make sure we have the player and bug reporting
+    if(pPlayer == NULL){
+        TC_LOG_ERROR("Arena", "GamblerDuelScript: OnLogout pPlayer is NULL!");
+        return;}
+
+    GamblerMatchData *matchData = sGamblingSystem->GetMatchDataBy(pPlayer);
+    if(matchData == NULL){
+        return;}
+    else if(matchData->MatchStarted() && (matchData->GetChallengerGUID() == pPlayer->GetGUID().GetCounter() || matchData->GetDefenderGUID() == pPlayer->GetGUID().GetCounter()))
+            pPlayer->DuelComplete(DUEL_FLED);
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/ArenaGamblingSystem.h b/src/server/scripts/Custom/ArenaGamblingSystem.h
new file mode 100644
index 0000000..c861ea0
--- /dev/null
+++ b/src/server/scripts/Custom/ArenaGamblingSystem.h
@@ -0,0 +1,458 @@
+/*
+ * Author: Xees
+ * FileName: ArenaGamblingSystem.h
+ * Description: This file is used for definitions and requirements of the Arena Gambling System
+ * Version: 1.9
+ * Status: functional
+*/
+#ifndef ArenaGambler_H
+#define ArenaGambler_H
+
+// scriptName
+#define GAMBLER_SYSTEM_SCRIPT_NAME "custom_gambling_system_script"
+#define GAMBLER_SYSTEM_DUEL_SCRIPT_NAME "custom_gambler_duel_script"
+
+#define ARENA_GAMBLER_SCRIPT_NAME "duel_system"
+#define ARENA_RECORDS_SCRIPT_NAME "duel_records_system"
+
+enum ARENA_GAMBLER_MENUS
+{
+    ARENA_GAMBLER_MENU_MAIN    = 1,
+    ARENA_GAMBLER_MENU_CHALLENGE_PLAYER,
+    ARENA_GAMBLER_MENU_BET_ITEM,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_1,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_10,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_20,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_30,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_40,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_50,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_100,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_200,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_300,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_500,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_1000,
+    ARENA_GAMBLER_MENU_ACCEPT_CHALLENGE,
+    ARENA_GAMBLER_MENU_CANCEL_CHALLENGE,
+    ARENA_GAMBLER_MENU_DECLINE_CHALLENGE,
+    ARENA_GAMBLER_MENU_EXIT
+};
+
+enum ARENA_GAMBLER_MENU_ICONS
+{
+    ARENA_GAMBLER_ICON_CHALLENGE    = GOSSIP_ICON_BATTLE,            // ARENA_GAMBLER_MENU_CHALLENGE_PLAYER
+    ARENA_GAMBLER_ICON_BET_ITEM        = GOSSIP_ICON_MONEY_BAG,        // ARENA_GAMBLER_MENU_BET_ITEM
+    ARENA_GAMBLER_ICON_ACCEPT        = GOSSIP_ICON_BATTLE,            // ARENA_GAMBLER_MENU_ACCEPT_CHALLENGE
+    ARENA_GAMBLER_ICON_CANCEL        = GOSSIP_ICON_DOT,                // ARENA_GAMBLER_MENU_CANCEL_CHALLENGE
+    ARENA_GAMBLER_ICON_DECLINE        = GOSSIP_ICON_TAXI,                // ARENA_GAMBLER_MENU_DECLINE_CHALLENGE
+    ARENA_GAMBLER_ICON_EXIT            = GOSSIP_ICON_TABARD,            // ARENA_GAMBLER_MENU_EXIT
+};
+
+// Menu Texts
+#define ARENA_GAMBLER_TEXT_CHALLENGE "I would like to Challenge a player to a duel!"
+#define ARENA_GAMBLER_TEXT_CHALLENGE_CODE_TEXT "Enter the name of a player you wish to challenge. (Case Sensitive)"
+#define ARENA_GAMBLER_TEXT_BET_ITEM "I would like to Bet an item"
+#define ARENA_GAMBLER_TEXT_BET_ITEM_CODE_TEXT "Enter the name of the item you wish to bet"
+#define ARENA_GAMBLER_TEXT_BET_ITEM_AMOUNT "I would like to enter the amount"
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_TEXT "Select the amount of items you wish to bet"
+#define ARENA_GAMBLER_TEXT_ACCEPT_CHALLENGE "I accept the challenge!"
+#define ARENA_GAMBLER_TEXT_CANCEL_CHALLENGE "I do not want to this challenge!"
+#define ARENA_GAMBLER_TEXT_DECLINE_CHALLENGE "I do not accept this challenge!"
+#define ARENA_GAMBLER_TEXT_EXIT "Nevermind"
+
+// Amount of bets Menu text -- TODO: write a more efficient way to override Opcode OnGossipSelectWithCode string restrictions
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_1 "1 item."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_10 "10 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_20 "20 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_30 "30 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_40 "40 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_50 "50 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_100 "100 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_200 "200 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_300 "300 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_500 "500 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_1000 "1000 items."
+
+// Mail System Defines
+#define GAMBLER_SYSTEM_MSG_MAIL_SUBJECT "The Judgment Arena : Rewards !"
+#define GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_INCOMPLETE "Your item is being returned as the result of an incomplete match"
+#define GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_WON "You've won the match!"
+#define GAMBLER_SYSTEM_MAIL_TYPE MAIL_STATIONERY_GM
+
+// Messages
+#define GAMBLER_SYSTEM_MSG_ACCEPTED_CHALLENGE "%s has accepted the challenge!" // %s = accepters name
+#define GAMBLER_SYSTEM_MSG_ITEM_BET_PLACED "%s has placed item %s up for bet!" // %s1 = players name %s2 = items name
+#define GAMBLER_SYSTEM_MSG_CANCELED "%s has %s the match!" // the first %s will utilize one of the below defines considering the player is either, the challenger canceling the match, or the defender canceling the match
+#define GAMBLER_SYSTEM_MSG_CANCELED_1 "Canceled"
+#define GAMBLER_SYSTEM_MSG_CANCELED_2 "Forfeit"
+#define GAMBLER_SYSTEM_MSG_CANT_LOCATE_PLAYER "Could not locate the second player, match aborted!"
+#define GAMBLER_SYSTEM_MSG_CANT_START_DUEL "Cannot start match while currently in a duel, or in combat."
+#define GAMBLER_SYSTEM_MSG_CANT_START_LOGGING "Cannot start the match while one fo the players is logging out!"
+#define GAMBLER_SYSTEM_MSG_MATCH_STARTING "The match is now underway!"
+#define GAMBLER_SYSTEM_MSG_DUEL_INTERRUPTED "The duel has been interrupted, items have been mailed back to their original owners"
+#define GAMBLER_SYSTEM_MSG_DUEL_FLED_NON_AWARD "items have been mailed to their original owners"
+#define GAMBLER_SYSTEM_MSG_DUEL_WON "%s has been mailed his match winnings!" // %s = winnerName
+#define GAMBLER_SYSTEM_MSG_ITEM_VALIDATE_FAIL "An invalid item has caused the match to be stopped!"
+#define GAMBLER_SYSTEM_MSG_ITEM_NO_INV "The amount of items you can bet is invalid!"
+#define ARENA_GAMBLER_MSG_NOT_SAME_PLAYER "That is not the same person i requested the duel with!"
+#define ARENA_GAMBLER_MSG_PLAYER_NOT_FOUND "The player might be offline or away at the moment , i was not able to locate the player."
+#define ARENA_GAMBLER_MSG_MATCH_NOT_POSSIBLE "Duel is not accepted because of the following: "
+#define ARENA_GAMBLER_MSG_NO_GMS_ALLOWED "Game Masters are not allowed to duel!"
+#define ARENA_GAMBLER_MSG_SAME_ACC_ID "You cannot duel your self!"
+#define ARENA_GAMBLER_MSG_NOT_READY "You or your opponent has not set ready for the duel!"
+#define ARENA_GAMBLER_MSG_NO_ITEM "You or your opponent did not specify an item id!"
+#define ARENA_GAMBLER_MSG_NO_AMOUNT "You or your opponent did not specify an item amount!"
+#define ARENA_GAMBLER_MSG_MULTI_BOX "You cannot duel anyone with the same ip address!"
+#define ARENA_GAMBLER_MSG_LOW_LEVEL "Your level is too low to duel"
+#define ARENA_GAMBLER_MSG_MATCH_DATA "You have requested a duel from someone who already is in a duel."
+#define ARENA_GAMBLER_MSG_DIFF_NOT_MET "Your level is too high or too low to duel this player."
+#define ARENA_GAMBLER_MSG_CHALLENGE_ISSUED "You have challenged %s to a duel!"    // %s = defenders name
+#define ARENA_GAMBLER_MSG_CHALLENGED "%s wants to challenge you to a duel!"        // %s = challengers name
+#define ARENA_GAMBLER_MSG_ITEM_ADD_FAILED "You may not have the item, or the item could be soulbound, or you are not allowed to bet that item."
+#define ARENA_GAMBLER_MSG_BET_ADD_FAILED "The maximum amount of items you can bet is %u" // %u = maximum bet
+#define ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED "You may not have the item, or your bet is not the same as your opponent, or you have chosen a higher bet that allowed, your not allowed to duel this item."
+#define ARENA_GAMBLER_MSG_BET_AMOUNT_TOO_HIGH "The maximum number of items the player can recieve is lower than the amount betted."
+#define ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS "Your bet amount was entered successfully, please accept or reject the duel!"
+#define ARENA_GAMBLER_MSG_ITEM_ADD_SUCCESS "Your item was selected successfully, now select the amount you would like to bet!"
+
+// Intervals
+#define GAMBLER_SYSTEM_INTERVAL_TELE_CHECK 10000
+
+// Vars
+#define GAMBLER_SYSTEM_TOTAL_MAX_BET 1000
+
+#define MSG_COLOR_LIGHTRED      "|cffff6060"
+#define MSG_COLOR_LIGHTBLUE     "|cff00ccff"
+#define MSG_COLOR_BLUE          "|cff0000ff"
+#define MSG_COLOR_GREEN         "|cff00ff00"
+#define MSG_COLOR_RED           "|cffff0000"
+#define MSG_COLOR_GOLD          "|cffffcc00"
+#define MSG_COLOR_GREY          "|cff888888"
+#define MSG_COLOR_WHITE         "|cffffffff"
+#define MSG_COLOR_SUBWHITE      "|cffbbbbbb"
+#define MSG_COLOR_MAGENTA       "|cffff00ff"
+#define MSG_COLOR_YELLOW        "|cffffff00"
+#define MSG_COLOR_CYAN          "|cff00ffff"
+#define MSG_COLOR_ORANGE        "|cffff9900"
+
+#define QUALITY_POOR                 "cff9d9d9d"              //GREY
+#define QUALITY_NORMAL               "cffffffff"             //WHITE
+#define QUALITY_UNCOMMON             "cff1eff00"             //GREEN
+#define QUALITY_RARE                 "cff0070dd"             //BLUE
+#define QUALITY_EPIC                 "cffa335ee"             //PURPLE
+#define QUALITY_LEGENDARY            "cffff8000"             //ORANGE
+#define QUALITY_ARTIFACT             "cffe6cc80"             //LIGHT YELLOW
+#define QUALITY_HEIRLOOM             "cffe6cc80"              //LIGHT YELLOW
+
+enum MatchParticipants
+{
+    GAMBLER_CHALLENGER,
+    GAMBLER_DEFENDER,
+    GAMBLER_WINNER,
+    GAMBLER_MAX_MEMBERS,
+};
+
+enum GamberSystemConfigIndex
+{
+    GAMBLER_CONFIG_OPTION_MAPID,
+    GAMBLER_CONFIG_OPTION_COORDSX,
+    GAMBLER_CONFIG_OPTION_COORDSY,
+    GAMBLER_CONFIG_OPTION_COORDSZ,
+    GAMBLER_CONFIG_OPTION_COORDSO,
+    GAMBLER_CONFIG_OPTION_MIN_REQUIREDLEVEL,
+    GAMBLER_CONFIG_OPTION_MAX_LEVELDIFF,
+    GAMBLER_CONFIG_OPTION_AWARD_FLED,
+    GAMBLER_CONFIG_OPTION_MAX_BET,
+    GAMBLER_CONFIG_OPTION_ENABLE_GM,
+    GAMBLER_CONFIG_OPTION_ENABLE_SAMEIP,
+    GAMBLER_CONFIG_OPTION_ENABLE_LIMITS,
+    GAMBLER_CONFIG_OPTION_ONLY_CURRENCY,
+    GAMBLER_CONFIG_OPTION_EQUAL_DUELS
+};
+
+enum GamblerPlayerStatIndex
+{
+    GAMBLER_PLAYER_STAT_GUID,
+    GAMBLER_PLAYER_STAT_DUELS_LOST,
+    GAMBLER_PLAYER_STAT_DUELS_WON,
+    GAMBLER_PLAYER_STAT_DUELS_REFUSED,
+    GAMBLER_PLAYER_STAT_DUELS_TOTAL,
+    GAMBLER_PLAYER_STAT_MAX
+};
+
+enum GamblerMatchStatus
+{
+    GAMBLER_MATCH_STATUS_SETUP,
+    GAMBLER_MATCH_STATUS_TELEPORT,
+    GAMBLER_MATCH_STATUS_RUNNING,
+};
+
+struct GamblerMatchData
+{
+    public:
+        GamblerMatchData(uint32 Id, uint32 challengerGUID, uint32 defenderGUID)
+        {
+            SetMatchStatus(GAMBLER_MATCH_STATUS_SETUP);
+            SetChallengerGUID(challengerGUID);
+            SetDefenderGUID(defenderGUID);
+            SetChallengerReady(false);
+            SetDefenderReady(false);
+            SetMatchWinner(0);
+            matchId = Id;
+
+            for(uint8 i = 0; i < GAMBLER_MAX_MEMBERS-1; i++)
+                itemStorage[i] = 0;
+
+            for(uint8 i = 0; i < GAMBLER_MAX_MEMBERS-1; i++)
+                CountStorage[i] = 0;
+        }
+
+        GamblerMatchData(Field *pFields)
+        {
+            SetMatchStatus(GAMBLER_MATCH_STATUS_SETUP);
+            matchId    = pFields[0].GetUInt32();
+            SetChallengerGUID(pFields[1].GetUInt32());
+            SetDefenderGUID(pFields[2].GetUInt32());
+            SetChallengerItemId(pFields[3].GetUInt32());
+            SetChallengerItemCount(pFields[4].GetUInt32());
+            SetDefenderItemId(pFields[5].GetUInt32());
+            SetDefenderItemCount(pFields[6].GetUInt32());
+            SetMatchDate(pFields[7].GetString());
+            SetMatchWinner(pFields[8].GetUInt32());
+            SetChallengerReady(false);
+            SetDefenderReady(false);
+        }
+
+        // External Assignment Functions
+        void SetChallengerGUID(uint32 challengerGUID)    { _setMemberGUID(GAMBLER_CHALLENGER,    challengerGUID);    }
+        void SetDefenderGUID(uint32 defenderGUID)        { _setMemberGUID(GAMBLER_DEFENDER,        defenderGUID);        }
+        void SetChallengerItemId(uint32 itemId)            { _setMemberItemId(GAMBLER_CHALLENGER,    itemId);            }
+        void SetDefenderItemId(uint32 itemId)            { _setMemberItemId(GAMBLER_DEFENDER,    itemId);            }
+        void SetChallengerItemCount(uint32 amount)        { _setMemberItemCount(GAMBLER_CHALLENGER,    amount);        }
+        void SetDefenderItemCount(uint32 amount)        { _setMemberItemCount(GAMBLER_DEFENDER,    amount);            }
+        void SetChallengerReady(bool isReady)            { _setMemberReady(GAMBLER_CHALLENGER,    isReady);            }
+        void SetDefenderReady(bool isReady)                { _setMemberReady(GAMBLER_DEFENDER,        isReady);            }
+        void SetMatchWinner(uint32 winnerGUID)            { _setMemberGUID(GAMBLER_WINNER,        winnerGUID);        }
+        void SetMatchDate(std::string matchTime)        { matchDate = matchTime;                                    }
+        void SetMatchStatus(GamblerMatchStatus status)    { matchStatus = status;                                        }
+
+        // External Retrieval Functions
+        uint32 GetChallengerGUID()                        { return _getMemberGUID(GAMBLER_CHALLENGER);                }
+        uint32 GetDefenderGUID()                        { return _getMemberGUID(GAMBLER_DEFENDER);                    }
+        uint32 GetChallengerItemId()                    { return _getMemberItemId(GAMBLER_CHALLENGER);                }
+        uint32 GetDefenderItemId()                        { return _getMemberItemId(GAMBLER_DEFENDER);                }
+        uint32 GetChallengerItemCount()                    { return _getMemberItemCount(GAMBLER_CHALLENGER);            }
+        uint32 GetDefenderItemCount()                    { return _getMemberItemCount(GAMBLER_DEFENDER);                }
+        uint32 GetMatchWinner()                            { return _getMemberGUID(GAMBLER_WINNER);                    }
+        uint32 GetMatchId()                                { return matchId;                                            }
+        uint8 GetMatchStatus()                            { return matchStatus;                                        }
+        bool GetChallengerReady()                        { return _getMemberReadyStatus(GAMBLER_CHALLENGER);            }
+        bool GetDefenderReady()                            { return _getMemberReadyStatus(GAMBLER_DEFENDER);            }
+        std::string GetMatchDate()                        { return matchDate;                                            }
+
+        bool MatchStarted()
+        {
+            if(GetMatchStatus() >= GAMBLER_MATCH_STATUS_TELEPORT)
+                return true;
+            return false;
+        }
+
+        bool HasSetReady(Player *pPlayer)
+        {
+            if(IsChallenger(pPlayer))
+                return GetChallengerReady();
+            else
+                return GetDefenderReady();
+        }
+
+        uint32 GetItemIdBy(Player *pPlayer)
+        {
+            if(pPlayer->GetGUID().GetCounter() == GetChallengerGUID())
+                return GetChallengerItemId();
+            else
+                return GetDefenderItemId();
+        }
+
+        uint32 GetItemCountBy(Player *pPlayer)
+        {
+            if(pPlayer->GetGUID().GetCounter() == GetChallengerGUID())
+                return GetChallengerItemCount();
+            else
+                return GetDefenderItemCount();
+        }
+
+        // Misc Functions
+        bool IsChallenger(Player *pPlayer)
+        {
+            if(pPlayer->GetGUID().GetCounter() == GetChallengerGUID())
+                return true;
+            return false;
+        }
+
+        bool IsDefender(Player *pPlayer) { return !IsChallenger(pPlayer); }
+
+    private:
+        // Internal Assignment Functions
+        void _setMemberGUID(MatchParticipants matchMember, uint32 memberGUID) { guidStorage[matchMember] = memberGUID; }
+        void _setMemberItemId(MatchParticipants matchMember, uint32 itemId)
+        {
+            if(matchMember > GAMBLER_DEFENDER)
+                return;
+            itemStorage[matchMember] = itemId;
+        }
+        void _setMemberItemCount(MatchParticipants matchMember, uint32 amount)
+        {
+            if(matchMember > GAMBLER_DEFENDER)
+                return;
+            CountStorage[matchMember] = amount;
+        }
+
+        void _setMemberReady(MatchParticipants matchMember, bool isReady)
+        {
+            if(matchMember > GAMBLER_DEFENDER)
+                return;
+            readyStatus[matchMember] = isReady;
+        }
+
+        // Internal Retrieval Functions
+        uint32 _getMemberGUID(MatchParticipants matchMember) { return guidStorage[matchMember]; }
+        uint32 _getMemberItemId(MatchParticipants matchMember)
+        {
+            if(matchMember > GAMBLER_DEFENDER)
+                return 0;
+            return itemStorage[matchMember];
+        }
+        uint32 _getMemberItemCount(MatchParticipants matchMember)
+        {
+            if(matchMember > GAMBLER_DEFENDER)
+                return 0;
+            return CountStorage[matchMember];
+        }
+
+        bool _getMemberReadyStatus(MatchParticipants matchMember)
+        {
+            if(matchMember > GAMBLER_DEFENDER)
+                return false;
+            return readyStatus[matchMember];
+        }
+
+    protected:
+        uint32 guidStorage[GAMBLER_MAX_MEMBERS];
+        uint32 itemStorage[GAMBLER_MAX_MEMBERS-1];
+        uint32 CountStorage[GAMBLER_MAX_MEMBERS-1];
+        uint32 matchId;
+        GamblerMatchStatus matchStatus;
+        bool readyStatus[GAMBLER_MAX_MEMBERS-1];
+        std::string matchDate;
+};
+
+typedef std::map<uint32, GamblerMatchData*> GamblerMatchMap;
+class GamblingSystem : public WorldScript
+{
+    public:
+    static GamblingSystem* instance()
+    {
+        static GamblingSystem* instance = new GamblingSystem();
+        return instance;
+    }
+        GamblingSystem();
+        ~GamblingSystem();
+
+        // Creation
+        void Initalize();
+
+        // Events
+        // Called on every world tick (don't execute too heavy code here).
+        void OnUpdate(uint32 diff);
+
+        // Database Interaction
+        void LoadConfigData();
+
+        // Match Data Retrieval
+        GamblerMatchData *GetMatchDataBy(Player *pPlayer);
+
+        // Match Requirements Checking
+        bool CanHaveMatch(Player *pChallenger, Player *pDefender);
+
+        // Match Setup
+        void SetupMatch(Player *pChallenger, Player *pDefender);
+        bool AddItemForMatch(Player *pPlayer, std::string itemName);
+        bool AddItemAmountForMatch(Player *pPlayer, uint32 amount);
+        void AcceptChallenge(Player *pPlayer);
+        void CancelChallenge(Player *pPlayer);
+
+        std::string GetQualityColor(int32 qualityType) const;
+
+        // Match Completion
+        void HandleMatchComplete(Player *pWinner, Player *pLoser, GamblerMatchData *matchData, DuelCompleteType completeType);
+
+        // Messaging
+        void SendMessageToPlayers(GamblerMatchData *matchData, const char *msgToSend, ...);
+
+
+    private:
+        // Database Interaction
+        void _loadPastMatches();
+        void _saveCurrentMatchProgress(GamblerMatchData *matchData);
+        void _updatePlayerStats(uint32 playerGUID, GamblerPlayerStatIndex statIndex, uint32 statIncreaseValue);
+
+        // Mail System
+        void _createItemAndMailToPlayer(Player *pPlayer, uint32 playerGUID, uint32 itemId, uint32 amount, std::string mailMessage);
+
+        // Mutex Wrappers
+        void AcquireMatchLock()
+        {
+            std::lock_guard<std::mutex> lock(_matchLock);
+        }
+        void ReleaseMatchLock()
+        {
+            std::lock_guard<std::mutex> unlock(_matchLock);
+        }
+        // Match Data
+        bool _checkItemValidity(Item *pItem);
+        bool _checkItemValidity(uint32 itemId);
+        bool _checkWithinLimits(Item *pItem);
+        void _deleteMatchData(Player *pPlayer);
+        void _deleteMatchData(uint32 matchId);
+        uint32 _generateMatchId();
+    protected:
+
+        // Matches
+        std::mutex _matchLock;
+        GamblerMatchMap m_matchStorage;
+        IntervalTimer m_checkMatches;
+
+        // Config Data
+        WorldLocation m_arenaCoords;
+        uint32 m_minRequiredLevel;
+        uint8 m_maxLevelDiff;
+        uint32 m_highMatchId;
+        bool m_awardFled;
+        uint32 m_maxBet;
+        bool m_enableGM;
+        bool m_enableSameip;
+        bool m_enableLimits;
+        bool m_onlyCurrency;
+        bool m_equalDuels;
+};
+
+class GamblerDuelScript : PlayerScript
+{
+    public:
+    static GamblingSystem* instance()
+    {
+        static GamblingSystem* instance = new GamblingSystem();
+        return instance;
+    }
+    GamblerDuelScript() : PlayerScript(GAMBLER_SYSTEM_DUEL_SCRIPT_NAME) {}
+
+     // Called when a duel is requested
+    void OnDuelRequest(Player *pDefender, Player *pChallenger);
+    // Called when a duel ends
+    void OnDuelEnd(Player *pWinner, Player *pLoser, DuelCompleteType type);
+    // Called when a player logsout
+    void OnLogout(Player *pPlayer);
+};
+
+#define sGamblingSystem GamblingSystem::instance()
+#endif
\ No newline at end of file
diff --git a/src/server/scripts/Custom/Arena_Anti_Draw.cpp b/src/server/scripts/Custom/Arena_Anti_Draw.cpp
new file mode 100644
index 0000000..ea650f7
--- /dev/null
+++ b/src/server/scripts/Custom/Arena_Anti_Draw.cpp
@@ -0,0 +1,51 @@
+#include "Pet.h"
+
+const uint32 SPELL_DEMENTIA = 41406;
+
+class AntiDrawSystem : public PlayerScript
+{
+public:
+    AntiDrawSystem() : PlayerScript("AntiDrawSystem") {}
+
+    void OnUpdateZone(Player* player, uint32 newZone, uint32 newArea)
+	{
+		Pet* pet = player->GetPet();
+
+        // Remove Dementia on updating zone for player
+        if (player->HasAura(SPELL_DEMENTIA))
+            player->RemoveAura(SPELL_DEMENTIA);
+
+		// Remove Dementia on upddating zone for pet
+		if (pet)
+		{
+			if (pet->HasAura(SPELL_DEMENTIA))
+			{
+				pet->RemoveAura(SPELL_DEMENTIA);
+			}
+		}
+    }
+
+    void OnLogin(Player* player, bool /* OnLogin */)
+    {
+		Pet* pet = player->GetPet();
+
+        // Remove Dementia on player login
+        if (player->HasAura(SPELL_DEMENTIA))
+            player->RemoveAura(SPELL_DEMENTIA);
+
+		// Remove Dementia on Pet Login
+		if (pet)
+		{
+			if (pet->HasAura(SPELL_DEMENTIA))
+			{
+				pet->RemoveAura(SPELL_DEMENTIA);
+			}
+		}
+    }
+
+};
+
+void AddSC_Arena_AntiDraw()
+{
+    new AntiDrawSystem();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/BloodMoneyDuels.cpp b/src/server/scripts/Custom/BloodMoneyDuels.cpp
new file mode 100644
index 0000000..e2d1db4
--- /dev/null
+++ b/src/server/scripts/Custom/BloodMoneyDuels.cpp
@@ -0,0 +1,429 @@
+// Blood Money Duels
+// Original code by Parranoia from AC-web
+// Updated by Faiver from Emudevs
+// Edited by Rochet2
+// Original thread: http://www.ac-web.org/forums/showthread.php?156980-C-Blood-Money-Duels
+
+// Set USE_TOKEN to 1 if you want to have it use tokens in place of gold
+#define USE_TOKEN       0
+#define TOKEN_ID        29434
+
+
+class BloodMoney
+{
+public:
+    // Read write lock and guards
+    typedef boost::shared_mutex LockType;
+    typedef boost::shared_lock<LockType> ReadGuard;             // Lock for read access: ReadGuard guard(_lock);
+    typedef boost::unique_lock<LockType> WriteGuard;            // Lock for write access: WriteGuard guard(_lock);
+    typedef boost::upgrade_lock<LockType> RWRead;               // Lock for read access before writing: RWRead read(_lock);
+    typedef boost::upgrade_to_unique_lock<LockType> RWWrite;    // Lock for write access before writing: RWWrite write(read);
+
+    // Data definitions
+    struct MoneyInfo
+    {
+        MoneyInfo() : challenger(0), amount(0), accepted(false) { }
+        uint32 challenger;
+        uint32 amount;
+        bool accepted;
+    };
+    typedef std::list<MoneyInfo> MoneyList;
+    typedef std::unordered_map<uint32, MoneyList> MoneyListMap;
+
+    // Returns a copy or empty list
+    MoneyList GetMoneyList(uint32 targetGUID)
+    {
+        ReadGuard guard(_lock);
+        MoneyListMap::const_iterator it = _listMap.find(targetGUID);
+        if (it != _listMap.end())
+            return it->second;
+        return MoneyList();
+    }
+
+    // Finds a challenge and removes it, then returns the challenge amount. Otherwise returns 0 and does nothing
+    uint32 GetAndRemoveChallenge(uint32 targetGUID, uint32 challengerGUID)
+    {
+        RWRead read(_lock);
+        MoneyListMap::iterator it = _listMap.find(targetGUID);
+        if (it == _listMap.end())
+            return 0;
+
+        MoneyList& list = it->second;
+        for (MoneyList::iterator itr = list.begin(); itr != list.end(); ++itr)
+        {
+            if (itr->challenger != challengerGUID)
+                continue;
+            if (!itr->accepted)
+                return 0;
+
+            uint32 amount = itr->amount;
+
+            RWWrite write(read);
+            list.erase(itr);
+            if (list.empty())
+                _listMap.erase(targetGUID);
+
+            return amount;
+        }
+        return 0;
+    }
+
+    bool IsChallenged(uint32 targetGUID)
+    {
+        ReadGuard guard(_lock);
+        return _listMap.find(targetGUID) != _listMap.end();
+    }
+
+    bool HasChallenger(uint32 targetGUID, uint32 challengerGUID)
+    {
+        ReadGuard guard(_lock);
+        MoneyListMap::const_iterator it = _listMap.find(targetGUID);
+        if (it == _listMap.end())
+            return false;
+
+        const MoneyList& list = it->second;
+        for (MoneyList::const_iterator itr = list.begin(); itr != list.end(); ++itr)
+            if (itr->challenger == challengerGUID)
+                return true;
+
+        return false;
+    }
+
+    bool AddChallenger(uint32 targetGUID, uint32 challengerGUID, uint32 amount)
+    {
+        MoneyInfo moneyInfo;
+        moneyInfo.challenger = challengerGUID;
+        moneyInfo.amount = amount;
+        moneyInfo.accepted = false;
+
+        RWRead read(_lock);
+
+        if (HasChallenger(targetGUID, challengerGUID))
+            return false;
+
+        if (HasChallenger(challengerGUID, targetGUID))
+            return false;
+
+        RWWrite write(read);
+        _listMap[targetGUID].push_back(moneyInfo);
+        return true;
+    }
+
+    bool RemoveChallenger(uint32 targetGUID, uint32 challengerGUID)
+    {
+        RWRead read(_lock);
+        MoneyListMap::iterator it = _listMap.find(targetGUID);
+        if (it == _listMap.end())
+            return false;
+
+        MoneyList &list = it->second;
+        for (MoneyList::iterator it = list.begin(); it != list.end(); ++it)
+        {
+            if (it->challenger != challengerGUID)
+                continue;
+
+            RWWrite write(read);
+            list.erase(it);
+            if (list.empty())
+                _listMap.erase(targetGUID);
+            return true;
+        }
+        return false;
+    }
+
+    bool AcceptChallenge(uint32 targetGUID, uint32 challengerGUID)
+    {
+        RWRead read(_lock);
+        MoneyListMap::iterator it = _listMap.find(targetGUID);
+        if (it == _listMap.end())
+            return false;
+
+        MoneyList &list = it->second;
+        for (MoneyList::iterator itr = list.begin(); itr != list.end(); ++itr)
+        {
+            if (itr->challenger != challengerGUID)
+                continue;
+
+            // Already accepted, internal error
+            if (itr->accepted)
+                return false;
+
+            RWWrite write(read);
+            itr->accepted = true;
+            return true;
+        }
+        return false;
+    }
+
+    // Used to lock for using GetMap access
+    LockType& GetLock()
+    {
+        return _lock;
+    }
+
+    // Access map directly, remember to use lock to guard the read and write
+    MoneyListMap& GetMap()
+    {
+        return _listMap;
+    }
+
+private:
+    MoneyListMap _listMap;
+    LockType _lock;
+};
+
+static BloodMoney bloodMoney;
+
+class npc_blood_money : public CreatureScript
+{
+public:
+    npc_blood_money() : CreatureScript("npc_blood_money") { }
+
+    enum Sender
+    {
+        SENDER_CLOSE,
+        SENDER_CHALLENGE,
+        SENDER_ACCEPT,
+        SENDER_DECLINE,
+    };
+
+    bool OnGossipHello(Player* player, Creature* creature) override
+    {
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, "Challenge a Player", SENDER_CHALLENGE, 0);
+        if (bloodMoney.IsChallenged(player->GetGUID().GetCounter()))
+        {
+            BloodMoney::MoneyList list = bloodMoney.GetMoneyList(player->GetGUID().GetCounter());
+            for (BloodMoney::MoneyList::const_iterator it = list.begin(); it != list.end(); ++it)
+            {
+                // Skip accepted entries
+                if (it->accepted)
+                    continue;
+
+                if (Player* plr = ObjectAccessor::FindPlayer(ObjectGuid(HighGuid::Player, it->challenger)))
+                {
+#if(USE_TOKEN == 1)
+                    char msg[100];
+                    sprintf(msg, "Accept %s's Challenge of %u tokens", plr->GetName().c_str(), it->amount);
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, msg, SENDER_ACCEPT, it->challenger);
+                    sprintf(msg, "Decline %s's Challenge of %u tokens", plr->GetName().c_str(), it->amount);
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, msg, SENDER_DECLINE, it->challenger);
+#else
+                    char msg[100];
+                    sprintf(msg, "Accept %s's Challenge of %ug", plr->GetName().c_str(), it->amount);
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, msg, SENDER_ACCEPT, it->challenger);
+                    sprintf(msg, "Decline %s's Challenge of %ug", plr->GetName().c_str(), it->amount);
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, msg, SENDER_DECLINE, it->challenger);
+#endif
+                }
+            }
+        }
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Nevermind", SENDER_CLOSE, 0);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+        return true;
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        player->PlayerTalkClass->ClearMenus();
+        switch (sender)
+        {
+            case SENDER_ACCEPT:
+                if (bloodMoney.AcceptChallenge(player->GetGUID().GetCounter(), action))
+                {
+                    if (Player* challenger = ObjectAccessor::FindPlayer(ObjectGuid(HighGuid::Player, action)))
+                        creature->Whisper(player->GetName() + " has accepted your challenge!", LANG_UNIVERSAL, challenger, true);
+                }
+                else
+                {
+                    player->GetSession()->SendNotification("Internal error, try again");
+                }
+                break;
+            case SENDER_DECLINE:
+                if (bloodMoney.RemoveChallenger(player->GetGUID().GetCounter(), action))
+                {
+                    if (Player* challenger = ObjectAccessor::FindPlayer(ObjectGuid(HighGuid::Player, action)))
+                        creature->Whisper(player->GetName() + " has declined your challenge!", LANG_UNIVERSAL, challenger, true);
+                }
+                break;
+            case SENDER_CHALLENGE:
+#if(USE_TOKEN == 1)
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "Bet 5 tokens", GOSSIP_SENDER_MAIN, 5, "", 0, true);
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "Bet 10 tokens", GOSSIP_SENDER_MAIN, 10, "", 0, true);
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "Bet 15 tokens", GOSSIP_SENDER_MAIN, 15, "", 0, true);
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "Bet 25 tokens", GOSSIP_SENDER_MAIN, 25, "", 0, true);
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "Bet 50 tokens", GOSSIP_SENDER_MAIN, 50, "", 0, true);
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "Bet 100 tokens", GOSSIP_SENDER_MAIN, 100, "", 0, true);
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "Bet 150 tokens", GOSSIP_SENDER_MAIN, 150, "", 0, true);
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "Bet 200 tokens", GOSSIP_SENDER_MAIN, 200, "", 0, true);
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "Bet 250 tokens", GOSSIP_SENDER_MAIN, 250, "", 0, true);
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "Bet 500 tokens", GOSSIP_SENDER_MAIN, 500, "", 0, true);
+#else
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "Bet 5g", GOSSIP_SENDER_MAIN, 5, "", 5 * GOLD, true);
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "Bet 10g", GOSSIP_SENDER_MAIN, 10, "", 10 * GOLD, true);
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "Bet 15g", GOSSIP_SENDER_MAIN, 15, "", 15 * GOLD, true);
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "Bet 25g", GOSSIP_SENDER_MAIN, 25, "", 25 * GOLD, true);
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "Bet 50g", GOSSIP_SENDER_MAIN, 50, "", 50 * GOLD, true);
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "Bet 100g", GOSSIP_SENDER_MAIN, 100, "", 100 * GOLD, true);
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "Bet 150g", GOSSIP_SENDER_MAIN, 150, "", 150 * GOLD, true);
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "Bet 200g", GOSSIP_SENDER_MAIN, 200, "", 200 * GOLD, true);
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "Bet 250g", GOSSIP_SENDER_MAIN, 250, "", 250 * GOLD, true);
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "Bet 500g", GOSSIP_SENDER_MAIN, 500, "", 500 * GOLD, true);
+#endif
+                player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+                return true;
+
+            default:
+                player->CLOSE_GOSSIP_MENU();
+                return true;
+        }
+
+        OnGossipHello(player, creature);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, const char* code)
+    {
+        player->PlayerTalkClass->ClearMenus();
+
+        std::string targetName(code);
+        if (player->GetName() == targetName)
+        {
+            player->GetSession()->SendNotification("You can not challenge yourself");
+            OnGossipSelect(player, creature, SENDER_CHALLENGE, GOSSIP_ACTION_INFO_DEF);
+            return true;
+        }
+
+        Player* target = ObjectAccessor::FindConnectedPlayerByName(targetName);
+        if (!target)
+        {
+            player->GetSession()->SendNotification("Challenged player not logged in");
+            OnGossipSelect(player, creature, SENDER_CHALLENGE, GOSSIP_ACTION_INFO_DEF);
+            return true;
+        }
+
+        if (player->GetGUID() == target->GetGUID())
+        {
+            player->GetSession()->SendNotification("You can not challenge yourself");
+            OnGossipSelect(player, creature, SENDER_CHALLENGE, GOSSIP_ACTION_INFO_DEF);
+            return true;
+        }
+
+        if (target->GetZoneId() != player->GetZoneId())
+        {
+            player->GetSession()->SendNotification("%s is not in same zone", target->GetName().c_str());
+            OnGossipSelect(player, creature, SENDER_CHALLENGE, GOSSIP_ACTION_INFO_DEF);
+            return true;
+        }
+
+#if (USE_TOKEN == 1)
+        if (!player->HasItemCount(TOKEN_ID, action))
+        {
+            player->GetSession()->SendNotification("You do not have enough tokens");
+            OnGossipSelect(player, creature, SENDER_CHALLENGE, GOSSIP_ACTION_INFO_DEF);
+            return true;
+        }
+
+        if (!target->HasItemCount(TOKEN_ID, action))
+        {
+            player->GetSession()->SendNotification("%s does not have enough tokens", target->GetName().c_str());
+            OnGossipSelect(player, creature, SENDER_CHALLENGE, GOSSIP_ACTION_INFO_DEF);
+            return true;
+        }
+#else
+        if (target->GetMoney() < action * GOLD)
+        {
+            player->GetSession()->SendNotification("%s does not have enough money", target->GetName().c_str());
+            OnGossipSelect(player, creature, SENDER_CHALLENGE, GOSSIP_ACTION_INFO_DEF);
+            return true;
+        }
+
+        if (player->GetMoney() < action * GOLD)
+        {
+            player->GetSession()->SendNotification("You do not have enough money");
+            OnGossipSelect(player, creature, SENDER_CHALLENGE, GOSSIP_ACTION_INFO_DEF);
+            return true;
+        }
+#endif
+
+        if (!bloodMoney.AddChallenger(target->GetGUID().GetCounter(), player->GetGUID().GetCounter(), action))
+        {
+            player->GetSession()->SendNotification("One of you already challenged the other");
+            OnGossipSelect(player, creature, SENDER_CHALLENGE, GOSSIP_ACTION_INFO_DEF);
+            return true;
+        }
+
+        creature->Whisper(player->GetName() + " has requested a Blood Money duel with you!", LANG_UNIVERSAL, target, true);
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+};
+
+class BloodMoneyReward : public PlayerScript
+{
+public:
+    BloodMoneyReward() : PlayerScript("BloodMoneyReward") { }
+
+    void OnDuelEnd(Player* winner, Player* loser, DuelCompleteType type)
+    {
+        if (type != DUEL_WON)
+            return;
+
+        // Loser challenged winner
+        uint32 amount = bloodMoney.GetAndRemoveChallenge(winner->GetGUID().GetCounter(), loser->GetGUID().GetCounter());
+
+        // Winner challenged loser
+        if (!amount)
+            amount = bloodMoney.GetAndRemoveChallenge(loser->GetGUID().GetCounter(), winner->GetGUID().GetCounter());
+
+        // No challenges
+        if (!amount)
+            return;
+
+#if (USE_TOKEN == 1)
+        if (!winner->HasItemCount(TOKEN_ID, amount))
+        {
+            winner->AddAura(15007, winner); // Apply Rez sickness for possible cheating
+            ChatHandler(winner->GetSession()).PSendSysMessage("|cff800C0C[Blood Money] |cffFFFFFFYou have gained Resurrection Sickness for possibly trying to abuse the system.");
+            ChatHandler(loser->GetSession()).PSendSysMessage("|cff800C0C[Blood Money] |cffFFFFFFYour opponent tried to cheat you. Don't worry you did not lose any tokens because of this.");
+        }
+        else if (!loser->HasItemCount(TOKEN_ID, amount))
+        {
+            loser->AddAura(15007, loser);   // Apply Rez sickness for possible cheating
+            ChatHandler(winner->GetSession()).PSendSysMessage("|cff800C0C[Blood Money] |cffFFFFFFYou have gained Resurrection Sickness for possibly trying to abuse the system.");
+            ChatHandler(loser->GetSession()).PSendSysMessage("|cff800C0C[Blood Money] |cffFFFFFFYour opponent tried to cheat you. Don't worry you did not lose any tokens because of this.");
+        }
+        else
+        {
+            winner->AddItem(TOKEN_ID, amount);
+            loser->DestroyItemCount(TOKEN_ID, amount, true);
+            ChatHandler(winner->GetSession()).PSendSysMessage("|cff800C0C[Blood Money] |cffFFFFFFCongratulations on winning %u tokens!", amount);
+        }
+#else
+        int32 money = amount * GOLD;
+        if (winner->GetMoney() < money)
+        {
+            winner->AddAura(15007, winner);         // Apply Rez sickness for possible cheating
+            ChatHandler(winner->GetSession()).PSendSysMessage("|cff800C0C[Blood Money] |cffFFFFFFYou have gained Resurrection Sickness for possibly trying to abuse the system.");
+            ChatHandler(loser->GetSession()).PSendSysMessage("|cff800C0C[Blood Money] |cffFFFFFFYour opponent tried to cheat you. Don't worry you did not lose any money because of this.");
+        }
+        else if (loser->GetMoney() < money)
+        {
+            loser->AddAura(15007, loser);           // Apply Rez sickness for possible cheating
+            ChatHandler(winner->GetSession()).PSendSysMessage("|cff800C0C[Blood Money] |cffFFFFFFYour opponent tried to cheat you. He did not have enough money to pay off the bet.");
+            ChatHandler(loser->GetSession()).PSendSysMessage("|cff800C0C[Blood Money] |cffFFFFFFYou have gained Resurrection Sickness for possibly trying to abuse the system.");
+        }
+        else
+        {
+            winner->ModifyMoney(money);
+            loser->ModifyMoney(-money);
+            ChatHandler(winner->GetSession()).PSendSysMessage("|cff800C0C[Blood Money] |cffFFFFFFCongratulations on winning %ug!", amount);
+        }
+#endif
+    }
+};
+
+void AddSC_npc_blood_money()
+{
+    new BloodMoneyReward();
+    new npc_blood_money();
+}
diff --git a/src/server/scripts/Custom/DoubleXP.cpp b/src/server/scripts/Custom/DoubleXP.cpp
new file mode 100644
index 0000000..d58ed67
--- /dev/null
+++ b/src/server/scripts/Custom/DoubleXP.cpp
@@ -0,0 +1,39 @@
+#include "Player.h"
+#include "Chat.h"
+#include "World.h"
+#include "boost/date_time.hpp"
+
+
+class XpWeekend : public PlayerScript 
+{
+	public:
+	XpWeekend() : PlayerScript("XpWeekend") { }
+	void OnGiveXP(Player* player, uint32& amount, Unit* victim)override
+{
+    boost::gregorian::date date(boost::gregorian::day_clock::local_day());
+    auto day = date.day_of_week();
+    if (day == boost::date_time::Friday ||
+        day == boost::date_time::Saturday ||
+        day == boost::date_time::Sunday) {
+
+        amount = amount*2; }
+} 
+	void OnLogin(Player* player, bool firstLogin)
+	{
+		boost::gregorian::date date(boost::gregorian::day_clock::local_day());
+    auto day = date.day_of_week();
+    if (day == boost::date_time::Friday ||
+        day == boost::date_time::Saturday ||
+        day == boost::date_time::Sunday) {
+
+		ChatHandler(player->GetSession()).PSendSysMessage("Double XP is going on now!");
+		}
+
+	}
+
+};
+
+void AddSC_XpWeekend()
+{
+	new XpWeekend();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/LearnSpells.cpp b/src/server/scripts/Custom/LearnSpells.cpp
new file mode 100644
index 0000000..0ad762e
--- /dev/null
+++ b/src/server/scripts/Custom/LearnSpells.cpp
@@ -0,0 +1,147 @@
+#include "DisableMgr.h"
+ 
+class LearnSpellsOnLevelUp : public PlayerScript
+{
+        public:
+                std::vector<uint32> ignoreSpells;
+ 
+                LearnSpellsOnLevelUp() : PlayerScript("LearnSpellsOnLevelUp")
+                {
+                        uint32 temp[] = {
+                                64380, 23885, 23880, 44461, 25346, 10274, 10273, 8418,
+                                8419, 7270, 7269, 7268, 54648, 12536, 24530, 70909,
+                                12494, 57933, 24224, 27095, 27096, 27097, 27099, 32841,
+                                56131, 56160, 56161, 48153, 34754, 64844, 64904, 48085,
+                                33110, 48084, 28276, 27874,     27873, 7001, 49821, 53022,
+                                47757, 47750, 47758, 47666, 53001, 52983, 52998, 52986,
+                                52987, 52999, 52984, 53002, 53003, 53000, 52988, 52985,
+                                42208, 42209, 42210, 42211, 42212, 42213, 42198, 42937,
+                                42938, 12484, 12485, 12486, 44461, 55361, 55362, 34913,
+                                43043, 43044, 38703, 38700, 27076, 42844, 42845, 64891,
+                                25912, 25914, 25911, 25913, 25902, 25903, 27175, 27176,
+                                33073, 33074, 48822, 48820, 48823, 48821, 20154, 25997,
+                                20467, 20425, 67, 26017, 34471, 53254, 13812, 14314,
+                                14315, 27026, 49064, 49065, 60202, 60210, 13797, 14298,
+                                14299, 14300, 14301, 27024, 49053, 49054, 52399, 1742,
+                                24453, 53548, 53562, 52016, 26064, 35346, 57386, 57389,
+                                57390, 57391, 57392, 57393, 55509, 35886, 43339, 45297,
+                                45298, 45299, 45300, 45301, 45302, 49268, 49269, 8349,
+                                8502, 8503, 11306, 11307, 25535, 25537, 61650, 61654,
+                                63685, 45284, 45286, 45287, 45288, 45289, 45290, 45291,
+                                45292, 45293, 45294, 45295, 45296, 49239, 49240, 26364,
+                                26365, 26366, 26367, 26369, 26370, 26363, 26371, 26372,
+                                49278, 49279, 32176, 32175, 21169, 47206, 27285, 47833,
+                                47836, 42223, 42224, 42225, 42226, 42218, 47817, 47818,
+                                42231, 42232, 42233, 42230, 48466, 44203, 44205, 44206,
+                                44207, 44208, 48444, 48445, 33891, 52374, 57532, 59921,
+                                52372, 49142, 52375, 47633, 47632, 52373, 50536, 27214,
+                                47822, 11682, 11681, 5857, 1010, 24907, 24905, 53227,
+                                61391, 61390, 61388, 61387, 64801, 5421, 9635, 1178,
+                                20186, 20185, 20184, 20187, 25899, 24406, 50581, 30708
+                                                        };
+ 
+                                ignoreSpells = std::vector<uint32> (temp, temp + sizeof(temp)/sizeof(temp[0]));
+                }
+ 
+        void OnLevelChanged(Player* player, uint8 oldLevel)
+        {
+                if (oldLevel < player->getLevel())
+                        LearnSpellsForNewLevel(player, oldLevel);
+        }
+ 
+        bool IsIgnoredSpell(uint32 spellID)
+        {
+                for (std::vector<uint32>::const_iterator itr = ignoreSpells.begin(); itr != ignoreSpells.end(); ++itr)
+                        if (spellID == (*itr))
+                                return true;
+                return false;
+        }
+ 
+        void LearnSpellsForNewLevel(Player* player, uint8 level)
+        {
+                if (level == player->getLevel() + 1)
+                        return;
+                uint32 family;
+                switch(player->getClass())
+                {
+                        case CLASS_ROGUE:
+                                family = SPELLFAMILY_ROGUE;
+                                break;
+                        case CLASS_DEATH_KNIGHT:
+                                family = SPELLFAMILY_DEATHKNIGHT;
+                                break;
+                        case CLASS_WARRIOR:
+                                family = SPELLFAMILY_WARRIOR;
+                                break;
+                        case CLASS_PRIEST:
+                                family = SPELLFAMILY_PRIEST;
+                                break;
+                        case CLASS_MAGE:
+                                family = SPELLFAMILY_MAGE;
+                                break;
+                        case CLASS_PALADIN:
+                                family = SPELLFAMILY_PALADIN;
+                                break;
+                        case CLASS_HUNTER:
+                                family = SPELLFAMILY_HUNTER;
+                                break;
+                        case CLASS_DRUID:
+                                family = SPELLFAMILY_DRUID;
+                                break;
+                        case CLASS_SHAMAN:
+                                family = SPELLFAMILY_SHAMAN;
+                                break;
+                        case CLASS_WARLOCK:
+                                family = SPELLFAMILY_WARLOCK;
+                                break;
+                }
+                for (uint32 i = 0; i < sSpellMgr->GetSpellInfoStoreSize(); ++i)
+                {
+                        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(i);
+                        if (!spellInfo)
+                                continue;
+                        if (spellInfo->SpellFamilyName != family)
+                                continue;
+                        if (IsIgnoredSpell(spellInfo->Id))
+                                continue;
+                        if (spellInfo->PowerType == POWER_FOCUS)
+                                continue;
+            if (DisableMgr::IsDisabledFor(DISABLE_TYPE_SPELL, spellInfo->Id, player))
+                                continue;
+            if ((spellInfo->AttributesEx7 & SPELL_ATTR7_ALLIANCE_ONLY && player->GetTeam() != ALLIANCE) || (spellInfo->AttributesEx7 & SPELL_ATTR7_HORDE_ONLY && player->GetTeam() != HORDE))
+                                continue;
+            if (spellInfo->BaseLevel != level && sSpellMgr->IsSpellValid(spellInfo, player))
+                continue;
+ 
+                        bool valid = false;
+ 
+                        SkillLineAbilityMapBounds bounds = sSpellMgr->GetSkillLineAbilityMapBounds(spellInfo->Id);
+                        for (SkillLineAbilityMap::const_iterator itr = bounds.first; itr != bounds.second; ++itr)
+                        {
+                                if (itr->second->spellId == spellInfo->Id && itr->second->racemask == 0 && itr->second->AutolearnType == 0)
+                                {
+                    valid = true;
+                    SpellInfo const* prevSpell = spellInfo->GetPrevRankSpell();
+                    if (prevSpell && !player->HasSpell(prevSpell->Id))
+                    {
+                        valid = false;
+                        break;
+                    }
+                    if (GetTalentSpellPos(itr->second->spellId))
+                        if (!prevSpell || !player->HasSpell(prevSpell->Id) || spellInfo->GetRank() == 1)
+                            valid = false;
+                    break;
+                                }
+                        }
+ 
+                        if (valid)
+                                player->LearnSpell(spellInfo->Id, false);
+                }
+                LearnSpellsForNewLevel(player, ++level);
+        }
+};
+ 
+void AddSC_LearnSpellsOnLevelUp()
+{
+        new LearnSpellsOnLevelUp();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/Phased_Duels.cpp b/src/server/scripts/Custom/Phased_Duels.cpp
new file mode 100644
index 0000000..8241a67
--- /dev/null
+++ b/src/server/scripts/Custom/Phased_Duels.cpp
@@ -0,0 +1,98 @@
+/*
+Credits:
+Rochet2
+Tommy
+
+There were few more, but couldnt find them
+
+Release:
+http://emudevs.com/showthread.php/3413-Phased-duel-(pets-work)?p=24109
+Original source:
+http://emudevs.com/showthread.php/2282-phase-out-dueling-error?p=15483&viewfull=1#post15483
+*/
+
+class PhasedDueling : public PlayerScript
+{
+public:
+    PhasedDueling(): PlayerScript("PhasedDueling") {}
+
+    void OnDuelStart(Player* firstplayer, Player* secondplayer) override
+    {
+        Map* map = firstplayer->GetMap();
+        if (map->IsDungeon())
+            return;
+
+        // Duel flag is used as duel center point
+		GameObject* go = map->GetGameObject(ObjectGuid(firstplayer->GetUInt64Value(PLAYER_DUEL_ARBITER)));
+        if (!go)
+            return;
+
+        // Get players from 100 yard radius ( duel radius is 40-50 yd )
+        std::list<Player*> playerList;
+        Trinity::AnyPlayerInObjectRangeCheck checker(go, 100.0f);
+        Trinity::PlayerListSearcher<Trinity::AnyPlayerInObjectRangeCheck> searcher(go, playerList, checker);
+        go->VisitNearbyWorldObject(100.0f, searcher);
+
+        // insert players' phases to used phases, ignore GMs
+        uint32 usedPhases = 0;
+        if (!playerList.empty())
+            for (std::list<Player*>::const_iterator it = playerList.begin(); it != playerList.end(); ++it)
+                if (!(*it)->IsGameMaster())
+                    usedPhases |= (*it)->GetPhaseMask();
+
+        // loop all unique phases
+        for (uint32 phase = 2; phase <= ULONG_MAX / 2; phase *= 2)
+        {
+            // If phase in use, skip
+            if (usedPhases & phase)
+                continue;
+
+            // Phase players & pets, dont update visibility yet
+            firstplayer->SetPhaseMask(phase, false);
+            secondplayer->SetPhaseMask(phase, false);
+            // Phase duel flag
+            go->SetPhaseMask(phase, true);
+            // Update visibility here so pets will be phased and wont despawn
+            firstplayer->UpdateObjectVisibility();
+            secondplayer->UpdateObjectVisibility();
+            return;
+        }
+
+        // Couldnt find free unique phase
+        firstplayer->GetSession()->SendNotification("There are no free phases");
+        secondplayer->GetSession()->SendNotification("There are no free phases");
+    }
+
+    // Restore phases
+    void OnDuelEnd(Player* firstplayer, Player* secondplayer, DuelCompleteType type) override
+    {
+        // Phase players, dont update visibility yet
+        firstplayer->SetPhaseMask(GetNormalPhase(firstplayer), false);
+        secondplayer->SetPhaseMask(GetNormalPhase(secondplayer), false);
+        // Update visibility here so pets will be phased and wont despawn
+        firstplayer->UpdateObjectVisibility();
+        secondplayer->UpdateObjectVisibility();
+    }
+
+    // Attempt in storing the player phase with spell phases included.
+    uint32 GetNormalPhase(Player* player) const
+    {
+        if (player->IsGameMaster())
+            return uint32(PHASEMASK_ANYWHERE);
+
+        // GetPhaseMaskForSpawn copypaste
+        uint32 phase = PHASEMASK_NORMAL;
+        Player::AuraEffectList const& phases = player->GetAuraEffectsByType(SPELL_AURA_PHASE);
+        if (!phases.empty())
+            phase = phases.front()->GetMiscValue();
+        if (uint32 n_phase = phase & ~PHASEMASK_NORMAL)
+            return n_phase;
+
+        return PHASEMASK_NORMAL;
+    }
+};
+
+void AddSC_PhasedDueling()
+{
+    new PhasedDueling();
+}
diff --git a/src/server/scripts/Custom/Reforging.cpp b/src/server/scripts/Custom/Reforging.cpp
new file mode 100644
index 0000000..b47e225
--- /dev/null
+++ b/src/server/scripts/Custom/Reforging.cpp
@@ -0,0 +1,644 @@
+/*
+Reforging by Rochet2
+https://rochet2.github.io/?page=Transmogrification
+
+Rules of thumb:
+Item can be reforged once.
+Item reforge wont show to anyone but you in tooltips. Stats will be there nevertheless.
+You will see the increased stats on all tooltips of the same item you reforged.
+You can disable the stat changes to tooltips by setting send_cache_packets to false.
+Reforges are stripped when you mail, ah, guildbank the item etc. Only YOU can have the reforge.
+Only item base stats are reforgable. Enchants and random stats are not.
+
+This script is made blizzlike. This means that the reforgable stats etc are from CATACLYSM!
+I have been informed that some stats were removed etc that would be important to be reforgable.
+However I do not know what those stats are currently. Do look through the statTypes to add whatever you want.
+Edit IsReforgable is you want to tweak requirements
+
+*/
+
+static const bool send_cache_packets = true;    // change player cache?
+
+// Remember to add to GetStatName too
+static const ItemModType statTypes[] = { ITEM_MOD_SPIRIT, ITEM_MOD_DODGE_RATING, ITEM_MOD_PARRY_RATING, ITEM_MOD_HIT_RATING, ITEM_MOD_CRIT_RATING, ITEM_MOD_HASTE_RATING, ITEM_MOD_EXPERTISE_RATING };
+static const uint8 stat_type_max = sizeof(statTypes) / sizeof(*statTypes);
+
+static const char* GetStatName(uint32 ItemStatType)
+{
+    switch(ItemStatType)
+    {
+    case ITEM_MOD_SPIRIT                   	: return "Spirit"; break;
+    case ITEM_MOD_DODGE_RATING             	: return "Dodge rating"; break;
+    case ITEM_MOD_PARRY_RATING             	: return "Parry rating"; break;
+    case ITEM_MOD_HIT_RATING               	: return "Hit rating"; break;
+    case ITEM_MOD_CRIT_RATING              	: return "Crit rating"; break;
+    case ITEM_MOD_HASTE_RATING             	: return "Haste rating"; break;
+    case ITEM_MOD_EXPERTISE_RATING         	: return "Expertise rating"; break;
+    default: return NULL;
+    }
+}
+
+static const char* GetSlotName(uint8 slot, WorldSession* session)
+{
+    switch (slot)
+    {
+    case EQUIPMENT_SLOT_HEAD      : return "Head";
+    case EQUIPMENT_SLOT_NECK      : return "Neck";
+    case EQUIPMENT_SLOT_SHOULDERS : return "Shoulders";
+    case EQUIPMENT_SLOT_BODY      : return "Shirt";
+    case EQUIPMENT_SLOT_CHEST     : return "Chest";
+    case EQUIPMENT_SLOT_WAIST     : return "Waist";
+    case EQUIPMENT_SLOT_LEGS      : return "Legs";
+    case EQUIPMENT_SLOT_FEET      : return "Feet";
+    case EQUIPMENT_SLOT_WRISTS    : return "Wrists";
+    case EQUIPMENT_SLOT_HANDS     : return "Hands";
+    case EQUIPMENT_SLOT_FINGER1   : return "Right finger";
+    case EQUIPMENT_SLOT_FINGER2   : return "Left finger";
+    case EQUIPMENT_SLOT_TRINKET1  : return "Right trinket";
+    case EQUIPMENT_SLOT_TRINKET2  : return "Left trinket";
+    case EQUIPMENT_SLOT_BACK      : return "Back";
+    case EQUIPMENT_SLOT_MAINHAND  : return "Main hand";
+    case EQUIPMENT_SLOT_OFFHAND   : return "Off hand";
+    case EQUIPMENT_SLOT_TABARD    : return "Tabard";
+    case EQUIPMENT_SLOT_RANGED    : return "Ranged";
+    default: return NULL;
+    }
+}
+
+static uint32 Melt(uint8 i, uint8 j)
+{
+    return (i << 8) + j;
+}
+
+static void Unmelt(uint32 melt, uint8& i, uint8& j)
+{
+    i = melt >> 8;
+    j = melt & 0xFF;
+}
+
+static std::vector<Item*> GetItemList(const Player* player)
+{
+    std::vector<Item*> itemlist;
+
+    // Copy paste from Player::GetItemByGuid(guid)
+
+    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            itemlist.push_back(pItem);
+
+    for (uint8 i = KEYRING_SLOT_START; i < CURRENCYTOKEN_SLOT_END; ++i)
+        if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            itemlist.push_back(pItem);
+
+    for (int i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
+        if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            itemlist.push_back(pItem);
+
+    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+        if (Bag* pBag = player->GetBagByPos(i))
+            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
+                if (Item* pItem = pBag->GetItemByPos(j))
+                    itemlist.push_back(pItem);
+
+    for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
+        if (Bag* pBag = player->GetBagByPos(i))
+            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
+                if (Item* pItem = pBag->GetItemByPos(j))
+                    itemlist.push_back(pItem);
+
+    return itemlist;
+}
+
+static Item* GetEquippedItem(Player* player, uint32 guidlow)
+{
+    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            if (pItem->GetGUID().GetCounter() == guidlow)
+                return pItem;
+    return NULL;
+}
+
+void RemoveReforge(Player* player, uint32 itemguid, bool update);
+
+// Supply lowguid or reforge! (or both)
+// Warning, this function may modify player->reforgeMap when lowguid is supplied
+static void SendReforgePacket(Player* player, uint32 entry, uint32 lowguid = 0, const ReforgeData* reforge = NULL)
+{
+    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(entry);
+    if (!pProto)
+        return;
+
+    if (lowguid)
+    {
+        if (!player->reforgeMap.empty() && player->reforgeMap.find(lowguid) != player->reforgeMap.end())
+            reforge = &player->reforgeMap[lowguid];
+        else
+            RemoveReforge(player, lowguid, true);
+    }
+
+    // Update player cache (self only) pure visual.
+    // HandleItemQuerySingleOpcode copy paste
+    std::string Name        = pProto->Name1;
+    std::string Description = pProto->Description;
+    int loc_idx = player->GetSession()->GetSessionDbLocaleIndex();
+    if (loc_idx >= 0)
+    {
+        if (ItemLocale const* il = sObjectMgr->GetItemLocale(pProto->ItemId))
+        {
+            ObjectMgr::GetLocaleString(il->Name, loc_idx, Name);
+            ObjectMgr::GetLocaleString(il->Description, loc_idx, Description);
+        }
+    }
+    WorldPacket data(SMSG_ITEM_QUERY_SINGLE_RESPONSE, 600);
+    data << pProto->ItemId;
+    data << pProto->Class;
+    data << pProto->SubClass;
+    data << pProto->SoundOverrideSubclass;
+    data << Name;
+    data << uint8(0x00);                                //pProto->Name2; // blizz not send name there, just uint8(0x00); <-- \0 = empty string = empty name...
+    data << uint8(0x00);                                //pProto->Name3; // blizz not send name there, just uint8(0x00);
+    data << uint8(0x00);                                //pProto->Name4; // blizz not send name there, just uint8(0x00);
+    data << pProto->DisplayInfoID;
+    data << pProto->Quality;
+    data << pProto->Flags;
+    data << pProto->Flags2;
+    data << pProto->BuyPrice;
+    data << pProto->SellPrice;
+    data << pProto->InventoryType;
+    data << pProto->AllowableClass;
+    data << pProto->AllowableRace;
+    data << pProto->ItemLevel;
+    data << pProto->RequiredLevel;
+    data << pProto->RequiredSkill;
+    data << pProto->RequiredSkillRank;
+    data << pProto->RequiredSpell;
+    data << pProto->RequiredHonorRank;
+    data << pProto->RequiredCityRank;
+    data << pProto->RequiredReputationFaction;
+    data << pProto->RequiredReputationRank;
+    data << int32(pProto->MaxCount);
+    data << int32(pProto->Stackable);
+    data << pProto->ContainerSlots;
+    data << pProto->StatsCount + (reforge ? 1 : 0); // increase stat count by 1
+    bool decreased = false;
+    for (uint32 i = 0; i < pProto->StatsCount; ++i)
+    {
+        data << pProto->ItemStat[i].ItemStatType;
+        if (reforge && !decreased && pProto->ItemStat[i].ItemStatType == reforge->decrease)
+        {
+            data << pProto->ItemStat[i].ItemStatValue-reforge->stat_value;
+            decreased = true;
+        }
+        else
+            data << pProto->ItemStat[i].ItemStatValue;
+    }
+    if (reforge)
+    {
+        data << reforge->increase;      // set new stat type
+        data << reforge->stat_value;    // and value
+    }
+    data << pProto->ScalingStatDistribution;            // scaling stats distribution
+    data << pProto->ScalingStatValue;                   // some kind of flags used to determine stat values column
+    for (int i = 0; i < MAX_ITEM_PROTO_DAMAGES; ++i)
+    {
+        data << pProto->Damage[i].DamageMin;
+        data << pProto->Damage[i].DamageMax;
+        data << pProto->Damage[i].DamageType;
+    }
+
+    // resistances (7)
+    data << pProto->Armor;
+    data << pProto->HolyRes;
+    data << pProto->FireRes;
+    data << pProto->NatureRes;
+    data << pProto->FrostRes;
+    data << pProto->ShadowRes;
+    data << pProto->ArcaneRes;
+
+    data << pProto->Delay;
+    data << pProto->AmmoType;
+    data << pProto->RangedModRange;
+
+    for (int s = 0; s < MAX_ITEM_PROTO_SPELLS; ++s)
+    {
+        // send DBC data for cooldowns in same way as it used in Spell::SendSpellCooldown
+        // use `item_template` or if not set then only use spell cooldowns
+        SpellInfo const* spell = sSpellMgr->GetSpellInfo(pProto->Spells[s].SpellId);
+        if (spell)
+        {
+            bool db_data = pProto->Spells[s].SpellCooldown >= 0 || pProto->Spells[s].SpellCategoryCooldown >= 0;
+
+            data << pProto->Spells[s].SpellId;
+            data << pProto->Spells[s].SpellTrigger;
+            data << uint32(-abs(pProto->Spells[s].SpellCharges));
+
+            if (db_data)
+            {
+                data << uint32(pProto->Spells[s].SpellCooldown);
+                data << uint32(pProto->Spells[s].SpellCategory);
+                data << uint32(pProto->Spells[s].SpellCategoryCooldown);
+            }
+            else
+            {
+                data << uint32(spell->RecoveryTime);
+                data << uint32(spell->GetCategory());
+                data << uint32(spell->CategoryRecoveryTime);
+            }
+        }
+        else
+        {
+            data << uint32(0);
+            data << uint32(0);
+            data << uint32(0);
+            data << uint32(-1);
+            data << uint32(0);
+            data << uint32(-1);
+        }
+    }
+    data << pProto->Bonding;
+    data << Description;
+    data << pProto->PageText;
+    data << pProto->LanguageID;
+    data << pProto->PageMaterial;
+    data << pProto->StartQuest;
+    data << pProto->LockID;
+    data << int32(pProto->Material);
+    data << pProto->Sheath;
+    data << pProto->RandomProperty;
+    data << pProto->RandomSuffix;
+    data << pProto->Block;
+    data << pProto->ItemSet;
+    data << pProto->MaxDurability;
+    data << pProto->Area;
+    data << pProto->Map;                                // Added in 1.12.x & 2.0.1 client branch
+    data << pProto->BagFamily;
+    data << pProto->TotemCategory;
+    for (int s = 0; s < MAX_ITEM_PROTO_SOCKETS; ++s)
+    {
+        data << pProto->Socket[s].Color;
+        data << pProto->Socket[s].Content;
+    }
+    data << pProto->socketBonus;
+    data << pProto->GemProperties;
+    data << pProto->RequiredDisenchantSkill;
+    data << pProto->ArmorDamageModifier;
+    data << pProto->Duration;                           // added in 2.4.2.8209, duration (seconds)
+    data << pProto->ItemLimitCategory;                  // WotLK, ItemLimitCategory
+    data << pProto->HolidayId;                          // Holiday.dbc?
+    player->GetSession()->SendPacket(&data);
+}
+
+static void SendReforgePackets(Player* player)
+{
+    if (!send_cache_packets)
+        return;
+
+    std::vector<Item*> items = GetItemList(player);
+    for (std::vector<Item*>::const_iterator it = items.begin(); it != items.end(); ++it)
+        SendReforgePacket(player, (*it)->GetEntry(), (*it)->GetGUID().GetCounter());
+}
+
+void RemoveReforge(Player* player, uint32 itemguid, bool update)
+{
+    uint32 lowguid = player->GetGUID().GetCounter();
+    if (!itemguid || player->reforgeMap.empty() ||
+        player->reforgeMap.find(itemguid) == player->reforgeMap.end())
+        return;
+
+    player->reforgeMap.erase(itemguid);
+    Item* invItem = update ? player->GetItemByGuid(ObjectGuid(HighGuid::Item, itemguid)) : NULL;
+    if (invItem)
+        player->_ApplyItemMods(invItem, invItem->GetSlot(), false);
+    player->reforgeMap.erase(itemguid);
+    if (invItem)
+        player->_ApplyItemMods(invItem, invItem->GetSlot(), true);
+
+    //if (!database)
+    //    return;
+    //CharacterDatabase.PExecute("DELETE FROM `custom_reforging` WHERE `GUID` = %u", itemguid);
+    if (invItem)
+        SendReforgePacket(player, invItem->GetEntry());
+    //player->SaveToDB();
+}
+
+static bool IsReforgable(Item* invItem, Player* player)
+{
+    //if (!invItem->IsEquipped())
+    //    return false;
+    if (invItem->GetOwnerGUID() != player->GetGUID())
+        return false;
+    const ItemTemplate* pProto = invItem->GetTemplate();
+    //if (pProto->ItemLevel < 200)
+    //    return false;
+    //if (pProto->Quality == ITEM_QUALITY_HEIRLOOM) // block heirlooms necessary?
+    //    return false;
+    if (!pProto->StatsCount || pProto->StatsCount >= MAX_ITEM_PROTO_STATS) // Mandatory! Do NOT remove or edit
+        return false;
+    if (!player->reforgeMap.empty() && player->reforgeMap.find(invItem->GetGUID().GetCounter()) != player->reforgeMap.end()) // Mandatory! Do NOT remove or edit
+        return false;
+    for (uint32 i = 0; i < pProto->StatsCount; ++i)
+    {
+        if (!GetStatName(pProto->ItemStat[i].ItemStatType))
+            continue;
+        if (((int32)floorf((float)pProto->ItemStat[i].ItemStatValue * 0.4f)) > 1)
+            return true;
+    }
+    return false;
+}
+
+static void UpdatePlayerReforgeStats(Item* invItem, Player* player, uint32 decrease, uint32 increase) // stat types
+{
+    const ItemTemplate* pProto = invItem->GetTemplate();
+
+    int32 stat_diff = 0;
+    for (uint32 i = 0; i < pProto->StatsCount; ++i)
+    {
+        if (pProto->ItemStat[i].ItemStatType == increase)
+            return; // Should not have the increased stat already
+        if (pProto->ItemStat[i].ItemStatType == decrease)
+            stat_diff = (int32)floorf((float)pProto->ItemStat[i].ItemStatValue * 0.4f);
+    }
+    if (stat_diff <= 0)
+        return; // Should have some kind of diff
+
+    // Update player stats
+    player->_ApplyItemMods(invItem, invItem->GetSlot(), false);
+    uint32 guidlow = invItem->GetGUID().GetCounter();
+    ReforgeData& data = player->reforgeMap[guidlow];
+    data.increase = increase;
+    data.decrease = decrease;
+    data.stat_value = stat_diff;
+    player->_ApplyItemMods(invItem, invItem->GetSlot(), true);
+    // CharacterDatabase.PExecute("REPLACE INTO `custom_reforging` (`GUID`, `increase`, `decrease`, `stat_value`) VALUES (%u, %u, %u, %i)", guidlow, increase, decrease, stat_diff);
+    player->ModifyMoney(pProto->SellPrice < (10*GOLD) ? (-10*GOLD) : -(int32)pProto->SellPrice);
+    SendReforgePacket(player, invItem->GetEntry(), 0, &data);
+    // player->SaveToDB();
+}
+
+class REFORGE_PLAYER : public PlayerScript
+{
+public:
+    REFORGE_PLAYER() : PlayerScript("REFORGE_PLAYER")
+    {
+        CharacterDatabase.DirectExecute("DELETE FROM `custom_reforging` WHERE NOT EXISTS (SELECT 1 FROM `item_instance` WHERE `item_instance`.`guid` = `custom_reforging`.`GUID`)");
+    }
+
+    class SendRefPackLogin : public BasicEvent
+    {
+    public:
+        SendRefPackLogin(Player* _player) : player(_player)
+        {
+            _player->m_Events.AddEvent(this, _player->m_Events.CalculateTime(1000));
+        }
+
+        bool Execute(uint64, uint32) override
+        {
+            SendReforgePackets(player);
+            return true;
+        }
+        Player* player;
+    };
+
+    void OnLogin(Player* player, bool firstLogin) override
+    {
+        uint32 playerGUID = player->GetGUID().GetCounter();
+        QueryResult result = CharacterDatabase.PQuery("SELECT `GUID`, `increase`, `decrease`, `stat_value` FROM `custom_reforging` WHERE `Owner` = %u", playerGUID);
+        if (result)
+        {
+            do
+            {
+                uint32 lowGUID = (*result)[0].GetUInt32();
+                Item* invItem = player->GetItemByGuid(ObjectGuid(HighGuid::Item, lowGUID));
+                if (invItem)
+                    player->_ApplyItemMods(invItem, invItem->GetSlot(), false);
+                ReforgeData& data = player->reforgeMap[lowGUID];
+                data.increase = (*result)[1].GetUInt32();
+                data.decrease = (*result)[2].GetUInt32();
+                data.stat_value = (*result)[3].GetInt32();
+                if (invItem)
+                    player->_ApplyItemMods(invItem, invItem->GetSlot(), true);
+                // SendReforgePacket(player, entry, lowGUID);
+            } while (result->NextRow());
+
+            // SendReforgePackets(player);
+            new SendRefPackLogin(player);
+        }
+    }
+
+    //void OnLogout(Player* player) override
+    //{
+    //    if (player->reforgeMap.empty())
+    //        return;
+    //    for (ReforgeMapType::const_iterator it = player->reforgeMap.begin(); it != player->reforgeMap.end();)
+    //    {
+    //        ReforgeMapType::const_iterator old_it = it++;
+    //        RemoveReforge(player, old_it->first, false);
+    //    }
+    //}
+
+    void OnSave(Player* player) override
+    {
+        uint32 lowguid = player->GetGUID().GetCounter();
+        SQLTransaction trans = CharacterDatabase.BeginTransaction();
+        trans->PAppend("DELETE FROM `custom_reforging` WHERE `Owner` = %u", lowguid);
+        if (!player->reforgeMap.empty())
+        {
+            // Only save items that are in inventory / bank / etc
+            std::vector<Item*> items = GetItemList(player);
+            for (std::vector<Item*>::const_iterator it = items.begin(); it != items.end(); ++it)
+            {
+                ReforgeMapType::const_iterator it2 = player->reforgeMap.find((*it)->GetGUID().GetCounter());
+                if (it2 == player->reforgeMap.end())
+                    continue;
+
+                trans->PAppend("REPLACE INTO `custom_reforging` (`GUID`, `increase`, `decrease`, `stat_value`, `Owner`) VALUES (%u, %u, %u, %i, %u)", it2->first, it2->second.increase, it2->second.decrease, it2->second.stat_value, lowguid);
+            }
+        }
+
+        if (trans->GetSize()) // basically never false
+            CharacterDatabase.CommitTransaction(trans);
+    }
+};
+
+class REFORGER_NPC : public CreatureScript
+{
+public:
+    REFORGER_NPC() : CreatureScript("REFORGER_NPC") { }
+
+    bool OnGossipHello(Player* player, Creature* creature) override
+    {
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, "Select slot of the item to reforge:", 0, Melt(MAIN_MENU, 0));
+        for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+        {
+            if (Item* invItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+                if (IsReforgable(invItem, player))
+                    if (const char* slotname = GetSlotName(slot, player->GetSession()))
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TRAINER, slotname, 0, Melt(SELECT_STAT_REDUCE, slot));
+        }
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TRAINER, "Remove reforges", 0, Melt(SELECT_RESTORE, 0));
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Update menu", 0, Melt(MAIN_MENU, 0));
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+        return true;
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 melt) override
+    {
+        player->PlayerTalkClass->ClearMenus();
+
+        uint8 menu, action;
+        Unmelt(melt, menu, action);
+
+        switch (menu)
+        {
+        case MAIN_MENU: OnGossipHello(player, creature); break;
+        case SELECT_STAT_REDUCE:
+            // action = slot
+            if (Item* invItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, action))
+            {
+                if (IsReforgable(invItem, player))
+                {
+                    uint32 guidlow = invItem->GetGUID().GetCounter();
+                    const ItemTemplate* pProto = invItem->GetTemplate();
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, "Stat to decrease:", sender, melt);
+                    for (uint32 i = 0; i < pProto->StatsCount; ++i)
+                    {
+                        int32 stat_diff = ((int32)floorf((float)pProto->ItemStat[i].ItemStatValue * 0.4f));
+                        if (stat_diff > 1)
+                            if (const char* stat_name = GetStatName(pProto->ItemStat[i].ItemStatType))
+                            {
+                                std::ostringstream oss;
+                                oss << stat_name << " (" << pProto->ItemStat[i].ItemStatValue << " |cFFDB2222-" << stat_diff << "|r)";
+                                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TRAINER, oss.str(), guidlow, Melt(SELECT_STAT_INCREASE, i));
+                            }
+                    }
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Back..", 0, Melt(MAIN_MENU, 0));
+                    player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+                }
+                else
+                {
+                    player->GetSession()->SendNotification("Invalid item selected");
+                    OnGossipHello(player, creature);
+                }
+            }
+            else
+            {
+                player->GetSession()->SendNotification("Invalid item selected");
+                OnGossipHello(player, creature);
+            }
+            break;
+        case SELECT_STAT_INCREASE:
+            // sender = item guidlow
+            // action = StatsCount id
+            {
+                Item* invItem = GetEquippedItem(player, sender);
+                if (invItem)
+                {
+                    const ItemTemplate* pProto = invItem->GetTemplate();
+                    int32 stat_diff = ((int32)floorf((float)pProto->ItemStat[action].ItemStatValue * 0.4f));
+
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, "Stat to increase:", sender, melt);
+                    for (uint8 i = 0; i < stat_type_max; ++i)
+                    {
+                        bool cont = false;
+                        for (uint32 j = 0; j < pProto->StatsCount; ++j)
+                        {
+                            if (statTypes[i] == pProto->ItemStat[j].ItemStatType) // skip existing stats on item
+                            {
+                                cont = true;
+                                break;
+                            }
+                        }
+                        if (cont)
+                            continue;
+                        if (const char* stat_name = GetStatName(statTypes[i]))
+                        {
+                            std::ostringstream oss;
+                            oss << stat_name << " |cFF3ECB3C+" << stat_diff << "|r";
+                            player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_INTERACT_1, oss.str(), sender, Melt(i, (uint8)pProto->ItemStat[action].ItemStatType), "Are you sure you want to reforge\n\n" + pProto->Name1, (pProto->SellPrice < (10 * GOLD) ? (10 * GOLD) : pProto->SellPrice), false);
+                        }
+                    }
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Back..", 0, Melt(SELECT_STAT_REDUCE, invItem->GetSlot()));
+                    player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+                }
+                else
+                {
+                    player->GetSession()->SendNotification("Invalid item selected");
+                    OnGossipHello(player, creature);
+                }
+            }
+            break;
+        case SELECT_RESTORE:
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, "Select slot to remove reforge from:", sender, melt);
+                if (!player->reforgeMap.empty())
+                {
+                    for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+                    {
+                        if (Item* invItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+                            if (player->reforgeMap.find(invItem->GetGUID().GetCounter()) != player->reforgeMap.end())
+                                if (const char* slotname = GetSlotName(slot, player->GetSession()))
+                                    player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_INTERACT_1, slotname, invItem->GetGUID().GetCounter(), Melt(RESTORE, 0), "Remove reforge from\n\n" + invItem->GetTemplate()->Name1, 0, false);
+                    }
+                }
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Update menu", sender, melt);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Back..", 0, Melt(MAIN_MENU, 0));
+                player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+            }
+            break;
+        case RESTORE:
+            // sender = item guidlow
+            {
+                if (Item* invItem = player->GetItemByGuid(ObjectGuid(HighGuid::Item, sender)))
+                {
+                    if (!player->reforgeMap.empty() && player->reforgeMap.find(sender) != player->reforgeMap.end())
+                        RemoveReforge(player, sender, true);
+                }
+                OnGossipHello(player, creature);
+            }
+            break;
+        default: // Reforge
+            // sender = item guidlow
+            // menu = stat type to increase index to statTypes[]
+            // action = stat type to decrease
+            {
+                if (menu < stat_type_max)
+                {
+                    Item* invItem = GetEquippedItem(player, sender);
+                    if (invItem && IsReforgable(invItem, player))
+                    {
+                        if (player->HasEnoughMoney(invItem->GetTemplate()->SellPrice < (10 * GOLD) ? (10 * GOLD) : invItem->GetTemplate()->SellPrice))
+                        {
+                            // int32 stat_diff = ((int32)floorf((float)invItem->GetTemplate()->ItemStat[action].ItemStatValue * 0.4f));
+                            UpdatePlayerReforgeStats(invItem, player, action, statTypes[menu]); // rewrite this function
+                        }
+                        else
+                            player->GetSession()->SendNotification("Not enough money");
+                    }
+                    else
+                        player->GetSession()->SendNotification("Invalid item selected");
+                }
+                OnGossipHello(player, creature);
+            }
+        }
+        return true;
+    }
+
+    enum Menus
+    {
+        MAIN_MENU = 200, // stat_type_max
+        SELECT_ITEM,
+        SELECT_STAT_REDUCE,
+        SELECT_STAT_INCREASE,
+        SELECT_RESTORE,
+        RESTORE,
+        REFORGE,
+    };
+};
+
+void AddSC_REFORGER_NPC()
+{
+    new REFORGER_NPC;
+    new REFORGE_PLAYER;
+}
+
+#undef FOR_REFORGE_ITEMS
diff --git a/src/server/scripts/Custom/TemplateNPC.cpp b/src/server/scripts/Custom/TemplateNPC.cpp
new file mode 100644
index 0000000..16dc313
--- /dev/null
+++ b/src/server/scripts/Custom/TemplateNPC.cpp
@@ -0,0 +1,1466 @@
+#include "TemplateNPC.h"
+
+void sTemplateNPC::LearnPlateMailSpells(Player* player)
+{
+    switch (player->getClass())
+    {
+    case CLASS_WARRIOR:
+    case CLASS_PALADIN:
+    case CLASS_DEATH_KNIGHT:
+        player->LearnSpell(PLATE_MAIL, true);
+        break;
+    case CLASS_SHAMAN:
+    case CLASS_HUNTER:
+        player->LearnSpell(MAIL, true);
+        break;
+    default:
+        break;
+    }
+}
+
+void sTemplateNPC::ApplyBonus(Player* player, Item* item, EnchantmentSlot slot, uint32 bonusEntry)
+{
+    if (!item)
+        return;
+
+    if (!bonusEntry || bonusEntry == 0)
+        return;
+
+    player->ApplyEnchantment(item, slot, false);
+    item->SetEnchantment(slot, bonusEntry, 0, 0);
+    player->ApplyEnchantment(item, slot, true);
+}
+
+void sTemplateNPC::ApplyGlyph(Player* player, uint8 slot, uint32 glyphID)
+{
+    if (GlyphPropertiesEntry const* gp = sGlyphPropertiesStore.LookupEntry(glyphID))
+    {
+        if (uint32 oldGlyph = player->GetGlyph(slot))
+        {
+            player->RemoveAurasDueToSpell(sGlyphPropertiesStore.LookupEntry(oldGlyph)->SpellId);
+            player->SetGlyph(slot, 0);
+        }
+        player->CastSpell(player, gp->SpellId, true);
+        player->SetGlyph(slot, glyphID);
+    }
+}
+
+void sTemplateNPC::LearnTemplateTalents(Player* player)
+{
+    for (TalentContainer::const_iterator itr = m_TalentContainer.begin(); itr != m_TalentContainer.end(); ++itr)
+    {
+        if ((*itr)->playerClass == GetClassString(player).c_str() && (*itr)->playerSpec == sTalentsSpec)
+        {
+            player->LearnSpell((*itr)->talentId, false);
+            player->AddTalent((*itr)->talentId, player->GetActiveSpec(), true);
+        }
+    }
+    player->SetFreeTalentPoints(0);
+    player->SendTalentsInfoData(false);
+}
+
+void sTemplateNPC::LearnTemplateGlyphs(Player* player)
+{
+    for (GlyphContainer::const_iterator itr = m_GlyphContainer.begin(); itr != m_GlyphContainer.end(); ++itr)
+    {
+        if ((*itr)->playerClass == GetClassString(player).c_str() && (*itr)->playerSpec == sTalentsSpec)
+            ApplyGlyph(player, (*itr)->slot, (*itr)->glyph);
+    }
+    player->SendTalentsInfoData(false);
+}
+
+void sTemplateNPC::EquipTemplateGear(Player* player)
+{
+    if (player->getRace() == RACE_HUMAN)
+    {
+        for (HumanGearContainer::const_iterator itr = m_HumanGearContainer.begin(); itr != m_HumanGearContainer.end(); ++itr)
+        {
+            if ((*itr)->playerClass == GetClassString(player).c_str() && (*itr)->playerSpec == sTalentsSpec)
+            {
+                player->EquipNewItem((*itr)->pos, (*itr)->itemEntry, true); // Equip the item and apply enchants and gems
+                ApplyBonus(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, (*itr)->pos), PERM_ENCHANTMENT_SLOT, (*itr)->enchant);
+                ApplyBonus(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, (*itr)->pos), SOCK_ENCHANTMENT_SLOT, (*itr)->socket1);
+                ApplyBonus(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, (*itr)->pos), SOCK_ENCHANTMENT_SLOT_2, (*itr)->socket2);
+                ApplyBonus(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, (*itr)->pos), SOCK_ENCHANTMENT_SLOT_3, (*itr)->socket3);
+                ApplyBonus(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, (*itr)->pos), BONUS_ENCHANTMENT_SLOT, (*itr)->bonusEnchant);
+                ApplyBonus(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, (*itr)->pos), PRISMATIC_ENCHANTMENT_SLOT, (*itr)->prismaticEnchant);
+            }
+        }
+    }
+    else if (player->GetTeam() == ALLIANCE && player->getRace() != RACE_HUMAN)
+    {
+        for (AllianceGearContainer::const_iterator itr = m_AllianceGearContainer.begin(); itr != m_AllianceGearContainer.end(); ++itr)
+        {
+            if ((*itr)->playerClass == GetClassString(player).c_str() && (*itr)->playerSpec == sTalentsSpec)
+            {
+                player->EquipNewItem((*itr)->pos, (*itr)->itemEntry, true); // Equip the item and apply enchants and gems
+                ApplyBonus(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, (*itr)->pos), PERM_ENCHANTMENT_SLOT, (*itr)->enchant);
+                ApplyBonus(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, (*itr)->pos), SOCK_ENCHANTMENT_SLOT, (*itr)->socket1);
+                ApplyBonus(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, (*itr)->pos), SOCK_ENCHANTMENT_SLOT_2, (*itr)->socket2);
+                ApplyBonus(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, (*itr)->pos), SOCK_ENCHANTMENT_SLOT_3, (*itr)->socket3);
+                ApplyBonus(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, (*itr)->pos), BONUS_ENCHANTMENT_SLOT, (*itr)->bonusEnchant);
+                ApplyBonus(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, (*itr)->pos), PRISMATIC_ENCHANTMENT_SLOT, (*itr)->prismaticEnchant);
+            }
+        }
+    }
+    else if (player->GetTeam() == HORDE)
+    {
+        for (HordeGearContainer::const_iterator itr = m_HordeGearContainer.begin(); itr != m_HordeGearContainer.end(); ++itr)
+        {
+            if ((*itr)->playerClass == GetClassString(player).c_str() && (*itr)->playerSpec == sTalentsSpec)
+            {
+                player->EquipNewItem((*itr)->pos, (*itr)->itemEntry, true); // Equip the item and apply enchants and gems
+                ApplyBonus(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, (*itr)->pos), PERM_ENCHANTMENT_SLOT, (*itr)->enchant);
+                ApplyBonus(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, (*itr)->pos), SOCK_ENCHANTMENT_SLOT, (*itr)->socket1);
+                ApplyBonus(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, (*itr)->pos), SOCK_ENCHANTMENT_SLOT_2, (*itr)->socket2);
+                ApplyBonus(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, (*itr)->pos), SOCK_ENCHANTMENT_SLOT_3, (*itr)->socket3);
+                ApplyBonus(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, (*itr)->pos), BONUS_ENCHANTMENT_SLOT, (*itr)->bonusEnchant);
+                ApplyBonus(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, (*itr)->pos), PRISMATIC_ENCHANTMENT_SLOT, (*itr)->prismaticEnchant);
+            }
+        }
+    }
+}
+
+void sTemplateNPC::LoadTalentsContainer()
+{
+    for (TalentContainer::const_iterator itr = m_TalentContainer.begin(); itr != m_TalentContainer.end(); ++itr)
+        delete *itr;
+
+    m_TalentContainer.clear();
+
+    uint32 oldMSTime = getMSTime();
+    uint32 count = 0;
+
+    QueryResult result = CharacterDatabase.PQuery("SELECT playerClass, playerSpec, talentId FROM template_npc_talents;");
+
+    if (!result)
+    {
+        TC_LOG_INFO("server.worldserver", ">> Loaded 0 talent templates. DB table `template_npc_talents` is empty!");
+        return;
+    }
+
+    do
+    {
+        Field* fields = result->Fetch();
+
+        TalentTemplate* pTalent = new TalentTemplate;
+
+        pTalent->playerClass = fields[0].GetString();
+        pTalent->playerSpec = fields[1].GetString();
+        pTalent->talentId = fields[2].GetUInt32();
+
+        m_TalentContainer.push_back(pTalent);
+        ++count;
+    }
+    while (result->NextRow());
+    TC_LOG_INFO("server.worldserver", ">> Loaded %u talent templates in %u ms.", count, GetMSTimeDiffToNow(oldMSTime));
+}
+
+void sTemplateNPC::LoadGlyphsContainer()
+{
+    for (GlyphContainer::const_iterator itr = m_GlyphContainer.begin(); itr != m_GlyphContainer.end(); ++itr)
+        delete *itr;
+
+    m_GlyphContainer.clear();
+
+    QueryResult result = CharacterDatabase.PQuery("SELECT playerClass, playerSpec, slot, glyph FROM template_npc_glyphs;");
+
+    uint32 oldMSTime = getMSTime();
+    uint32 count = 0;
+
+    if (!result)
+    {
+        TC_LOG_INFO("server.worldserver", ">> Loaded 0 glyph templates. DB table `template_npc_glyphs` is empty!");
+        return;
+    }
+
+    do
+    {
+        Field* fields = result->Fetch();
+
+        GlyphTemplate* pGlyph = new GlyphTemplate;
+
+        pGlyph->playerClass = fields[0].GetString();
+        pGlyph->playerSpec = fields[1].GetString();
+        pGlyph->slot = fields[2].GetUInt8();
+        pGlyph->glyph = fields[3].GetUInt32();
+
+        m_GlyphContainer.push_back(pGlyph);
+        ++count;
+    }
+    while (result->NextRow());
+    TC_LOG_INFO("server.worldserver", ">> Loaded %u glyph templates in %u ms.", count, GetMSTimeDiffToNow(oldMSTime));
+}
+
+void sTemplateNPC::LoadHumanGearContainer()
+{
+    for (HumanGearContainer::const_iterator itr = m_HumanGearContainer.begin(); itr != m_HumanGearContainer.end(); ++itr)
+        delete *itr;
+
+    m_HumanGearContainer.clear();
+
+    QueryResult result = CharacterDatabase.PQuery("SELECT playerClass, playerSpec, pos, itemEntry, enchant, socket1, socket2, socket3, bonusEnchant, prismaticEnchant FROM template_npc_human;");
+
+    uint32 oldMSTime = getMSTime();
+    uint32 count = 0;
+
+    if (!result)
+    {
+        TC_LOG_INFO("server.worldserver", ">> Loaded 0 'gear templates. DB table `template_npc_human` is empty!");
+        return;
+    }
+
+    do
+    {
+        Field* fields = result->Fetch();
+
+        HumanGearTemplate* pItem = new HumanGearTemplate;
+
+        pItem->playerClass = fields[0].GetString();
+        pItem->playerSpec = fields[1].GetString();
+        pItem->pos = fields[2].GetUInt8();
+        pItem->itemEntry = fields[3].GetUInt32();
+        pItem->enchant = fields[4].GetUInt32();
+        pItem->socket1 = fields[5].GetUInt32();
+        pItem->socket2 = fields[6].GetUInt32();
+        pItem->socket3 = fields[7].GetUInt32();
+        pItem->bonusEnchant = fields[8].GetUInt32();
+        pItem->prismaticEnchant = fields[9].GetUInt32();
+
+        m_HumanGearContainer.push_back(pItem);
+        ++count;
+    }
+    while (result->NextRow());
+    TC_LOG_INFO("server.worldserver", ">> Loaded %u gear templates for Humans in %u ms.", count, GetMSTimeDiffToNow(oldMSTime));
+}
+
+void sTemplateNPC::LoadAllianceGearContainer()
+{
+    for (AllianceGearContainer::const_iterator itr = m_AllianceGearContainer.begin(); itr != m_AllianceGearContainer.end(); ++itr)
+        delete *itr;
+
+    m_AllianceGearContainer.clear();
+
+    QueryResult result = CharacterDatabase.PQuery("SELECT playerClass, playerSpec, pos, itemEntry, enchant, socket1, socket2, socket3, bonusEnchant, prismaticEnchant FROM template_npc_alliance;");
+
+    uint32 oldMSTime = getMSTime();
+    uint32 count = 0;
+
+    if (!result)
+    {
+        TC_LOG_INFO("server.worldserver", ">> Loaded 0 'gear templates. DB table `template_npc_alliance` is empty!");
+        return;
+    }
+
+    do
+    {
+        Field* fields = result->Fetch();
+
+        AllianceGearTemplate* pItem = new AllianceGearTemplate;
+
+        pItem->playerClass = fields[0].GetString();
+        pItem->playerSpec = fields[1].GetString();
+        pItem->pos = fields[2].GetUInt8();
+        pItem->itemEntry = fields[3].GetUInt32();
+        pItem->enchant = fields[4].GetUInt32();
+        pItem->socket1 = fields[5].GetUInt32();
+        pItem->socket2 = fields[6].GetUInt32();
+        pItem->socket3 = fields[7].GetUInt32();
+        pItem->bonusEnchant = fields[8].GetUInt32();
+        pItem->prismaticEnchant = fields[9].GetUInt32();
+
+        m_AllianceGearContainer.push_back(pItem);
+        ++count;
+    }
+    while (result->NextRow());
+    TC_LOG_INFO("server.worldserver", ">> Loaded %u gear templates for Alliances in %u ms.", count, GetMSTimeDiffToNow(oldMSTime));
+}
+
+void sTemplateNPC::LoadHordeGearContainer()
+{
+    for (HordeGearContainer::const_iterator itr = m_HordeGearContainer.begin(); itr != m_HordeGearContainer.end(); ++itr)
+        delete *itr;
+
+    m_HordeGearContainer.clear();
+
+    QueryResult result = CharacterDatabase.PQuery("SELECT playerClass, playerSpec, pos, itemEntry, enchant, socket1, socket2, socket3, bonusEnchant, prismaticEnchant FROM template_npc_horde;");
+
+    uint32 oldMSTime = getMSTime();
+    uint32 count = 0;
+
+    if (!result)
+    {
+        TC_LOG_INFO("server.worldserver", ">> Loaded 0 'gear templates. DB table `template_npc_horde` is empty!");
+        return;
+    }
+
+    do
+    {
+        Field* fields = result->Fetch();
+
+        HordeGearTemplate* pItem = new HordeGearTemplate;
+
+        pItem->playerClass = fields[0].GetString();
+        pItem->playerSpec = fields[1].GetString();
+        pItem->pos = fields[2].GetUInt8();
+        pItem->itemEntry = fields[3].GetUInt32();
+        pItem->enchant = fields[4].GetUInt32();
+        pItem->socket1 = fields[5].GetUInt32();
+        pItem->socket2 = fields[6].GetUInt32();
+        pItem->socket3 = fields[7].GetUInt32();
+        pItem->bonusEnchant = fields[8].GetUInt32();
+        pItem->prismaticEnchant = fields[9].GetUInt32();
+
+        m_HordeGearContainer.push_back(pItem);
+        ++count;
+    }
+    while (result->NextRow());
+    TC_LOG_INFO("server.worldserver", ">> Loaded %u gear templates for Hordes in %u ms.", count, GetMSTimeDiffToNow(oldMSTime));
+}
+
+std::string sTemplateNPC::GetClassString(Player* player)
+{
+    switch (player->getClass())
+    {
+    case CLASS_PRIEST:       return "Priest";      break;
+    case CLASS_PALADIN:      return "Paladin";     break;
+    case CLASS_WARRIOR:      return "Warrior";     break;
+    case CLASS_MAGE:         return "Mage";        break;
+    case CLASS_WARLOCK:      return "Warlock";     break;
+    case CLASS_SHAMAN:       return "Shaman";      break;
+    case CLASS_DRUID:        return "Druid";       break;
+    case CLASS_HUNTER:       return "Hunter";      break;
+    case CLASS_ROGUE:        return "Rogue";       break;
+    case CLASS_DEATH_KNIGHT: return "DeathKnight"; break;
+    default:
+        break;
+    }
+    return "Unknown"; // Fix warning, this should never happen
+}
+
+bool sTemplateNPC::OverwriteTemplate(Player* player, std::string& playerSpecStr)
+{
+    // Delete old talent and glyph templates before extracting new ones
+    CharacterDatabase.PExecute("DELETE FROM template_npc_talents WHERE playerClass = '%s' AND playerSpec = '%s';", GetClassString(player).c_str(), playerSpecStr.c_str());
+    CharacterDatabase.PExecute("DELETE FROM template_npc_glyphs WHERE playerClass = '%s' AND playerSpec = '%s';", GetClassString(player).c_str(), playerSpecStr.c_str());
+
+    // Delete old gear templates before extracting new ones
+    if (player->getRace() == RACE_HUMAN)
+    {
+        CharacterDatabase.PExecute("DELETE FROM template_npc_human WHERE playerClass = '%s' AND playerSpec = '%s';", GetClassString(player).c_str(), playerSpecStr.c_str());
+        player->GetSession()->SendAreaTriggerMessage("Template successfuly created!");
+        return false;
+    }
+    else if (player->GetTeam() == ALLIANCE && player->getRace() != RACE_HUMAN)
+    {
+        CharacterDatabase.PExecute("DELETE FROM template_npc_alliance WHERE playerClass = '%s' AND playerSpec = '%s';", GetClassString(player).c_str(), playerSpecStr.c_str());
+        player->GetSession()->SendAreaTriggerMessage("Template successfuly created!");
+        return false;
+    }
+    else if (player->GetTeam() == HORDE)
+    {                                                                                                        // ????????????? sTemplateNpcMgr here??
+        CharacterDatabase.PExecute("DELETE FROM template_npc_horde WHERE playerClass = '%s' AND playerSpec = '%s';", GetClassString(player).c_str(), playerSpecStr.c_str());
+        player->GetSession()->SendAreaTriggerMessage("Template successfuly created!");
+        return false;
+    }
+    return true;
+}
+
+void sTemplateNPC::ExtractGearTemplateToDB(Player* player, std::string& playerSpecStr)
+{
+    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
+    {
+        Item* equippedItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+
+        if (equippedItem)
+        {
+            if (player->getRace() == RACE_HUMAN)
+            {
+                CharacterDatabase.PExecute("INSERT INTO template_npc_human (`playerClass`, `playerSpec`, `pos`, `itemEntry`, `enchant`, `socket1`, `socket2`, `socket3`, `bonusEnchant`, `prismaticEnchant`) VALUES ('%s', '%s', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u');"
+                    , GetClassString(player).c_str(), playerSpecStr.c_str(), equippedItem->GetSlot(), equippedItem->GetEntry(), equippedItem->GetEnchantmentId(PERM_ENCHANTMENT_SLOT),
+                    equippedItem->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT), equippedItem->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT_2), equippedItem->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT_3),
+                    equippedItem->GetEnchantmentId(BONUS_ENCHANTMENT_SLOT), equippedItem->GetEnchantmentId(PRISMATIC_ENCHANTMENT_SLOT));
+            }
+            else if (player->GetTeam() == ALLIANCE && player->getRace() != RACE_HUMAN)
+            {
+                CharacterDatabase.PExecute("INSERT INTO template_npc_alliance (`playerClass`, `playerSpec`, `pos`, `itemEntry`, `enchant`, `socket1`, `socket2`, `socket3`, `bonusEnchant`, `prismaticEnchant`) VALUES ('%s', '%s', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u');"
+                    , GetClassString(player).c_str(), playerSpecStr.c_str(), equippedItem->GetSlot(), equippedItem->GetEntry(), equippedItem->GetEnchantmentId(PERM_ENCHANTMENT_SLOT),
+                    equippedItem->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT), equippedItem->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT_2), equippedItem->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT_3),
+                    equippedItem->GetEnchantmentId(BONUS_ENCHANTMENT_SLOT), equippedItem->GetEnchantmentId(PRISMATIC_ENCHANTMENT_SLOT));
+            }
+            else if (player->GetTeam() == HORDE)
+            {
+                CharacterDatabase.PExecute("INSERT INTO template_npc_horde (`playerClass`, `playerSpec`, `pos`, `itemEntry`, `enchant`, `socket1`, `socket2`, `socket3`, `bonusEnchant`, `prismaticEnchant`) VALUES ('%s', '%s', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u');"
+                    , GetClassString(player).c_str(), playerSpecStr.c_str(), equippedItem->GetSlot(), equippedItem->GetEntry(), equippedItem->GetEnchantmentId(PERM_ENCHANTMENT_SLOT),
+                    equippedItem->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT), equippedItem->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT_2), equippedItem->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT_3),
+                    equippedItem->GetEnchantmentId(BONUS_ENCHANTMENT_SLOT), equippedItem->GetEnchantmentId(PRISMATIC_ENCHANTMENT_SLOT));
+            }
+        }
+    }
+}
+
+void sTemplateNPC::ExtractTalentTemplateToDB(Player* player, std::string& playerSpecStr)
+{
+    QueryResult result = CharacterDatabase.PQuery("SELECT spell FROM character_talent WHERE guid = '%u' "
+        "AND spec = '%u';", player->GetGUID(), player->GetActiveSpec());
+
+    if (!result)
+    {
+        return;
+    }
+    else if (player->GetFreeTalentPoints() > 0)
+    {
+        player->GetSession()->SendAreaTriggerMessage("You have unspend talent points. Please spend all your talent points and re-extract the template.");
+        return;
+    }
+    else
+    {
+        do
+        {
+            Field* fields = result->Fetch();
+            uint32 spell = fields[0].GetUInt32();
+
+            CharacterDatabase.PExecute("INSERT INTO template_npc_talents (playerClass, playerSpec, talentId) "
+                "VALUES ('%s', '%s', '%u');", GetClassString(player).c_str(), playerSpecStr.c_str(), spell);
+        }
+        while (result->NextRow());
+    }
+}
+
+void sTemplateNPC::ExtractGlyphsTemplateToDB(Player* player, std::string& playerSpecStr)
+{
+    QueryResult result = CharacterDatabase.PQuery("SELECT glyph1, glyph2, glyph3, glyph4, glyph5, glyph6 "
+        "FROM character_glyphs WHERE guid = '%u' AND spec = '%u';", player->GetGUID(), player->GetActiveSpec());
+
+    for (uint8 slot = 0; slot < MAX_GLYPH_SLOT_INDEX; ++slot)
+    {
+        if (!result)
+        {
+            player->GetSession()->SendAreaTriggerMessage("Get glyphs and re-extract the template!");
+            continue;
+        }
+
+        Field* fields = result->Fetch();
+        uint32 glyph1 = fields[0].GetUInt32();
+        uint32 glyph2 = fields[1].GetUInt32();
+        uint32 glyph3 = fields[2].GetUInt32();
+        uint32 glyph4 = fields[3].GetUInt32();
+        uint32 glyph5 = fields[4].GetUInt32();
+        uint32 glyph6 = fields[5].GetUInt32();
+
+        uint32 storedGlyph;
+
+        switch (slot)
+        {
+        case 0:
+            storedGlyph = glyph1;
+            break;
+        case 1:
+            storedGlyph = glyph2;
+            break;
+        case 2:
+            storedGlyph = glyph3;
+            break;
+        case 3:
+            storedGlyph = glyph4;
+            break;
+        case 4:
+            storedGlyph = glyph5;
+            break;
+        case 5:
+            storedGlyph = glyph6;
+            break;
+        default:
+            break;
+        }
+
+        CharacterDatabase.PExecute("INSERT INTO template_npc_glyphs (playerClass, playerSpec, slot, glyph) "
+            "VALUES ('%s', '%s', '%u', '%u');", GetClassString(player).c_str(), playerSpecStr.c_str(), slot, storedGlyph);
+    }
+}
+
+bool sTemplateNPC::CanEquipTemplate(Player* player, std::string& playerSpecStr)
+{
+    if (player->getRace() == RACE_HUMAN)
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT playerClass, playerSpec FROM template_npc_human "
+            "WHERE playerClass = '%s' AND playerSpec = '%s';", GetClassString(player).c_str(), playerSpecStr.c_str());
+
+        if (!result)
+            return false;
+    }
+    else if (player->GetTeam() == ALLIANCE && player->getRace() != RACE_HUMAN)
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT playerClass, playerSpec FROM template_npc_alliance "
+            "WHERE playerClass = '%s' AND playerSpec = '%s';", GetClassString(player).c_str(), playerSpecStr.c_str());
+
+        if (!result)
+            return false;
+    }
+    else if (player->GetTeam() == HORDE)
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT playerClass, playerSpec FROM template_npc_horde "
+            "WHERE playerClass = '%s' AND playerSpec = '%s';", GetClassString(player).c_str(), playerSpecStr.c_str());
+
+        if (!result)
+            return false;
+    }
+    return true;
+}
+
+class TemplateNPC_Commands : public CommandScript
+{
+public:
+    TemplateNPC_Commands() : CommandScript("TemplateNPC_Commands") { }
+
+    std::vector<ChatCommand> GetCommands() const override
+    {
+        static std::vector<ChatCommand> createDeathKnightItemSetTable =
+        {
+            { "blood",             SEC_ADMINISTRATOR,         false,          &HandleCreateDeathKnightBloodItemSetCommand,       ""},
+            { "frost",             SEC_ADMINISTRATOR,         false,          &HandleCreateDeathKnightFrostItemSetCommand,       ""},
+            { "unholy",            SEC_ADMINISTRATOR,         false,          &HandleCreateDeathKnightUnholyItemSetCommand,      ""},
+        };
+        static std::vector<ChatCommand> createRogueItemSetTable =
+        {
+            { "assassination",     SEC_ADMINISTRATOR,         false,          &HandleCreateRogueAssassinationItemSetCommand,     ""},
+            { "combat",            SEC_ADMINISTRATOR,         false,          &HandleCreateRogueCombatItemSetCommand,            ""},
+            { "subtlety",          SEC_ADMINISTRATOR,         false,          &HandleCreateRogueSubtletyItemSetCommand,          ""},
+        };
+        static std::vector<ChatCommand> createHunterItemSetTable =
+        {
+            { "marksmanship",      SEC_ADMINISTRATOR,         false,          &HandleCreateHunterMarksmanshipItemSetCommand,     ""},
+            { "beastmastery",      SEC_ADMINISTRATOR,         false,          &HandleCreateHunterBeastmasteryItemSetCommand,     ""},
+            { "survival",          SEC_ADMINISTRATOR,         false,          &HandleCreateHunterSurvivalItemSetCommand,         ""},
+        };
+        static std::vector<ChatCommand> createDruidItemSetTable =
+        {
+            { "ballance",          SEC_ADMINISTRATOR,         false,          &HandleCreateDruidBallanceItemSetCommand,          ""},
+            { "feral",             SEC_ADMINISTRATOR,         false,          &HandleCreateDruidFeralItemSetCommand,             ""},
+            { "restoration",       SEC_ADMINISTRATOR,         false,          &HandleCreateDruidRestorationItemSetCommand,       ""},
+        };
+        static std::vector<ChatCommand> createShamanItemSetTable =
+        {
+            { "elemental",         SEC_ADMINISTRATOR,         false,          &HandleCreateShamanElementalItemSetCommand,        ""},
+            { "enhancement",       SEC_ADMINISTRATOR,         false,          &HandleCreateShamanEnhancementItemSetCommand,      ""},
+            { "restoration",       SEC_ADMINISTRATOR,         false,          &HandleCreateShamanRestorationItemSetCommand,      ""},
+        };
+        static std::vector<ChatCommand> createWarlockItemSetTable =
+        {
+            { "affliction",        SEC_ADMINISTRATOR,         false,          &HandleCreateWarlockAfflictionItemSetCommand,      ""},
+            { "demonology",        SEC_ADMINISTRATOR,         false,          &HandleCreateWarlockDemonologyItemSetCommand,      ""},
+            { "destruction",       SEC_ADMINISTRATOR,         false,          &HandleCreateWarlockDestructionItemSetCommand,     ""},
+        };
+        static std::vector<ChatCommand> createMageItemSetTable =
+        {
+            { "frost",             SEC_ADMINISTRATOR,         false,          &HandleCreateMageFrostItemSetCommand,              ""},
+            { "fire",              SEC_ADMINISTRATOR,         false,          &HandleCreateMageFireItemSetCommand,               ""},
+            { "arcane",            SEC_ADMINISTRATOR,         false,          &HandleCreateMageArcaneItemSetCommand,             ""},
+        };
+        static std::vector<ChatCommand> createWarriorItemSetTable =
+        {
+            { "arms",              SEC_ADMINISTRATOR,         false,          &HandleCreateWarriorArmsItemSetCommand,            ""},
+            { "fury",              SEC_ADMINISTRATOR,         false,          &HandleCreateWarriorFuryItemSetCommand,            ""},
+            { "protection",        SEC_ADMINISTRATOR,         false,          &HandleCreateWarriorProtectionItemSetCommand,      ""},
+        };
+        static std::vector<ChatCommand> createPaladinItemSetTable =
+        {
+            { "holy",              SEC_ADMINISTRATOR,         false,          &HandleCreatePaladinHolyItemSetCommand,            ""},
+            { "protection",        SEC_ADMINISTRATOR,         false,          &HandleCreatePaladinProtectionItemSetCommand,      ""},
+            { "retribution",       SEC_ADMINISTRATOR,         false,          &HandleCreatePaladinRetributionItemSetCommand,     ""},
+        };
+
+        static std::vector<ChatCommand> createPriestItemSetTable =
+        {
+            { "discipline",        SEC_ADMINISTRATOR,         false,          &HandleCreatePriestDisciplineItemSetCommand,       ""},
+            { "shadow",            SEC_ADMINISTRATOR,         false,          &HandleCreatePriestShadowItemSetCommand,           ""},
+            { "holy",              SEC_ADMINISTRATOR,         false,          &HandleCreatePriestHolyItemSetCommand,             ""},
+        };
+        static std::vector<ChatCommand> createItemSetCommandTable =
+        {
+            { "priest",            SEC_ADMINISTRATOR,          true,            NULL,         "", createPriestItemSetTable },
+            { "paladin",           SEC_ADMINISTRATOR,          true,            NULL,         "", createPaladinItemSetTable },
+            { "warrior",           SEC_ADMINISTRATOR,          true,            NULL,         "", createWarriorItemSetTable },
+            { "mage",              SEC_ADMINISTRATOR,          true,            NULL,         "", createMageItemSetTable },
+            { "warlock",           SEC_ADMINISTRATOR,          true,            NULL,         "", createWarlockItemSetTable },
+            { "shaman",            SEC_ADMINISTRATOR,          true,            NULL,         "", createShamanItemSetTable },
+            { "druid",             SEC_ADMINISTRATOR,          true,            NULL,         "", createDruidItemSetTable },
+            { "hunter",            SEC_ADMINISTRATOR,          true,            NULL,         "", createHunterItemSetTable },
+            { "rogue",             SEC_ADMINISTRATOR,          true,            NULL,         "", createRogueItemSetTable },
+            { "deathknight",       SEC_ADMINISTRATOR,          true,            NULL,         "", createDeathKnightItemSetTable },
+        };
+        static std::vector<ChatCommand> commandTable =
+        {
+            { "create",            SEC_ADMINISTRATOR,         true,             NULL,         "", createItemSetCommandTable },
+        };
+        return commandTable;
+    }
+
+    // DISCIPLINE PRIEST
+    static bool HandleCreatePriestDisciplineItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+
+        if (player->getClass() != CLASS_PRIEST)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a priest!");
+            return false;
+        }
+        player->SaveToDB();
+        sTemplateNpcMgr->sTalentsSpec = "Discipline";
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // SHADOW PRIEST
+    static bool HandleCreatePriestShadowItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_PRIEST)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a priest!");
+            return false;
+        }
+        player->SaveToDB();
+        sTemplateNpcMgr->sTalentsSpec = "Shadow";
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // HOLY PRIEST
+    static bool HandleCreatePriestHolyItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_PRIEST)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a priest!");
+            return false;
+        }
+        player->SaveToDB();
+        sTemplateNpcMgr->sTalentsSpec = "Holy";
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // HOLY PALADIN
+    static bool HandleCreatePaladinHolyItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_PALADIN)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a paladin!");
+            return false;
+        }
+        player->SaveToDB();
+        sTemplateNpcMgr->sTalentsSpec = "Holy";
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // PROTECTION PALADIN
+    static bool HandleCreatePaladinProtectionItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_PALADIN)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a paladin!");
+            return false;
+        }
+        player->SaveToDB();
+        sTemplateNpcMgr->sTalentsSpec = "Protection";
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // RETRIBUTION PALADIN
+    static bool HandleCreatePaladinRetributionItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_PALADIN)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a paladin!");
+            return false;
+        }
+        player->SaveToDB();
+        sTemplateNpcMgr->sTalentsSpec = "Retribution";
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // FURY WARRIOR
+    static bool HandleCreateWarriorFuryItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_WARRIOR)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a warrior!");
+            return false;
+        }
+        player->SaveToDB();
+        sTemplateNpcMgr->sTalentsSpec = "Fury";
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // ARMS WARRIOR
+    static bool HandleCreateWarriorArmsItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_WARRIOR)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a warrior!");
+            return false;
+        }
+        player->SaveToDB();
+        sTemplateNpcMgr->sTalentsSpec = "Arms";
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // PROTECTION WARRIOR
+    static bool HandleCreateWarriorProtectionItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_WARRIOR)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a warrior!");
+            return false;
+        }
+        player->SaveToDB();
+        sTemplateNpcMgr->sTalentsSpec = "Protection";
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // ARCANE MAGE
+    static bool HandleCreateMageArcaneItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_MAGE)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a mage!");
+            return false;
+        }
+        player->SaveToDB();
+        sTemplateNpcMgr->sTalentsSpec = "Arcane";
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // FIRE MAGE
+    static bool HandleCreateMageFireItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_MAGE)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a mage!");
+            return false;
+        }
+        player->SaveToDB();
+        sTemplateNpcMgr->sTalentsSpec = "Fire";
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // FROST MAGE
+    static bool HandleCreateMageFrostItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_MAGE)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a mage!");
+            return false;
+        }
+        player->SaveToDB();
+        sTemplateNpcMgr->sTalentsSpec = "Frost";
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // AFFLICTION WARLOCK
+    static bool HandleCreateWarlockAfflictionItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_WARLOCK)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a warlock!");
+            return false;
+        }
+        player->SaveToDB();
+        sTemplateNpcMgr->sTalentsSpec = "Affliction";
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // DEMONOLOGY WARLOCK
+    static bool HandleCreateWarlockDemonologyItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_WARLOCK)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a warlock!");
+            return false;
+        }
+        player->SaveToDB();
+        sTemplateNpcMgr->sTalentsSpec = "Demonology";
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // DESTRUCTION WARLOCK
+    static bool HandleCreateWarlockDestructionItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_WARLOCK)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a warlock!");
+            return false;
+        }
+        player->SaveToDB();
+        sTemplateNpcMgr->sTalentsSpec = "Destruction";
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // ELEMENTAL SHAMAN
+    static bool HandleCreateShamanElementalItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_SHAMAN)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a shaman!");
+            return false;
+        }
+        player->SaveToDB();
+        sTemplateNpcMgr->sTalentsSpec = "Elemental";
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // ENHANCEMENT SHAMAN
+    static bool HandleCreateShamanEnhancementItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_SHAMAN)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a shaman!");
+            return false;
+        }
+        player->SaveToDB();
+        sTemplateNpcMgr->sTalentsSpec = "Enhancement";
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // RESTORATION SHAMAN
+    static bool HandleCreateShamanRestorationItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_SHAMAN)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a shaman!");
+            return false;
+        }
+        player->SaveToDB();
+        sTemplateNpcMgr->sTalentsSpec = "Restoration";
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // BALLANCE DRUID
+    static bool HandleCreateDruidBallanceItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_DRUID)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a druid!");
+            return false;
+        }
+        player->SaveToDB();
+        sTemplateNpcMgr->sTalentsSpec = "Ballance";
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // FERAL DRUID
+    static bool HandleCreateDruidFeralItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_DRUID)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a druid!");
+            return false;
+        }
+        player->SaveToDB();
+        sTemplateNpcMgr->sTalentsSpec = "Feral";
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // RESTORATION DRUID
+    static bool HandleCreateDruidRestorationItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_DRUID)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a druid!");
+            return false;
+        }
+        player->SaveToDB();
+        sTemplateNpcMgr->sTalentsSpec = "Restoration";
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // MARKSMANSHIP HUNTER
+    static bool HandleCreateHunterMarksmanshipItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_HUNTER)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a hunter!");
+            return false;
+        }
+        player->SaveToDB();
+        sTemplateNpcMgr->sTalentsSpec = "Marksmanship";
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // BEASTMASTERY HUNTER
+    static bool HandleCreateHunterBeastmasteryItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_HUNTER)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a hunter!");
+            return false;
+        }
+        player->SaveToDB();
+        sTemplateNpcMgr->sTalentsSpec = "Beastmastery";
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // SURVIVAL HUNTER
+    static bool HandleCreateHunterSurvivalItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_HUNTER)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a hunter!");
+            return false;
+        }
+        player->SaveToDB();
+        sTemplateNpcMgr->sTalentsSpec = "Survival";
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // ASSASSINATION ROGUE
+    static bool HandleCreateRogueAssassinationItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_ROGUE)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a rogue!");
+            return false;
+        }
+        player->SaveToDB();
+        sTemplateNpcMgr->sTalentsSpec = "Assassination";
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // COMBAT ROGUE
+    static bool HandleCreateRogueCombatItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_ROGUE)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a rogue!");
+            return false;
+        }
+        player->SaveToDB();
+        sTemplateNpcMgr->sTalentsSpec = "Combat";
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // SUBTLETY ROGUE
+    static bool HandleCreateRogueSubtletyItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_ROGUE)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a rogue!");
+            return false;
+        }
+        player->SaveToDB();
+        sTemplateNpcMgr->sTalentsSpec = "Subtlety";
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // BLOOD DEATHKNIGHT
+    static bool HandleCreateDeathKnightBloodItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_DEATH_KNIGHT)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a death knight!");
+            return false;
+        }
+        player->SaveToDB();
+        sTemplateNpcMgr->sTalentsSpec = "Blood";
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // FROST DEATHKNIGHT
+    static bool HandleCreateDeathKnightFrostItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_DEATH_KNIGHT)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a death knight!");
+            return false;
+        }
+        sTemplateNpcMgr->sTalentsSpec = "Frost";
+        player->SaveToDB();
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+
+    // UNHOLY DEATHKNIGHT
+    static bool HandleCreateDeathKnightUnholyItemSetCommand(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        if (player->getClass() != CLASS_DEATH_KNIGHT)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You're not a death knight!");
+            return false;
+        }
+        sTemplateNpcMgr->sTalentsSpec = "Unholy";
+        player->SaveToDB();
+        sTemplateNpcMgr->OverwriteTemplate(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGearTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractTalentTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        sTemplateNpcMgr->ExtractGlyphsTemplateToDB(player, sTemplateNpcMgr->sTalentsSpec);
+        return true;
+    }
+};
+
+class TemplateNPC : public CreatureScript
+{
+public:
+    TemplateNPC() : CreatureScript("TemplateNPC") { }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        switch (player->getClass())
+        {
+        case CLASS_PRIEST:
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\spell_holy_wordfortitude:30|t|r Use Discipline Spec", GOSSIP_SENDER_MAIN, 0);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\spell_holy_holybolt:30|t|r Use Holy Spec", GOSSIP_SENDER_MAIN, 1);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\spell_shadow_shadowwordpain:30|t|r Use Shadow Spec", GOSSIP_SENDER_MAIN, 2);
+            }
+            break;
+        case CLASS_PALADIN:
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\spell_holy_holybolt:30|t|r Use Holy Spec", GOSSIP_SENDER_MAIN, 3);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\spell_holy_devotionaura:30|t|r Use Protection Spec", GOSSIP_SENDER_MAIN, 4);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\spell_holy_auraoflight:30|t|r Use Retribution Spec", GOSSIP_SENDER_MAIN, 5);
+            }
+            break;
+        case CLASS_WARRIOR:
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\ability_warrior_innerrage:30|t|r Use Fury Spec", GOSSIP_SENDER_MAIN, 6);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\ability_rogue_eviscerate:30|t|r Use Arms Spec", GOSSIP_SENDER_MAIN, 7);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\ability_warrior_defensivestance:30|t|r Use Protection Spec", GOSSIP_SENDER_MAIN, 8);
+            }
+            break;
+        case CLASS_MAGE:
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\spell_holy_magicalsentry:30|t|r Use Arcane Spec", GOSSIP_SENDER_MAIN, 9);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\spell_fire_flamebolt:30|t|r Use Fire Spec", GOSSIP_SENDER_MAIN, 10);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\spell_frost_frostbolt02:30|t|r Use Frost Spec", GOSSIP_SENDER_MAIN, 11);
+            }
+            break;
+        case CLASS_WARLOCK:
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\spell_shadow_deathcoil:30|t|r Use Affliction Spec", GOSSIP_SENDER_MAIN, 12);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\spell_shadow_metamorphosis:30|t|r Use Demonology Spec", GOSSIP_SENDER_MAIN, 13);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\spell_shadow_rainoffire:30|t|r Use Destruction Spec", GOSSIP_SENDER_MAIN, 14);
+            }
+            break;
+        case CLASS_SHAMAN:
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\spell_nature_lightning:30|t|r Use Elemental Spec", GOSSIP_SENDER_MAIN, 15);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\spell_nature_lightningshield:30|t|r Use Enhancement Spec", GOSSIP_SENDER_MAIN, 16);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\spell_nature_magicimmunity:30|t|r Use Restoration Spec", GOSSIP_SENDER_MAIN, 17);
+            }
+            break;
+        case CLASS_DRUID:
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\spell_nature_starfall:30|t|r Use Ballance Spec", GOSSIP_SENDER_MAIN, 18);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\ability_racial_bearform:30|t|r Use Feral Spec", GOSSIP_SENDER_MAIN, 19);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\spell_nature_healingtouch:30|t|r Use Restoration Spec", GOSSIP_SENDER_MAIN, 20);
+            }
+            break;
+        case CLASS_HUNTER:
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\ability_marksmanship:30|t|r Use Markmanship Spec", GOSSIP_SENDER_MAIN, 21);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\ability_hunter_beasttaming:30|t|r Use Beastmastery Spec", GOSSIP_SENDER_MAIN, 22);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\ability_Hunter_swiftstrike:30|t|r Use Survival Spec", GOSSIP_SENDER_MAIN, 23);
+            }
+            break;
+        case CLASS_ROGUE:
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\ability_rogue_eviscerate:30|t|r Use Assasination Spec", GOSSIP_SENDER_MAIN, 24);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\ability_backstab:30|t|r Use Combat Spec", GOSSIP_SENDER_MAIN, 25);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\ability_stealth:30|t|r Use Subtlety Spec", GOSSIP_SENDER_MAIN, 26);
+            }
+            break;
+        case CLASS_DEATH_KNIGHT:
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\spell_deathknight_bloodpresence:30|t|r Use Blood Spec", GOSSIP_SENDER_MAIN, 27);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\spell_deathknight_frostpresence:30|t|r Use Frost Spec", GOSSIP_SENDER_MAIN, 28);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, "|cff00ff00|TInterface\\icons\\spell_deathknight_unholypresence:30|t|r Use Unholy Spec", GOSSIP_SENDER_MAIN, 29);
+            }
+            break;
+        }
+        player->SEND_GOSSIP_MENU(60025, creature->GetGUID());
+        return true;
+    }
+
+    void EquipFullTemplateGear(Player* player, std::string& playerSpecStr) // Merge
+    {
+        if (sTemplateNpcMgr->CanEquipTemplate(player, playerSpecStr) == false)
+        {
+            player->GetSession()->SendAreaTriggerMessage("There's no templates for %s specialization yet.", playerSpecStr.c_str());
+            return;
+        }
+
+        // Don't let players to use Template feature while wearing some gear
+        for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
+        {
+            if (Item* haveItemEquipped = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            {
+                if (haveItemEquipped)
+                {
+                    player->GetSession()->SendAreaTriggerMessage("You need to remove all your equipped items in order to use this feature!");
+                    player->CLOSE_GOSSIP_MENU();
+                    return;
+                }
+            }
+        }
+
+        // Don't let players to use Template feature after spending some talent points
+        if (player->GetFreeTalentPoints() < 71)
+        {
+            player->GetSession()->SendAreaTriggerMessage("You have already spent some talent points. You need to reset your talents first!");
+            player->CLOSE_GOSSIP_MENU();
+            return;
+        }
+
+        sTemplateNpcMgr->LearnTemplateTalents(player);
+        sTemplateNpcMgr->LearnTemplateGlyphs(player);
+        sTemplateNpcMgr->EquipTemplateGear(player);
+        sTemplateNpcMgr->LearnPlateMailSpells(player);
+
+        LearnWeaponSkills(player);
+
+        player->GetSession()->SendAreaTriggerMessage("Successfuly equipped %s %s template!", playerSpecStr.c_str(), sTemplateNpcMgr->GetClassString(player).c_str());
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 /*uiSender*/, uint32 uiAction)
+    {
+        player->PlayerTalkClass->ClearMenus();
+
+        if (!player || !creature)
+            return true;
+
+        switch (uiAction)
+        {
+        case 0: // Use Discipline Priest Spec
+            sTemplateNpcMgr->sTalentsSpec = "Discipline";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 1: // Use Holy Priest Spec
+            sTemplateNpcMgr->sTalentsSpec = "Holy";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 2: // Use Shadow Priest Spec
+            sTemplateNpcMgr->sTalentsSpec = "Shadow";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 3: // Use Holy Paladin Spec
+            sTemplateNpcMgr->sTalentsSpec = "Holy";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 4: // Use Protection Paladin Spec
+            sTemplateNpcMgr->sTalentsSpec = "Protection";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 5: // Use Retribution Paladin Spec
+            sTemplateNpcMgr->sTalentsSpec = "Retribution";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 6: // Use Fury Warrior Spec
+            sTemplateNpcMgr->sTalentsSpec = "Fury";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 7: // Use Arms Warrior Spec
+            sTemplateNpcMgr->sTalentsSpec = "Arms";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 8: // Use Protection Warrior Spec
+            sTemplateNpcMgr->sTalentsSpec = "Protection";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 9: // Use Arcane Mage Spec
+            sTemplateNpcMgr->sTalentsSpec = "Arcane";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 10: // Use Fire Mage Spec
+            sTemplateNpcMgr->sTalentsSpec = "Fire";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 11: // Use Frost Mage Spec
+            sTemplateNpcMgr->sTalentsSpec = "Frost";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 12: // Use Affliction Warlock Spec
+            sTemplateNpcMgr->sTalentsSpec = "Affliction";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 13: // Use Demonology Warlock Spec
+            sTemplateNpcMgr->sTalentsSpec = "Demonology";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 14: // Use Destruction Warlock Spec
+            sTemplateNpcMgr->sTalentsSpec = "Destruction";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 15: // Use Elemental Shaman Spec
+            sTemplateNpcMgr->sTalentsSpec = "Elemental";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 16: // Use Enhancement Shaman Spec
+            sTemplateNpcMgr->sTalentsSpec = "Enhancement";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 17: // Use Restoration Shaman Spec
+            sTemplateNpcMgr->sTalentsSpec = "Restoration";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 18: // Use Ballance Druid Spec
+            sTemplateNpcMgr->sTalentsSpec = "Ballance";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 19: // Use Feral Druid Spec
+            sTemplateNpcMgr->sTalentsSpec = "Feral";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 20: // Use Restoration Druid Spec
+            sTemplateNpcMgr->sTalentsSpec = "Restoration";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 21: // Use Marksmanship Hunter Spec
+            sTemplateNpcMgr->sTalentsSpec = "Marksmanship";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 22: // Use Beastmastery Hunter Spec
+            sTemplateNpcMgr->sTalentsSpec = "Beastmastery";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 23: // Use Survival Hunter Spec
+            sTemplateNpcMgr->sTalentsSpec = "Survival";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 24: // Use Assassination Rogue Spec
+            sTemplateNpcMgr->sTalentsSpec = "Assassination";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 25: // Use Combat Rogue Spec
+            sTemplateNpcMgr->sTalentsSpec = "Combat";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 26: // Use Subtlety Rogue Spec
+            sTemplateNpcMgr->sTalentsSpec = "Subtlety";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 27: // Use Blood DK Spec
+            sTemplateNpcMgr->sTalentsSpec = "Blood";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 28: // Use Frost DK Spec
+            sTemplateNpcMgr->sTalentsSpec = "Frost";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+
+        case 29: // Use Unholy DK Spec
+            sTemplateNpcMgr->sTalentsSpec = "Unholy";
+            EquipFullTemplateGear(player, sTemplateNpcMgr->sTalentsSpec);
+            player->CLOSE_GOSSIP_MENU();
+            break;
+        default: // Just in case
+            player->GetSession()->SendAreaTriggerMessage("Something went wrong in the code. Please contact the administrator.");
+            break;
+        }
+        player->UpdateSkillsForLevel();
+        return true;
+    }
+};
+
+void AddSC_TemplateNPC()
+{
+    new TemplateNPC_Commands();
+    new TemplateNPC();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/TemplateNPC.h b/src/server/scripts/Custom/TemplateNPC.h
new file mode 100644
index 0000000..86ef307
--- /dev/null
+++ b/src/server/scripts/Custom/TemplateNPC.h
@@ -0,0 +1,257 @@
+#ifndef TALENT_FUNCTIONS_H
+#define TALENT_FUNCTIONS_H
+
+#include "Define.h"
+
+enum templateSpells
+{
+    PLATE_MAIL = 750,
+    MAIL       = 8737
+};
+
+enum WeaponProficiencies
+{
+    BLOCK           = 107,
+    BOWS            = 264,
+    CROSSBOWS       = 5011,
+    DAGGERS         = 1180,
+    FIST_WEAPONS    = 15590,
+    GUNS            = 266,
+    ONE_H_AXES      = 196,
+    ONE_H_MACES     = 198,
+    ONE_H_SWORDS    = 201,
+    POLEARMS        = 200,
+    SHOOT           = 5019,
+    STAVES          = 227,
+    TWO_H_AXES      = 197,
+    TWO_H_MACES     = 199,
+    TWO_H_SWORDS    = 202,
+    WANDS           = 5009,
+    THROW_WAR       = 2567
+};
+
+static void LearnWeaponSkills(Player* player)
+{
+    WeaponProficiencies wepSkills[] = {
+        BLOCK, BOWS, CROSSBOWS, DAGGERS, FIST_WEAPONS, GUNS, ONE_H_AXES, ONE_H_MACES,
+        ONE_H_SWORDS, POLEARMS, SHOOT, STAVES, TWO_H_AXES, TWO_H_MACES, TWO_H_SWORDS, WANDS, THROW_WAR
+    };
+
+    uint32 size = 17;
+
+    for (uint32 i = 0; i < size; ++i)
+        if (player->HasSpell(wepSkills[i]))
+            continue;
+
+    switch (player->getClass())
+    {
+    case CLASS_WARRIOR:
+        player->LearnSpell(THROW_WAR, false);
+        player->LearnSpell(TWO_H_SWORDS, false);
+        player->LearnSpell(TWO_H_MACES, false);
+        player->LearnSpell(TWO_H_AXES, false);
+        player->LearnSpell(STAVES, false);
+        player->LearnSpell(POLEARMS, false);
+        player->LearnSpell(ONE_H_SWORDS, false);
+        player->LearnSpell(ONE_H_MACES, false);
+        player->LearnSpell(ONE_H_AXES, false);
+        player->LearnSpell(GUNS, false);
+        player->LearnSpell(FIST_WEAPONS, false);
+        player->LearnSpell(DAGGERS, false);
+        player->LearnSpell(CROSSBOWS, false);
+        player->LearnSpell(BOWS, false);
+        player->LearnSpell(BLOCK, false);
+        break;
+    case CLASS_PRIEST:
+        player->LearnSpell(WANDS, false);
+        player->LearnSpell(STAVES, false);
+        player->LearnSpell(SHOOT, false);
+        player->LearnSpell(ONE_H_MACES, false);
+        player->LearnSpell(DAGGERS, false);
+        break;
+    case CLASS_PALADIN:
+        player->LearnSpell(TWO_H_SWORDS, false);
+        player->LearnSpell(TWO_H_MACES, false);
+        player->LearnSpell(TWO_H_AXES, false);
+        player->LearnSpell(POLEARMS, false);
+        player->LearnSpell(ONE_H_SWORDS, false);
+        player->LearnSpell(ONE_H_MACES, false);
+        player->LearnSpell(ONE_H_AXES, false);
+        player->LearnSpell(BLOCK, false);
+        break;
+    case CLASS_ROGUE:
+        player->LearnSpell(ONE_H_SWORDS, false);
+        player->LearnSpell(ONE_H_MACES, false);
+        player->LearnSpell(ONE_H_AXES, false);
+        player->LearnSpell(GUNS, false);
+        player->LearnSpell(FIST_WEAPONS, false);
+        player->LearnSpell(DAGGERS, false);
+        player->LearnSpell(CROSSBOWS, false);
+        player->LearnSpell(BOWS, false);
+        break;
+    case CLASS_DEATH_KNIGHT:
+        player->LearnSpell(TWO_H_SWORDS, false);
+        player->LearnSpell(TWO_H_MACES, false);
+        player->LearnSpell(TWO_H_AXES, false);
+        player->LearnSpell(POLEARMS, false);
+        player->LearnSpell(ONE_H_SWORDS, false);
+        player->LearnSpell(ONE_H_MACES, false);
+        player->LearnSpell(ONE_H_AXES, false);
+        break;
+    case CLASS_MAGE:
+        player->LearnSpell(WANDS, false);
+        player->LearnSpell(STAVES, false);
+        player->LearnSpell(SHOOT, false);
+        player->LearnSpell(ONE_H_SWORDS, false);
+        player->LearnSpell(DAGGERS, false);
+        break;
+    case CLASS_SHAMAN:
+        player->LearnSpell(TWO_H_MACES, false);
+        player->LearnSpell(TWO_H_AXES, false);
+        player->LearnSpell(STAVES, false);
+        player->LearnSpell(ONE_H_MACES, false);
+        player->LearnSpell(ONE_H_AXES, false);
+        player->LearnSpell(FIST_WEAPONS, false);
+        player->LearnSpell(DAGGERS, false);
+        player->LearnSpell(BLOCK, false);
+        break;
+    case CLASS_HUNTER:
+        player->LearnSpell(THROW_WAR, false);
+        player->LearnSpell(TWO_H_SWORDS, false);
+        player->LearnSpell(TWO_H_AXES, false);
+        player->LearnSpell(STAVES, false);
+        player->LearnSpell(POLEARMS, false);
+        player->LearnSpell(ONE_H_SWORDS, false);
+        player->LearnSpell(ONE_H_AXES, false);
+        player->LearnSpell(GUNS, false);
+        player->LearnSpell(FIST_WEAPONS, false);
+        player->LearnSpell(DAGGERS, false);
+        player->LearnSpell(CROSSBOWS, false);
+        player->LearnSpell(BOWS, false);
+        break;
+    case CLASS_DRUID:
+        player->LearnSpell(TWO_H_MACES, false);
+        player->LearnSpell(STAVES, false);
+        player->LearnSpell(POLEARMS, false);
+        player->LearnSpell(ONE_H_MACES, false);
+        player->LearnSpell(FIST_WEAPONS, false);
+        player->LearnSpell(DAGGERS, false);
+        break;
+    case CLASS_WARLOCK:
+        player->LearnSpell(WANDS, false);
+        player->LearnSpell(STAVES, false);
+        player->LearnSpell(SHOOT, false);
+        player->LearnSpell(ONE_H_SWORDS, false);
+        player->LearnSpell(DAGGERS, false);
+        break;
+    default:
+        break;
+    }
+}
+
+struct TalentTemplate
+{
+    std::string    playerClass;
+    std::string    playerSpec;
+    uint32         talentId;
+};
+
+struct GlyphTemplate
+{
+    std::string    playerClass;
+    std::string    playerSpec;
+    uint8          slot;
+    uint32         glyph;
+};
+
+struct HumanGearTemplate
+{
+    std::string    playerClass;
+    std::string    playerSpec;
+    uint8          pos;
+    uint32         itemEntry;
+    uint32         enchant;
+    uint32         socket1;
+    uint32         socket2;
+    uint32         socket3;
+    uint32         bonusEnchant;
+    uint32         prismaticEnchant;
+};
+
+struct AllianceGearTemplate
+{
+    std::string    playerClass;
+    std::string    playerSpec;
+    uint8          pos;
+    uint32         itemEntry;
+    uint32         enchant;
+    uint32         socket1;
+    uint32         socket2;
+    uint32         socket3;
+    uint32         bonusEnchant;
+    uint32         prismaticEnchant;
+};
+
+struct HordeGearTemplate
+{
+    std::string    playerClass;
+    std::string    playerSpec;
+    uint8          pos;
+    uint32         itemEntry;
+    uint32         enchant;
+    uint32         socket1;
+    uint32         socket2;
+    uint32         socket3;
+    uint32         bonusEnchant;
+    uint32         prismaticEnchant;
+};
+
+typedef std::vector<HumanGearTemplate*> HumanGearContainer;
+typedef std::vector<AllianceGearTemplate*> AllianceGearContainer;
+typedef std::vector<HordeGearTemplate*> HordeGearContainer;
+
+typedef std::vector<TalentTemplate*> TalentContainer;
+typedef std::vector<GlyphTemplate*> GlyphContainer;
+
+class sTemplateNPC
+{
+public:
+    static sTemplateNPC* instance()
+    {
+        static sTemplateNPC* instance = new sTemplateNPC();
+        return instance;
+    }
+    void LoadTalentsContainer();
+    void LoadGlyphsContainer();
+
+    void LoadHumanGearContainer();
+    void LoadAllianceGearContainer();
+    void LoadHordeGearContainer();
+
+    void ApplyGlyph(Player* player, uint8 slot, uint32 glyphID);
+    void ApplyBonus(Player* player, Item* item, EnchantmentSlot slot, uint32 bonusEntry);
+
+    bool OverwriteTemplate(Player* /*player*/, std::string& /*playerSpecStr*/);
+    void ExtractGearTemplateToDB(Player* /*player*/, std::string& /*playerSpecStr*/);
+    void ExtractTalentTemplateToDB(Player* /*player*/, std::string& /*playerSpecStr*/);
+    void ExtractGlyphsTemplateToDB(Player* /*player*/, std::string& /*playerSpecStr*/);
+    bool CanEquipTemplate(Player* /*player*/, std::string& /*playerSpecStr*/);
+
+    std::string GetClassString(Player* /*player*/);
+    std::string sTalentsSpec;
+
+    void LearnTemplateTalents(Player* /*player*/);
+    void LearnTemplateGlyphs(Player* /*player*/);
+    void EquipTemplateGear(Player* /*player*/);
+
+    void LearnPlateMailSpells(Player* /*player*/);
+
+    GlyphContainer m_GlyphContainer;
+    TalentContainer m_TalentContainer;
+
+    HumanGearContainer m_HumanGearContainer;
+    AllianceGearContainer m_AllianceGearContainer;
+    HordeGearContainer m_HordeGearContainer;
+};
+#define sTemplateNpcMgr sTemplateNPC::instance()
+#endif
\ No newline at end of file
diff --git a/src/server/scripts/Custom/TransmogDisplayVendor.cpp b/src/server/scripts/Custom/TransmogDisplayVendor.cpp
new file mode 100644
index 0000000..81e037e
--- /dev/null
+++ b/src/server/scripts/Custom/TransmogDisplayVendor.cpp
@@ -0,0 +1,1155 @@
+/*
+Transmog display vendor
+Code by Rochet2
+Ideas LilleCarl
+
+ScriptName for NPC:
+NPC_TransmogDisplayVendor
+
+Compatible with Transmogrification 6.1 by Rochet2
+http://rochet2.github.io/Transmogrification
+*/
+
+#include "TransmogDisplayVendorConf.h"
+#include "Bag.h"
+#include "Common.h"
+#include "Config.h"
+#include "Creature.h"
+#include "DatabaseEnv.h"
+#include "DBCStructure.h"
+#include "Define.h"
+#include "Field.h"
+#include "GameEventMgr.h"
+#include "GossipDef.h"
+#include "Item.h"
+#include "ItemPrototype.h"
+#include "Language.h"
+#include "Log.h"
+#include "Player.h"
+#include "ObjectGuid.h"
+#include "ObjectMgr.h"
+#include "QueryResult.h"
+#include "ScriptedGossip.h"
+#include "ScriptMgr.h"
+#include "SharedDefines.h"
+#include "Transaction.h"
+#include "WorldSession.h"
+#include <sstream>
+#include <string>
+
+// Config start
+
+// Edit Transmogrification compatibility in TransmogDisplayVendorConf.h
+
+// A multiplier for the default gold cost (change to 0.0f for no default cost)
+const float TransmogDisplayVendorMgr::ScaledCostModifier = 1.0f;
+// Cost added on top of other costs (can be negative)
+const int32 TransmogDisplayVendorMgr::CopperCost = 0;
+// For custom gold cost set ScaledCostModifier to 0.0f and CopperCost to what ever cost you want
+
+const bool TransmogDisplayVendorMgr::RequireToken = false;
+const uint32 TransmogDisplayVendorMgr::TokenEntry = 49426;
+const uint32 TransmogDisplayVendorMgr::TokenAmount = 1;
+
+const bool TransmogDisplayVendorMgr::AllowPoor = false;
+const bool TransmogDisplayVendorMgr::AllowCommon = false;
+const bool TransmogDisplayVendorMgr::AllowUncommon = true;
+const bool TransmogDisplayVendorMgr::AllowRare = true;
+const bool TransmogDisplayVendorMgr::AllowEpic = true;
+const bool TransmogDisplayVendorMgr::AllowLegendary = false;
+const bool TransmogDisplayVendorMgr::AllowArtifact = false;
+const bool TransmogDisplayVendorMgr::AllowHeirloom = true;
+
+const bool TransmogDisplayVendorMgr::AllowMixedArmorTypes = false;
+const bool TransmogDisplayVendorMgr::AllowMixedWeaponTypes = false;
+const bool TransmogDisplayVendorMgr::AllowFishingPoles = false;
+
+const bool TransmogDisplayVendorMgr::IgnoreReqRace = false;
+const bool TransmogDisplayVendorMgr::IgnoreReqClass = false;
+const bool TransmogDisplayVendorMgr::IgnoreReqSkill = false;
+const bool TransmogDisplayVendorMgr::IgnoreReqSpell = false;
+const bool TransmogDisplayVendorMgr::IgnoreReqLevel = false;
+const bool TransmogDisplayVendorMgr::IgnoreReqEvent = false;
+const bool TransmogDisplayVendorMgr::IgnoreReqStats = false;
+
+// Example AllowedItems[] = { 123, 234, 345 };
+static const uint32 AllowedItems[] = { 0 };
+static const uint32 NotAllowedItems[] = { 0 };
+
+// Config end
+
+std::set<uint32> TransmogDisplayVendorMgr::Allowed;
+std::set<uint32> TransmogDisplayVendorMgr::NotAllowed;
+
+#ifndef UNORDERED_MAP
+#define UNORDERED_MAP std::unordered_map
+#endif
+
+#ifdef BOOST_VERSION
+#define USING_BOOST
+#endif
+#ifdef USING_BOOST
+#include <boost/thread/locks.hpp>
+#include <boost/thread/shared_mutex.hpp>
+#endif
+
+namespace
+{
+    class RWLockable
+    {
+    public:
+#ifdef USING_BOOST
+        typedef boost::shared_mutex LockType;
+        typedef boost::shared_lock<boost::shared_mutex> ReadGuard;
+        typedef boost::unique_lock<boost::shared_mutex> WriteGuard;
+#else
+        typedef ACE_RW_Thread_Mutex LockType;
+        typedef ACE_Read_Guard<LockType> ReadGuard;
+        typedef ACE_Write_Guard<LockType> WriteGuard;
+#endif
+        LockType& GetLock() { return _lock; }
+    private:
+        LockType _lock;
+    };
+
+    class SelectionStore : public RWLockable
+    {
+    public:
+        struct Selection { uint32 item; uint8 slot; uint32 offset; uint32 quality; };
+        typedef UNORDERED_MAP<uint32, Selection> PlayerLowToSelection;
+
+        void SetSelection(uint32 playerLow, const Selection& selection)
+        {
+            WriteGuard guard(GetLock());
+            hashmap[playerLow] = selection;
+        }
+
+        bool GetSelection(uint32 playerLow, Selection& returnVal)
+        {
+            ReadGuard guard(GetLock());
+
+            PlayerLowToSelection::iterator it = hashmap.find(playerLow);
+            if (it == hashmap.end())
+                return false;
+
+            returnVal = it->second;
+            return true;
+        }
+
+        void RemoveSelection(uint32 playerLow)
+        {
+            WriteGuard guard(GetLock());
+            hashmap.erase(playerLow);
+        }
+
+    private:
+        PlayerLowToSelection hashmap;
+    };
+};
+
+// Selection store
+static SelectionStore selectionStore; // selectionStore[lowGUID] = Selection
+
+// Vendor data store
+// optionMap[Class? + SubClass][invtype][Quality] = EntryVector
+typedef std::vector<uint32> EntryVector;
+static EntryVector* optionMap[MAX_ITEM_SUBCLASS_WEAPON + MAX_ITEM_SUBCLASS_ARMOR][MAX_INVTYPE][MAX_ITEM_QUALITY];
+
+uint32 TransmogDisplayVendorMgr::GetFakeEntry(const Item* item)
+{
+    TC_LOG_DEBUG("custom.transmog", "TransmogDisplayVendorMgr::GetFakeEntry");
+
+    Player* owner = item->GetOwner();
+
+    if (!owner)
+        return 0;
+    if (owner->transmogMap.empty())
+        return 0;
+
+    TransmogMapType::const_iterator it = owner->transmogMap.find(item->GetGUID());
+    if (it == owner->transmogMap.end())
+        return 0;
+    return it->second;
+}
+void TransmogDisplayVendorMgr::DeleteFakeEntry(Player* player, Item* item)
+{
+    TC_LOG_DEBUG("custom.transmog", "TransmogDisplayVendorMgr::DeleteFakeEntry");
+
+    if (player->transmogMap.erase(item->GetGUID()) != 0)
+        UpdateItem(player, item);
+}
+void TransmogDisplayVendorMgr::SetFakeEntry(Player* player, Item* item, uint32 entry)
+{
+    TC_LOG_DEBUG("custom.transmog", "TransmogDisplayVendorMgr::SetFakeEntry");
+
+    player->transmogMap[item->GetGUID()] = entry;
+    UpdateItem(player, item);
+}
+void TransmogDisplayVendorMgr::UpdateItem(Player* player, Item* item)
+{
+    TC_LOG_DEBUG("custom.transmog", "TransmogDisplayVendorMgr::UpdateItem");
+
+    if (item->IsEquipped())
+    {
+        player->SetVisibleItemSlot(item->GetSlot(), item);
+        if (player->IsInWorld())
+            item->SendUpdateToPlayer(player);
+    }
+}
+const char* TransmogDisplayVendorMgr::getSlotName(uint8 slot, WorldSession* /*session*/)
+{
+    TC_LOG_DEBUG("custom.transmog", "TransmogDisplayVendorMgr::TransmogDisplayVendorMgr::getSlotName");
+
+    switch (slot)
+    {
+        case EQUIPMENT_SLOT_HEAD: return  "Head";// session->GetTrinityString(LANG_SLOT_NAME_HEAD);
+        case EQUIPMENT_SLOT_SHOULDERS: return  "Shoulders";// session->GetTrinityString(LANG_SLOT_NAME_SHOULDERS);
+        case EQUIPMENT_SLOT_BODY: return  "Shirt";// session->GetTrinityString(LANG_SLOT_NAME_BODY);
+        case EQUIPMENT_SLOT_CHEST: return  "Chest";// session->GetTrinityString(LANG_SLOT_NAME_CHEST);
+        case EQUIPMENT_SLOT_WAIST: return  "Waist";// session->GetTrinityString(LANG_SLOT_NAME_WAIST);
+        case EQUIPMENT_SLOT_LEGS: return  "Legs";// session->GetTrinityString(LANG_SLOT_NAME_LEGS);
+        case EQUIPMENT_SLOT_FEET: return  "Feet";// session->GetTrinityString(LANG_SLOT_NAME_FEET);
+        case EQUIPMENT_SLOT_WRISTS: return  "Wrists";// session->GetTrinityString(LANG_SLOT_NAME_WRISTS);
+        case EQUIPMENT_SLOT_HANDS: return  "Hands";// session->GetTrinityString(LANG_SLOT_NAME_HANDS);
+        case EQUIPMENT_SLOT_BACK: return  "Back";// session->GetTrinityString(LANG_SLOT_NAME_BACK);
+        case EQUIPMENT_SLOT_MAINHAND: return  "Main hand";// session->GetTrinityString(LANG_SLOT_NAME_MAINHAND);
+        case EQUIPMENT_SLOT_OFFHAND: return  "Off hand";// session->GetTrinityString(LANG_SLOT_NAME_OFFHAND);
+        case EQUIPMENT_SLOT_RANGED: return  "Ranged";// session->GetTrinityString(LANG_SLOT_NAME_RANGED);
+        case EQUIPMENT_SLOT_TABARD: return  "Tabard";// session->GetTrinityString(LANG_SLOT_NAME_TABARD);
+        default: return NULL;
+    }
+}
+uint32 TransmogDisplayVendorMgr::GetSpecialPrice(ItemTemplate const* proto)
+{
+    TC_LOG_DEBUG("custom.transmog", "TransmogDisplayVendorMgr::GetSpecialPrice");
+
+    uint32 cost = proto->SellPrice < 10000 ? 10000 : proto->SellPrice;
+    return cost;
+}
+bool TransmogDisplayVendorMgr::CanTransmogrifyItemWithItem(Player* player, ItemTemplate const* target, ItemTemplate const* source)
+{
+    TC_LOG_DEBUG("custom.transmog", "TransmogDisplayVendorMgr::CanTransmogrifyItemWithItem");
+
+    if (!target || !source)
+        return false;
+
+    if (source->ItemId == target->ItemId)
+        return false;
+
+    if (source->DisplayInfoID == target->DisplayInfoID)
+        return false;
+
+    if (source->Class != target->Class)
+        return false;
+
+    if (source->InventoryType == INVTYPE_BAG ||
+        source->InventoryType == INVTYPE_RELIC ||
+        // source->InventoryType == INVTYPE_BODY ||
+        source->InventoryType == INVTYPE_FINGER ||
+        source->InventoryType == INVTYPE_TRINKET ||
+        source->InventoryType == INVTYPE_AMMO ||
+        source->InventoryType == INVTYPE_QUIVER)
+        return false;
+
+    if (target->InventoryType == INVTYPE_BAG ||
+        target->InventoryType == INVTYPE_RELIC ||
+        // target->InventoryType == INVTYPE_BODY ||
+        target->InventoryType == INVTYPE_FINGER ||
+        target->InventoryType == INVTYPE_TRINKET ||
+        target->InventoryType == INVTYPE_AMMO ||
+        target->InventoryType == INVTYPE_QUIVER)
+        return false;
+
+    if (!SuitableForTransmogrification(player, target) || !SuitableForTransmogrification(player, source)) // if (!transmogrified->CanTransmogrify() || !transmogrifier->CanBeTransmogrified())
+        return false;
+
+    if (IsRangedWeapon(source->Class, source->SubClass) != IsRangedWeapon(target->Class, target->SubClass))
+        return false;
+
+    if (source->SubClass != target->SubClass && !IsRangedWeapon(target->Class, target->SubClass))
+    {
+        if (source->Class == ITEM_CLASS_ARMOR && !AllowMixedArmorTypes)
+            return false;
+        if (source->Class == ITEM_CLASS_WEAPON && !AllowMixedWeaponTypes)
+            return false;
+    }
+
+    if (source->InventoryType != target->InventoryType)
+    {
+        if (source->Class == ITEM_CLASS_WEAPON && !((IsRangedWeapon(target->Class, target->SubClass) ||
+            ((target->InventoryType == INVTYPE_WEAPON || target->InventoryType == INVTYPE_2HWEAPON) &&
+                (source->InventoryType == INVTYPE_WEAPON || source->InventoryType == INVTYPE_2HWEAPON)) ||
+            ((target->InventoryType == INVTYPE_WEAPONMAINHAND || target->InventoryType == INVTYPE_WEAPONOFFHAND) &&
+                (source->InventoryType == INVTYPE_WEAPON || source->InventoryType == INVTYPE_2HWEAPON)))))
+            return false;
+        if (source->Class == ITEM_CLASS_ARMOR &&
+            !((source->InventoryType == INVTYPE_CHEST || source->InventoryType == INVTYPE_ROBE) &&
+                (target->InventoryType == INVTYPE_CHEST || target->InventoryType == INVTYPE_ROBE)))
+            return false;
+    }
+
+    return true;
+}
+bool TransmogDisplayVendorMgr::SuitableForTransmogrification(Player* player, ItemTemplate const* proto)
+{
+    TC_LOG_DEBUG("custom.transmog", "TransmogDisplayVendorMgr::SuitableForTransmogrification");
+
+    // ItemTemplate const* proto = item->GetTemplate();
+    if (!proto)
+        return false;
+
+    if (proto->Class != ITEM_CLASS_ARMOR &&
+        proto->Class != ITEM_CLASS_WEAPON)
+        return false;
+
+    // Skip all checks for allowed items
+    if (IsAllowed(proto->ItemId))
+        return true;
+
+    if (IsNotAllowed(proto->ItemId))
+        return false;
+
+    if (!AllowFishingPoles && proto->Class == ITEM_CLASS_WEAPON && proto->SubClass == ITEM_SUBCLASS_WEAPON_FISHING_POLE)
+        return false;
+
+    if (!IsAllowedQuality(proto->Quality)) // (proto->Quality == ITEM_QUALITY_LEGENDARY)
+        return false;
+
+    if (player)
+    {
+        if ((proto->Flags2 & ITEM_FLAGS_EXTRA_HORDE_ONLY) && player->GetTeam() != HORDE)
+            return false;
+
+        if ((proto->Flags2 & ITEM_FLAGS_EXTRA_ALLIANCE_ONLY) && player->GetTeam() != ALLIANCE)
+            return false;
+
+        if (!IgnoreReqClass && (proto->AllowableClass & player->getClassMask()) == 0)
+            return false;
+
+        if (!IgnoreReqRace && (proto->AllowableRace & player->getRaceMask()) == 0)
+            return false;
+
+        if (!IgnoreReqSkill && proto->RequiredSkill != 0)
+        {
+            if (player->GetSkillValue(proto->RequiredSkill) == 0)
+                return false;
+            else if (player->GetSkillValue(proto->RequiredSkill) < proto->RequiredSkillRank)
+                return false;
+        }
+
+        if (!IgnoreReqSpell && proto->RequiredSpell != 0 && !player->HasSpell(proto->RequiredSpell))
+            return false;
+
+        if (!IgnoreReqLevel && player->getLevel() < proto->RequiredLevel)
+            return false;
+    }
+
+    // If World Event is not active, prevent using event dependant items
+    if (!IgnoreReqEvent && proto->HolidayId && !IsHolidayActive((HolidayIds)proto->HolidayId))
+        return false;
+
+    if (!IgnoreReqStats)
+    {
+        if (!proto->RandomProperty && !proto->RandomSuffix)
+        {
+            bool found = false;
+            for (uint8 i = 0; i < proto->StatsCount; ++i)
+            {
+                if (proto->ItemStat[i].ItemStatValue != 0)
+                {
+                    found = true;
+                    break;
+                }
+            }
+            if (!found)
+                return false;
+        }
+    }
+
+    return true;
+}
+
+bool TransmogDisplayVendorMgr::IsRangedWeapon(uint32 Class, uint32 SubClass)
+{
+    TC_LOG_DEBUG("custom.transmog", "TransmogDisplayVendorMgr::IsRangedWeapon");
+
+    return Class == ITEM_CLASS_WEAPON && (
+        SubClass == ITEM_SUBCLASS_WEAPON_BOW ||
+        SubClass == ITEM_SUBCLASS_WEAPON_GUN ||
+        SubClass == ITEM_SUBCLASS_WEAPON_CROSSBOW);
+}
+bool TransmogDisplayVendorMgr::IsAllowed(uint32 entry)
+{
+    TC_LOG_DEBUG("custom.transmog", "TransmogDisplayVendorMgr::IsAllowed");
+
+    return Allowed.find(entry) != Allowed.end();
+}
+bool TransmogDisplayVendorMgr::IsNotAllowed(uint32 entry)
+{
+    TC_LOG_DEBUG("custom.transmog", "TransmogDisplayVendorMgr::IsNotAllowed");
+
+    return NotAllowed.find(entry) != NotAllowed.end();
+}
+bool TransmogDisplayVendorMgr::IsAllowedQuality(uint32 quality)
+{
+    TC_LOG_DEBUG("custom.transmog", "TransmogDisplayVendorMgr::IsAllowedQuality");
+
+    switch (quality)
+    {
+        case ITEM_QUALITY_POOR: return AllowPoor;
+        case ITEM_QUALITY_NORMAL: return AllowCommon;
+        case ITEM_QUALITY_UNCOMMON: return AllowUncommon;
+        case ITEM_QUALITY_RARE: return AllowRare;
+        case ITEM_QUALITY_EPIC: return AllowEpic;
+        case ITEM_QUALITY_LEGENDARY: return AllowLegendary;
+        case ITEM_QUALITY_ARTIFACT: return AllowArtifact;
+        case ITEM_QUALITY_HEIRLOOM: return AllowHeirloom;
+        default: return false;
+    }
+}
+
+static const char* getQualityName(uint32 quality)
+{
+    switch (quality)
+    {
+        case ITEM_QUALITY_POOR: return "|CFF9d9d9d[Poor]";
+        case ITEM_QUALITY_NORMAL: return "|CFFffffff[Common]";
+        case ITEM_QUALITY_UNCOMMON: return "|CFF1eff00[Uncommon]";
+        case ITEM_QUALITY_RARE: return "|CFF0070dd[Rare]";
+        case ITEM_QUALITY_EPIC: return "|CFFa335ee[Epic]";
+        case ITEM_QUALITY_LEGENDARY: return "|CFFff8000[Legendary]";
+        case ITEM_QUALITY_ARTIFACT: return "|CFFe6cc80[Artifact]";
+        case ITEM_QUALITY_HEIRLOOM: return "|CFFe5cc80[Heirloom]";
+        default: return "[Unknown]";
+    }
+}
+
+static std::string getItemName(const ItemTemplate* itemTemplate, WorldSession* session)
+{
+    std::string name = itemTemplate->Name1;
+    int loc_idx = session->GetSessionDbLocaleIndex();
+    if (loc_idx >= 0)
+        if (ItemLocale const* il = sObjectMgr->GetItemLocale(itemTemplate->ItemId))
+            sObjectMgr->GetLocaleString(il->Name, loc_idx, name);
+    return name;
+}
+
+static uint32 getCorrectInvType(uint32 inventorytype)
+{
+    switch (inventorytype)
+    {
+        case INVTYPE_WEAPONMAINHAND:
+        case INVTYPE_WEAPONOFFHAND:
+            return INVTYPE_WEAPON;
+        case INVTYPE_RANGEDRIGHT:
+            return INVTYPE_RANGED;
+        case INVTYPE_ROBE:
+            return INVTYPE_CHEST;
+        default:
+            return inventorytype;
+    }
+}
+
+void TransmogDisplayVendorMgr::HandleTransmogrify(Player* player, Creature* /*creature*/, uint32 vendorslot, uint32 itemEntry, bool no_cost)
+{
+    TC_LOG_DEBUG("custom.transmog", "TransmogDisplayVendorMgr::HandleTransmogrify");
+
+    SelectionStore::Selection selection;
+    if (!selectionStore.GetSelection(player->GetGUID().GetCounter(), selection))
+        return; // cheat, no slot selected
+
+    const char* slotname = TransmogDisplayVendorMgr::getSlotName(selection.slot, player->GetSession());
+    if (!slotname)
+        return;
+    uint8 slot = selection.slot;
+
+    // slot of the transmogrified item
+    if (slot >= EQUIPMENT_SLOT_END)
+    {
+        TC_LOG_DEBUG("custom.transmog", "TransmogDisplayVendorMgr::HandleTransmogrify - %s (%s) tried to transmogrify item %u with a wrong slot (%u) when transmogrifying items.", player->GetName().c_str(), player->GetGUID().ToString().c_str(), itemEntry, slot);
+        return; // LANG_ERR_TRANSMOG_INVALID_SLOT
+    }
+
+    const ItemTemplate* itemTransmogrifier = NULL;
+    // guid of the transmogrifier item, if it's not 0
+    if (itemEntry)
+    {
+        itemTransmogrifier = sObjectMgr->GetItemTemplate(itemEntry);
+        if (!itemTransmogrifier)
+        {
+            TC_LOG_DEBUG("custom.transmog", "TransmogDisplayVendorMgr::HandleTransmogrify - %s (%s) tried to transmogrify with an invalid item entry %u.", player->GetName().c_str(), player->GetGUID().ToString().c_str(), itemEntry);
+            return; // LANG_ERR_TRANSMOG_MISSING_SRC_ITEM
+        }
+    }
+
+    // transmogrified item
+    Item* itemTransmogrified = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+    if (!itemTransmogrified)
+    {
+        TC_LOG_DEBUG("custom.transmog", "TransmogDisplayVendorMgr::HandleTransmogrify - %s (%s) tried to transmogrify an invalid item in a valid slot (slot: %u).", player->GetName().c_str(), player->GetGUID().ToString().c_str(), slot);
+        player->GetSession()->SendNotification("No item in %s slot", slotname);
+        return; // LANG_ERR_TRANSMOG_MISSING_DEST_ITEM
+    }
+
+    if (!itemTransmogrifier) // reset look newEntry
+    {
+        DeleteFakeEntry(player, itemTransmogrified);
+    }
+    else
+    {
+        if (!CanTransmogrifyItemWithItem(player, itemTransmogrified->GetTemplate(), itemTransmogrifier))
+        {
+            TC_LOG_DEBUG("custom.transmog", "TransmogDisplayVendorMgr::HandleTransmogrify - %s (%s) failed CanTransmogrifyItemWithItem (%u with %u).", player->GetName().c_str(), player->GetGUID().ToString().c_str(), itemTransmogrified->GetEntry(), itemTransmogrifier->ItemId);
+            player->GetSession()->SendNotification("Equipped item is not suitable for selected transmogrification");
+            return; // LANG_ERR_TRANSMOG_INVALID_ITEMS
+        }
+
+        if (uint32 fakeEntry = GetFakeEntry(itemTransmogrified))
+        {
+            if (const ItemTemplate* fakeItemTemplate = sObjectMgr->GetItemTemplate(fakeEntry))
+            {
+                if (fakeItemTemplate->DisplayInfoID == itemTransmogrifier->DisplayInfoID)
+                {
+                    player->GetSession()->SendNotification("%s already transmogrified with %s", slotname, getItemName(itemTransmogrifier, player->GetSession()).c_str());
+                    return;
+                }
+            }
+        }
+
+        // {{entry}, {entry}, ...}
+        std::list<uint32> L;
+        uint32 counter = 0;
+        bool over = false;
+        if (itemTransmogrified->GetTemplate()->Class != ITEM_CLASS_WEAPON && TransmogDisplayVendorMgr::AllowMixedArmorTypes)
+        {
+            for (uint32 i = 0; i < MAX_ITEM_SUBCLASS_ARMOR; ++i)
+            {
+                const EntryVector* oM = optionMap[MAX_ITEM_SUBCLASS_WEAPON + i][getCorrectInvType(itemTransmogrified->GetTemplate()->InventoryType)][selection.quality];
+                if (!oM)
+                    continue;
+                if (!over && counter + oM->size() < selection.offset)
+                {
+                    counter += oM->size();
+                }
+                else
+                {
+                    over = true;
+                    L.insert(L.end(), oM->begin(), oM->end());
+                }
+            }
+        }
+        else if (itemTransmogrified->GetTemplate()->Class == ITEM_CLASS_WEAPON && TransmogDisplayVendorMgr::AllowMixedWeaponTypes)
+        {
+            for (uint32 i = 0; i < MAX_ITEM_SUBCLASS_WEAPON; ++i)
+            {
+                const EntryVector* oM = optionMap[i][getCorrectInvType(itemTransmogrified->GetTemplate()->InventoryType)][selection.quality];
+                if (!oM)
+                    continue;
+                if (!over && counter + oM->size() < selection.offset)
+                {
+                    counter += oM->size();
+                }
+                else
+                {
+                    over = true;
+                    L.insert(L.end(), oM->begin(), oM->end());
+                }
+            }
+        }
+        else
+        {
+            const EntryVector* oM = optionMap[(itemTransmogrified->GetTemplate()->Class != ITEM_CLASS_WEAPON ? MAX_ITEM_SUBCLASS_WEAPON : 0) + itemTransmogrified->GetTemplate()->SubClass][getCorrectInvType(itemTransmogrified->GetTemplate()->InventoryType)][selection.quality];
+            if (oM)
+            {
+                if (!over && counter + oM->size() < selection.offset)
+                {
+                    counter += oM->size();
+                }
+                else
+                {
+                    over = true;
+                    L.insert(L.end(), oM->begin(), oM->end());
+                }
+            }
+        }
+        std::list<uint32>::const_iterator it = L.begin();
+        std::advance(it, (selection.offset - counter) + vendorslot);
+        if (it == L.end() || (*it) != itemEntry)
+        {
+            player->GetSession()->SendNotification("Equipped item is not suitable for selected transmogrification");
+            return; // either cheat or changed items (not found in correct place in transmog vendor view)
+        }
+
+        if (!no_cost)
+        {
+            if (RequireToken)
+            {
+                if (player->HasItemCount(TokenEntry, TokenAmount))
+                {
+                    player->DestroyItemCount(TokenEntry, TokenAmount, true);
+                }
+                else
+                {
+                    player->GetSession()->SendNotification("You do not have enough %ss", getItemName(sObjectMgr->GetItemTemplate(TransmogDisplayVendorMgr::TokenEntry), player->GetSession()).c_str());
+                    return; // LANG_ERR_TRANSMOG_NOT_ENOUGH_TOKENS
+                }
+            }
+
+            int32 cost = 0;
+            cost = GetSpecialPrice(itemTransmogrified->GetTemplate());
+            cost *= ScaledCostModifier;
+            cost += CopperCost;
+
+            if (cost) // 0 cost if reverting look
+            {
+                if (cost < 0)
+                {
+                    TC_LOG_DEBUG("custom.transmog", "TransmogDisplayVendorMgr::HandleTransmogrify - %s (%s) transmogrification invalid cost (non negative, amount %i). Transmogrified %u with %u", player->GetName().c_str(), player->GetGUID().ToString().c_str(), -cost, itemTransmogrified->GetEntry(), itemTransmogrifier->ItemId);
+                }
+                else
+                {
+                    if (!player->HasEnoughMoney(cost))
+                    {
+                        player->GetSession()->SendNotification("You do not have enough money");
+                        return; // LANG_ERR_TRANSMOG_NOT_ENOUGH_MONEY
+                    }
+                    player->ModifyMoney(-cost, false);
+                }
+            }
+
+            SetFakeEntry(player, itemTransmogrified, itemTransmogrifier->ItemId);
+
+            itemTransmogrified->UpdatePlayedTime(player);
+
+            itemTransmogrified->SetOwnerGUID(player->GetGUID());
+            itemTransmogrified->SetNotRefundable(player);
+            itemTransmogrified->ClearSoulboundTradeable(player);
+
+            //if (itemTransmogrifier->GetTemplate()->Bonding == BIND_WHEN_EQUIPED || itemTransmogrifier->GetTemplate()->Bonding == BIND_WHEN_USE)
+            //    itemTransmogrifier->SetBinding(true);
+
+            //itemTransmogrifier->SetOwnerGUID(player->GetGUID());
+            //itemTransmogrifier->SetNotRefundable(player);
+            //itemTransmogrifier->ClearSoulboundTradeable(player);
+        }
+
+        player->PlayDirectSound(3337);
+        player->GetSession()->SendAreaTriggerMessage("%s transmogrified", slotname);
+        //return LANG_ERR_TRANSMOG_OK;
+    }
+}
+
+class NPC_TransmogDisplayVendor : public CreatureScript
+{
+public:
+    NPC_TransmogDisplayVendor() : CreatureScript("NPC_TransmogDisplayVendor") { } // If you change this, also change in Player.cpp: if (creature->GetScriptName() == "NPC_TransmogDisplayVendor")
+
+    bool OnGossipHello(Player* player, Creature* creature) override
+    {
+        player->PlayerTalkClass->ClearMenus();
+        selectionStore.RemoveSelection(player->GetGUID().GetCounter());
+        WorldSession* session = player->GetSession();
+        for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; slot++)
+        {
+            // if (player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+            if (const char* slotName = TransmogDisplayVendorMgr::getSlotName(slot, session))
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TRAINER, slotName, SENDER_SELECT_VENDOR, slot);
+        }
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TRAINER, "Remove transmogrifications", SENDER_REMOVE_MENU, 0);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+        return true;
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action) override
+    {
+        WorldSession* session = player->GetSession();
+        player->PlayerTalkClass->ClearMenus();
+        switch (sender)
+        {
+            case SENDER_SELECT_VENDOR: // action = slot
+            {
+                Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, action);
+                if (!item)
+                {
+                    if (const char* slotname = TransmogDisplayVendorMgr::getSlotName(action, player->GetSession()))
+                        session->SendNotification("No item equipped in %s slot", slotname);
+                    OnGossipHello(player, creature);
+                    return true;
+                }
+                const ItemTemplate * itemTemplate = item->GetTemplate();
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_INTERACT_1, (std::string)"Update selected; " + getItemName(itemTemplate, session), sender, action);
+
+                // [quality] = {size}
+                std::map<uint32, uint32> L;
+                if (itemTemplate->Class != ITEM_CLASS_WEAPON && TransmogDisplayVendorMgr::AllowMixedArmorTypes)
+                {
+                    for (uint32 i = 0; i < MAX_ITEM_SUBCLASS_ARMOR; ++i)
+                    {
+                        EntryVector** oM = optionMap[MAX_ITEM_SUBCLASS_WEAPON + i][getCorrectInvType(itemTemplate->InventoryType)];
+                        for (uint32 i = 0; i < MAX_ITEM_QUALITY; ++i, ++oM)
+                            if (TransmogDisplayVendorMgr::IsAllowedQuality(i)) // skip not allowed qualities
+                                if (*oM)
+                                    L[i] += (*oM)->size();
+                    }
+                }
+                else if (itemTemplate->Class == ITEM_CLASS_WEAPON && TransmogDisplayVendorMgr::AllowMixedWeaponTypes)
+                {
+                    for (uint32 i = 0; i < MAX_ITEM_SUBCLASS_WEAPON; ++i)
+                    {
+                        EntryVector** oM = optionMap[i][getCorrectInvType(itemTemplate->InventoryType)];
+                        for (uint32 i = 0; i < MAX_ITEM_QUALITY; ++i, ++oM)
+                            if (TransmogDisplayVendorMgr::IsAllowedQuality(i)) // skip not allowed qualities
+                                if (*oM)
+                                    L[i] += (*oM)->size();
+                    }
+                }
+                else
+                {
+                    EntryVector** oM = optionMap[(itemTemplate->Class != ITEM_CLASS_WEAPON ? MAX_ITEM_SUBCLASS_WEAPON : 0) + itemTemplate->SubClass][getCorrectInvType(itemTemplate->InventoryType)];
+                    for (uint32 i = 0; i < MAX_ITEM_QUALITY; ++i, ++oM)
+                        if (TransmogDisplayVendorMgr::IsAllowedQuality(i)) // skip not allowed qualities
+                            if (*oM)
+                                L[i] += (*oM)->size();
+                }
+
+                for (std::map<uint32, uint32>::const_iterator it = L.begin(); it != L.end(); ++it)
+                {
+                    for (uint32 count = 0; count*MAX_VENDOR_ITEMS < it->second; ++count)
+                    {
+                        std::ostringstream ss;
+                        ss << getQualityName(it->first);
+                        if (count)
+                            ss << " [" << count << "]";
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_VENDOR, ss.str().c_str(), it->first, count*MAX_VENDOR_ITEMS);
+                    }
+                }
+
+                if (player->PlayerTalkClass->GetGossipMenu().GetMenuItemCount() <= 1)
+                {
+                    if (const char* slotname = TransmogDisplayVendorMgr::getSlotName(action, player->GetSession()))
+                        session->SendNotification("No transmogrifications available for %s", slotname);
+                    OnGossipHello(player, creature);
+                    return true;
+                }
+
+                SelectionStore::Selection temp = { item->GetEntry(), action, 0, 0 }; // entry, slot, offset, quality
+                selectionStore.SetSelection(player->GetGUID().GetCounter(), temp);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Back..", SENDER_BACK, 0);
+                player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+            } break;
+            case SENDER_BACK: // Back
+            {
+                OnGossipHello(player, creature);
+            } break;
+            case SENDER_REMOVE_ALL: // Remove TransmogDisplayVendorMgrs
+            {
+                bool removed = false;
+                for (uint8 Slot = EQUIPMENT_SLOT_START; Slot < EQUIPMENT_SLOT_END; Slot++)
+                {
+                    if (Item* newItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, Slot))
+                    {
+                        if (!TransmogDisplayVendorMgr::GetFakeEntry(newItem))
+                            continue;
+                        TransmogDisplayVendorMgr::DeleteFakeEntry(player, newItem);
+                        removed = true;
+                    }
+                }
+                if (removed)
+                {
+                    session->SendAreaTriggerMessage("Transmogrifications removed from equipped items");
+                    player->PlayDirectSound(3337);
+                }
+                else
+                {
+                    session->SendNotification("You have no transmogrified items equipped");
+                }
+                OnGossipSelect(player, creature, SENDER_REMOVE_MENU, 0);
+            } break;
+            case SENDER_REMOVE_ONE: // Remove TransmogDisplayVendorMgr from single item
+            {
+                const char* slotname = TransmogDisplayVendorMgr::getSlotName(action, player->GetSession());
+                if (Item* newItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, action))
+                {
+                    if (TransmogDisplayVendorMgr::GetFakeEntry(newItem))
+                    {
+                        TransmogDisplayVendorMgr::DeleteFakeEntry(player, newItem);
+                        if (slotname)
+                            session->SendAreaTriggerMessage("%s transmogrification removed", slotname);
+                        player->PlayDirectSound(3337);
+                    }
+                    else if (slotname)
+                    {
+                        session->SendNotification("No transmogrification on %s slot", slotname);
+                    }
+                }
+                else if (slotname)
+                {
+                    session->SendNotification("No item equipped in %s slot", slotname);
+                }
+                OnGossipSelect(player, creature, SENDER_REMOVE_MENU, 0);
+            } break;
+            case SENDER_REMOVE_MENU:
+            {
+                for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; slot++)
+                {
+                    const char* slotname = TransmogDisplayVendorMgr::getSlotName(slot, player->GetSession());
+                    if (!slotname)
+                        continue;
+                    std::ostringstream ss;
+                    ss << "Remove transmogrification from " << slotname << "?";
+                    player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_INTERACT_1, (std::string)"Remove from " + slotname, SENDER_REMOVE_ONE, slot, ss.str().c_str(), 0, false);
+                }
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_INTERACT_1, "Remove all transmogrifications", SENDER_REMOVE_ALL, 0, "Are you sure you want to remove all transmogrifications?", 0, false);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Back..", SENDER_BACK, 0);
+                player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+            } break;
+            default: // Show items you can use
+            {
+                if (sender >= MAX_ITEM_QUALITY) // sender = quality, action = iterator
+                    return false; // cheat
+
+                SelectionStore::Selection selection;
+                if (!selectionStore.GetSelection(player->GetGUID().GetCounter(), selection))
+                    return false; // cheat
+                if (selection.offset != 0 || selection.quality != 0)
+                    return false; // cheat (something is off)
+
+                selection.offset = action;
+                selection.quality = sender;
+                uint32 slot = selection.slot; // slot
+                selectionStore.SetSelection(player->GetGUID().GetCounter(), selection);
+
+                if (const ItemTemplate* itemTemplate = sObjectMgr->GetItemTemplate(selection.item))
+                {
+                    if (!TransmogDisplayVendorMgr::SuitableForTransmogrification(player, itemTemplate))
+                    {
+                        player->GetSession()->SendNotification("Equipped item is not suitable for transmogrification");
+                        OnGossipSelect(player, creature, SENDER_SELECT_VENDOR, slot);
+                        return true;
+                    }
+
+                    // {{entry}, {entry}, ...}
+                    std::list<uint32> L;
+                    uint32 counter = 0;
+                    bool over = false;
+                    if (itemTemplate->Class != ITEM_CLASS_WEAPON && TransmogDisplayVendorMgr::AllowMixedArmorTypes)
+                    {
+                        for (uint32 i = 0; i < MAX_ITEM_SUBCLASS_ARMOR; ++i)
+                        {
+                            const EntryVector* oM = optionMap[MAX_ITEM_SUBCLASS_WEAPON + i][getCorrectInvType(itemTemplate->InventoryType)][selection.quality];
+                            if (!oM)
+                                continue;
+                            if (!over && counter + oM->size() < selection.offset)
+                            {
+                                counter += oM->size();
+                            }
+                            else
+                            {
+                                over = true;
+                                L.insert(L.end(), oM->begin(), oM->end());
+                            }
+                        }
+                    }
+                    else if (itemTemplate->Class == ITEM_CLASS_WEAPON && TransmogDisplayVendorMgr::AllowMixedWeaponTypes)
+                    {
+                        for (uint32 i = 0; i < MAX_ITEM_SUBCLASS_WEAPON; ++i)
+                        {
+                            const EntryVector* oM = optionMap[i][getCorrectInvType(itemTemplate->InventoryType)][selection.quality];
+                            if (!oM)
+                                continue;
+                            if (!over && counter + oM->size() < selection.offset)
+                                counter += oM->size();
+                            else
+                            {
+                                over = true;
+                                L.insert(L.end(), oM->begin(), oM->end());
+                            }
+                        }
+                    }
+                    else
+                    {
+                        const EntryVector* oM = optionMap[(itemTemplate->Class != ITEM_CLASS_WEAPON ? MAX_ITEM_SUBCLASS_WEAPON : 0) + itemTemplate->SubClass][getCorrectInvType(itemTemplate->InventoryType)][selection.quality];
+                        if (oM)
+                        {
+                            if (!over && counter + oM->size() < selection.offset)
+                            {
+                                counter += oM->size();
+                            }
+                            else
+                            {
+                                over = true;
+                                L.insert(L.end(), oM->begin(), oM->end());
+                            }
+                        }
+                    }
+
+                    // EntryVector oM = optionMap[(itemTemplate->Class != ITEM_CLASS_WEAPON ? MAX_ITEM_SUBCLASS_WEAPON : 0) + itemTemplate->SubClass][getCorrectInvType(itemTemplate->InventoryType)][selection.quality];
+                    uint32 itemCount = L.size() - (selection.offset - counter);
+                    if (itemCount > MAX_VENDOR_ITEMS)
+                        itemCount = MAX_VENDOR_ITEMS;
+
+                    if (!itemCount)
+                    {
+                        session->SendAreaTriggerMessage("No items found");
+                        OnGossipSelect(player, creature, SENDER_SELECT_VENDOR, slot);
+                        return true;
+                    }
+                    player->CLOSE_GOSSIP_MENU();
+
+                    TC_LOG_DEBUG("network", "WORLD: Sent SMSG_LIST_INVENTORY");
+
+                    Creature* vendor = player->GetNPCIfCanInteractWith(creature->GetGUID(), UNIT_NPC_FLAG_VENDOR);
+                    if (!vendor)
+                    {
+                        TC_LOG_DEBUG("network", "WORLD: SendListInventory - Unit (GUID: %u) not found or you can not interact with him.", creature->GetGUID().GetCounter());
+                        player->SendSellError(SELL_ERR_CANT_FIND_VENDOR, NULL, ObjectGuid::Empty, 0);
+                        return true;
+                    }
+
+                    if (player->HasUnitState(UNIT_STATE_DIED))
+                        player->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
+
+                    if (vendor->HasUnitState(UNIT_STATE_MOVING))
+                        vendor->StopMoving();
+
+                    uint8 count = 0;
+
+                    WorldPacket data(SMSG_LIST_INVENTORY, 8 + 1 + itemCount * 8 * 4);
+                    data << uint64(creature->GetGUID());
+
+                    size_t countPos = data.wpos();
+                    data << uint8(count);
+
+                    uint32 item_amount = 0;
+                    std::list<uint32>::const_iterator it = L.begin();
+                    std::advance(it, (selection.offset - counter));
+                    for (; it != L.end() && count < itemCount; ++it, ++count)
+                    {
+                        if (ItemTemplate const* curtemp = sObjectMgr->GetItemTemplate(*it))
+                        {
+                            if (!TransmogDisplayVendorMgr::CanTransmogrifyItemWithItem(player, itemTemplate, curtemp))
+                                continue;
+
+                            data << uint32(count + 1);
+                            data << uint32(curtemp->ItemId);
+                            data << uint32(curtemp->DisplayInfoID);
+                            data << int32(0xFFFFFFFF);
+                            data << uint32(0);
+                            data << uint32(curtemp->MaxDurability);
+                            data << uint32(curtemp->BuyCount);
+                            data << uint32(0);
+                            ++item_amount;
+                        }
+                    }
+
+                    if (!item_amount)
+                    {
+                        session->SendAreaTriggerMessage("No transmogrifications found for equipped item");
+                        OnGossipSelect(player, creature, SENDER_SELECT_VENDOR, slot);
+                        return true;
+                    }
+                    else
+                    {
+                        data.put<uint8>(countPos, item_amount);
+                        session->SendPacket(&data);
+                    }
+                }
+                else
+                {
+                    session->SendNotification("Invalid item equipped");
+                    OnGossipSelect(player, creature, SENDER_SELECT_VENDOR, slot);
+                    return true;
+                }
+            } break;
+        }
+        return true;
+    }
+};
+
+#if !TRANSMOGRIFICATION_ALREADY_INSTALLED
+class Player_Transmogrify : public PlayerScript
+{
+public:
+    Player_Transmogrify() : PlayerScript("Player_Transmogrify") { }
+
+    std::vector<ObjectGuid> GetItemList(const Player* player) const
+    {
+        std::vector<ObjectGuid> itemlist;
+
+        // Copy paste from Player::GetItemByGuid(guid)
+
+        for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+            if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                itemlist.push_back(pItem->GetGUID());
+
+        for (uint8 i = KEYRING_SLOT_START; i < CURRENCYTOKEN_SLOT_END; ++i)
+            if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                itemlist.push_back(pItem->GetGUID());
+
+        for (int i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
+            if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                itemlist.push_back(pItem->GetGUID());
+
+        for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+            if (Bag* pBag = player->GetBagByPos(i))
+                for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
+                    if (Item* pItem = pBag->GetItemByPos(j))
+                        itemlist.push_back(pItem->GetGUID());
+
+        for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
+            if (Bag* pBag = player->GetBagByPos(i))
+                for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
+                    if (Item* pItem = pBag->GetItemByPos(j))
+                        itemlist.push_back(pItem->GetGUID());
+
+        return itemlist;
+    }
+
+    void OnSave(Player* player) override
+    {
+        uint32 lowguid = player->GetGUID().GetCounter();
+        SQLTransaction trans = CharacterDatabase.BeginTransaction();
+        trans->PAppend("DELETE FROM `custom_transmogrification` WHERE `Owner` = %u", lowguid);
+
+        if (!player->transmogMap.empty())
+        {
+            // Only save items that are in inventory / bank / etc
+            std::vector<ObjectGuid> items = GetItemList(player);
+            for (std::vector<ObjectGuid>::const_iterator it = items.begin(); it != items.end(); ++it)
+            {
+                TransmogMapType::const_iterator it2 = player->transmogMap.find(*it);
+                if (it2 == player->transmogMap.end())
+                    continue;
+
+                trans->PAppend("REPLACE INTO custom_transmogrification (GUID, FakeEntry, Owner) VALUES (%u, %u, %u)", it2->first.GetCounter(), it2->second, lowguid);
+            }
+        }
+
+        if (trans->GetSize()) // basically never false
+            CharacterDatabase.CommitTransaction(trans);
+    }
+
+    void OnLogin(Player* player, bool /*firstLogin*/) override
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT GUID, FakeEntry FROM custom_transmogrification WHERE Owner = %u", player->GetGUID().GetCounter());
+
+        if (result)
+        {
+            do
+            {
+                Field* field = result->Fetch();
+                ObjectGuid itemGUID(HighGuid::Item, 0, field[0].GetUInt32());
+                uint32 fakeEntry = field[1].GetUInt32();
+                // Only load items that are in inventory / bank / etc
+                if (sObjectMgr->GetItemTemplate(fakeEntry) && player->GetItemByGuid(itemGUID))
+                {
+                    player->transmogMap[itemGUID] = fakeEntry;
+                }
+                else
+                {
+                    // Ignore, will be erased on next save.
+                    // Additionally this can happen if an item was deleted from DB but still exists for the player
+                    // TC_LOG_ERROR("custom.transmog", "Item entry (Entry: %u, itemGUID: %u, playerGUID: %u) does not exist, ignoring.", fakeEntry, GUID_LOPART(itemGUID), player->GetGUID().GetCounter());
+                    // CharacterDatabase.PExecute("DELETE FROM custom_transmogrification WHERE FakeEntry = %u", fakeEntry);
+                }
+            } while (result->NextRow());
+
+            if (!player->transmogMap.empty())
+            {
+                for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+                {
+                    if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+                    {
+                        player->SetVisibleItemSlot(slot, item);
+                        if (player->IsInWorld())
+                            item->SendUpdateToPlayer(player);
+                    }
+                }
+            }
+        }
+    }
+
+    void OnLogout(Player* player) override
+    {
+        selectionStore.RemoveSelection(player->GetGUID().GetCounter());
+    }
+};
+#endif
+
+class PREP_TransmogDisplayVendor : public WorldScript
+{
+public:
+    PREP_TransmogDisplayVendor() : WorldScript("PREP_TransmogDisplayVendor") { }
+
+    void OnStartup() override
+    {
+        for (size_t i = 0; i < sizeof(AllowedItems) / sizeof(*AllowedItems); ++i)
+            TransmogDisplayVendorMgr::Allowed.insert(AllowedItems[i]);
+        for (size_t i = 0; i < sizeof(NotAllowedItems) / sizeof(*NotAllowedItems); ++i)
+            TransmogDisplayVendorMgr::NotAllowed.insert(NotAllowedItems[i]);
+
+        TC_LOG_INFO("server.loading", "Creating a list of usable transmogrification entries...");
+        // initialize .. for reload in future?
+        for (uint32 i = 0; i < MAX_ITEM_SUBCLASS_WEAPON + MAX_ITEM_SUBCLASS_ARMOR; ++i)
+            for (uint32 j = 0; j < MAX_INVTYPE; ++j)
+                for (uint32 k = 0; k < MAX_ITEM_QUALITY; ++k)
+                    delete optionMap[i][j][k], optionMap[i][j][k] = NULL;
+
+        std::unordered_set<uint32> displays;
+        ItemTemplateContainer const* its = sObjectMgr->GetItemTemplateStore();
+        for (ItemTemplateContainer::const_iterator itr = its->begin(); itr != its->end(); ++itr)
+        {
+            if (itr->second.Class != ITEM_CLASS_WEAPON && itr->second.Class != ITEM_CLASS_ARMOR)
+                continue;
+            if (!TransmogDisplayVendorMgr::SuitableForTransmogrification(NULL, &itr->second))
+                continue;
+            if (displays.find(itr->second.DisplayInfoID) != displays.end()) // skip duplicate item displays
+                continue;
+            EntryVector* oM = optionMap[(itr->second.Class != ITEM_CLASS_WEAPON ? MAX_ITEM_SUBCLASS_WEAPON : 0) + itr->second.SubClass][getCorrectInvType(itr->second.InventoryType)][itr->second.Quality];
+            if (!oM)
+            {
+                oM = new EntryVector();
+                optionMap[(itr->second.Class != ITEM_CLASS_WEAPON ? MAX_ITEM_SUBCLASS_WEAPON : 0) + itr->second.SubClass][getCorrectInvType(itr->second.InventoryType)][itr->second.Quality] = oM;
+            }
+            if (oM->size() < MAX_VENDOR_ITEMS * 3)
+            {
+                oM->push_back(itr->second.ItemId);
+                displays.insert(itr->second.DisplayInfoID);
+            }
+            else
+            {
+                TC_LOG_INFO("server.loading", "Too many items for transmogrification: Class: %u SubClass: %u InventoryType: %u Quality: %u", itr->second.Class, itr->second.SubClass, getCorrectInvType(itr->second.InventoryType), itr->second.Quality);
+            }
+        }
+
+        // resize entry lists
+        for (uint32 i = 0; i < MAX_ITEM_SUBCLASS_WEAPON + MAX_ITEM_SUBCLASS_ARMOR; ++i)
+            for (uint32 j = 0; j < MAX_INVTYPE; ++j)
+                for (uint32 k = 0; k < MAX_ITEM_QUALITY; ++k)
+                    if (optionMap[i][j][k])
+                        optionMap[i][j][k]->resize(optionMap[i][j][k]->size());
+
+#if !TRANSMOGRIFICATION_ALREADY_INSTALLED
+        TC_LOG_INFO("custom.transmog", "Deleting non-existing transmogrification entries...");
+        CharacterDatabase.DirectExecute("DELETE FROM custom_transmogrification WHERE NOT EXISTS (SELECT 1 FROM item_instance WHERE item_instance.guid = custom_transmogrification.GUID)");
+#endif
+    }
+
+    void OnShutdown() override
+    {
+        for (uint32 i = 0; i < MAX_ITEM_SUBCLASS_WEAPON + MAX_ITEM_SUBCLASS_ARMOR; ++i)
+            for (uint32 j = 0; j < MAX_INVTYPE; ++j)
+                for (uint32 k = 0; k < MAX_ITEM_QUALITY; ++k)
+                    delete optionMap[i][j][k], optionMap[i][j][k] = NULL;
+    }
+};
+
+void AddSC_NPC_TransmogDisplayVendor()
+{
+    new NPC_TransmogDisplayVendor();
+    new PREP_TransmogDisplayVendor();
+
+#if !TRANSMOGRIFICATION_ALREADY_INSTALLED
+    new Player_Transmogrify();
+#endif
+}
diff --git a/src/server/scripts/Custom/TransmogDisplayVendorConf.h b/src/server/scripts/Custom/TransmogDisplayVendorConf.h
new file mode 100644
index 0000000..a1e8a99
--- /dev/null
+++ b/src/server/scripts/Custom/TransmogDisplayVendorConf.h
@@ -0,0 +1,93 @@
+#ifndef DEF_TRANSMOGRIFICATION_DISPLAY_H
+#define DEF_TRANSMOGRIFICATION_DISPLAY_H
+
+/*
+Transmogrification display vendor
+Code by Rochet2
+Ideas LilleCarl
+
+ScriptName for NPC:
+NPC_TransmogDisplayVendor
+
+Compatible with Transmogrification 6.1 by Rochet2
+http://rochet2.github.io/Transmogrification
+*/
+
+// use 0 or 1
+#define TRANSMOGRIFICATION_ALREADY_INSTALLED    0
+// Note! If you use both, set this to true (1) and in scriptloader make transmog load first
+
+#include "Define.h"
+#include "ItemPrototype.h"
+#include "SharedDefines.h"
+#include <set>
+
+class Creature;
+class Item;
+class Player;
+class WorldSession;
+struct ItemTemplate;
+
+enum TransmogDisplayVendorSenders
+{
+    SENDER_START = MAX_ITEM_QUALITY,
+    SENDER_BACK,
+    SENDER_SELECT_VENDOR,
+    SENDER_REMOVE_ALL,
+    SENDER_REMOVE_ONE,
+    SENDER_REMOVE_MENU,
+    SENDER_END,
+};
+
+class TransmogDisplayVendorMgr
+{
+public:
+    static const float ScaledCostModifier;
+    static const int32 CopperCost;
+
+    static const bool RequireToken;
+    static const uint32 TokenEntry;
+    static const uint32 TokenAmount;
+
+    static const bool AllowPoor;
+    static const bool AllowCommon;
+    static const bool AllowUncommon;
+    static const bool AllowRare;
+    static const bool AllowEpic;
+    static const bool AllowLegendary;
+    static const bool AllowArtifact;
+    static const bool AllowHeirloom;
+
+    static const bool AllowMixedArmorTypes;
+    static const bool AllowMixedWeaponTypes;
+    static const bool AllowFishingPoles;
+
+    static const bool IgnoreReqRace;
+    static const bool IgnoreReqClass;
+    static const bool IgnoreReqSkill;
+    static const bool IgnoreReqSpell;
+    static const bool IgnoreReqLevel;
+    static const bool IgnoreReqEvent;
+    static const bool IgnoreReqStats;
+
+    static std::set<uint32> Allowed;
+    static std::set<uint32> NotAllowed;
+
+    static void HandleTransmogrify(Player* player, Creature* creature, uint32 vendorslot, uint32 itemEntry, bool no_cost = false);
+
+    // From Transmogrification
+    static uint32 GetFakeEntry(const Item* item);
+    static void DeleteFakeEntry(Player* player, Item* item);
+    static void SetFakeEntry(Player* player, Item* item, uint32 entry);
+    static const char* getSlotName(uint8 slot, WorldSession* session);
+    static void UpdateItem(Player* player, Item* item);
+    static uint32 GetSpecialPrice(ItemTemplate const* proto);
+    static bool CanTransmogrifyItemWithItem(Player* player, ItemTemplate const* target, ItemTemplate const* source);
+    static bool SuitableForTransmogrification(Player* player, ItemTemplate const* proto);
+    static bool IsRangedWeapon(uint32 Class, uint32 SubClass);
+    static bool IsAllowed(uint32 entry);
+    static bool IsNotAllowed(uint32 entry);
+    static bool IsAllowedQuality(uint32 quality);
+};
+
+#endif
diff --git a/src/server/scripts/Custom/Transmogrification.cpp b/src/server/scripts/Custom/Transmogrification.cpp
new file mode 100644
index 0000000..ebe10ac
--- /dev/null
+++ b/src/server/scripts/Custom/Transmogrification.cpp
@@ -0,0 +1,872 @@
+#include "Transmogrification.h"
+#include "Bag.h"
+#include "Common.h"
+#include "Config.h"
+#include "DatabaseEnv.h"
+#include "DBCStructure.h"
+#include "Define.h"
+#include "Field.h"
+#include "GameEventMgr.h"
+#include "Item.h"
+#include "ItemPrototype.h"
+#include "Language.h"
+#include "Log.h"
+#include "ObjectGuid.h"
+#include "ObjectMgr.h"
+#include "Player.h"
+#include "QueryResult.h"
+#include "ScriptMgr.h"
+#include "SharedDefines.h"
+#include "Transaction.h"
+#include "WorldSession.h"
+#include <sstream>
+#include <string>
+
+#ifdef PRESETS
+void Transmogrification::PresetTransmog(Player* player, Item* itemTransmogrified, uint32 fakeEntry, uint8 slot)
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::PresetTransmog");
+
+    if (!EnableSets)
+        return;
+    if (!player || !itemTransmogrified)
+        return;
+    if (slot >= EQUIPMENT_SLOT_END)
+        return;
+    if (!CanTransmogrifyItemWithItem(player, itemTransmogrified->GetTemplate(), sObjectMgr->GetItemTemplate(fakeEntry)))
+        return;
+
+    SetFakeEntry(player, itemTransmogrified, fakeEntry);
+
+    itemTransmogrified->UpdatePlayedTime(player);
+
+    itemTransmogrified->SetOwnerGUID(player->GetGUID());
+    itemTransmogrified->SetNotRefundable(player);
+    itemTransmogrified->ClearSoulboundTradeable(player);
+}
+
+void Transmogrification::LoadPlayerSets(Player* player)
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::LoadPlayerSets");
+
+    player->presetMap.clear();
+
+    QueryResult result = CharacterDatabase.PQuery("SELECT `PresetID`, `SetName`, `SetData` FROM `custom_transmogrification_sets` WHERE Owner = %u", player->GetGUID().GetCounter());
+    if (!result)
+        return;
+
+    do
+    {
+        Field* field = result->Fetch();
+        uint8 PresetID = field[0].GetUInt8();
+        std::string SetName = field[1].GetString();
+        std::istringstream SetData(field[2].GetString());
+
+        player->presetMap[PresetID].name = SetName;
+
+        while (SetData.good())
+        {
+            uint32 slot;
+            uint32 entry;
+            SetData >> slot >> entry;
+            if (SetData.fail())
+                break;
+            if (slot >= EQUIPMENT_SLOT_END)
+            {
+                TC_LOG_ERROR("custom.transmog", "Item entry (FakeEntry: %u, playerGUID: %u, slot: %u, presetId: %u) has invalid slot, ignoring.", entry, player->GetGUID().GetCounter(), uint32(slot), uint32(PresetID));
+                continue;
+            }
+            if (sObjectMgr->GetItemTemplate(entry))
+            {
+                player->presetMap[PresetID].slotMap[slot] = entry;
+            }
+            else
+                TC_LOG_ERROR("custom.transmog", "Item entry (FakeEntry: %u, playerGUID: %u, slot: %u, presetId: %u) does not exist, ignoring.", entry, player->GetGUID().GetCounter(), uint32(slot), uint32(PresetID));
+        }
+
+        if (player->presetMap[PresetID].slotMap.empty())
+        {
+            // Should never happen
+            player->presetMap.erase(PresetID);
+            CharacterDatabase.PExecute("DELETE FROM `custom_transmogrification_sets` WHERE Owner = %u AND PresetID = %u", player->GetGUID().GetCounter(), uint32(PresetID));
+            return;
+        }
+
+    } while (result->NextRow());
+}
+#endif
+
+const char* Transmogrification::GetSlotName(uint8 slot, WorldSession* /*session*/) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::GetSlotName");
+
+    switch (slot)
+    {
+        case EQUIPMENT_SLOT_HEAD: return  "Head";// session->GetTrinityString(LANG_SLOT_NAME_HEAD);
+        case EQUIPMENT_SLOT_SHOULDERS: return  "Shoulders";// session->GetTrinityString(LANG_SLOT_NAME_SHOULDERS);
+        case EQUIPMENT_SLOT_BODY: return  "Shirt";// session->GetTrinityString(LANG_SLOT_NAME_BODY);
+        case EQUIPMENT_SLOT_CHEST: return  "Chest";// session->GetTrinityString(LANG_SLOT_NAME_CHEST);
+        case EQUIPMENT_SLOT_WAIST: return  "Waist";// session->GetTrinityString(LANG_SLOT_NAME_WAIST);
+        case EQUIPMENT_SLOT_LEGS: return  "Legs";// session->GetTrinityString(LANG_SLOT_NAME_LEGS);
+        case EQUIPMENT_SLOT_FEET: return  "Feet";// session->GetTrinityString(LANG_SLOT_NAME_FEET);
+        case EQUIPMENT_SLOT_WRISTS: return  "Wrists";// session->GetTrinityString(LANG_SLOT_NAME_WRISTS);
+        case EQUIPMENT_SLOT_HANDS: return  "Hands";// session->GetTrinityString(LANG_SLOT_NAME_HANDS);
+        case EQUIPMENT_SLOT_BACK: return  "Back";// session->GetTrinityString(LANG_SLOT_NAME_BACK);
+        case EQUIPMENT_SLOT_MAINHAND: return  "Main hand";// session->GetTrinityString(LANG_SLOT_NAME_MAINHAND);
+        case EQUIPMENT_SLOT_OFFHAND: return  "Off hand";// session->GetTrinityString(LANG_SLOT_NAME_OFFHAND);
+        case EQUIPMENT_SLOT_RANGED: return  "Ranged";// session->GetTrinityString(LANG_SLOT_NAME_RANGED);
+        case EQUIPMENT_SLOT_TABARD: return  "Tabard";// session->GetTrinityString(LANG_SLOT_NAME_TABARD);
+        default: return NULL;
+    }
+}
+
+std::string Transmogrification::GetItemIcon(uint32 entry, uint32 width, uint32 height, int x, int y) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::GetItemIcon");
+
+    std::ostringstream ss;
+    ss << "|TInterface";
+    const ItemTemplate* temp = sObjectMgr->GetItemTemplate(entry);
+    const ItemDisplayInfoEntry* dispInfo = NULL;
+    if (temp)
+    {
+        dispInfo = sItemDisplayInfoStore.LookupEntry(temp->DisplayInfoID);
+        if (dispInfo)
+            ss << "/ICONS/" << dispInfo->inventoryIcon;
+    }
+    if (!dispInfo)
+        ss << "/InventoryItems/WoWUnknownItem01";
+    ss << ":" << width << ":" << height << ":" << x << ":" << y << "|t";
+    return ss.str();
+}
+
+std::string Transmogrification::GetSlotIcon(uint8 slot, uint32 width, uint32 height, int x, int y) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::GetSlotIcon");
+
+    std::ostringstream ss;
+    ss << "|TInterface/PaperDoll/";
+    switch (slot)
+    {
+        case EQUIPMENT_SLOT_HEAD: ss << "UI-PaperDoll-Slot-Head"; break;
+        case EQUIPMENT_SLOT_SHOULDERS: ss << "UI-PaperDoll-Slot-Shoulder"; break;
+        case EQUIPMENT_SLOT_BODY: ss << "UI-PaperDoll-Slot-Shirt"; break;
+        case EQUIPMENT_SLOT_CHEST: ss << "UI-PaperDoll-Slot-Chest"; break;
+        case EQUIPMENT_SLOT_WAIST: ss << "UI-PaperDoll-Slot-Waist"; break;
+        case EQUIPMENT_SLOT_LEGS: ss << "UI-PaperDoll-Slot-Legs"; break;
+        case EQUIPMENT_SLOT_FEET: ss << "UI-PaperDoll-Slot-Feet"; break;
+        case EQUIPMENT_SLOT_WRISTS: ss << "UI-PaperDoll-Slot-Wrists"; break;
+        case EQUIPMENT_SLOT_HANDS: ss << "UI-PaperDoll-Slot-Hands"; break;
+        case EQUIPMENT_SLOT_BACK: ss << "UI-PaperDoll-Slot-Chest"; break;
+        case EQUIPMENT_SLOT_MAINHAND: ss << "UI-PaperDoll-Slot-MainHand"; break;
+        case EQUIPMENT_SLOT_OFFHAND: ss << "UI-PaperDoll-Slot-SecondaryHand"; break;
+        case EQUIPMENT_SLOT_RANGED: ss << "UI-PaperDoll-Slot-Ranged"; break;
+        case EQUIPMENT_SLOT_TABARD: ss << "UI-PaperDoll-Slot-Tabard"; break;
+        default: ss << "UI-Backpack-EmptySlot";
+    }
+    ss << ":" << width << ":" << height << ":" << x << ":" << y << "|t";
+    return ss.str();
+}
+
+std::string Transmogrification::GetItemLink(Item* item, WorldSession* session) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::GetItemLink");
+
+    int loc_idx = session->GetSessionDbLocaleIndex();
+    const ItemTemplate* temp = item->GetTemplate();
+    std::string name = temp->Name1;
+    if (ItemLocale const* il = sObjectMgr->GetItemLocale(temp->ItemId))
+        ObjectMgr::GetLocaleString(il->Name, loc_idx, name);
+
+    if (int32 itemRandPropId = item->GetItemRandomPropertyId())
+    {
+        char* const* suffix = NULL;
+        if (itemRandPropId < 0)
+        {
+            const ItemRandomSuffixEntry* itemRandEntry = sItemRandomSuffixStore.LookupEntry(-item->GetItemRandomPropertyId());
+            if (itemRandEntry)
+                suffix = itemRandEntry->nameSuffix;
+        }
+        else
+        {
+            const ItemRandomPropertiesEntry* itemRandEntry = sItemRandomPropertiesStore.LookupEntry(item->GetItemRandomPropertyId());
+            if (itemRandEntry)
+                suffix = itemRandEntry->nameSuffix;
+        }
+        if (suffix)
+        {
+            std::string test(suffix[(name != temp->Name1) ? loc_idx : DEFAULT_LOCALE]);
+            if (!test.empty())
+            {
+                name += ' ';
+                name += test;
+            }
+        }
+    }
+
+    std::ostringstream oss;
+    oss << "|c" << std::hex << ItemQualityColors[temp->Quality] << std::dec <<
+        "|Hitem:" << temp->ItemId << ":" <<
+        item->GetEnchantmentId(PERM_ENCHANTMENT_SLOT) << ":" <<
+        item->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT) << ":" <<
+        item->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT_2) << ":" <<
+        item->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT_3) << ":" <<
+        item->GetEnchantmentId(BONUS_ENCHANTMENT_SLOT) << ":" <<
+        item->GetItemRandomPropertyId() << ":" << item->GetItemSuffixFactor() << ":" <<
+        (uint32)item->GetOwner()->getLevel() << "|h[" << name << "]|h|r";
+
+    return oss.str();
+}
+
+std::string Transmogrification::GetItemLink(uint32 entry, WorldSession* session) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::GetItemLink");
+
+    const ItemTemplate* temp = sObjectMgr->GetItemTemplate(entry);
+    int loc_idx = session->GetSessionDbLocaleIndex();
+    std::string name = temp->Name1;
+    if (ItemLocale const* il = sObjectMgr->GetItemLocale(entry))
+        ObjectMgr::GetLocaleString(il->Name, loc_idx, name);
+
+    std::ostringstream oss;
+    oss << "|c" << std::hex << ItemQualityColors[temp->Quality] << std::dec <<
+        "|Hitem:" << entry << ":0:0:0:0:0:0:0:0:0|h[" << name << "]|h|r";
+
+    return oss.str();
+}
+
+uint32 Transmogrification::GetFakeEntry(const Item* item)
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::GetFakeEntry");
+
+    Player* owner = item->GetOwner();
+
+    if (!owner)
+        return 0;
+    if (owner->transmogMap.empty())
+        return 0;
+
+    TransmogMapType::const_iterator it = owner->transmogMap.find(item->GetGUID());
+    if (it == owner->transmogMap.end())
+        return 0;
+    return it->second;
+}
+
+void Transmogrification::UpdateItem(Player* player, Item* item) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::UpdateItem");
+
+    if (item->IsEquipped())
+    {
+        player->SetVisibleItemSlot(item->GetSlot(), item);
+        if (player->IsInWorld())
+            item->SendUpdateToPlayer(player);
+    }
+}
+
+void Transmogrification::DeleteFakeEntry(Player* player, Item* item)
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::DeleteFakeEntry");
+
+    if (player->transmogMap.erase(item->GetGUID()) != 0)
+        UpdateItem(player, item);
+}
+
+void Transmogrification::SetFakeEntry(Player* player, Item* item, uint32 entry)
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::SetFakeEntry");
+
+    player->transmogMap[item->GetGUID()] = entry;
+    UpdateItem(player, item);
+}
+
+TransmogTrinityStrings Transmogrification::Transmogrify(Player* player, ObjectGuid itemGUID, uint8 slot, bool no_cost)
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::Transmogrify");
+
+    // slot of the transmogrified item
+    if (slot >= EQUIPMENT_SLOT_END)
+    {
+        TC_LOG_DEBUG("custom.transmog", "Transmogrification::Transmogrify - %s (%s) tried to transmogrify an %s with a wrong slot (%u) when transmogrifying items.", player->GetName().c_str(), player->GetGUID().ToString().c_str(), itemGUID.ToString().c_str(), slot);
+        return LANG_ERR_TRANSMOG_INVALID_SLOT;
+    }
+
+    Item* itemTransmogrifier = NULL;
+    // guid of the transmogrifier item, if it's not 0
+    if (!itemGUID.IsEmpty())
+    {
+        itemTransmogrifier = player->GetItemByGuid(itemGUID);
+        if (!itemTransmogrifier)
+        {
+            TC_LOG_DEBUG("custom.transmog", "Transmogrification::Transmogrify - %s (%s) tried to transmogrify with an invalid %s.", player->GetName().c_str(), player->GetGUID().ToString().c_str(), itemGUID.ToString().c_str());
+            return LANG_ERR_TRANSMOG_MISSING_SRC_ITEM;
+        }
+    }
+
+    // transmogrified item
+    Item* itemTransmogrified = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+    if (!itemTransmogrified)
+    {
+        TC_LOG_DEBUG("custom.transmog", "Transmogrification::Transmogrify - %s (%s) tried to transmogrify an invalid item in a valid slot (slot: %u).", player->GetName().c_str(), player->GetGUID().ToString().c_str(), slot);
+        return LANG_ERR_TRANSMOG_MISSING_DEST_ITEM;
+    }
+
+    if (!itemTransmogrifier) // reset look newEntry
+    {
+        DeleteFakeEntry(player, itemTransmogrified);
+    }
+    else
+    {
+        if (!CanTransmogrifyItemWithItem(player, itemTransmogrified->GetTemplate(), itemTransmogrifier->GetTemplate()))
+        {
+            TC_LOG_DEBUG("custom.transmog", "Transmogrification::Transmogrify - %s (%s) failed CanTransmogrifyItemWithItem (%u with %u).", player->GetName().c_str(), player->GetGUID().ToString().c_str(), itemTransmogrified->GetEntry(), itemTransmogrifier->GetEntry());
+            return LANG_ERR_TRANSMOG_INVALID_ITEMS;
+        }
+
+        if (!no_cost)
+        {
+            if (RequireToken)
+            {
+                if (player->HasItemCount(TokenEntry, TokenAmount))
+                    player->DestroyItemCount(TokenEntry, TokenAmount, true);
+                else
+                    return LANG_ERR_TRANSMOG_NOT_ENOUGH_TOKENS;
+            }
+
+            int32 cost = 0;
+            cost = GetSpecialPrice(itemTransmogrified->GetTemplate());
+            cost *= ScaledCostModifier;
+            cost += CopperCost;
+
+            if (cost) // 0 cost if reverting look
+            {
+                if (cost < 0)
+                    TC_LOG_DEBUG("custom.transmog", "Transmogrification::Transmogrify - %s (%s) transmogrification invalid cost (non negative, amount %i). Transmogrified %u with %u", player->GetName().c_str(), player->GetGUID().ToString().c_str(), -cost, itemTransmogrified->GetEntry(), itemTransmogrifier->GetEntry());
+                else
+                {
+                    if (!player->HasEnoughMoney(cost))
+                        return LANG_ERR_TRANSMOG_NOT_ENOUGH_MONEY;
+                    player->ModifyMoney(-cost, false);
+                }
+            }
+        }
+
+        SetFakeEntry(player, itemTransmogrified, itemTransmogrifier->GetEntry());
+
+        itemTransmogrified->UpdatePlayedTime(player);
+
+        itemTransmogrified->SetOwnerGUID(player->GetGUID());
+        itemTransmogrified->SetNotRefundable(player);
+        itemTransmogrified->ClearSoulboundTradeable(player);
+
+        if (itemTransmogrifier->GetTemplate()->Bonding == BIND_WHEN_EQUIPED || itemTransmogrifier->GetTemplate()->Bonding == BIND_WHEN_USE)
+            itemTransmogrifier->SetBinding(true);
+
+        itemTransmogrifier->SetOwnerGUID(player->GetGUID());
+        itemTransmogrifier->SetNotRefundable(player);
+        itemTransmogrifier->ClearSoulboundTradeable(player);
+    }
+
+    return LANG_ERR_TRANSMOG_OK;
+}
+
+bool Transmogrification::CanTransmogrifyItemWithItem(Player* player, ItemTemplate const* target, ItemTemplate const* source) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::CanTransmogrifyItemWithItem");
+
+    if (!target || !source)
+        return false;
+
+    if (source->ItemId == target->ItemId)
+        return false;
+
+    if (source->DisplayInfoID == target->DisplayInfoID)
+        return false;
+
+    if (source->Class != target->Class)
+        return false;
+
+    if (source->InventoryType == INVTYPE_BAG ||
+        source->InventoryType == INVTYPE_RELIC ||
+        // source->InventoryType == INVTYPE_BODY ||
+        source->InventoryType == INVTYPE_FINGER ||
+        source->InventoryType == INVTYPE_TRINKET ||
+        source->InventoryType == INVTYPE_AMMO ||
+        source->InventoryType == INVTYPE_QUIVER)
+        return false;
+
+    if (target->InventoryType == INVTYPE_BAG ||
+        target->InventoryType == INVTYPE_RELIC ||
+        // target->InventoryType == INVTYPE_BODY ||
+        target->InventoryType == INVTYPE_FINGER ||
+        target->InventoryType == INVTYPE_TRINKET ||
+        target->InventoryType == INVTYPE_AMMO ||
+        target->InventoryType == INVTYPE_QUIVER)
+        return false;
+
+    if (!SuitableForTransmogrification(player, target) || !SuitableForTransmogrification(player, source)) // if (!transmogrified->CanTransmogrify() || !transmogrifier->CanBeTransmogrified())
+        return false;
+
+    if (IsRangedWeapon(source->Class, source->SubClass) != IsRangedWeapon(target->Class, target->SubClass))
+        return false;
+
+    if (source->SubClass != target->SubClass && !IsRangedWeapon(target->Class, target->SubClass))
+    {
+        if (source->Class == ITEM_CLASS_ARMOR && !AllowMixedArmorTypes)
+            return false;
+        if (source->Class == ITEM_CLASS_WEAPON && !AllowMixedWeaponTypes)
+            return false;
+    }
+
+    if (source->InventoryType != target->InventoryType)
+    {
+        if (source->Class == ITEM_CLASS_WEAPON && !((IsRangedWeapon(target->Class, target->SubClass) ||
+            ((target->InventoryType == INVTYPE_WEAPON || target->InventoryType == INVTYPE_2HWEAPON) &&
+                (source->InventoryType == INVTYPE_WEAPON || source->InventoryType == INVTYPE_2HWEAPON)) ||
+            ((target->InventoryType == INVTYPE_WEAPONMAINHAND || target->InventoryType == INVTYPE_WEAPONOFFHAND) &&
+                (source->InventoryType == INVTYPE_WEAPON || source->InventoryType == INVTYPE_2HWEAPON)))))
+            return false;
+        if (source->Class == ITEM_CLASS_ARMOR &&
+            !((source->InventoryType == INVTYPE_CHEST || source->InventoryType == INVTYPE_ROBE) &&
+                (target->InventoryType == INVTYPE_CHEST || target->InventoryType == INVTYPE_ROBE)))
+            return false;
+    }
+
+    return true;
+}
+
+bool Transmogrification::SuitableForTransmogrification(Player* player, ItemTemplate const* proto) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::SuitableForTransmogrification");
+
+    // ItemTemplate const* proto = item->GetTemplate();
+    if (!player || !proto)
+        return false;
+
+    if (proto->Class != ITEM_CLASS_ARMOR &&
+        proto->Class != ITEM_CLASS_WEAPON)
+        return false;
+
+    // Skip all checks for allowed items
+    if (IsAllowed(proto->ItemId))
+        return true;
+
+    if (IsNotAllowed(proto->ItemId))
+        return false;
+
+    if (!AllowFishingPoles && proto->Class == ITEM_CLASS_WEAPON && proto->SubClass == ITEM_SUBCLASS_WEAPON_FISHING_POLE)
+        return false;
+
+    if (!IsAllowedQuality(proto->Quality)) // (proto->Quality == ITEM_QUALITY_LEGENDARY)
+        return false;
+
+    if ((proto->Flags2 & ITEM_FLAGS_EXTRA_HORDE_ONLY) && player->GetTeam() != HORDE)
+        return false;
+
+    if ((proto->Flags2 & ITEM_FLAGS_EXTRA_ALLIANCE_ONLY) && player->GetTeam() != ALLIANCE)
+        return false;
+
+    if (!IgnoreReqClass && (proto->AllowableClass & player->getClassMask()) == 0)
+        return false;
+
+    if (!IgnoreReqRace && (proto->AllowableRace & player->getRaceMask()) == 0)
+        return false;
+
+    if (!IgnoreReqSkill && proto->RequiredSkill != 0)
+    {
+        if (player->GetSkillValue(proto->RequiredSkill) == 0)
+            return false;
+        else if (player->GetSkillValue(proto->RequiredSkill) < proto->RequiredSkillRank)
+            return false;
+    }
+
+    if (!IgnoreReqSpell && proto->RequiredSpell != 0 && !player->HasSpell(proto->RequiredSpell))
+        return false;
+
+    if (!IgnoreReqLevel && player->getLevel() < proto->RequiredLevel)
+        return false;
+
+    // If World Event is not active, prevent using event dependant items
+    if (!IgnoreReqEvent && proto->HolidayId && !IsHolidayActive((HolidayIds)proto->HolidayId))
+        return false;
+
+    if (!IgnoreReqStats)
+    {
+        if (!proto->RandomProperty && !proto->RandomSuffix)
+        {
+            bool found = false;
+            for (uint8 i = 0; i < proto->StatsCount; ++i)
+            {
+                if (proto->ItemStat[i].ItemStatValue != 0)
+                {
+                    found = true;
+                    break;
+                }
+            }
+            if (!found)
+                return false;
+        }
+    }
+
+    return true;
+}
+
+/*
+bool Transmogrification::CanTransmogrify(Item const* item)
+{
+ItemTemplate const* proto = item->GetTemplate();
+
+if (!proto)
+return false;
+
+if (proto->Flags2 & ITEM_FLAGS_EXTRA_CANNOT_TRANSMOG)
+return false;
+
+if (proto->Quality == ITEM_QUALITY_LEGENDARY)
+return false;
+
+if (proto->Class != ITEM_CLASS_ARMOR &&
+proto->Class != ITEM_CLASS_WEAPON)
+return false;
+
+if (proto->Class == ITEM_CLASS_WEAPON && proto->SubClass == ITEM_SUBCLASS_WEAPON_FISHING_POLE)
+return false;
+
+if (proto->Flags2 & ITEM_FLAGS_EXTRA_CAN_TRANSMOG)
+return true;
+
+if (item->GetItemRandomPropertyId() == 0)
+return false;
+
+for (uint8 i = 0; i < MAX_ITEM_PROTO_STATS; ++i)
+if (proto->ItemStat[i].ItemStatValue != 0)
+return true;
+
+return false;
+}
+bool Transmogrification::CanBeTransmogrified(Item const* item)
+{
+ItemTemplate const* proto = item->GetTemplate();
+
+if (!proto)
+return false;
+
+if (proto->Quality == ITEM_QUALITY_LEGENDARY)
+return false;
+
+if (proto->Class != ITEM_CLASS_ARMOR &&
+proto->Class != ITEM_CLASS_WEAPON)
+return false;
+
+if (proto->Class == ITEM_CLASS_WEAPON && proto->SubClass == ITEM_SUBCLASS_WEAPON_FISHING_POLE)
+return false;
+
+if (proto->Flags2 & ITEM_FLAGS_EXTRA_CANNOT_BE_TRANSMOG)
+return false;
+
+if (item->GetItemRandomPropertyId() == 0)
+return false;
+
+for (uint8 i = 0; i < MAX_ITEM_PROTO_STATS; ++i)
+if (proto->ItemStat[i].ItemStatValue != 0)
+return true;
+
+return false;
+}
+*/
+
+uint32 Transmogrification::GetSpecialPrice(ItemTemplate const* proto) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::GetSpecialPrice");
+
+    uint32 cost = proto->SellPrice < 10000 ? 10000 : proto->SellPrice;
+    return cost;
+}
+
+bool Transmogrification::IsRangedWeapon(uint32 Class, uint32 SubClass) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::IsRangedWeapon");
+
+    return Class == ITEM_CLASS_WEAPON && (
+        SubClass == ITEM_SUBCLASS_WEAPON_BOW ||
+        SubClass == ITEM_SUBCLASS_WEAPON_GUN ||
+        SubClass == ITEM_SUBCLASS_WEAPON_CROSSBOW);
+}
+
+bool Transmogrification::IsAllowed(uint32 entry) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::IsAllowed");
+
+    return Allowed.find(entry) != Allowed.end();
+}
+
+bool Transmogrification::IsNotAllowed(uint32 entry) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::IsNotAllowed");
+
+    return NotAllowed.find(entry) != NotAllowed.end();
+}
+
+bool Transmogrification::IsAllowedQuality(uint32 quality) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::IsAllowedQuality");
+
+    switch (quality)
+    {
+        case ITEM_QUALITY_POOR: return AllowPoor;
+        case ITEM_QUALITY_NORMAL: return AllowCommon;
+        case ITEM_QUALITY_UNCOMMON: return AllowUncommon;
+        case ITEM_QUALITY_RARE: return AllowRare;
+        case ITEM_QUALITY_EPIC: return AllowEpic;
+        case ITEM_QUALITY_LEGENDARY: return AllowLegendary;
+        case ITEM_QUALITY_ARTIFACT: return AllowArtifact;
+        case ITEM_QUALITY_HEIRLOOM: return AllowHeirloom;
+        default: return false;
+    }
+}
+
+void Transmogrification::LoadConfig(bool reload)
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::LoadConfig");
+
+#ifdef PRESETS
+    EnableSetInfo = sConfigMgr->GetBoolDefault("Transmogrification.EnableSetInfo", true);
+    SetNpcText = uint32(sConfigMgr->GetIntDefault("Transmogrification.SetNpcText", 50001));
+
+    EnableSets = sConfigMgr->GetBoolDefault("Transmogrification.EnableSets", true);
+    MaxSets = (uint8)sConfigMgr->GetIntDefault("Transmogrification.MaxSets", 10);
+    SetCostModifier = sConfigMgr->GetFloatDefault("Transmogrification.SetCostModifier", 3.0f);
+    SetCopperCost = sConfigMgr->GetIntDefault("Transmogrification.SetCopperCost", 0);
+
+    if (MaxSets > MAX_OPTIONS)
+        MaxSets = MAX_OPTIONS;
+
+    if (reload) // dont store presets for nothing
+    {
+        // this should be thread safe as long as LoadConfig is triggered on thread safe env
+        SessionMap const& sessions = sWorld->GetAllSessions();
+        for (SessionMap::const_iterator it = sessions.begin(); it != sessions.end(); ++it)
+        {
+            if (Player* player = it->second->GetPlayer())
+            {
+                // skipping session check
+                if (EnableSets)
+                    LoadPlayerSets(player);
+            }
+        }
+    }
+#endif
+
+    EnableTransmogInfo = sConfigMgr->GetBoolDefault("Transmogrification.EnableTransmogInfo", true);
+    TransmogNpcText = uint32(sConfigMgr->GetIntDefault("Transmogrification.TransmogNpcText", 50000));
+
+    std::istringstream issAllowed(sConfigMgr->GetStringDefault("Transmogrification.Allowed", ""));
+    std::istringstream issNotAllowed(sConfigMgr->GetStringDefault("Transmogrification.NotAllowed", ""));
+    while (issAllowed.good())
+    {
+        uint32 entry;
+        issAllowed >> entry;
+        if (issAllowed.fail())
+            break;
+        Allowed.insert(entry);
+    }
+    while (issNotAllowed.good())
+    {
+        uint32 entry;
+        issNotAllowed >> entry;
+        if (issNotAllowed.fail())
+            break;
+        NotAllowed.insert(entry);
+    }
+
+    ScaledCostModifier = sConfigMgr->GetFloatDefault("Transmogrification.ScaledCostModifier", 1.0f);
+    CopperCost = sConfigMgr->GetIntDefault("Transmogrification.CopperCost", 0);
+
+    RequireToken = sConfigMgr->GetBoolDefault("Transmogrification.RequireToken", false);
+    TokenEntry = uint32(sConfigMgr->GetIntDefault("Transmogrification.TokenEntry", 49426));
+    TokenAmount = uint32(sConfigMgr->GetIntDefault("Transmogrification.TokenAmount", 1));
+
+    AllowPoor = sConfigMgr->GetBoolDefault("Transmogrification.AllowPoor", false);
+    AllowCommon = sConfigMgr->GetBoolDefault("Transmogrification.AllowCommon", false);
+    AllowUncommon = sConfigMgr->GetBoolDefault("Transmogrification.AllowUncommon", true);
+    AllowRare = sConfigMgr->GetBoolDefault("Transmogrification.AllowRare", true);
+    AllowEpic = sConfigMgr->GetBoolDefault("Transmogrification.AllowEpic", true);
+    AllowLegendary = sConfigMgr->GetBoolDefault("Transmogrification.AllowLegendary", false);
+    AllowArtifact = sConfigMgr->GetBoolDefault("Transmogrification.AllowArtifact", false);
+    AllowHeirloom = sConfigMgr->GetBoolDefault("Transmogrification.AllowHeirloom", true);
+
+    AllowMixedArmorTypes = sConfigMgr->GetBoolDefault("Transmogrification.AllowMixedArmorTypes", false);
+    AllowMixedWeaponTypes = sConfigMgr->GetBoolDefault("Transmogrification.AllowMixedWeaponTypes", false);
+    AllowFishingPoles = sConfigMgr->GetBoolDefault("Transmogrification.AllowFishingPoles", false);
+
+    IgnoreReqRace = sConfigMgr->GetBoolDefault("Transmogrification.IgnoreReqRace", false);
+    IgnoreReqClass = sConfigMgr->GetBoolDefault("Transmogrification.IgnoreReqClass", false);
+    IgnoreReqSkill = sConfigMgr->GetBoolDefault("Transmogrification.IgnoreReqSkill", false);
+    IgnoreReqSpell = sConfigMgr->GetBoolDefault("Transmogrification.IgnoreReqSpell", false);
+    IgnoreReqLevel = sConfigMgr->GetBoolDefault("Transmogrification.IgnoreReqLevel", false);
+    IgnoreReqEvent = sConfigMgr->GetBoolDefault("Transmogrification.IgnoreReqEvent", false);
+    IgnoreReqStats = sConfigMgr->GetBoolDefault("Transmogrification.IgnoreReqStats", false);
+
+    if (!sObjectMgr->GetItemTemplate(TokenEntry))
+    {
+        TC_LOG_INFO("custom.transmog", "Transmogrification.TokenEntry (%u) does not exist. Using default (%u).", TokenEntry, 49426);
+        TokenEntry = 49426;
+    }
+}
+
+std::vector<ObjectGuid> Transmogrification::GetItemList(const Player* player) const
+{
+    std::vector<ObjectGuid> itemlist;
+
+    // Copy paste from Player::GetItemByGuid(guid)
+
+    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            itemlist.push_back(pItem->GetGUID());
+
+    for (uint8 i = KEYRING_SLOT_START; i < CURRENCYTOKEN_SLOT_END; ++i)
+        if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            itemlist.push_back(pItem->GetGUID());
+
+    for (int i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
+        if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            itemlist.push_back(pItem->GetGUID());
+
+    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+        if (Bag* pBag = player->GetBagByPos(i))
+            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
+                if (Item* pItem = pBag->GetItemByPos(j))
+                    itemlist.push_back(pItem->GetGUID());
+
+    for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
+        if (Bag* pBag = player->GetBagByPos(i))
+            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
+                if (Item* pItem = pBag->GetItemByPos(j))
+                    itemlist.push_back(pItem->GetGUID());
+
+    return itemlist;
+}
+
+namespace
+{
+    class PS_Transmogrification : public PlayerScript
+    {
+    public:
+        PS_Transmogrification() : PlayerScript("PS_Transmogrification") { }
+
+        void OnSave(Player* player) override
+        {
+            uint32 lowguid = player->GetGUID().GetCounter();
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            trans->PAppend("DELETE FROM `custom_transmogrification` WHERE `Owner` = %u", lowguid);
+#ifdef PRESETS
+            trans->PAppend("DELETE FROM `custom_transmogrification_sets` WHERE `Owner` = %u", lowguid);
+#endif
+
+            if (!player->transmogMap.empty())
+            {
+                // Only save items that are in inventory / bank / etc
+                std::vector<ObjectGuid> items = sTransmogrification->GetItemList(player);
+                for (std::vector<ObjectGuid>::const_iterator it = items.begin(); it != items.end(); ++it)
+                {
+                    TransmogMapType::const_iterator it2 = player->transmogMap.find(*it);
+                    if (it2 == player->transmogMap.end())
+                        continue;
+
+                    trans->PAppend("REPLACE INTO custom_transmogrification (GUID, FakeEntry, Owner) VALUES (%u, %u, %u)", it2->first.GetCounter(), it2->second, lowguid);
+                }
+            }
+
+#ifdef PRESETS
+            if (!player->presetMap.empty())
+            {
+                for (PresetMapType::const_iterator it = player->presetMap.begin(); it != player->presetMap.end(); ++it)
+                {
+                    std::ostringstream ss;
+                    for (PresetslotMapType::const_iterator it2 = it->second.slotMap.begin(); it2 != it->second.slotMap.end(); ++it2)
+                        ss << uint32(it2->first) << ' ' << it2->second << ' ';
+                    trans->PAppend("REPLACE INTO `custom_transmogrification_sets` (`Owner`, `PresetID`, `SetName`, `SetData`) VALUES (%u, %u, \"%s\", \"%s\")", lowguid, uint32(it->first), it->second.name.c_str(), ss.str().c_str());
+                }
+            }
+#endif
+
+            if (trans->GetSize()) // basically never false
+                CharacterDatabase.CommitTransaction(trans);
+        }
+
+        void OnLogin(Player* player, bool /*firstLogin*/) override
+        {
+            QueryResult result = CharacterDatabase.PQuery("SELECT GUID, FakeEntry FROM custom_transmogrification WHERE Owner = %u", player->GetGUID().GetCounter());
+
+            if (result)
+            {
+                do
+                {
+                    Field* field = result->Fetch();
+                    ObjectGuid itemGUID(HighGuid::Item, 0, field[0].GetUInt32());
+                    uint32 fakeEntry = field[1].GetUInt32();
+                    // Only load items that are in inventory / bank / etc
+                    if (sObjectMgr->GetItemTemplate(fakeEntry) && player->GetItemByGuid(itemGUID))
+                    {
+                        player->transmogMap[itemGUID] = fakeEntry;
+                    }
+                    else
+                    {
+                        // Ignore, will be erased on next save.
+                        // Additionally this can happen if an item was deleted from DB but still exists for the player
+                        // TC_LOG_ERROR("custom.transmog", "Item entry (Entry: %u, itemGUID: %u, playerGUID: %u) does not exist, ignoring.", fakeEntry, GUID_LOPART(itemGUID), player->GetGUID().GetCounter());
+                        // CharacterDatabase.PExecute("DELETE FROM custom_transmogrification WHERE FakeEntry = %u", fakeEntry);
+                    }
+                } while (result->NextRow());
+
+                if (!player->transmogMap.empty())
+                {
+                    for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+                    {
+                        if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+                        {
+                            player->SetVisibleItemSlot(slot, item);
+                            if (player->IsInWorld())
+                                item->SendUpdateToPlayer(player);
+                        }
+                    }
+                }
+            }
+
+#ifdef PRESETS
+            if (sTransmogrification->EnableSets)
+                sTransmogrification->LoadPlayerSets(player);
+#endif
+        }
+    };
+
+    class WS_Transmogrification : public WorldScript
+    {
+    public:
+        WS_Transmogrification() : WorldScript("WS_Transmogrification") { }
+
+        void OnConfigLoad(bool reload) override
+        {
+            sTransmogrification->LoadConfig(reload);
+        }
+
+        void OnStartup() override
+        {
+            TC_LOG_INFO("custom.transmog", "Deleting non-existing transmogrification entries...");
+            CharacterDatabase.DirectExecute("DELETE FROM custom_transmogrification WHERE NOT EXISTS (SELECT 1 FROM item_instance WHERE item_instance.guid = custom_transmogrification.GUID)");
+
+#ifdef PRESETS
+            // Clean even if disabled
+            // Dont delete even if player has more presets than should
+            CharacterDatabase.DirectExecute("DELETE FROM `custom_transmogrification_sets` WHERE NOT EXISTS(SELECT 1 FROM characters WHERE characters.guid = custom_transmogrification_sets.Owner)");
+#endif
+            sTransmogrification->LoadConfig(false);
+        }
+    };
+}
+
+void AddSC_PWS_Transmogrification()
+{
+    new WS_Transmogrification();
+    new PS_Transmogrification();
+}
diff --git a/src/server/scripts/Custom/Transmogrification.h b/src/server/scripts/Custom/Transmogrification.h
new file mode 100644
index 0000000..739bb11
--- /dev/null
+++ b/src/server/scripts/Custom/Transmogrification.h
@@ -0,0 +1,129 @@
+#ifndef DEF_TRANSMOGRIFICATION_H
+#define DEF_TRANSMOGRIFICATION_H
+
+#include <vector>
+#include "Define.h"
+#include "ObjectGuid.h"
+
+#define PRESETS // comment this line to disable preset feature totally
+#define MAX_OPTIONS 25 // do not alter
+
+class Item;
+class Player;
+class WorldSession;
+struct ItemTemplate;
+
+enum TransmogTrinityStrings // Language.h might have same entries, appears when executing SQL, change if needed
+{
+    LANG_ERR_TRANSMOG_OK = 11100, // change this
+    LANG_ERR_TRANSMOG_INVALID_SLOT,
+    LANG_ERR_TRANSMOG_INVALID_SRC_ENTRY,
+    LANG_ERR_TRANSMOG_MISSING_SRC_ITEM,
+    LANG_ERR_TRANSMOG_MISSING_DEST_ITEM,
+    LANG_ERR_TRANSMOG_INVALID_ITEMS,
+    LANG_ERR_TRANSMOG_NOT_ENOUGH_MONEY,
+    LANG_ERR_TRANSMOG_NOT_ENOUGH_TOKENS,
+
+    LANG_ERR_UNTRANSMOG_OK,
+    LANG_ERR_UNTRANSMOG_NO_TRANSMOGS,
+
+#ifdef PRESETS
+    LANG_PRESET_ERR_INVALID_NAME,
+#endif
+};
+
+class Transmogrification
+{
+private:
+    Transmogrification() { };
+    ~Transmogrification() { };
+    Transmogrification(const Transmogrification&);
+    Transmogrification& operator=(const Transmogrification&);
+
+public:
+    static Transmogrification* instance()
+    {
+        // Thread safe in C++11 standard
+        static Transmogrification instance;
+        return &instance;
+    }
+
+#ifdef PRESETS
+
+    bool EnableSetInfo;
+    uint32 SetNpcText;
+
+    bool EnableSets;
+    uint8 MaxSets;
+    float SetCostModifier;
+    int32 SetCopperCost;
+
+    void LoadPlayerSets(Player* player);
+
+    void PresetTransmog(Player* player, Item* itemTransmogrified, uint32 fakeEntry, uint8 slot);
+#endif
+
+    bool EnableTransmogInfo;
+    uint32 TransmogNpcText;
+
+    // Use IsAllowed() and IsNotAllowed()
+    // these are thread unsafe, but assumed to be static data so it should be safe
+    std::set<uint32> Allowed;
+    std::set<uint32> NotAllowed;
+
+    float ScaledCostModifier;
+    int32 CopperCost;
+
+    bool RequireToken;
+    uint32 TokenEntry;
+    uint32 TokenAmount;
+
+    bool AllowPoor;
+    bool AllowCommon;
+    bool AllowUncommon;
+    bool AllowRare;
+    bool AllowEpic;
+    bool AllowLegendary;
+    bool AllowArtifact;
+    bool AllowHeirloom;
+
+    bool AllowMixedArmorTypes;
+    bool AllowMixedWeaponTypes;
+    bool AllowFishingPoles;
+
+    bool IgnoreReqRace;
+    bool IgnoreReqClass;
+    bool IgnoreReqSkill;
+    bool IgnoreReqSpell;
+    bool IgnoreReqLevel;
+    bool IgnoreReqEvent;
+    bool IgnoreReqStats;
+
+    bool IsAllowed(uint32 entry) const;
+    bool IsNotAllowed(uint32 entry) const;
+    bool IsAllowedQuality(uint32 quality) const;
+    bool IsRangedWeapon(uint32 Class, uint32 SubClass) const;
+
+    void LoadConfig(bool reload); // thread unsafe
+
+    std::string GetItemIcon(uint32 entry, uint32 width, uint32 height, int x, int y) const;
+    std::string GetSlotIcon(uint8 slot, uint32 width, uint32 height, int x, int y) const;
+    const char * GetSlotName(uint8 slot, WorldSession* session) const;
+    std::string GetItemLink(Item* item, WorldSession* session) const;
+    std::string GetItemLink(uint32 entry, WorldSession* session) const;
+    uint32 GetFakeEntry(const Item* item);
+    void UpdateItem(Player* player, Item* item) const;
+    void DeleteFakeEntry(Player* player, Item* item);
+    void SetFakeEntry(Player* player, Item* item, uint32 entry);
+
+    TransmogTrinityStrings Transmogrify(Player* player, ObjectGuid itemGUID, uint8 slot, bool no_cost = false);
+    bool CanTransmogrifyItemWithItem(Player* player, ItemTemplate const* destination, ItemTemplate const* source) const;
+    bool SuitableForTransmogrification(Player* player, ItemTemplate const* proto) const;
+    // bool CanBeTransmogrified(Item const* item);
+    // bool CanTransmogrify(Item const* item);
+    uint32 GetSpecialPrice(ItemTemplate const* proto) const;
+    std::vector<ObjectGuid> GetItemList(const Player* player) const;
+};
+#define sTransmogrification Transmogrification::instance()
+
+#endif
diff --git a/src/server/scripts/Custom/Transmogrifier.cpp b/src/server/scripts/Custom/Transmogrifier.cpp
new file mode 100644
index 0000000..dedc81d
--- /dev/null
+++ b/src/server/scripts/Custom/Transmogrifier.cpp
@@ -0,0 +1,421 @@
+/*
+6.1
+Transmogrification 3.3.5a - Gossip menu
+By Rochet2
+
+ScriptName for NPC:
+Creature_Transmogrify
+
+TODO:
+Fix the cost formula
+-- Too much data handling, use default costs
+
+Cant transmogrify rediculus items // Foereaper: would be fun to stab people with a fish
+-- Cant think of any good way to handle this easily, could rip flagged items from cata DB
+*/
+
+#include "Transmogrification.h"
+#include "Bag.h"
+#include "Common.h"
+#include "Config.h"
+#include "Creature.h"
+#include "DatabaseEnv.h"
+#include "DBCStructure.h"
+#include "Define.h"
+#include "Field.h"
+#include "GameEventMgr.h"
+#include "GossipDef.h"
+#include "Item.h"
+#include "ItemPrototype.h"
+#include "Language.h"
+#include "Log.h"
+#include "Player.h"
+#include "ObjectGuid.h"
+#include "ObjectMgr.h"
+#include "QueryResult.h"
+#include "ScriptedGossip.h"
+#include "ScriptMgr.h"
+#include "SharedDefines.h"
+#include "Transaction.h"
+#include "WorldSession.h"
+#include <sstream>
+#include <string>
+
+#define GTS session->GetTrinityString
+
+namespace
+{
+    class CS_Transmogrification : public CreatureScript
+    {
+    public:
+        CS_Transmogrification() : CreatureScript("Creature_Transmogrify") { }
+
+        bool OnGossipHello(Player* player, Creature* creature) override
+        {
+            WorldSession* session = player->GetSession();
+            if (sTransmogrification->EnableTransmogInfo)
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/INV_Misc_Book_11:30:30:-18:0|tHow transmogrification works", EQUIPMENT_SLOT_END + 9, 0);
+            for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+            {
+                if (const char* slotName = sTransmogrification->GetSlotName(slot, session))
+                {
+                    Item* newItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+                    uint32 entry = newItem ? sTransmogrification->GetFakeEntry(newItem) : 0;
+                    std::string icon = entry ? sTransmogrification->GetItemIcon(entry, 30, 30, -18, 0) : sTransmogrification->GetSlotIcon(slot, 30, 30, -18, 0);
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, icon + std::string(slotName), EQUIPMENT_SLOT_END, slot);
+                }
+            }
+#ifdef PRESETS
+            if (sTransmogrification->EnableSets)
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/RAIDFRAME/UI-RAIDFRAME-MAINASSIST:30:30:-18:0|tManage sets", EQUIPMENT_SLOT_END + 4, 0);
+#endif
+            player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/INV_Enchant_Disenchant:30:30:-18:0|tRemove all transmogrifications", EQUIPMENT_SLOT_END + 2, 0, "Remove transmogrifications from all equipped items?", 0, false);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/PaperDollInfoFrame/UI-GearManager-Undo:30:30:-18:0|tUpdate menu", EQUIPMENT_SLOT_END + 1, 0);
+            player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+            return true;
+        }
+
+        bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action) override
+        {
+            player->PlayerTalkClass->ClearMenus();
+            WorldSession* session = player->GetSession();
+            switch (sender)
+            {
+                case EQUIPMENT_SLOT_END: // Show items you can use
+                    ShowTransmogItems(player, creature, action);
+                    break;
+                case EQUIPMENT_SLOT_END + 1: // Main menu
+                    OnGossipHello(player, creature);
+                    break;
+                case EQUIPMENT_SLOT_END + 2: // Remove Transmogrifications
+                {
+                    bool removed = false;
+                    for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+                    {
+                        if (Item* newItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+                        {
+                            if (!sTransmogrification->GetFakeEntry(newItem))
+                                continue;
+                            sTransmogrification->DeleteFakeEntry(player, newItem);
+                            removed = true;
+                        }
+                    }
+                    if (removed)
+                        session->SendAreaTriggerMessage("%s", GTS(LANG_ERR_UNTRANSMOG_OK));
+                    else
+                        session->SendNotification(LANG_ERR_UNTRANSMOG_NO_TRANSMOGS);
+                    OnGossipHello(player, creature);
+                } break;
+                case EQUIPMENT_SLOT_END + 3: // Remove Transmogrification from single item
+                {
+                    if (Item* newItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, action))
+                    {
+                        if (sTransmogrification->GetFakeEntry(newItem))
+                        {
+                            sTransmogrification->DeleteFakeEntry(player, newItem);
+                            session->SendAreaTriggerMessage("%s", GTS(LANG_ERR_UNTRANSMOG_OK));
+                        }
+                        else
+                            session->SendNotification(LANG_ERR_UNTRANSMOG_NO_TRANSMOGS);
+                    }
+                    OnGossipSelect(player, creature, EQUIPMENT_SLOT_END, action);
+                } break;
+#ifdef PRESETS
+                case EQUIPMENT_SLOT_END + 4: // Presets menu
+                {
+                    if (!sTransmogrification->EnableSets)
+                    {
+                        OnGossipHello(player, creature);
+                        return true;
+                    }
+                    if (sTransmogrification->EnableSetInfo)
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/INV_Misc_Book_11:30:30:-18:0|tHow sets work", EQUIPMENT_SLOT_END + 10, 0);
+
+                    if (!player->presetMap.empty())
+                    {
+                        for (PresetMapType::const_iterator it = player->presetMap.begin(); it != player->presetMap.end(); ++it)
+                            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/INV_Misc_Statue_02:30:30:-18:0|t" + it->second.name, EQUIPMENT_SLOT_END + 6, it->first);
+
+                        if (player->presetMap.size() < sTransmogrification->MaxSets)
+                            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/GuildBankFrame/UI-GuildBankFrame-NewTab:30:30:-18:0|tSave set", EQUIPMENT_SLOT_END + 8, 0);
+                    }
+                    else
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/GuildBankFrame/UI-GuildBankFrame-NewTab:30:30:-18:0|tSave set", EQUIPMENT_SLOT_END + 8, 0);
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/Ability_Spy:30:30:-18:0|tBack..", EQUIPMENT_SLOT_END + 1, 0);
+                    player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+                } break;
+                case EQUIPMENT_SLOT_END + 5: // Use preset
+                {
+                    if (!sTransmogrification->EnableSets)
+                    {
+                        OnGossipHello(player, creature);
+                        return true;
+                    }
+                    // action = presetID
+
+                    PresetMapType::const_iterator it = player->presetMap.find(action);
+                    if (it != player->presetMap.end())
+                    {
+                        for (PresetslotMapType::const_iterator it2 = it->second.slotMap.begin(); it2 != it->second.slotMap.end(); ++it2)
+                            if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, it2->first))
+                                sTransmogrification->PresetTransmog(player, item, it2->second, it2->first);
+                    }
+                    OnGossipSelect(player, creature, EQUIPMENT_SLOT_END + 6, action);
+                } break;
+                case EQUIPMENT_SLOT_END + 6: // view preset
+                {
+                    if (!sTransmogrification->EnableSets)
+                    {
+                        OnGossipHello(player, creature);
+                        return true;
+                    }
+                    // action = presetID
+
+                    PresetMapType::const_iterator it = player->presetMap.find(action);
+                    if (it == player->presetMap.end())
+                    {
+                        OnGossipSelect(player, creature, EQUIPMENT_SLOT_END + 4, 0);
+                        return true;
+                    }
+
+                    for (PresetslotMapType::const_iterator it2 = it->second.slotMap.begin(); it2 != it->second.slotMap.end(); ++it2)
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, sTransmogrification->GetItemIcon(it2->second, 30, 30, -18, 0) + sTransmogrification->GetItemLink(it2->second, session), sender, action);
+
+                    player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/INV_Misc_Statue_02:30:30:-18:0|tUse set", EQUIPMENT_SLOT_END + 5, action, "Using this set for transmogrify will bind transmogrified items to you and make them non-refundable and non-tradeable.\nDo you wish to continue?\n\n" + it->second.name, 0, false);
+                    player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "|TInterface/PaperDollInfoFrame/UI-GearManager-LeaveItem-Opaque:30:30:-18:0|tDelete set", EQUIPMENT_SLOT_END + 7, action, "Are you sure you want to delete " + it->second.name + "?", 0, false);
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/Ability_Spy:30:30:-18:0|tBack..", EQUIPMENT_SLOT_END + 4, 0);
+                    player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+                } break;
+                case EQUIPMENT_SLOT_END + 7: // Delete preset
+                {
+                    if (!sTransmogrification->EnableSets)
+                    {
+                        OnGossipHello(player, creature);
+                        return true;
+                    }
+                    // action = presetID
+
+                    player->presetMap.erase(action);
+
+                    OnGossipSelect(player, creature, EQUIPMENT_SLOT_END + 4, 0);
+                } break;
+                case EQUIPMENT_SLOT_END + 8: // Save preset
+                {
+                    if (!sTransmogrification->EnableSets)
+                    {
+                        OnGossipHello(player, creature);
+                        return true;
+                    }
+
+                    if (player->presetMap.size() >= sTransmogrification->MaxSets)
+                    {
+                        OnGossipHello(player, creature);
+                        return true;
+                    }
+
+                    uint32 cost = 0;
+                    bool canSave = false;
+                    for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+                    {
+                        if (!sTransmogrification->GetSlotName(slot, session))
+                            continue;
+                        if (Item* newItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+                        {
+                            uint32 entry = sTransmogrification->GetFakeEntry(newItem);
+                            if (!entry)
+                                continue;
+                            const ItemTemplate* temp = sObjectMgr->GetItemTemplate(entry);
+                            if (!temp)
+                                continue;
+                            if (!sTransmogrification->SuitableForTransmogrification(player, temp)) // no need to check?
+                                continue;
+                            cost += sTransmogrification->GetSpecialPrice(temp);
+                            canSave = true;
+                            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, sTransmogrification->GetItemIcon(entry, 30, 30, -18, 0) + sTransmogrification->GetItemLink(entry, session), EQUIPMENT_SLOT_END + 8, 0);
+                        }
+                    }
+                    if (canSave)
+                        player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "|TInterface/GuildBankFrame/UI-GuildBankFrame-NewTab:30:30:-18:0|tSave set", 0, 0, "Insert set name", cost*sTransmogrification->SetCostModifier + sTransmogrification->SetCopperCost, true);
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/PaperDollInfoFrame/UI-GearManager-Undo:30:30:-18:0|tUpdate menu", sender, action);
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/Ability_Spy:30:30:-18:0|tBack..", EQUIPMENT_SLOT_END + 4, 0);
+                    player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+                } break;
+                case EQUIPMENT_SLOT_END + 10: // Set info
+                {
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/Ability_Spy:30:30:-18:0|tBack..", EQUIPMENT_SLOT_END + 4, 0);
+                    player->SEND_GOSSIP_MENU(sTransmogrification->SetNpcText, creature->GetGUID());
+                } break;
+#endif
+                case EQUIPMENT_SLOT_END + 9: // Transmog info
+                {
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/Ability_Spy:30:30:-18:0|tBack..", EQUIPMENT_SLOT_END + 1, 0);
+                    player->SEND_GOSSIP_MENU(sTransmogrification->TransmogNpcText, creature->GetGUID());
+                } break;
+                default: // Transmogrify
+                {
+                    if (!sender && !action)
+                    {
+                        OnGossipHello(player, creature);
+                        return true;
+                    }
+                    // sender = slot, action = display
+                    TransmogTrinityStrings res = sTransmogrification->Transmogrify(player, ObjectGuid(HighGuid::Item, 0, action), sender);
+                    if (res == LANG_ERR_TRANSMOG_OK)
+                        session->SendAreaTriggerMessage("%s", GTS(LANG_ERR_TRANSMOG_OK));
+                    else
+                        session->SendNotification(res);
+                    OnGossipSelect(player, creature, EQUIPMENT_SLOT_END, sender);
+                } break;
+            }
+            return true;
+        }
+
+#ifdef PRESETS
+        bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, const char* code) override
+        {
+            player->PlayerTalkClass->ClearMenus();
+            if (sender || action)
+                return true; // should never happen
+            if (!sTransmogrification->EnableSets)
+            {
+                OnGossipHello(player, creature);
+                return true;
+            }
+
+            // Allow only alnum
+            std::string name = code;
+            static const char* allowedcharacters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz _.,'1234567890";
+            if (!name.length() || name.find_first_not_of(allowedcharacters) != std::string::npos)
+            {
+                player->GetSession()->SendNotification(LANG_PRESET_ERR_INVALID_NAME);
+                OnGossipSelect(player, creature, EQUIPMENT_SLOT_END + 4, 0);
+                return true;
+            }
+
+            int32 cost = 0;
+            PresetslotMapType items;
+            for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+            {
+                if (!sTransmogrification->GetSlotName(slot, player->GetSession()))
+                    continue;
+                if (Item* newItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+                {
+                    uint32 entry = sTransmogrification->GetFakeEntry(newItem);
+                    if (!entry)
+                        continue;
+                    const ItemTemplate* temp = sObjectMgr->GetItemTemplate(entry);
+                    if (!temp)
+                        continue;
+                    if (!sTransmogrification->SuitableForTransmogrification(player, temp))
+                        continue;
+                    cost += sTransmogrification->GetSpecialPrice(temp);
+                    items[slot] = entry;
+                }
+            }
+
+            if (!items.empty())
+            {
+                // transmogrified items were found to be saved
+                cost *= sTransmogrification->SetCostModifier;
+                cost += sTransmogrification->SetCopperCost;
+
+                if (!player->HasEnoughMoney(cost))
+                {
+                    player->GetSession()->SendNotification(LANG_ERR_TRANSMOG_NOT_ENOUGH_MONEY);
+                }
+                else
+                {
+                    uint8 presetID = sTransmogrification->MaxSets;
+                    if (player->presetMap.size() < sTransmogrification->MaxSets)
+                    {
+                        for (uint8 i = 0; i < sTransmogrification->MaxSets; ++i) // should never reach over max
+                        {
+                            if (player->presetMap.find(i) == player->presetMap.end())
+                            {
+                                presetID = i;
+                                break;
+                            }
+                        }
+                    }
+
+                    if (presetID < sTransmogrification->MaxSets)
+                    {
+                        // Make sure code doesnt mess up SQL!
+                        player->presetMap[presetID].name = name;
+                        player->presetMap[presetID].slotMap = items;
+
+                        if (cost)
+                            player->ModifyMoney(-cost);
+                    }
+                }
+            }
+
+            OnGossipSelect(player, creature, EQUIPMENT_SLOT_END + 4, 0);
+            return true;
+        }
+#endif
+
+        void ShowTransmogItems(Player* player, Creature* creature, uint8 slot) // Only checks bags while can use an item from anywhere in inventory
+        {
+            WorldSession* session = player->GetSession();
+            Item* oldItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+            if (oldItem)
+            {
+                uint32 limit = 0;
+                uint32 price = sTransmogrification->GetSpecialPrice(oldItem->GetTemplate());
+                price *= sTransmogrification->ScaledCostModifier;
+                price += sTransmogrification->CopperCost;
+                std::ostringstream ss;
+                ss << std::endl;
+                if (sTransmogrification->RequireToken)
+                    ss << std::endl << std::endl << sTransmogrification->TokenAmount << " x " << sTransmogrification->GetItemLink(sTransmogrification->TokenEntry, session);
+
+                for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+                {
+                    if (limit >= MAX_OPTIONS)
+                        break;
+                    Item* newItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                    if (!newItem)
+                        continue;
+                    if (!sTransmogrification->CanTransmogrifyItemWithItem(player, oldItem->GetTemplate(), newItem->GetTemplate()))
+                        continue;
+                    if (sTransmogrification->GetFakeEntry(oldItem) == newItem->GetEntry())
+                        continue;
+                    ++limit;
+                    player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, sTransmogrification->GetItemIcon(newItem->GetEntry(), 30, 30, -18, 0) + sTransmogrification->GetItemLink(newItem, session), slot, newItem->GetGUID().GetCounter(), "Using this item for transmogrify will bind it to you and make it non-refundable and non-tradeable.\nDo you wish to continue?\n\n" + sTransmogrification->GetItemIcon(newItem->GetEntry(), 40, 40, -15, -10) + sTransmogrification->GetItemLink(newItem, session) + ss.str(), price, false);
+                }
+
+                for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+                {
+                    Bag* bag = player->GetBagByPos(i);
+                    if (!bag)
+                        continue;
+                    for (uint32 j = 0; j < bag->GetBagSize(); ++j)
+                    {
+                        if (limit >= MAX_OPTIONS)
+                            break;
+                        Item* newItem = player->GetItemByPos(i, j);
+                        if (!newItem)
+                            continue;
+                        if (!sTransmogrification->CanTransmogrifyItemWithItem(player, oldItem->GetTemplate(), newItem->GetTemplate()))
+                            continue;
+                        if (sTransmogrification->GetFakeEntry(oldItem) == newItem->GetEntry())
+                            continue;
+                        ++limit;
+                        player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, sTransmogrification->GetItemIcon(newItem->GetEntry(), 30, 30, -18, 0) + sTransmogrification->GetItemLink(newItem, session), slot, newItem->GetGUID().GetCounter(), "Using this item for transmogrify will bind it to you and make it non-refundable and non-tradeable.\nDo you wish to continue?\n\n" + sTransmogrification->GetItemIcon(newItem->GetEntry(), 40, 40, -15, -10) + sTransmogrification->GetItemLink(newItem, session) + ss.str(), price, false);
+                    }
+                }
+            }
+
+            player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/INV_Enchant_Disenchant:30:30:-18:0|tRemove transmogrification", EQUIPMENT_SLOT_END + 3, slot, "Remove transmogrification from the slot?", 0, false);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/PaperDollInfoFrame/UI-GearManager-Undo:30:30:-18:0|tUpdate menu", EQUIPMENT_SLOT_END, slot);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/Ability_Spy:30:30:-18:0|tBack..", EQUIPMENT_SLOT_END + 1, 0);
+            player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+        }
+    };
+}
+
+void AddSC_CS_Transmogrification()
+{
+    new CS_Transmogrification();
+}
diff --git a/src/server/scripts/Custom/VAS_AutoBalance.cpp b/src/server/scripts/Custom/VAS_AutoBalance.cpp
new file mode 100644
index 0000000..fa406ae
--- /dev/null
+++ b/src/server/scripts/Custom/VAS_AutoBalance.cpp
@@ -0,0 +1,510 @@
+/*
+ * Copyright (C) 2012 CVMagic <http://www.trinitycore.org/f/topic/6551-vas-autobalance/>
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2006-2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ * Copyright (C) 1985-2010 {VAS} KalCorp  <http://vasserver.dyndns.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * Script Name: AutoBalance
+ * Original Authors: KalCorp and Vaughner
+ * Maintainer(s): CVMagic
+ * Original Script Name: VAS.AutoBalance
+ * Description: This script is intended to scale based on number of players, instance mobs & world bosses' health, mana, and damage.
+ */
+
+
+//#include "ScriptPCH.h"
+#include "Configuration/Config.h"
+#include "Unit.h"
+#include "Chat.h"
+#include "Creature.h"
+#include "Player.h"
+#include "ObjectMgr.h"
+#include "MapManager.h"
+#include "World.h"
+#include "Map.h"
+#include "ScriptMgr.h"
+#include <vector>
+
+#define BOOL_TO_STRING(b) ((b)? "true":"false")
+
+struct AutoBalanceCreatureInfo
+{
+    uint32 instancePlayerCount;
+    float DamageMultiplier;
+};
+
+static std::map<uint32, AutoBalanceCreatureInfo> CreatureInfo; // A hook should be added to remove the mapped entry when the creature is dead or this should be added into the creature object
+static std::map<int, int> forcedCreatureIds;                   // The map values correspond with the VAS.AutoBalance.XX.Name entries in the configuration file.
+
+int GetValidDebugLevel()
+{
+    int debugLevel = sWorld->getIntConfig(VAS_VasDebug);
+
+    if ((debugLevel < 0) || (debugLevel > 3))
+    {
+        return 1;
+    }
+    return debugLevel;
+}
+
+void LoadForcedCreatureIdsFromString(std::string creatureIds, int forcedPlayerCount) // Used for reading the string from the configuration file to for those creatures who need to be scaled for XX number of players.
+{
+    std::string delimitedValue;
+    std::stringstream creatureIdsStream;
+
+    creatureIdsStream.str(creatureIds);
+    while (std::getline(creatureIdsStream, delimitedValue, ',')) // Process each Creature ID in the string, delimited by the comma - ","
+    {
+        int creatureId = atoi(delimitedValue.c_str());
+        if (creatureId >= 0)
+        {
+            forcedCreatureIds[creatureId] = forcedPlayerCount;
+        }
+    }
+}
+
+int GetForcedCreatureId(int creatureId)
+{
+    if(forcedCreatureIds.find(creatureId) == forcedCreatureIds.end()) // Don't want the forcedCreatureIds map to blowup to a massive empty array
+    {
+        return 0;
+    }
+    return forcedCreatureIds[creatureId];
+}
+
+class VAS_AutoBalance_WorldScript : public WorldScript
+{
+    public:
+        VAS_AutoBalance_WorldScript()
+            : WorldScript("VAS_AutoBalance_WorldScript")
+        {
+        }
+
+    void OnConfigLoad(bool /*reload*/)
+    {
+    }
+
+    void OnStartup()
+    {
+    }
+
+    void SetInitialWorldSettings()
+    {
+        // Load from the VAS.AutoBalance.XX.Name entries in the Configuration File
+        forcedCreatureIds.clear();
+        LoadForcedCreatureIdsFromString(sWorld->GetVAS40(), 40);
+        LoadForcedCreatureIdsFromString(sWorld->GetVAS25(), 25);
+        LoadForcedCreatureIdsFromString(sWorld->GetVAS10(), 10);
+        LoadForcedCreatureIdsFromString(sWorld->GetVAS5(), 5);
+        LoadForcedCreatureIdsFromString(sWorld->GetVAS2(), 2);
+
+        //sLog->outInfo(LOG_FILTER_WORLDSERVER, "----------------------------------------------------");
+        //sLog->outInfo(LOG_FILTER_WORLDSERVER, "  Powered by {VAS} AutoBalance");
+        //sLog->outInfo(LOG_FILTER_WORLDSERVER, "----------------------------------------------------");
+        //sLog->outInfo(LOG_FILTER_WORLDSERVER, "  xPlayer = %4.1f ", sWorld->getFloatConfig(VAS_Config_xPlayer));
+        //sLog->outInfo(LOG_FILTER_WORLDSERVER, "  AutoInstance = %u ", sWorld->getIntConfig(VAS_AutoInstance));
+        //sLog->outInfo(LOG_FILTER_WORLDSERVER, "  PlayerChangeNotify = %u ", sWorld->getIntConfig(VAS_PlayerChangeNotify));
+        //sLog->outInfo(LOG_FILTER_WORLDSERVER, "  Min.D.Mod = %4.2f ", sWorld->getFloatConfig(VAS_Min_D_Mod));
+        //sLog->outInfo(LOG_FILTER_WORLDSERVER, "  Min.HP.Mod = %4.2f ", sWorld->getFloatConfig(VAS_Min_HP_Mod));
+        //sLog->outInfo(LOG_FILTER_WORLDSERVER, "  VasDebug   =  %u ", GetValidDebugLevel());
+        //sLog->outInfo(LOG_FILTER_WORLDSERVER, "----------------------------------------------------\n");
+    }
+
+};
+
+class VAS_AutoBalance_PlayerScript : public PlayerScript
+{
+    public:
+        VAS_AutoBalance_PlayerScript()
+            : PlayerScript("VAS_AutoBalance_PlayerScript")
+        {
+        }
+
+    void OnLogin(Player *Player, bool /*firstLogin*/)
+    {
+            //TC_LOG_INFO("vas.player.loading", "### VAS_AutoBalance_PlayerScript - OnLogin Player=%s", Player->GetName());
+    }
+};
+
+class VAS_AutoBalance_UnitScript : public UnitScript
+{
+    public:
+        VAS_AutoBalance_UnitScript()
+            : UnitScript("VAS_AutoBalance_UnitScript")
+        {
+        }
+
+    uint32 DealDamage(Unit* AttackerUnit, Unit *playerVictim, uint32 damage, DamageEffectType damagetype)
+    {
+        if (AttackerUnit->GetMap()->IsDungeon() && playerVictim->GetMap()->IsDungeon())
+            if (AttackerUnit->GetTypeId() != TYPEID_PLAYER)
+            {
+                //if (GetValidDebugLevel() >= 3)
+                    //sLog->outInfo(LOG_FILTER_TSCR, "### VAS_AutoBalance_UnitScript - VAS_Unit_DealDamage Attacker=%s Victim=%s Start Damage=%u",AttackerUnit->GetName(),playerVictim->GetName(),damage);
+                damage = VAS_Modifer_DealDamage(AttackerUnit,damage);
+                //if (GetValidDebugLevel() >= 3)
+                    //sLog->outInfo(LOG_FILTER_TSCR, "### VAS_AutoBalance_UnitScript - VAS_Unit_DealDamage Attacker=%s Victim=%s End Damage=%u",AttackerUnit->GetName(),playerVictim->GetName(),damage);
+            }
+            return damage;
+    }
+
+    uint32 HandlePeriodicDamageAurasTick(Unit *target, Unit *caster, int32 damage)
+    {
+        if (caster->GetMap()->IsDungeon() && target->GetMap()->IsDungeon())
+            if (caster->GetTypeId() != TYPEID_PLAYER)
+            {
+                //if (GetValidDebugLevel() >= 3)
+                    //sLog->outInfo(LOG_FILTER_TSCR, "### VAS_AutoBalance_UnitScript - VAS_Unit_HandlePeriodicDamage Attacker=%s Victim=%s Start Damage=%u",caster->GetName(),target->GetName(),damage);
+
+                if (!((caster->IsHunterPet() || caster->IsPet() || caster->IsSummon()) && caster->IsControlledByPlayer()))
+                    damage = (float)damage * (float)CreatureInfo[caster->GetGUID()].DamageMultiplier;
+
+                //if (GetValidDebugLevel() >= 3)
+                    //sLog->outInfo(LOG_FILTER_TSCR, "### VAS_AutoBalance_UnitScript - VAS_Unit_HandlePeriodicDamage Attacker=%s Victim=%s End Damage=%u",caster->GetName(),target->GetName(),damage);
+            }
+            return damage;
+    }
+
+    void CalculateSpellDamageTaken(SpellNonMeleeDamage *damageInfo, int32 damage, SpellInfo const *spellInfo, WeaponAttackType attackType, bool crit)
+    {
+        if ((damageInfo->attacker->GetMap()->IsDungeon() && damageInfo->target->GetMap()->IsDungeon()) || ( damageInfo->attacker->GetMap()->IsBattleground() && damageInfo->target->GetMap()->IsBattleground()))
+        {
+            if (damageInfo->attacker->GetTypeId() != TYPEID_PLAYER)
+            {
+                //if (GetValidDebugLevel() >= 3)
+                    //sLog->outInfo(LOG_FILTER_TSCR, "### VAS_AutoBalance_UnitScript - CalculateSpellDamageTaken Attacker=%s Victim=%s Start Damage=%u",damageInfo->attacker->GetName(),damageInfo->target->GetName(),damageInfo->damage);
+
+                if ((damageInfo->attacker->IsHunterPet() || damageInfo->attacker->IsPet() || damageInfo->attacker->IsSummon()) && damageInfo->attacker->IsControlledByPlayer())
+                    return;
+
+                damageInfo->damage = (float)damageInfo->damage * (float)CreatureInfo[damageInfo->attacker->GetGUID()].DamageMultiplier;
+
+                //if (GetValidDebugLevel() >= 3)
+                    //sLog->outInfo(LOG_FILTER_TSCR, "### VAS_AutoBalance_UnitScript - CalculateSpellDamageTaken Attacker=%s Victim=%s End Damage=%u",damageInfo->attacker->GetName(),damageInfo->target->GetName(),damageInfo->damage);
+            }
+        }
+            return;
+    }
+
+    void CalculateMeleeDamage(Unit *playerVictim, uint32 damage, CalcDamageInfo *damageInfo, WeaponAttackType attackType)
+    {
+        // Make sure the Attacker and the Victim are in the same location, in addition that the attacker is not player.
+        if (((damageInfo->attacker->GetMap()->IsDungeon() && damageInfo->target->GetMap()->IsDungeon()) || (damageInfo->attacker->GetMap()->IsBattleground() && damageInfo->target->GetMap()->IsBattleground())) && (damageInfo->attacker->GetTypeId() != TYPEID_PLAYER))
+            if (!((damageInfo->attacker->IsHunterPet() || damageInfo->attacker->IsPet() || damageInfo->attacker->IsSummon()) && damageInfo->attacker->IsControlledByPlayer())) // Make sure that the attacker Is not a Pet of some sort
+            {
+                //if (GetValidDebugLevel() >= 3)
+                    //sLog->outInfo(LOG_FILTER_TSCR, "### VAS_AutoBalance_UnitScript - CalculateMeleeDamage Attacker=%s Victim=%s Start Damage=%u",damageInfo->attacker->GetName(),damageInfo->target->GetName(),damageInfo->damage);
+
+                damageInfo->damage = (float)damageInfo->damage * (float)CreatureInfo[damageInfo->attacker->GetGUID()].DamageMultiplier;
+
+                //if (GetValidDebugLevel() >= 3)
+                    //sLog->outInfo(LOG_FILTER_TSCR, "### VAS_AutoBalance_UnitScript - CalculateMeleeDamage Attacker=%s Victim=%s End Damage=%u",damageInfo->attacker->GetName(),damageInfo->target->GetName(),damageInfo->damage);
+            }
+            return;
+    }
+
+    uint32 VAS_Modifer_DealDamage(Unit* AttackerUnit,uint32 damage)
+    {
+    if ((AttackerUnit->IsHunterPet() || AttackerUnit->IsPet() || AttackerUnit->IsSummon()) && AttackerUnit->IsControlledByPlayer())
+        return damage;
+
+    float damageMultiplier = CreatureInfo[AttackerUnit->GetGUID()].DamageMultiplier;
+
+    return damage * damageMultiplier;
+
+    }
+
+};
+
+
+class VAS_AutoBalance_AllMapScript : public AllMapScript
+{
+    public:
+        VAS_AutoBalance_AllMapScript()
+            : AllMapScript("VAS_AutoBalance_AllMapScript")
+        {
+        }
+
+    void OnPlayerEnterAll(Map* map, Player* player)
+    {
+        if (GetValidDebugLevel() >= 2)
+        {
+            //sLog->outInfo(LOG_FILTER_TSCR, "----------------------------------------------------");
+            //sLog->outInfo(LOG_FILTER_TSCR, "## VAS_AutoBalance_AllMapScript - OnPlayerEnterAll");
+            //sLog->outInfo(LOG_FILTER_TSCR, "## For InsatanceID %u",map->GetInstanceId());
+            //sLog->outInfo(LOG_FILTER_TSCR, "## IsDungeon= %u",map->GetEntry()->IsDungeon());
+            //sLog->outInfo(LOG_FILTER_TSCR, "## For Map %u",player->GetMapId());
+            //sLog->outInfo(LOG_FILTER_TSCR, "## PlayersInMap %u",map->GetPlayersCountExceptGMs());
+            //sLog->outInfo(LOG_FILTER_TSCR, "## pDifficulty %u",uint32(player->GetDifficulty(player->GetMap()->IsHeroic())));
+            //sLog->outInfo(LOG_FILTER_TSCR, "## pGetDungeonDifficulty %u",uint32(player->GetDungeonDifficulty()));
+            //sLog->outInfo(LOG_FILTER_TSCR, "## pGetRaidDifficulty %u",uint32(player->GetRaidDifficulty()));
+            //sLog->outInfo(LOG_FILTER_TSCR, "## maxPlayers %u",((InstanceMap*)sMapMgr->FindMap(player->GetMapId(), player->GetInstanceId()))->GetMaxPlayers());
+            //sLog->outInfo(LOG_FILTER_TSCR, "## IsHeroic=%s IsRaid=%s IsRegularDifficulty=%s IsRaidOrHeroicDungeon=%s IsNonRaidDungeon=%s",BOOL_TO_STRING(player->GetMap()->IsHeroic()),BOOL_TO_STRING(player->GetMap()->IsRaid()),BOOL_TO_STRING(player->GetMap()->IsRegularDifficulty()),BOOL_TO_STRING(player->GetMap()->IsRaidOrHeroicDungeon()),BOOL_TO_STRING(player->GetMap()->IsNonRaidDungeon()));
+            //sLog->outInfo(LOG_FILTER_TSCR, "----------------------------------------------------\n");
+        }
+
+        if (sWorld->getIntConfig(VAS_PlayerChangeNotify) >= 1)
+        {
+            if ((map->GetEntry()->IsDungeon()) && !player->IsGameMaster() )
+            {
+                Map::PlayerList const &playerList = map->GetPlayers();
+                if (!playerList.isEmpty())
+                {
+                    for (Map::PlayerList::const_iterator playerIteration = playerList.begin(); playerIteration != playerList.end(); ++playerIteration)
+                    {
+                        if (Player* playerHandle = playerIteration->GetSource())
+                        {
+                            ChatHandler chatHandle = ChatHandler(playerHandle->GetSession());
+                            chatHandle.PSendSysMessage("|cffFF0000 [AutoBalance]|r|cffFF8000 %s entered the Instance %s. Auto setting player count to %u |r",player->GetName().c_str(),map->GetMapName(),map->GetPlayersCountExceptGMs());
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    void OnPlayerLeaveAll(Map* map, Player* player)
+    {
+
+        //if (GetValidDebugLevel() >= 3)
+            //sLog->outInfo(LOG_FILTER_TSCR, "#### VAS_AutoBalance_AllMapScript - OnPlayerLeaveAll map=%s player=%s", map->GetMapName(),player->GetName());
+
+        int instancePlayerCount = map->GetPlayersCountExceptGMs() - 1;
+
+        if (instancePlayerCount >=1)
+        {
+            if (GetValidDebugLevel() >= 2)
+            {
+                //sLog->outInfo(LOG_FILTER_TSCR, "----------------------------------------------------");
+                //sLog->outInfo(LOG_FILTER_TSCR, "## VAS_AutoBalance_AllMapScript - OnPlayerLeaveAll");
+                //sLog->outInfo(LOG_FILTER_TSCR, "## For InsatanceID %u",map->GetInstanceId());
+                //sLog->outInfo(LOG_FILTER_TSCR, "## IsDungeon= %u",map->GetEntry()->IsDungeon());
+                //sLog->outInfo(LOG_FILTER_TSCR, "## For Map %u",player->GetMapId());
+                //sLog->outInfo(LOG_FILTER_TSCR, "## PlayersInMap %u",instancePlayerCount);
+                //sLog->outInfo(LOG_FILTER_TSCR, "----------------------------------------------------\n");
+            }
+
+            if (sWorld->getIntConfig(VAS_PlayerChangeNotify) >= 1)
+            {
+                if ((map->GetEntry()->IsDungeon()) && !player->IsGameMaster())
+                {
+                    Map::PlayerList const &playerList = map->GetPlayers();
+                    if (!playerList.isEmpty())
+                    {
+                        for (Map::PlayerList::const_iterator playerIteration = playerList.begin(); playerIteration != playerList.end(); ++playerIteration)
+                        {
+                            if (Player* playerHandle = playerIteration->GetSource())
+                            {
+                                ChatHandler chatHandle = ChatHandler(playerHandle->GetSession());
+                                chatHandle.PSendSysMessage("|cffFF0000 [VAS-AutoBalance]|r|cffFF8000 %s left the Instance %s. Auto setting player count to %u |r",player->GetName().c_str(),map->GetMapName(),instancePlayerCount);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+};
+
+class VAS_AutoBalance_WorldMapScript : public WorldMapScript
+{
+    public:
+        VAS_AutoBalance_WorldMapScript()
+            : WorldMapScript("VAS_AutoBalance_WorldMapScript",0)
+        {
+        }
+
+    void OnPlayerEnter(Map* map, Player* player)
+    {
+
+        //if (GetValidDebugLevel() >= 3)
+            //sLog->outInfo(LOG_FILTER_TSCR, "### VAS_AutoBalance_WorldMapScript - OnPlayerEnter Map=%s player=%s",map->GetMapName(),player->GetName());
+    }
+
+    void OnPlayerLeave(Map* map, Player* player)
+    {
+
+        //if (GetValidDebugLevel() >= 3)
+            //sLog->outInfo(LOG_FILTER_TSCR, "### VAS_AutoBalance_WorldMapScript - OnPlayerLeave Map=%s player=%s",map->GetMapName(),player->GetName());
+    }
+};
+
+
+class VAS_AutoBalance_AllCreatureScript : public AllCreatureScript
+{
+    public:
+        VAS_AutoBalance_AllCreatureScript()
+            : AllCreatureScript("VAS_AutoBalance_AllCreatureScript")
+        {
+        }
+
+
+    void Creature_SelectLevel(const CreatureTemplate *creatureTemplate, Creature* creature)
+    {
+
+        if (creature->GetMap()->IsDungeon())
+        {
+            ModifyCreatureAttributes(creature);
+            CreatureInfo[creature->GetGUID()].instancePlayerCount = creature->GetMap()->GetPlayersCountExceptGMs();
+        }
+    }
+
+    void OnAllCreatureUpdate(Creature* creature, uint32 diff)
+    {
+        if(!(CreatureInfo[creature->GetGUID()].instancePlayerCount == creature->GetMap()->GetPlayersCountExceptGMs()))
+        {
+            if (creature->GetMap()->IsDungeon() || creature->GetMap()->IsBattleground())
+                ModifyCreatureAttributes(creature);
+            CreatureInfo[creature->GetGUID()].instancePlayerCount = creature->GetMap()->GetPlayersCountExceptGMs();
+        }
+    }
+
+    void ModifyCreatureAttributes(Creature* creature)
+    {
+        if(((creature->IsHunterPet() || creature->IsPet() || creature->IsSummon()) && creature->IsControlledByPlayer()) || sWorld->getIntConfig(VAS_AutoInstance) < 1 || creature->GetMap()->GetPlayersCountExceptGMs() <= 0)
+        {
+            return;
+        }
+
+        CreatureTemplate const *creatureTemplate = creature->GetCreatureTemplate();
+        CreatureBaseStats const* creatureStats = sObjectMgr->GetCreatureBaseStats(creature->getLevel(), creatureTemplate->unit_class);
+
+        float damageMultiplier = 1.0f;
+        float healthMultiplier = 1.0f;
+
+        uint32 baseHealth = creatureStats->GenerateHealth(creatureTemplate);
+        uint32 baseMana = creatureStats->GenerateMana(creatureTemplate);
+        uint32 instancePlayerCount = creature->GetMap()->GetPlayersCountExceptGMs();
+        uint32 maxNumberOfPlayers = ((InstanceMap*)sMapMgr->FindMap(creature->GetMapId(), creature->GetInstanceId()))->GetMaxPlayers();
+        uint32 scaledHealth = 0;
+        uint32 scaledMana = 0;
+
+        //   VAS SOLO  - By MobID
+        if(GetForcedCreatureId(creatureTemplate->Entry) > 0)
+        {
+            maxNumberOfPlayers = GetForcedCreatureId(creatureTemplate->Entry); // Force maxNumberOfPlayers to be changed to match the Configuration entry.
+        }
+
+        // (tanh((X-2.2)/1.5) +1 )/2    // 5 Man formula X = Number of Players
+        // (tanh((X-5)/2) +1 )/2        // 10 Man Formula X = Number of Players
+        // (tanh((X-16.5)/6.5) +1 )/2   // 25 Man Formula X = Number of players
+        //
+        // Note: The 2.2, 5, and 16.5 are the number of players required to get 50% health.
+        //       It's not required this be a whole number, you'd adjust this to raise or lower
+        //       the hp modifier for per additional player in a non-whole group. These
+        //       values will eventually be part of the configuration file once I finalize the mod.
+        //
+        //       The 1.5, 2, and 6.5 modify the rate of percentage increase between
+        //       number of players. Generally the closer to the value of 1 you have this
+        //       the less gradual the rate will be. For example in a 5 man it would take 3
+        //       total players to face a mob at full health.
+        //
+        //       The +1 and /2 values raise the TanH function to a positive range and make
+        //       sure the modifier never goes above the value or 1.0 or below 0.
+        //
+        //       Lastly this formula has one side effect on full groups Bosses and mobs will
+        //       never have full health, this can be tested against by making sure the number
+        //       of players match the maxNumberOfPlayers variable.
+
+        switch (maxNumberOfPlayers)
+        {
+        case 40:
+            healthMultiplier = (float)instancePlayerCount / (float)maxNumberOfPlayers; // 40 Man Instances oddly enough scale better with the old formula
+            break;
+        case 25:
+            healthMultiplier = (tanh((instancePlayerCount - 16.5f) / 1.5f) + 1.0f) / 2.0f;
+            break;
+        case 10:
+            healthMultiplier = (tanh((instancePlayerCount - 4.5f) / 1.5f) + 1.0f) / 2.0f;
+            break;
+        case 2:
+            healthMultiplier = (float)instancePlayerCount / (float)maxNumberOfPlayers;                   // Two Man Creatures are too easy if handled by the 5 man formula, this would only
+            break;                                                                         // apply in the situation where it's specified in the configuration file.
+        default:
+            healthMultiplier = (tanh((instancePlayerCount - 2.2f) / 1.5f) + 1.0f) / 2.0f;    // default to a 5 man group
+        }
+
+        //   VAS SOLO  - Map 0,1 and 530 ( World Mobs )                                                               // This may be where VAS_AutoBalance_CheckINIMaps might have come into play. None the less this is
+        if((creature->GetMapId() == 0 || creature->GetMapId() == 1 || creature->GetMapId() == 530) && (creature->isElite() || creature->isWorldBoss()))  // specific to World Bosses and elites in those Maps, this is going to use the entry XPlayer in place of instancePlayerCount.
+        {
+            if(baseHealth > 800000){
+                healthMultiplier = (tanh((sWorld->getFloatConfig(VAS_Config_xPlayer) - 5.0f) / 1.5f) + 1.0f) / 2.0f;
+            }else{
+                healthMultiplier = (tanh((sWorld->getFloatConfig(VAS_Config_xPlayer) - 2.2f) / 1.5f) + 1.0f) / 2.0f; // Assuming a 5 man configuration, as World Bosses have been relatively retired since BC so unless the boss has some substantial baseHealth
+            }
+
+        }
+
+        // Ensure that the healthMultiplier is not lower than the configuration specified value. -- This may be Deprecated later.
+        if(healthMultiplier <= sWorld->getFloatConfig(VAS_Min_HP_Mod) )
+        {
+            healthMultiplier = sWorld->getFloatConfig(VAS_Min_HP_Mod);
+        }
+
+        //Getting the list of Classes in this group - this will be used later on to determine what additional scaling will be required based on the ratio of tank/dps/healer
+        //GetPlayerClassList(creature, playerClassList); // Update playerClassList with the list of all the participating Classes
+
+
+        scaledHealth = uint32((baseHealth * healthMultiplier) + 1.0f);
+        // Now adjusting Mana, Mana is something that can be scaled linearly
+        if (maxNumberOfPlayers==0){
+            scaledMana = uint32((baseMana * healthMultiplier) + 1.0f);
+            // Now Adjusting Damage, this too is linear for now .... this will have to change I suspect.
+            damageMultiplier = healthMultiplier;
+        }else{
+            scaledMana = ((baseMana/maxNumberOfPlayers) * instancePlayerCount);
+            // Now Adjusting Damage, this too is linear for now .... this will have to change I suspect.
+            damageMultiplier = (float)instancePlayerCount / (float)maxNumberOfPlayers;
+        }
+
+        // Can not be less then Min_D_Mod
+        if(damageMultiplier <= sWorld->getFloatConfig(VAS_Min_D_Mod))
+        {
+            damageMultiplier = sWorld->getFloatConfig(VAS_Min_D_Mod);
+        }
+
+        if((GetValidDebugLevel() >= 3))
+        {
+            //sLog->outInfo(LOG_FILTER_TSCR, "## VAS-AutoBalance MobID=%u MapID=%u creatureName=%s  GUID=%llu  instancePlayerCount=%u", creatureTemplate->Entry, creature->GetMapId(), creatureTemplate->Name.c_str(), creature->GetGUID(), instancePlayerCount);
+            //sLog->outInfo(LOG_FILTER_TSCR, "## VAS-AutoBalance MapDifficulty=%u Health=%u / %u healthMultiplier=%4.5f", creature->GetMap()->GetDifficulty(), scaledHealth, baseHealth, healthMultiplier);
+            //sLog->outInfo(LOG_FILTER_TSCR, "## VAS-AutoBalance maxNumberOfPlayers=%u IsRaid=%s", maxNumberOfPlayers, BOOL_TO_STRING(creature->GetMap()->IsRaid()));
+            //sLog->outInfo(LOG_FILTER_TSCR, "## VAS-AutoBalance Mana %u / %u", baseMana, scaledMana);
+            //sLog->outInfo(LOG_FILTER_TSCR, "## VAS-AutoBalance damageMultiplier=%4.2f", damageMultiplier);
+        }
+
+        creature->SetCreateHealth(scaledHealth);
+        creature->SetMaxHealth(scaledHealth);
+        creature->ResetPlayerDamageReq();
+        creature->SetCreateMana(scaledMana);
+        creature->SetMaxPower(POWER_MANA, scaledMana);
+        creature->SetPower(POWER_MANA, scaledMana);
+        creature->SetModifierValue(UNIT_MOD_HEALTH, BASE_VALUE, (float)scaledHealth);
+        creature->SetModifierValue(UNIT_MOD_MANA, BASE_VALUE, (float)scaledMana);
+        CreatureInfo[creature->GetGUID()].DamageMultiplier = damageMultiplier;
+    }
+};
+
+void AddSC_VAS_AutoBalance()
+{
+    new VAS_AutoBalance_WorldScript;
+    new VAS_AutoBalance_PlayerScript;
+    new VAS_AutoBalance_UnitScript;
+    new VAS_AutoBalance_AllCreatureScript;
+    new VAS_AutoBalance_AllMapScript;
+    new VAS_AutoBalance_WorldMapScript;
+}
diff --git a/src/server/scripts/Custom/WorldChat.cpp b/src/server/scripts/Custom/WorldChat.cpp
new file mode 100644
index 0000000..86b252a
--- /dev/null
+++ b/src/server/scripts/Custom/WorldChat.cpp
@@ -0,0 +1,120 @@
+/*
+<--------------------------------------------------------------------------->
+- Developer(s): Ghostcrawler336
+- Made By??
+- Complete: %0
+- ScriptName: 'World chat'
+- Comment: Untested ingame.
+<--------------------------------------------------------------------------->
+*/
+
+#include "Chat.h"
+#include "Common.h"
+
+/* Colors */
+#define MSG_COLOR_ORANGE "|cffFFA500"
+#define MSG_COLOR_DARKORANGE "|cffFF8C00"
+#define MSG_COLOR_RED "|cffFF0000"
+#define MSG_COLOR_LIGHTRED "|cffD63931"
+#define MSG_COLOR_ROYALBLUE "|cff4169E1"
+#define MSG_COLOR_LIGHTBLUE "|cffADD8E6"
+#define MSG_COLOR_YELLOW "|cffFFFF00"
+#define MSG_COLOR_GREEN "|cff008000"
+#define MSG_COLOR_PURPLE "|cffDA70D6"
+#define MSG_COLOR_WHITE  "|cffffffff"
+#define MSG_COLOR_SUBWHITE  "|cffbbbbbb"
+
+/* Ranks */
+#define ADMINISTRATOR "Admin"
+#define HEADGM "Head GM"
+#define GAMEMASTER "GM"
+#define DEVELOPER "Developer"
+#define OWNER "Owner"
+#define VIP "Vip"
+#define PLAYER "Player"
+#define EVENTM "Event Master"
+
+
+class World_Chat : public CommandScript
+{
+    public:
+    World_Chat() : CommandScript("World_Chat") { }
+
+    static bool HandleWorldChatCommand(ChatHandler * pChat, const char * msg)
+    {
+        if(!*msg)
+            return false;
+
+        Player * player = pChat->GetSession()->GetPlayer();
+        char message[1024];
+
+        switch(player->GetSession()->GetSecurity())
+        {
+            case SEC_PLAYER:
+                snprintf(message, 1024, "[World][Player][%s%s|r]: %s%s|r", MSG_COLOR_WHITE, player->GetName().c_str(), MSG_COLOR_LIGHTBLUE, msg);
+                sWorld->SendGlobalText(message, NULL);
+            break;
+
+                case SEC_VIP:
+                snprintf(message, 1024, "[World][Vip][%s%s|r]: %s%s|r", MSG_COLOR_WHITE, player->GetName().c_str(), MSG_COLOR_PURPLE, msg);
+                sWorld->SendGlobalText(message, NULL);
+            break;
+
+                case SEC_GAMEMASTER:
+                snprintf(message, 1024, "[World][GM][%s%s|r]: %s%s|r", MSG_COLOR_WHITE, player->GetName().c_str(),  MSG_COLOR_YELLOW, msg);
+                sWorld->SendGlobalText(message, NULL);
+            break;
+
+                case SEC_EVENTM:
+                snprintf(message, 1024, "[World][Event Master][%s%s|r]: %s%s|r", MSG_COLOR_WHITE, player->GetName().c_str(), MSG_COLOR_ORANGE, msg);
+                sWorld->SendGlobalText(message, NULL);
+            break;
+
+                case SEC_HEADGM:
+                snprintf(message, 1024, "[World][Head GM][%s%s|r]: %s%s|r", MSG_COLOR_WHITE, player->GetName().c_str(), MSG_COLOR_GREEN, msg);
+                sWorld->SendGlobalText(message, NULL);
+            break;
+
+
+                case SEC_DEVELOPER:
+                snprintf(message, 1024, "[World][Developer][%s%s|r]: %s%s|r", MSG_COLOR_WHITE, player->GetName().c_str(), MSG_COLOR_ROYALBLUE, msg);
+                sWorld->SendGlobalText(message, NULL);
+            break;
+
+                case SEC_ADMINISTRATOR:
+                snprintf(message, 1024, "[World][Admin][%s%s|r]: %s%s|r", MSG_COLOR_WHITE, player->GetName().c_str(), MSG_COLOR_RED, msg);
+                sWorld->SendGlobalText(message, NULL);
+            break;
+
+                case SEC_OWNER:
+                snprintf(message, 1024, "[World][Owner][%s%s|r]: %s%s|r", MSG_COLOR_WHITE, player->GetName().c_str(), MSG_COLOR_RED, msg);
+                sWorld->SendGlobalText(message, NULL);
+            break;
+
+            case SEC_CONSOLE:
+                snprintf(message, 1024, "[World][%sAdministrator|r][%s%s|r]: %s%s|r", MSG_COLOR_RED, MSG_COLOR_LIGHTRED, player->GetName().c_str(),
+                    MSG_COLOR_LIGHTBLUE, msg);
+                sWorld->SendGlobalText(message, NULL);
+            break;
+
+
+
+
+        }
+        return true;
+    }
+
+    std::vector<ChatCommand> GetCommands() const override
+    {
+            static std::vector<ChatCommand> HandleWorldChatCommandTable =
+            {
+                { "world",  rbac::RBAC_PERM_COMMAND_WORLD_CHAT, true, &HandleWorldChatCommand, ""},
+            };
+            return HandleWorldChatCommandTable;
+    }
+};
+
+void AddSC_World_Chat()
+{
+        new World_Chat;
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/account_mount.cpp b/src/server/scripts/Custom/account_mount.cpp
new file mode 100644
index 0000000..19b0a38
--- /dev/null
+++ b/src/server/scripts/Custom/account_mount.cpp
@@ -0,0 +1,53 @@
+class AccountMounts : public PlayerScript
+{
+    static const bool limitrace = true; // This set to true will only learn mounts from chars on the same team, do what you want.
+public:
+    AccountMounts() : PlayerScript("AccountMounts") { }
+
+    void OnLogin(Player* player, bool /*firstLogin*/) override
+    {
+        std::vector<uint32> Guids;
+        uint32 playerGUID = player->GetGUID();
+        QueryResult result1 = CharacterDatabase.PQuery("SELECT guid, race FROM characters WHERE account = %u", playerGUID);
+        if (!result1)
+            return;
+
+        do 
+        {
+            Field* fields = result1->Fetch();
+
+            uint32 guid = fields[0].GetUInt32();
+            uint32 race = fields[1].GetUInt8();
+
+            if ((Player::TeamForRace(race) == Player::TeamForRace(player->getRace())) || !limitrace)
+                Guids.push_back(result1->Fetch()[0].GetUInt32());
+
+        } while (result1->NextRow());
+
+        std::vector<uint32> Spells;
+
+        for (auto& i : Guids)
+        {
+            QueryResult result2 = CharacterDatabase.PQuery("SELECT spell FROM character_spell WHERE guid = %u", i);
+            if (!result2)
+                continue;
+
+            do
+            {
+                Spells.push_back(result2->Fetch()[0].GetUInt32());
+            } while (result2->NextRow());
+        }
+
+        for (auto& i : Spells)
+        {
+            auto sSpell = sSpellStore.LookupEntry(i);
+            if (sSpell->Effect[0] == SPELL_EFFECT_APPLY_AURA && sSpell->EffectApplyAuraName[0] == SPELL_AURA_MOUNTED)
+                player->LearnSpell(sSpell->Id, false);
+        }
+    }
+};
+
+void AddSC_accontmounts()
+{
+    new AccountMounts;
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/all-in-one.cpp b/src/server/scripts/Custom/all-in-one.cpp
new file mode 100644
index 0000000..858b3b3
--- /dev/null
+++ b/src/server/scripts/Custom/all-in-one.cpp
@@ -0,0 +1,1329 @@
+/*
+
+
+Full NPC with lots of menus, and options.
+By: Blue
+Rewritten by: LordPsyan http://www.realmsofwarcraft.com
+Version: 4.0a // Will be updated
+
+/*-------------------------------------
+*
+*
+        DEFINES
+*
+//------------------------------------*/
+#include "Language.h"
+
+// Whisps
+#define notvip "You are not a VIP Member. Check website for details."
+#define yesvip "Welcome honored VIP Member"
+#define skillsmaxed "You skills are now maxed"
+#define votewhisper "Time to vote"
+#define donationhelp "Please donate to help the realm"
+#define normalhelp "If you need help, ask."
+#define ingamehelp "If you need help ingame, contact a GM"
+#define nosickness "You do not have Ressurection Sickness"
+#define nopet "You do not have a pet"
+#define welcome "Greetings Traveler. How can I help you?"
+
+// TOKEN ------------------------
+#define tokenbuy "I want to buy a %Servername% token."
+#define tokenchange "I want to change a %tokenname% to a %tokenname2%."
+
+// mails
+#define moneymail 60003
+
+// items
+#define token1 99999 // Token1 entry number (swap).
+#define token2 99998 // Token2 entry number (receive).
+#define vasarolhatotoken 100000 // Available as token -.-
+
+// Trainers
+#define dk        28474
+#define wari    914
+#define pala    23128
+#define sami    17204
+#define hunta    5115
+#define rogue    4584
+#define dudu    16655
+#define mage    28958
+#define priest    4090
+#define lock    23534
+
+//Teleport
+#define HMX -1854.022095f
+#define HMY -5412.382324f
+#define HMZ -12.428071f
+#define HMM 530
+
+#define AMX -1854.022095f
+#define AMY -5412.382324f
+#define AMZ -12.428071f
+#define AMM 530
+
+//Levelroad Teleport
+#define HLX 4613.816406f
+#define HLY -3589.231689f
+#define HLZ 994.164185f
+#define HLM 1
+
+#define ALX 6899.129883f
+#define ALY -2298.679932f
+#define ALZ 588.010986f
+#define ALM 1
+// DO NOT EDIT HERE //
+#define SPELL_ID_PASSIVE_RESURRECTION_SICKNESS  15007
+
+
+
+class npc_all : public CreatureScript
+{
+public:
+    npc_all() : CreatureScript("npc_all") { }
+
+        //struct npc_allAI : public ScriptedAI
+        //{
+
+bool OnGossipHello(Player *player, Creature *_Creature)
+
+{
+    _Creature->Whisper(welcome, LANG_UNIVERSAL, player);
+
+
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Morph", GOSSIP_SENDER_MAIN, 100);
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Teleport", GOSSIP_SENDER_MAIN, 101); // 1.1
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Set My Skills to Maximum", GOSSIP_SENDER_MAIN, 102);
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Trainers", GOSSIP_SENDER_MAIN, 103); // 1.2
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Server Menus", GOSSIP_SENDER_MAIN, 104);
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Funny Things", GOSSIP_SENDER_MAIN, 105);
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Announcer", GOSSIP_SENDER_MAIN, 106);
+    //player->ADD_GOSSIP_ITEM(0, "[Menu]Token Buy", GOSSIP_SENDER_MAIN, 107); // Not configured
+    //player->ADD_GOSSIP_ITEM(0, "[Menu]Token Change", GOSSIP_SENDER_MAIN, 108); // Not Configured
+    //player->ADD_GOSSIP_ITEM(0, "[Menu]Vote", GOSSIP_SENDER_MAIN, 113); // Not Configured
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Remove Sickness", GOSSIP_SENDER_MAIN, 120);
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Reset Talent Points", GOSSIP_SENDER_MAIN, 121);
+    //player->ADD_GOSSIP_ITEM(0, "[Menu]Reputations", GOSSIP_SENDER_MAIN, 123); // Not Configured. No Data.
+    //player->ADD_GOSSIP_ITEM(0, "[Menu]Titles", GOSSIP_SENDER_MAIN, 124); // No Data for adding titles.
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Buffs", GOSSIP_SENDER_MAIN, 125);
+
+
+        if (player->GetSession()->GetSecurity() >= 1)
+        {
+        _Creature->Whisper(yesvip, LANG_UNIVERSAL, player);
+        player->ADD_GOSSIP_ITEM(0, "[Menu]Battleground Control", GOSSIP_SENDER_MAIN, 109);
+        //player->ADD_GOSSIP_ITEM(0, "[Menu]Vip functions", GOSSIP_SENDER_MAIN, 110);// No Data.
+        } else { _Creature->Whisper(notvip, LANG_UNIVERSAL, player); }
+
+
+    player->SEND_GOSSIP_MENU(1, _Creature->GetGUID());
+    return true;
+}
+
+void SendDefaultMenu(Player *player, Creature *_Creature, uint32 action)
+{
+
+// Not allow in combat
+if (player->IsInCombat())
+{
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->Say("You are in combat!", LANG_UNIVERSAL);
+    return;
+}
+
+    switch(action)
+
+    {
+
+        //////////////// MAIN MENUS -> Normal Menus //////////////////
+    case 100: // Morphs
+        player->ADD_GOSSIP_ITEM(0, "Illidan", GOSSIP_SENDER_MAIN, 500);
+        player->ADD_GOSSIP_ITEM(0, "Kil'jaeden", GOSSIP_SENDER_MAIN, 501);
+        player->ADD_GOSSIP_ITEM(0, "Akama", GOSSIP_SENDER_MAIN, 502);
+        player->ADD_GOSSIP_ITEM(0, "Deathknight", GOSSIP_SENDER_MAIN, 503);
+        player->ADD_GOSSIP_ITEM(0, "Tauren", GOSSIP_SENDER_MAIN, 504);
+        player->ADD_GOSSIP_ITEM(0, "Undead", GOSSIP_SENDER_MAIN, 505);
+        player->ADD_GOSSIP_ITEM(0, "Human", GOSSIP_SENDER_MAIN, 506);
+        player->ADD_GOSSIP_ITEM(0, "Lich King", GOSSIP_SENDER_MAIN, 507);
+        player->ADD_GOSSIP_ITEM(0, "Tirion", GOSSIP_SENDER_MAIN, 508);
+        player->ADD_GOSSIP_ITEM(0, "Uther Lightbringer", GOSSIP_SENDER_MAIN, 509);
+        player->ADD_GOSSIP_ITEM(0, "Arthas", GOSSIP_SENDER_MAIN, 510);
+        ///////////// From SPGM
+        player->ADD_GOSSIP_ITEM(4, "Algalon", GOSSIP_SENDER_MAIN, 711);
+        player->ADD_GOSSIP_ITEM(4, "Doomwalker", GOSSIP_SENDER_MAIN, 712);
+        player->ADD_GOSSIP_ITEM(4, "Doomlord kazzak", GOSSIP_SENDER_MAIN, 713);
+        player->ADD_GOSSIP_ITEM(4, "Onyxia", GOSSIP_SENDER_MAIN, 714);
+        player->ADD_GOSSIP_ITEM(4, "Thaddius", GOSSIP_SENDER_MAIN, 715);
+        player->ADD_GOSSIP_ITEM(4, "Gluth", GOSSIP_SENDER_MAIN, 716);
+        player->ADD_GOSSIP_ITEM(4, "Maexxna", GOSSIP_SENDER_MAIN, 717);
+        player->ADD_GOSSIP_ITEM(4, "Sapphiron", GOSSIP_SENDER_MAIN, 718);
+        player->ADD_GOSSIP_ITEM(4, "Noth The Plaguebringer", GOSSIP_SENDER_MAIN, 719);
+        player->ADD_GOSSIP_ITEM(4, "Kel'Thuzad", GOSSIP_SENDER_MAIN, 720);
+        player->ADD_GOSSIP_ITEM(4, "Kael'thas Sunstrider", GOSSIP_SENDER_MAIN, 721);
+        player->ADD_GOSSIP_ITEM(4, "C'thun", GOSSIP_SENDER_MAIN, 722);
+        player->ADD_GOSSIP_ITEM(4, "Thrall", GOSSIP_SENDER_MAIN, 723);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+    break;
+
+
+    case 101: // Teleport
+        player->ADD_GOSSIP_ITEM(1, "Raids/Dungeons", GOSSIP_SENDER_MAIN, 600);
+        player->ADD_GOSSIP_ITEM(1, "Cities", GOSSIP_SENDER_MAIN, 601);
+        //player->ADD_GOSSIP_ITEM(1, "Fun places", GOSSIP_SENDER_MAIN, 602); // Only For Funservers. Not Configured
+        //player->ADD_GOSSIP_ITEM(1, "Events", GOSSIP_SENDER_MAIN, 603); // Funservers. Not Configured
+        player->ADD_GOSSIP_ITEM(1, "Areas", GOSSIP_SENDER_MAIN, 604);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+    case 102: // Skill maxer
+        player->CLOSE_GOSSIP_MENU();
+        player->UpdateSkillsToMaxSkillsForLevel();
+        _Creature->Whisper(skillsmaxed, LANG_UNIVERSAL, player);
+        break;
+
+    case 103: // Trainers
+
+        player->ADD_GOSSIP_ITEM(1, "Prof Trainer", GOSSIP_SENDER_MAIN, 800);
+        player->ADD_GOSSIP_ITEM(1, "Class Trainer", GOSSIP_SENDER_MAIN, 801);
+        //player->ADD_GOSSIP_ITEM(1, "Weapon Trainer", GOSSIP_SENDER_MAIN, 802); // Not Configured.
+        player->ADD_GOSSIP_ITEM(1, "Mount Trainer", GOSSIP_SENDER_MAIN, 803);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+    case 104: // Server Menus
+        //player->ADD_GOSSIP_ITEM(1, "Help! I've got hacked (Lock Account)", GOSSIP_SENDER_MAIN, 900);
+        player->ADD_GOSSIP_ITEM(0, "Report Lagg", GOSSIP_SENDER_MAIN, 901);
+        player->ADD_GOSSIP_ITEM(0, "Help", GOSSIP_SENDER_MAIN, 903);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+    case 105: // Funny Things, Need some more
+        player->ADD_GOSSIP_ITEM(0, "Money", GOSSIP_SENDER_MAIN, 1000); // DELETE THIS IF YOU DONT WANT PLAYERS TO GET MONEY
+        player->ADD_GOSSIP_ITEM(0, "Drunk", GOSSIP_SENDER_MAIN, 1001);
+        player->ADD_GOSSIP_ITEM(0, "Sober", GOSSIP_SENDER_MAIN, 1002);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+    case 106: // Announcer Part
+        player->ADD_GOSSIP_ITEM(0, "Join Warsong Guilch!", GOSSIP_SENDER_MAIN, 1100);
+        player->ADD_GOSSIP_ITEM(0, "Join Arathi Basin!", GOSSIP_SENDER_MAIN, 1101);
+        player->ADD_GOSSIP_ITEM(0, "Join Wintergrasp!", GOSSIP_SENDER_MAIN, 1102);
+        player->ADD_GOSSIP_ITEM(0, "Join Strand of the ancients!", GOSSIP_SENDER_MAIN, 1103);
+        player->ADD_GOSSIP_ITEM(0, "Join Alterac Valley!", GOSSIP_SENDER_MAIN, 1104);
+        player->ADD_GOSSIP_ITEM(0, "Join Random Battleground!", GOSSIP_SENDER_MAIN, 1105);
+        player->ADD_GOSSIP_ITEM(0, "Join Arena 2v2!", GOSSIP_SENDER_MAIN, 1106);
+        player->ADD_GOSSIP_ITEM(0, "Join Arena 3v3!", GOSSIP_SENDER_MAIN, 1107);
+        player->ADD_GOSSIP_ITEM(0, "Join Arena 5v5!", GOSSIP_SENDER_MAIN, 1108);
+        player->ADD_GOSSIP_ITEM(0, "Join Eye of the Storm!", GOSSIP_SENDER_MAIN, 1109);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+    case 107: // Token -> BUY
+        player->ADD_GOSSIP_ITEM(0, tokenbuy, GOSSIP_SENDER_MAIN, 1200);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+    case 108: // Token ->Change
+        player->ADD_GOSSIP_ITEM(0, tokenchange, GOSSIP_SENDER_MAIN, 1300);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+    case 109: // Battleground function
+        player->ADD_GOSSIP_ITEM(0, "WSG 100%", GOSSIP_SENDER_MAIN, 1400);
+        player->ADD_GOSSIP_ITEM(0, "EOTS 100%", GOSSIP_SENDER_MAIN, 1401);
+        player->ADD_GOSSIP_ITEM(0, "AB 100%", GOSSIP_SENDER_MAIN, 1402);
+        player->ADD_GOSSIP_ITEM(0, "SOTA 100%", GOSSIP_SENDER_MAIN, 1403);
+        player->ADD_GOSSIP_ITEM(0, "AV 100%", GOSSIP_SENDER_MAIN, 1404); // LOL!
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+    case 110: // VIP Functions, from another script(by me :D)
+        player->ADD_GOSSIP_ITEM(0, "Repair", GOSSIP_SENDER_MAIN, 1500);
+        player->ADD_GOSSIP_ITEM(0, "Nyugit szeretnk", GOSSIP_SENDER_MAIN, 1501);
+        player->ADD_GOSSIP_ITEM(0, "Surgery", GOSSIP_SENDER_MAIN, 1502);
+        player->ADD_GOSSIP_ITEM(0, "Faction change", GOSSIP_SENDER_MAIN, 1503);
+        player->ADD_GOSSIP_ITEM(0, "Race Change", GOSSIP_SENDER_MAIN, 1504);
+        //player->ADD_GOSSIP_ITEM(0, "Move?", GOSSIP_SENDER_MAIN, 1505); Not yet implemented
+        player->ADD_GOSSIP_ITEM(0, "Name Change", GOSSIP_SENDER_MAIN, 1506);
+        player->ADD_GOSSIP_ITEM(0, "Save Character", GOSSIP_SENDER_MAIN, 1507);
+        player->ADD_GOSSIP_ITEM(0, "Mailbox", GOSSIP_SENDER_MAIN, 1508);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+    case 111: // VOte
+        _Creature->Whisper(votewhisper, LANG_UNIVERSAL, player);
+        player->ADD_GOSSIP_ITEM(0, "1 - %VOTE1%", GOSSIP_SENDER_MAIN, 1600);
+        player->ADD_GOSSIP_ITEM(0, "2 - %VOTE2%", GOSSIP_SENDER_MAIN, 1601);
+        player->ADD_GOSSIP_ITEM(0, "3 - %VOTE3%", GOSSIP_SENDER_MAIN, 1602);
+        player->ADD_GOSSIP_ITEM(0, "4 - %VOTE4%", GOSSIP_SENDER_MAIN, 1603);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+    case 124: // Titles, Not Ready Yet!
+        player->ADD_GOSSIP_ITEM(0, "Jenkins", GOSSIP_SENDER_MAIN, 3000);
+        player->ADD_GOSSIP_ITEM(0, "Loremaster", GOSSIP_SENDER_MAIN, 3001);
+        player->ADD_GOSSIP_ITEM(0, "the Seeker", GOSSIP_SENDER_MAIN, 3002);
+        player->ADD_GOSSIP_ITEM(0, "the Argent Defender", GOSSIP_SENDER_MAIN, 3003);
+        player->ADD_GOSSIP_ITEM(0, "Bane of the Fallen King", GOSSIP_SENDER_MAIN, 3004);
+        player->ADD_GOSSIP_ITEM(0, "Champion of the Frozen Wastes", GOSSIP_SENDER_MAIN, 3005);
+        player->ADD_GOSSIP_ITEM(0, "Champion of the Naaru", GOSSIP_SENDER_MAIN, 3006);
+        player->ADD_GOSSIP_ITEM(0, "Conqueror of Naxxramas", GOSSIP_SENDER_MAIN, 3007);
+        player->ADD_GOSSIP_ITEM(0, "Conqueror of Ulduar", GOSSIP_SENDER_MAIN, 3008);
+        player->ADD_GOSSIP_ITEM(0, "Hand of A'dal", GOSSIP_SENDER_MAIN, 3009);
+        player->ADD_GOSSIP_ITEM(0, "the Immortal", GOSSIP_SENDER_MAIN, 3010);
+        player->ADD_GOSSIP_ITEM(0, "the Patient", GOSSIP_SENDER_MAIN, 3011);
+        player->ADD_GOSSIP_ITEM(0, "the Undying", GOSSIP_SENDER_MAIN, 3012);
+        player->ADD_GOSSIP_ITEM(0, "Ambassador", GOSSIP_SENDER_MAIN, 3013);
+        player->ADD_GOSSIP_ITEM(0, "Bloodsail Admiral", GOSSIP_SENDER_MAIN, 3014);
+        player->ADD_GOSSIP_ITEM(0, "Crusader", GOSSIP_SENDER_MAIN, 3015);
+        player->ADD_GOSSIP_ITEM(0, "the Diplomat", GOSSIP_SENDER_MAIN, 3016);
+        player->ADD_GOSSIP_ITEM(0, "the Exalted", GOSSIP_SENDER_MAIN, 3017);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+        /// Buffer part
+    case 125: // buffer
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Power Word: Fortitude, Rank 8", GOSSIP_SENDER_MAIN, 4000);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Greater Blessing of Kings", GOSSIP_SENDER_MAIN, 4001);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Greater Bleesing of Mights", GOSSIP_SENDER_MAIN,4002);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Greater Blessing of Wisdom", GOSSIP_SENDER_MAIN, 4003);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Mark of the Wild, Rank 9", GOSSIP_SENDER_MAIN, 4004);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Arcane Intellect, Rank 7", GOSSIP_SENDER_MAIN, 4005);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Soul Stone", GOSSIP_SENDER_MAIN, 4006);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Thorns, Rank 8", GOSSIP_SENDER_MAIN, 4007);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Divine Spirit, Rank 8", GOSSIP_SENDER_MAIN, 4008);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Shadow Protection, Rank 5", GOSSIP_SENDER_MAIN, 4009);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+         break;
+
+    case 4000:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 48161, false); // target, spellid, triggered-e
+        break;
+
+        case 4001:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 25898, false);
+        break;
+
+        case 4002:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 48934, false);
+        break;
+
+        case 4003:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 48938, false);
+        break;
+
+        case 4004:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 48469, false);
+        break;
+
+        case 4005:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 42995, false);
+        break;
+
+        case 4006:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 47883, false);
+        break;
+
+        case 4007:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 53307, false);
+        break;
+
+        case 4008:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 48073, false);
+        break;
+
+        case 4009:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 48169, false);
+        break;
+
+
+        /////////// NORMAL MENUS -> ACTION OR MENU
+
+
+
+        ///-- Server Menus part start --///
+        /*case 900: // Hacked
+        // Closes the account
+        LoginDatabase.PQuery("UPDATE `account` SET `locked`=1 WHERE `id`='%s'", player->GetSession()->GetAccountId());
+        LoginDatabase.PQuery("INSERT INTO `hacked` (`charname`) VALUES ('%s'", player); // Report it to the DB.
+        break;
+*/
+        case 901: // Report lagg
+        /*player->CLOSE_GOSSIP_MENU();
+        _Creature->Whisper(('%s', player->GetSession()->GetAccountId()), player);
+        LoginDatabase.PExecute("INSERT INTO `lagreports` (`account`) VALUES ('%s'", player->GetSession()->GetAccountId());
+        _Creature->Whisper("Lagg report done.", LANG_UNIVERSAL, player);*/
+        break;
+
+        case 902: // Help
+        player->ADD_GOSSIP_ITEM(0, "Donation Help", GOSSIP_SENDER_MAIN, 1700);
+        player->ADD_GOSSIP_ITEM(0, "Ingame Help", GOSSIP_SENDER_MAIN, 1701);
+        player->ADD_GOSSIP_ITEM(0, "Normal Help", GOSSIP_SENDER_MAIN, 1702);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+        case 1700: // Donation Help
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->Whisper("Donations can be done on www.realmsofwarcraft.com", LANG_UNIVERSAL, player);
+        break;
+
+        case 1701: // INGAME HELP
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->Whisper("Contact a GM for help", LANG_UNIVERSAL, player);
+        break;
+
+        case 1702: // Normal Help
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->Whisper("Helpful information can be found on www.realmsofwarcraft.com", LANG_UNIVERSAL, player);
+        break;
+        /// -- Server Menus part End -- ///
+
+        /// -- Funny Things Menu Start -- /// money drunk sober
+
+        case 1000: // Money
+        player->CLOSE_GOSSIP_MENU();
+        player->GetMail(moneymail);
+        _Creature->Whisper("Check your mailbox.", LANG_UNIVERSAL, player);
+        break;
+
+        case 1001: // Drunk
+        player->CLOSE_GOSSIP_MENU();
+        player->CastSpell(player, 46876, false);
+        break;
+
+        case 1002: // Sober
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDrunkValue(0, 9);
+        break;
+        /// -- Funny Things Menu End -- ///
+
+        /// -- Announcer Part Start -- ///
+
+        case 1100:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).PSendSysMessage(LANG_WSG);
+        break;
+
+        case 1101:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).SendSysMessage(LANG_AB);
+        break;
+
+        case 1102:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).SendSysMessage(LANG_WG);
+        break;
+
+        case 1103:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).SendSysMessage(LANG_SOTA);
+        break;
+
+        case 1104:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).SendSysMessage(LANG_AV);
+        break;
+
+        case 1105:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).SendSysMessage(LANG_RANDOM);
+        break;
+
+        case 1106:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).SendSysMessage(LANG_ARENA_1);
+        break;
+
+        case 1107:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).SendSysMessage(LANG_ARENA_2);
+        break;
+
+        case 1108:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).SendSysMessage(LANG_ARENA_3);
+        break;
+
+        case 1109:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).SendSysMessage(LANG_EOTS);
+        break;
+
+        /// -- Announcer part end -- ///
+
+        /////////////////////////////////
+        //        BREAK           //
+        //////////////////////////////////
+        //////////////////////////////////
+
+    /*************************************************************************/
+
+        /// -- Morph Part Start -- ///
+
+               case 500:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(21135);
+        break;
+
+        case 501:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(23200);
+        break;
+
+        case 502:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(20681);
+        break;
+
+        case 503:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(16508);
+        break;
+
+        case 504:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(17332);
+        break;
+
+        case 505:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(2789);
+        break;
+
+        case 506:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(16280);
+        break;
+
+        case 507:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(24191);
+        break;
+
+        case 508:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(22209);
+        break;
+
+        case 509:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(23889);
+        break;
+
+        case 510:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(24949);
+        break;
+
+        case 711: // Algalon
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(28641);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.2f);
+        break;
+
+        case 712: // Doomwalker
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(16630);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.1f);
+        break;
+
+        case 713: // Doomlord kazzak
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(17887);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.10f);
+        break;
+
+        case 714: // Onyxia
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(8570);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.1f);
+        break;
+
+        case 715: // Thaddius
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(16137);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.2f);
+        break;
+
+        case 716: // Gluth
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(16064);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.2f);
+        break;
+
+        case 717: // Maexxna
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(15928);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.15f);
+        break;
+
+        case 718: // Sapphiron
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(16033);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.1f);
+        break;
+
+        case 719: // Noth The Plaguebringer
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(16590);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.7f);
+        break;
+
+        case 720: // Kel'Thuzad
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(15945);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.2f);
+        break;
+
+        case 721: // Kael'thas Sunstrider
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(20023);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.5f);
+        break;
+
+        case 722: // C'thun
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(15786);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.1f);
+        break;
+
+        case 723: // Thrall
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(4527);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 1.0f);
+        break;
+
+/// -- Morph Part End -- ///
+
+
+
+
+
+
+
+/// -- Teleport Part Start -- ///
+        case 600: // Raid dungeon , cities
+        player->ADD_GOSSIP_ITEM(0, "ICC", GOSSIP_SENDER_MAIN, 1900);
+        player->ADD_GOSSIP_ITEM(0, "Naxxramas", GOSSIP_SENDER_MAIN, 1901);
+        player->ADD_GOSSIP_ITEM(0, "Ulduar", GOSSIP_SENDER_MAIN, 1902);
+        player->ADD_GOSSIP_ITEM(0, "Nexus", GOSSIP_SENDER_MAIN, 1903);
+        player->ADD_GOSSIP_ITEM(0, "Argent Tournament Grounds", GOSSIP_SENDER_MAIN, 1904);
+        player->ADD_GOSSIP_ITEM(0, "Azjol-Nerub", GOSSIP_SENDER_MAIN, 1905);
+        player->ADD_GOSSIP_ITEM(0, "Drak' Tharon Keep", GOSSIP_SENDER_MAIN, 1906);
+        player->ADD_GOSSIP_ITEM(0, "Gundrak", GOSSIP_SENDER_MAIN, 1907);
+        player->ADD_GOSSIP_ITEM(0, "Utgarde Keep", GOSSIP_SENDER_MAIN, 1908);
+        player->ADD_GOSSIP_ITEM(0, "Utgarde Pinnacle", GOSSIP_SENDER_MAIN, 1909);
+        player->ADD_GOSSIP_ITEM(0, "Vault of Archavon", GOSSIP_SENDER_MAIN, 1910);
+        player->ADD_GOSSIP_ITEM(0, "Violet Hold", GOSSIP_SENDER_MAIN, 1911);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+        case 601: // Cities
+
+        player->ADD_GOSSIP_ITEM(0, "Teleport Stormwind", GOSSIP_SENDER_MAIN, 1800);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Ironforge", GOSSIP_SENDER_MAIN, 1801);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Darnassus", GOSSIP_SENDER_MAIN, 1802);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Exodar", GOSSIP_SENDER_MAIN, 1803);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Shattrath", GOSSIP_SENDER_MAIN, 1804);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Dalaran", GOSSIP_SENDER_MAIN, 1805);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Gurubashi Arena", GOSSIP_SENDER_MAIN, 1806);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Orgrimmar", GOSSIP_SENDER_MAIN, 1807);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Undercity", GOSSIP_SENDER_MAIN, 1808);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Silvermoon", GOSSIP_SENDER_MAIN, 1809);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Thunder Bluff", GOSSIP_SENDER_MAIN, 1810);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Alliance Mall", GOSSIP_SENDER_MAIN, 5000);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Alliance LevelRoad", GOSSIP_SENDER_MAIN, 9998);
+
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+        case 604: // areas
+        player->ADD_GOSSIP_ITEM(0, "Azuremyst Isle", GOSSIP_SENDER_MAIN, 1850);
+        player->ADD_GOSSIP_ITEM(0, "Teldrassil", GOSSIP_SENDER_MAIN, 1851);
+        player->ADD_GOSSIP_ITEM(0, "Elwynn Forest", GOSSIP_SENDER_MAIN, 1852);
+        player->ADD_GOSSIP_ITEM(0, "Dun Morogh", GOSSIP_SENDER_MAIN, 1853);
+        player->ADD_GOSSIP_ITEM(0, "Durotar", GOSSIP_SENDER_MAIN, 1854);
+        player->ADD_GOSSIP_ITEM(0, "Mulgore", GOSSIP_SENDER_MAIN, 1855);
+        player->ADD_GOSSIP_ITEM(0, "Tirisfal Glades", GOSSIP_SENDER_MAIN, 1856);
+        player->ADD_GOSSIP_ITEM(0, "Eversong Woods", GOSSIP_SENDER_MAIN, 1857);
+        player->ADD_GOSSIP_ITEM(0, "Darkshore", GOSSIP_SENDER_MAIN, 1858);
+        player->ADD_GOSSIP_ITEM(0, "Loch Modan", GOSSIP_SENDER_MAIN, 1859);
+        player->ADD_GOSSIP_ITEM(0, "Redridge Mountains", GOSSIP_SENDER_MAIN, 1860);
+        player->ADD_GOSSIP_ITEM(0, "Barrens", GOSSIP_SENDER_MAIN, 1861);
+        player->ADD_GOSSIP_ITEM(0, "Stonetalon Mountains", GOSSIP_SENDER_MAIN, 1862);
+        player->ADD_GOSSIP_ITEM(0, "Ashenvale", GOSSIP_SENDER_MAIN, 1863);
+        player->ADD_GOSSIP_ITEM(0, "Wetlands", GOSSIP_SENDER_MAIN, 1864);
+        player->ADD_GOSSIP_ITEM(0, "Thousand Needles", GOSSIP_SENDER_MAIN, 1865);
+        player->ADD_GOSSIP_ITEM(0, "Hillsbrad Foothills", GOSSIP_SENDER_MAIN, 1866);
+        player->ADD_GOSSIP_ITEM(0, "Arathi Highlands", GOSSIP_SENDER_MAIN, 1867);
+        player->ADD_GOSSIP_ITEM(0, "Desolace", GOSSIP_SENDER_MAIN, 1868);
+        player->ADD_GOSSIP_ITEM(0, "Stranglethorn Vale", GOSSIP_SENDER_MAIN, 1869);
+        player->ADD_GOSSIP_ITEM(0, "Badlands", GOSSIP_SENDER_MAIN, 1870);
+        player->ADD_GOSSIP_ITEM(0, "Swamp of Sorrows", GOSSIP_SENDER_MAIN, 1871);
+        player->ADD_GOSSIP_ITEM(0, "The Hinterlands", GOSSIP_SENDER_MAIN, 1872);
+        player->ADD_GOSSIP_ITEM(0, "Tanaris", GOSSIP_SENDER_MAIN, 1873);
+        player->ADD_GOSSIP_ITEM(0, "Blasted Lands", GOSSIP_SENDER_MAIN, 1874);
+        player->ADD_GOSSIP_ITEM(0, "Searing Gorge", GOSSIP_SENDER_MAIN, 1875);
+        player->ADD_GOSSIP_ITEM(0, "Un Goro Crater", GOSSIP_SENDER_MAIN, 1876);
+        player->ADD_GOSSIP_ITEM(0, "Azshara", GOSSIP_SENDER_MAIN, 1877);
+        player->ADD_GOSSIP_ITEM(0, "Felwood", GOSSIP_SENDER_MAIN, 1878);
+        player->ADD_GOSSIP_ITEM(0, "Winterspring", GOSSIP_SENDER_MAIN, 1879);
+        player->ADD_GOSSIP_ITEM(0, "Silithus", GOSSIP_SENDER_MAIN, 1880);
+        player->ADD_GOSSIP_ITEM(0, "Western Plaguelands", GOSSIP_SENDER_MAIN, 1881);
+        player->ADD_GOSSIP_ITEM(0, "Burning Steppes", GOSSIP_SENDER_MAIN, 1882);
+        player->ADD_GOSSIP_ITEM(0, "Hellfire Peninsula", GOSSIP_SENDER_MAIN, 1883);
+        player->ADD_GOSSIP_ITEM(0, "Zangarmarsh", GOSSIP_SENDER_MAIN, 1884);
+        player->ADD_GOSSIP_ITEM(0, "Terokkar Forest", GOSSIP_SENDER_MAIN, 1885);
+        player->ADD_GOSSIP_ITEM(0, "Nagrand", GOSSIP_SENDER_MAIN, 1886);
+        player->ADD_GOSSIP_ITEM(0, "Blades Edge Mountain", GOSSIP_SENDER_MAIN, 1887);
+        player->ADD_GOSSIP_ITEM(0, "Netherstorm", GOSSIP_SENDER_MAIN, 1888);
+        player->ADD_GOSSIP_ITEM(0, "Shadowmoon Valley", GOSSIP_SENDER_MAIN, 1889);
+        player->ADD_GOSSIP_ITEM(0, "Borean Tundra", GOSSIP_SENDER_MAIN, 1890);
+        player->ADD_GOSSIP_ITEM(0, "Dragonblight", GOSSIP_SENDER_MAIN, 1891);
+        player->ADD_GOSSIP_ITEM(0, "Grizzly Hills", GOSSIP_SENDER_MAIN, 1892);
+        player->ADD_GOSSIP_ITEM(0, "Zul'Drak", GOSSIP_SENDER_MAIN, 1893);
+        player->ADD_GOSSIP_ITEM(0, "Sholazar Basin", GOSSIP_SENDER_MAIN, 1894);
+        player->ADD_GOSSIP_ITEM(0, "The Storm Peaks", GOSSIP_SENDER_MAIN, 1895);
+        player->ADD_GOSSIP_ITEM(0, "Howling Fjord", GOSSIP_SENDER_MAIN, 1896);
+        player->ADD_GOSSIP_ITEM(0, "Icecrown", GOSSIP_SENDER_MAIN, 1897);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+        /// tele loactions
+
+        // RAIDS & Dungeons
+
+        case 1900: // icc
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 5873.819824f, 2110.979980f, 636.010986f, 0.0f);
+            break;
+
+        case 1901: // Naxxramas
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 3665.904053f, -1267.064575f, 243.512207f, 0.0f);
+            break;
+
+        case 1902: // Ulduar
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 8948.200165f, -1268.270020f, 1025.500000f, 0.0f);
+            break;
+        case 1903: // Nexus
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 3785.800049f, 6944.919922f, 104.620003f, 0.0f);
+            break;
+        case 1904: // Argent tournement
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 8513.266602f, 638.120728f, 547.324890f, 0.0f);
+            break;
+        case 1905: // Azjol-Nerub
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 3707.86f, 2150.23f, 36.7568f, 0.0f);
+            break;
+        case 1906: // Drak' Tharon Keep
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 4774.6f, -2032.92f, 229.145f, 0.0f);
+            break;
+        case 1907: // Gundrak
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 6910.8f, -4603.23f, 450.61f, 0.0f);
+            break;
+        case 1908: // Utgarde Keep
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 1219.72f, -4865.28f, 41.2479f, 0.0f);
+            break;
+        case 1909: // Utgarde Pinnacle
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 1259.33f, -4852.02f, 215.763f, 0.0f);
+            break;
+        case 1910: // Vault of Archavon
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 5453.72f, 2840.79f, 421.277f, 0.0f);
+            break;
+        case 1911: // Violet Hold
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 5689.03f, 508.278f, 652.763f, 0.0f);
+            break;
+
+/////// cities
+
+        case 1800: // Stormwind
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -8960.14f, 516.266f, 96.3568f, 0.0f); // Teleport(location)
+        break;
+
+        case 1801: // Ironforge
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -4924.07f, -951.95f, 501.55f, 5.40f);
+        break;
+
+        case 1802: // Darnassus
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 9947.52f, 2482.73f, 1316.21f, 0.0f);
+        break;
+
+        case 1803: // Exodar
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -3954.20f, -11656.54f, -138.69f, 0.0f);
+        break;
+
+        case 1804: // Shattrath
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -1850.209961f, 5435.821777f, -10.961435f, 3.403913f);
+        break;
+
+        case 1805: // Dalaran
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 5819.08f, 643.99f, 647.80f, 3.32f);
+        break;
+
+        case 1806: // Gurubashi Arena
+        player->CLOSE_GOSSIP_MENU();
+
+        player->TeleportTo(0,  -13277.4f, 127.372f, 26.1418f, 1.0f);
+        break;
+
+        case 1807: // Orgrimmar
+         player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 1552.5f, -4420.66f, 8.94802f, 0.0f);
+        break;
+
+        case 1808: // Undercity
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, 1819.71f, 238.79f, 60.5321f, 0.0f);
+
+        break;
+
+        case 1809: // Silvermoon
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, 9338.74f, -7277.27f, 13.7895f, 0.0f);
+        break;
+
+        case 1810: // Thunder Bluff
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -1290.0f, 147.033997f, 129.682007f, 4.919000f);
+        break;
+
+        case 5001: // Horde Mall
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(HMM, HMX, HMY, HMZ, 0.0f);
+        break;
+
+        case 5000: // Alliance Mall
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(AMM, AMX, AMY, AMZ, 0.0f);
+        break;
+
+// Leveling Roads
+        case 9999:    // horde level road
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(HLM, HLX, HLY, HLZ, 0.0f);
+        break;
+
+        case 9998:    //alliance level road
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(ALM, ALX, ALY, ALZ, 0.0f);
+        break;
+// Zones
+        case 1850:  // Azuremyst Isle
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -4216.870117f, -12336.900391f, 4.340638f, 0.0f);
+        break;
+        case 1851:  // Teldrassil
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 10111.299805f, 1557.729980f, 1324.329956f, 0.0f);
+        break;
+        case 1852:  // Elwynn Forest
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -9617.059570f, -288.949005f, 57.305149f, 0.0f);
+        break;
+        case 1853:  // Dun Morogh
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -5451.549805f, -656.992004f, 392.674988f, 0.0f);
+        break;
+        case 1854:  // Durotar
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 1007.780029f, -446.220215f, 11.202200f, 0.0f);
+        break;
+        case 1855:  // Mulgore
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -2192.620117f, -736.317017f, -13.327400f, 0.0f);
+        break;
+        case 1856:  // Tirisfal Glades
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, 2036.020020f, 161.330994f, 33.867401f, 0.0f);
+        break;
+        case 1857:  // Eversong Woods
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, 9079.919922f, -7193.229980f, 55.601299f, 0.0f);
+        break;
+        case 1858:  // Darkshore
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 5756.250000f, 298.505005f, 20.604900f, 0.0f);
+        break;
+        case 1859:  // Loch Modan
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -5202.939941f, -2855.179932f, 335.953827f, 0.0f);
+        break;
+        case 1860:  // Redridge Mountains
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -9551.809570f, -2204.729980f, 93.473000f, 0.0f);
+        break;
+        case 1861:  // The Barrens
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 884.539978f, -3548.449951f, 91.853165f, 0.0f);
+        break;
+        case 1862:  // Stonetalon Mountains
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 1570.920044f, 1031.520020f, 137.959000f, 0.0f);
+        break;
+        case 1863:  // Ashenvale
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 1928.339966f, -2165.949951f, 93.789597f, 0.0f);
+        break;
+        case 1864:  // Wetlands
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -3242.810059f, -2469.040039f, 15.922600f, 0.0f);
+        break;
+        case 1865:  // Thousand Needles
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -4969.020020f, -1726.890015f, -62.126911f, 0.0f);
+        break;
+        case 1866:  // Hillsbrad Foothills
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -436.657013f, -581.254028f, 53.594398f, 0.0f);
+        break;
+        case 1867:  // Arathi Highlands
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -1508.510010f, -2732.060059f, 32.498600f, 0.0f);
+        break;
+        case 1868:  // Desolace
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -606.395020f, 2211.750000f, 92.981796f, 0.0f);
+        break;
+        case 1869:  // Stranglethorn Vale
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -12644.299805f, -377.411011f, 10.102062f, 0.0f);
+        break;
+        case 1870:  // Badlands
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -6779.200195f, -3423.639893f, 241.667007f, 0.0f);
+        break;
+        case 1871:  // Spawm of Sorrows
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -10345.400391f, -2773.419922f, 21.990000f, 0.0f);
+        break;
+        case 1872:  // The Hinterlands
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, 119.387001f, -3190.370117f, 117.330994f, 0.0f);
+        break;
+        case 1873:  // Tanaris
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -7931.200195f, -3414.280029f, 80.736496f, 0.0f);
+        break;
+        case 1874:  // Blasted Lands
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -11182.500000f, -3016.669922f, 7.422350f, 0.0f);
+        break;
+        case 1875:  // Searing Gorge
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -7012.470215f, -1065.130005f, 241.785995f, 0.0f);
+        break;
+        case 1876:  // Un Goro Crater
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -7943.220215f, -2119.090088f, -218.344589f, 0.0f);
+        break;
+        case 1877:  // Azshara
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 3341.360107f, -4603.790039f, 92.502701f, 0.0f);
+        break;
+        case 1878:  // Felwood
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 4102.250000f, -1006.789978f, 272.717010f, 0.0f);
+        break;
+        case 1879:  // Winterspring
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 6759.180176f, -4419.629883f, 763.213989f, 0.0f);
+        break;
+        case 1880:  // Silithus
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -7426.870117f, 1005.309998f, 1.133590f, 0.0f);
+        break;
+        case 1881:  // Western Plaguelands
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, 1728.650024f, -1602.250000f, 63.428963f, 0.0f);
+        break;
+        case 1882:  // Burning Steppes
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -8118.540039f, -1633.829956f, 132.996002f, 0.0f);
+        break;
+        case 1883:  // Hellfire Peninsula
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -211.237000f, 4278.540039f, 86.567802f, 0.0f);
+        break;
+        case 1884:  // Zangarmarsh
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -54.862099f, 5813.439941f, 20.605900f, 0.0f);
+        break;
+        case 1885:  // Terokkar Forest
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -2000.469971f, 4451.540039f, 8.369170f, 0.0f);
+        break;
+        case 1886:  // Nagrand
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -1145.949951f, 8182.350098f, 3.602490f, 0.0f);
+        break;
+        case 1887:  // Blades Edge Mountain
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, 3037.669922f, 5962.859863f, 130.774002f, 0.0f);
+        break;
+        case 1888:  // Netherstorm
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, 3830.229980f, 3426.500000f, 88.614502f, 0.0f);
+        break;
+        case 1889:  // Shadowmoon Valley
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -3077.271973f, 2878.689209f, 82.129242f, 0.0f);
+        break;
+        case 1890:  // Borean Tundra
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 3256.570068f, 5278.229980f, 40.804588f, 0.0f);
+        break;
+        case 1891:  // Dragonblight
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 4103.359863f, 264.477997f, 50.501900f, 0.0f);
+        break;
+        case 1892:  // Grizzly Hills
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 4391.729980f, -3587.919922f, 238.531006f, 0.0f);
+        break;
+        case 1893:  // Zul' Drak
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 5560.229980f, -3211.659912f, 371.709015f, 0.0f);
+        break;
+        case 1894:  // Sholazar Basin
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 5323.000000f, 4942.000000f, -133.558670f, 0.0f);
+        break;
+        case 1895:  // The Storm Peaks
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 7527.140137f, -1260.890015f, 919.049011f, 0.0f);
+        break;
+        case 1896:  // Howling Fjord
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 1902.150024f, -4883.910156f, 161.363007f, 0.0f);
+        break;
+        case 1897:  // Icecrown
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 7253.640137f, 1644.780029f, 433.679993f, 0.0f);
+        break;
+
+
+        /// -- Tele part stop -- ///
+
+    /// -- Dungeons, Raids -- ///
+
+
+        /// -- BG Control Part Start -- ///
+            player->ADD_GOSSIP_ITEM(0, "WSG 100%", GOSSIP_SENDER_MAIN, 1400);
+        player->ADD_GOSSIP_ITEM(0, "EOTS 100%", GOSSIP_SENDER_MAIN, 1401);
+        player->ADD_GOSSIP_ITEM(0, "AB 100%", GOSSIP_SENDER_MAIN, 1402);
+        player->ADD_GOSSIP_ITEM(0, "SOTA 100%", GOSSIP_SENDER_MAIN, 1403);
+        player->ADD_GOSSIP_ITEM(0, "AV 100%", GOSSIP_SENDER_MAIN, 1404); // LOL!
+
+        case 1400: // WSG 100%
+        /* Comment: IDS:
+        SOTA - 9
+        AV - 1
+        WSG - 2
+        AB - 3
+        EOTS - 7*/
+        player->CLOSE_GOSSIP_MENU();
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=0 WHERE `id` IN(1, 3, 7, 9)");
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=10 WHERE `id`=2");
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Done", GOSSIP_SENDER_MAIN, 12345);
+        break;
+
+        case 1401: // EOTS 100%
+        player->CLOSE_GOSSIP_MENU();
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=0 WHERE `id` IN(1, 3, 2, 9)");
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=10 WHERE `id`=7");
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Done", GOSSIP_SENDER_MAIN, 12345);
+        break;
+
+        case 1402: // AB 100%
+        player->CLOSE_GOSSIP_MENU();
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=0 WHERE `id` IN(1, 2, 7, 9)");
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=10 WHERE `id`=3");
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Done", GOSSIP_SENDER_MAIN, 12345);
+        break;
+
+        case 1403: // Sota 100%
+        player->CLOSE_GOSSIP_MENU();
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=0 WHERE `id` IN(1, 3, 7, 2)");
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=10 WHERE `id`=9");
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Done", GOSSIP_SENDER_MAIN, 12345);
+        break;
+
+        case 1404: // AV 100%
+        player->CLOSE_GOSSIP_MENU();
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=0 WHERE `id` IN(2, 3, 7, 9)");
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=10 WHERE `id`=1");
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Done", GOSSIP_SENDER_MAIN, 12345);
+        break;
+
+        /// -- BG Modify Part End -- ///
+
+        /* Break */
+
+
+
+
+
+        /// -- Token Part Start -- ///
+
+        /*
+            case 107: // Token -> BUY
+        player->ADD_GOSSIP_ITEM(0, tokenbuy, GOSSIP_SENDER_MAIN, 1200);
+        break;
+
+        case 108: // Token ->Change
+        player->ADD_GOSSIP_ITEM(0, tokenchange, GOSSIP_SENDER_MAIN, 1300);
+        break;
+        */
+
+        case 1201: // Token change
+        if(player->HasItemCount(token1, 1, false))
+        {
+        player->ItemRemovedQuestCheck(token1, 1);
+        player->AddItem(token2, 1);
+        } else {
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "You don't have got enough token.", GOSSIP_SENDER_MAIN, 12345);
+        break;
+        }
+
+        case 1200:
+        player->ADD_GOSSIP_ITEM_EXTENDED(0, tokenbuy, GOSSIP_SENDER_MAIN, 2000, "Are you sure you want to buy a token?", -10000, 0);
+        break;
+        case 2000:
+        player->AddItem(vasarolhatotoken, 1);
+        break;
+
+        ///-- Token Part End --///
+
+        ///-- Trainers Part Start --///
+        /*
+        player->ADD_GOSSIP_ITEM(1, "Prof Trainer", GOSSIP_SENDER_MAIN, 800);
+        player->ADD_GOSSIP_ITEM(1, "Class Trainer", GOSSIP_SENDER_MAIN, 801);
+        player->ADD_GOSSIP_ITEM(1, "Weapon Trainer", GOSSIP_SENDER_MAIN, 802);
+        player->ADD_GOSSIP_ITEM(1, "Mount Trainer", GOSSIP_SENDER_MAIN, 803);
+        */
+
+        case 803: // Mount Trainer
+        {
+        player->CLOSE_GOSSIP_MENU();
+        player->LearnSpell(33388, false);
+        player->LearnSpell(33391, false);
+        player->LearnSpell(34090, false);
+        player->LearnSpell(34091, false);
+        player->LearnSpell(54197, false);
+        }
+
+        case 800: // profs
+        // SPGM
+        player->ADD_GOSSIP_ITEM(3, "Alchemy"                     , GOSSIP_SENDER_MAIN, 2100);
+        player->ADD_GOSSIP_ITEM(3, "Blacksmithing"           , GOSSIP_SENDER_MAIN, 2101);
+        player->ADD_GOSSIP_ITEM(3, "Enchanter"        , GOSSIP_SENDER_MAIN, 2102);
+        player->ADD_GOSSIP_ITEM(3, "Engineering"              , GOSSIP_SENDER_MAIN, 2103);
+        player->ADD_GOSSIP_ITEM(3, "Herbalism"            , GOSSIP_SENDER_MAIN, 2104);
+        player->ADD_GOSSIP_ITEM(3, "Inscription"        , GOSSIP_SENDER_MAIN, 2105);
+        player->ADD_GOSSIP_ITEM(3, "Jewelcrafting"           , GOSSIP_SENDER_MAIN, 2106);
+        player->ADD_GOSSIP_ITEM(3, "Leatherworking"           , GOSSIP_SENDER_MAIN, 2107);
+        player->ADD_GOSSIP_ITEM(3, "Mining"                , GOSSIP_SENDER_MAIN, 2108);
+        player->ADD_GOSSIP_ITEM(3, "Skinning"        , GOSSIP_SENDER_MAIN, 2109);
+        player->ADD_GOSSIP_ITEM(3, "Tailoring"                  , GOSSIP_SENDER_MAIN, 2110);
+        player->ADD_GOSSIP_ITEM(3, "Cooking"              , GOSSIP_SENDER_MAIN, 2111);
+        player->ADD_GOSSIP_ITEM(3, "First Aid"            , GOSSIP_SENDER_MAIN, 2112);
+        player->ADD_GOSSIP_ITEM(3, "Fishing"              , GOSSIP_SENDER_MAIN, 2113);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+        case 801: // Class Trainers
+
+        player->ADD_GOSSIP_ITEM(3, "Death Knight"          , GOSSIP_SENDER_MAIN, 2200);
+        player->ADD_GOSSIP_ITEM(3, "Druid"               , GOSSIP_SENDER_MAIN, 2201);
+        player->ADD_GOSSIP_ITEM(3, "Hunter"            , GOSSIP_SENDER_MAIN, 2202);
+        player->ADD_GOSSIP_ITEM(3, "Mage"            , GOSSIP_SENDER_MAIN, 2203);
+        player->ADD_GOSSIP_ITEM(3, "Paladin"             , GOSSIP_SENDER_MAIN, 2204);
+        player->ADD_GOSSIP_ITEM(3, "Priest"                , GOSSIP_SENDER_MAIN, 2205);
+        player->ADD_GOSSIP_ITEM(3, "Rogue"                       , GOSSIP_SENDER_MAIN, 2206);
+        player->ADD_GOSSIP_ITEM(3, "Shaman"               , GOSSIP_SENDER_MAIN, 2207);
+        player->ADD_GOSSIP_ITEM(3, "Warlock"        , GOSSIP_SENDER_MAIN, 2208);
+        player->ADD_GOSSIP_ITEM(3, "Warrior"                 , GOSSIP_SENDER_MAIN, 2209);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+        case 2200:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(dk,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+        case 2201:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(dudu,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+        case 2202:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(hunta,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+           case 2203:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(mage,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+        case 2204:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(pala,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+           case 2205:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(priest,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+           case 2206:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(rogue,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+        case 2207:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(sami,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+           case 2208:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(lock,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+           case 2209:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(wari,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+        //Sickness,Reset Talent Start//
+        case 121: // Reset Talent Pont
+        player->CLOSE_GOSSIP_MENU();
+        player->SendTalentWipeConfirm(_Creature->GetGUID());
+        break;
+
+        case 120: //Sickness leszedse
+        if(!player->HasAura(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS))
+        {
+            _Creature->Whisper(nosickness, LANG_UNIVERSAL, player);
+        }
+        else
+        {
+        _Creature->CastSpell(player,38588,false); // Flash Heal
+        player->RemoveAurasDueToSpell(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS);
+        }
+        player->CLOSE_GOSSIP_MENU();
+        break;
+        //Sickness,Reset Talent End//
+        ////// Prof trainers
+
+        case 2100: // Alchemy
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(33630,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        player->SummonCreature(28703,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+        case 2101: // Blacksmithing
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(28694,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+case 2102: // Enchanting
+    player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28693,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+    player->SummonCreature(33633,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+        case 2103: // Engineering
+   player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28697,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2104: // Herbalism
+    player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28704,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+case 2105: // Inscription
+ player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28702,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2106: // Jewelcrafting
+    player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28701,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2107: // Leatherworking
+    player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28700,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2108: // Mining
+    player->CLOSE_GOSSIP_MENU();    player->SummonCreature(28698,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2109: // Skinning
+    player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28696,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2110: // Tailoring
+    player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28699,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2111: // Cooking
+   player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28705,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2112: // First Aid
+    player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28706,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+        case 2113: // Fishing
+    player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28742,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+}
+//return true;
+    }
+
+bool OnGossipSelect(Player* player, Creature* _Creature, uint32 sender, uint32 action)
+{
+    // Main menu
+    player->PlayerTalkClass->ClearMenus();
+    if (sender == GOSSIP_SENDER_MAIN)
+    SendDefaultMenu(player, _Creature, action);
+
+return true;
+}
+};
+
+void AddSC_npc_all()
+{
+    new npc_all();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/announce_login.cpp b/src/server/scripts/Custom/announce_login.cpp
new file mode 100644
index 0000000..e4a8628
--- /dev/null
+++ b/src/server/scripts/Custom/announce_login.cpp
@@ -0,0 +1,26 @@
+class announce_login : public PlayerScript
+{
+public:
+	announce_login() : PlayerScript("announce_login") { }
+ 
+	void OnLogin(Player* player, bool /*loginFirst*/)
+	{
+		if (player->GetTeam() == ALLIANCE)
+				{
+			std::ostringstream ss;
+						ss << "|cff3DAEFF[ Login Announcer ]|cffFFD800 : Player|cff4CFF00 " << player->GetName() << " |cffFFD800Has Online. This Player is|cff0026FF Alliance";
+			sWorld->SendServerMessage(SERVER_MSG_STRING, ss.str().c_str());
+				}
+				else
+				{
+			std::ostringstream ss;
+						ss << "|cff3DAEFF[ Login Announcer ]|cffFFD800 : Player|cff4CFF00 " << player->GetName() << " |cffFFD800Has Online. This Player is|cffFF0000 Horde" ;
+			sWorld->SendServerMessage(SERVER_MSG_STRING, ss.str().c_str());
+				}
+		}
+};
+ 
+void AddSC_announce_login()
+{
+	new announce_login;
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/beastmaster.cpp b/src/server/scripts/Custom/beastmaster.cpp
new file mode 100644
index 0000000..c7fd003
--- /dev/null
+++ b/src/server/scripts/Custom/beastmaster.cpp
@@ -0,0 +1,383 @@
+//Modified by Marcus rewritten by LordPsyan
+//original script created by ??
+#include "Config.h"
+#include "Pet.h"
+
+#define GOSSIP_SENDER_MAIN      1000
+#define MSG_TYPE                100004
+#define MSG_PET                 100005
+#define MAIN_MENU               "<= [Main Menu]"
+
+class Npc_Beastmaster : public CreatureScript
+{
+public:
+        Npc_Beastmaster() : CreatureScript("Npc_Beastmaster") { }
+
+void CreatePet(Player *player, Creature * m_creature, uint32 entry) {
+
+    if(sConfigMgr->GetBoolDefault("BeastMaster.OnlyHunter", false)) // Checks to see if Only Hunters can have pets.
+     {
+        if(player->getClass() != CLASS_HUNTER) {
+            m_creature->Whisper("You are not a Hunter!", LANG_UNIVERSAL, player);
+            return;
+        }
+     }
+
+    if(player->GetPet()) {
+        m_creature->Whisper("First you must abandon your Pet!", LANG_UNIVERSAL, player);
+        return;
+    }
+
+    Creature *creatureTarget = m_creature->SummonCreature(entry, player->GetPositionX(), player->GetPositionY()+2, player->GetPositionZ(), player->GetOrientation(), TEMPSUMMON_CORPSE_TIMED_DESPAWN, 500);
+    if(!creatureTarget) return;
+
+    Pet* pet = player->CreateTamedPetFrom(creatureTarget, 0);
+
+    if(!pet) return;
+
+        // kill original creature
+    creatureTarget->setDeathState(JUST_DIED);
+    creatureTarget->RemoveCorpse();
+    creatureTarget->SetHealth(0);                       // just for nice GM-mode view
+
+    pet->SetPower(POWER_HAPPINESS, 1048000);
+
+    // prepare visual effect for levelup
+    pet->SetUInt32Value(UNIT_FIELD_LEVEL, player->getLevel() - 1);
+    pet->GetMap()->AddToMap((Creature*)pet);
+        // visual effect for levelup
+    pet->SetUInt32Value(UNIT_FIELD_LEVEL, player->getLevel());
+
+    if(!pet->InitStatsForLevel(player->getLevel()))
+        TC_LOG_ERROR("scripts", "Pet Create fail: no init stats for entry %u", entry);
+        pet->UpdateAllStats();
+
+    // caster have pet now
+        player->SetMinion(pet, true);
+
+        pet->SavePetToDB(PET_SAVE_AS_CURRENT);
+        pet->InitTalentForLevel();
+        player->PetSpellInitialize();
+    //end
+        player->CLOSE_GOSSIP_MENU();
+        m_creature->Whisper("Pet added. You might want to feed it and name it somehow.", LANG_UNIVERSAL, player);
+        return;
+    }
+
+bool OnGossipHello(Player* player, Creature* m_creature)
+{
+    bool EnableNormalPet = sConfigMgr->GetBoolDefault("BeastMaster.EnableNormalPet", true);
+    bool EnableExoticPet = sConfigMgr->GetBoolDefault("BeastMaster.EnableExoticPet", true);
+
+    // Main Menu
+
+    // Check config if "Normal Pet " is enabled or not
+    if(EnableNormalPet)
+        player->ADD_GOSSIP_ITEM( 7, "Normal Pets ->"              , GOSSIP_SENDER_MAIN, 1000);
+    // Check if player can have an exotic pet, and check config if "Exotic" is enabled or not
+    if(player->CanTameExoticPets() && EnableExoticPet)
+        player->ADD_GOSSIP_ITEM( 7, "Exotic Pets ->"              , GOSSIP_SENDER_MAIN, 2000);
+    // Now to add the spells, vendor, and stable stuffs
+    player->ADD_GOSSIP_ITEM(4, "Teach Me Pet spells ->"      , GOSSIP_SENDER_MAIN, 3000);
+    player->ADD_GOSSIP_ITEM(2, "Take me to the Stable.", GOSSIP_SENDER_MAIN, 6006);
+    player->ADD_GOSSIP_ITEM(6, "Sell me some Food for my Pet.", GOSSIP_SENDER_MAIN, 6007);
+    player->SEND_GOSSIP_MENU(MSG_TYPE, m_creature->GetGUID());
+return true;
+}
+
+bool showNormalPet(Player *player, Creature *m_creature, uint32 showFromId = 0)
+{
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `entry`, `name` FROM `beastmaster` WHERE `cat_number` = 0 ORDER BY `entry` ASC");
+
+ if (result)
+ {
+ uint32 entryNum = 0;
+ std::string petName = "";
+ uint8 tokenOrGold = 0;
+ uint32 price = 0;
+ uint32 nToken = 0;
+
+  do
+ {
+ Field *fields = result->Fetch();
+ entryNum = fields[0].GetInt32();
+ petName = fields[1].GetString();
+
+    player->ADD_GOSSIP_ITEM(9, petName, GOSSIP_SENDER_MAIN, entryNum);
+}
+ while (result->NextRow());
+
+    player->SEND_GOSSIP_MENU(MSG_PET, m_creature->GetGUID());
+ return true;
+ }
+ else
+ {
+ if (showFromId = 0)
+ {
+ //you are too poor
+ m_creature->Whisper("You don't have enough money.", LANG_UNIVERSAL, player);
+ player->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+
+ //show Spells from beginning
+ showNormalPet(player, m_creature, 0);
+ }
+ }
+
+ return false;
+}
+
+bool showExoticPet(Player *player, Creature *m_creature, uint32 showFromId = 0)
+{
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `entry`, `name` FROM `beastmaster` WHERE `cat_number` = 1 ORDER BY `entry` ASC");
+
+ if (result)
+ {
+ uint32 entryNum = 0;
+ std::string petName = "";
+  do
+ {
+ Field *fields = result->Fetch();
+ entryNum = fields[0].GetInt32();
+ petName = fields[1].GetString();
+
+    player->ADD_GOSSIP_ITEM(9, petName, GOSSIP_SENDER_MAIN, entryNum);
+}
+ while (result->NextRow());
+
+    player->SEND_GOSSIP_MENU(MSG_PET, m_creature->GetGUID());
+ return true;
+ }
+ else
+ {
+ if (showFromId = 0)
+ {
+ //you are too poor
+ //m_creature->Whisper("You don't have enough money.", LANG_UNIVERSAL, player);
+ //player->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+
+ //show Spells from beginning
+ showExoticPet(player, m_creature, 0);
+ }
+ }
+
+ return false;
+}
+
+bool showPetSpells(Player *player, Creature *m_creature, uint32 showFromId = 0)
+{
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `entry`, `name` FROM `beastmaster` WHERE `cat_number` = 2 ORDER BY `entry` ASC");
+
+ if (result)
+ {
+ uint32 entryNum = 0;
+ std::string petName = "";
+ uint8 tokenOrGold = 0;
+ uint32 price = 0;
+ uint32 nToken = 0;
+
+  do
+ {
+ Field *fields = result->Fetch();
+ entryNum = fields[0].GetInt32();
+ petName = fields[1].GetString();
+
+    player->ADD_GOSSIP_ITEM(9, petName, GOSSIP_SENDER_MAIN, entryNum);
+}
+ while (result->NextRow());
+
+    player->SEND_GOSSIP_MENU(MSG_PET, m_creature->GetGUID());
+ return true;
+ }
+ else
+ {
+ if (showFromId = 0)
+ {
+ //you are too poor
+ m_creature->Whisper("You don't have enough money.", LANG_UNIVERSAL, player);
+ player->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+
+ //show Spells from beginning
+ showPetSpells(player, m_creature, 0);
+ }
+ }
+
+ return false;
+}
+
+void SendDefaultMenu(Player* player, Creature* m_creature, uint32 uiAction)
+{
+
+// Not allow in combat
+if (player->IsInCombat())
+{
+    player->CLOSE_GOSSIP_MENU();
+    m_creature->Say("You are in combat!", LANG_UNIVERSAL);
+    return;
+}
+
+    bool EnableNormalPet = sConfigMgr->GetBoolDefault("BeastMaster.EnableNormalPet", true);
+    bool EnableExoticPet = sConfigMgr->GetBoolDefault("BeastMaster.EnableExoticPet", true);
+
+  // send name as gossip item
+       QueryResult result;
+        uint32 spellId = 0;
+        uint32 catNumber = 0;
+        uint32 cost = 0;
+        std::string spellName = "";
+        uint32 token = 0;
+        bool tokenOrGold = true;
+
+        result = WorldDatabase.PQuery("SELECT * FROM `beastmaster` WHERE `entry` = %u LIMIT 1", uiAction);
+
+if (result)
+{
+    do {
+        Field *fields = result->Fetch();
+        catNumber = fields[1].GetInt32();
+        tokenOrGold = fields[2].GetBool();
+        cost = fields[3].GetInt32();
+        token = fields[4].GetInt32();
+        spellName = fields[5].GetString();
+        spellId = fields[6].GetInt32();
+
+        if (tokenOrGold)
+        {
+            if (!player->HasItemCount(token, cost))
+                {
+                    m_creature->Whisper("You ain't gots no darn chips.", LANG_UNIVERSAL, player);
+                    player->CLOSE_GOSSIP_MENU();
+                    return;
+                }
+            else if (uiAction != 1000 && uiAction != 2000 && uiAction != 3000 && catNumber != 2)
+            {
+    player->CLOSE_GOSSIP_MENU();
+    CreatePet(player, m_creature, spellId);
+    player->DestroyItemCount(token, cost, true);
+            }
+            else if (catNumber = 2)
+            {
+            if (player->HasSpell(spellId))
+            {
+                m_creature->Whisper("You already know this spell.", LANG_UNIVERSAL, player);
+                player->CLOSE_GOSSIP_MENU();
+                return;
+            } else {
+    player->CLOSE_GOSSIP_MENU();
+    player->LearnSpell(spellId, false);
+    player->DestroyItemCount(token, cost, true);
+            }
+        }
+
+        } else {
+            if (player->GetMoney() < cost)
+            {
+                m_creature->Whisper("You dont have enough money!", LANG_UNIVERSAL, player);
+                player->CLOSE_GOSSIP_MENU();
+                return;
+            }
+        else if (uiAction != 1000 && uiAction != 2000 && uiAction != 3000 && catNumber != 2)
+        {
+    player->CLOSE_GOSSIP_MENU();
+    CreatePet(player, m_creature, spellId);
+    player->ModifyMoney(-int(cost));
+        }
+        else if (catNumber = 2)
+        {
+            if (player->HasSpell(spellId))
+            {
+                m_creature->Whisper("You already know this spell.", LANG_UNIVERSAL, player);
+                player->CLOSE_GOSSIP_MENU();
+                return;
+            } else {
+    player->CLOSE_GOSSIP_MENU();
+    player->LearnSpell(spellId, false);
+    player->ModifyMoney(-int(cost));
+            }
+        }
+    }
+} while (result->NextRow());
+} else {
+//player->ADD_GOSSIP_ITEM( 7, MAIN_MENU, GOSSIP_SENDER_MAIN, 5005);
+}
+
+ switch(uiAction)
+{
+
+case 1000: //Normal Pet
+        showNormalPet(player, m_creature, 0);
+        player->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                            , GOSSIP_SENDER_MAIN, 5005);
+
+    player->SEND_GOSSIP_MENU(MSG_PET, m_creature->GetGUID());
+break;
+
+case 2000: //Exotic Pet
+        showExoticPet(player, m_creature, 0);
+        player->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                            , GOSSIP_SENDER_MAIN, 5005);
+
+    player->SEND_GOSSIP_MENU(MSG_PET, m_creature->GetGUID());
+break;
+
+case 3000: //Pet Spells
+        showPetSpells(player, m_creature, 0);
+        player->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                            , GOSSIP_SENDER_MAIN, 5005);
+
+    player->SEND_GOSSIP_MENU(MSG_PET, m_creature->GetGUID());
+break;
+
+case 5005: //Back To Main Menu
+    // Main Menu
+    // Check config if "Normal Pet " is enabled or not
+    if(EnableNormalPet)
+        player->ADD_GOSSIP_ITEM( 7, "Normal Pets ->"              , GOSSIP_SENDER_MAIN, 1000);
+    // Check if player can have an exotic pet, and check config if "Exotic" is enabled or not
+    if(player->CanTameExoticPets() && EnableExoticPet)
+        player->ADD_GOSSIP_ITEM( 7, "Exotic Pets ->"              , GOSSIP_SENDER_MAIN, 2000);
+    // Now to add the spells, vendor, and stable stuffs
+    player->ADD_GOSSIP_ITEM(4, "Teach Me Pet spells ->"      , GOSSIP_SENDER_MAIN, 3000);
+    player->ADD_GOSSIP_ITEM(2, "Take me to the Stable.", GOSSIP_SENDER_MAIN, 6006);
+    player->ADD_GOSSIP_ITEM(6, "Sell me some Food for my Pet.", GOSSIP_SENDER_MAIN, 6007);
+    player->SEND_GOSSIP_MENU(MSG_TYPE, m_creature->GetGUID());
+break;
+
+case 6006:
+    player->GetSession()->SendStablePet(m_creature->GetGUID());
+    player->CLOSE_GOSSIP_MENU();
+    break;
+
+case 6007:
+    player->GetSession()->SendListInventory(m_creature->GetGUID());
+    player->CLOSE_GOSSIP_MENU();
+    break;
+
+ player->CLOSE_GOSSIP_MENU();
+ }
+
+} //end of function
+
+bool OnGossipSelect(Player* player, Creature* m_creature, uint32 uiSender, uint32 uiAction)
+{
+    // Main menu
+    player->PlayerTalkClass->ClearMenus();
+    if (uiSender == GOSSIP_SENDER_MAIN)
+    SendDefaultMenu(player, m_creature, uiAction);
+
+return true;
+}
+};
+
+void AddSC_Npc_Beastmaster()
+{
+    new Npc_Beastmaster();
+}
diff --git a/src/server/scripts/Custom/bountyhunter.cpp b/src/server/scripts/Custom/bountyhunter.cpp
new file mode 100644
index 0000000..ba7c08d
--- /dev/null
+++ b/src/server/scripts/Custom/bountyhunter.cpp
@@ -0,0 +1,463 @@
+#include <cstring>
+
+using namespace std;
+
+#define SET_CURRENCY 0  //0 for gold, 1 for honor, 2 for tokens
+#define TOKEN_ID 0 // token id
+
+#if SET_CURRENCY == 0
+#define BOUNTY_1 "1000g bounty."
+#define BOUNTY_2 "2000g bounty."
+#define BOUNTY_3 "5000g bounty."
+#define BOUNTY_4 "10000g bounty."
+#endif
+#if SET_CURRENCY == 1
+#define BOUNTY_1 "I would like to place a 20 honor bounty."
+#define BOUNTY_2 "I would like to place a 40 honor bounty."
+#define BOUNTY_3 "I would like to place a 100 honor bounty."
+#define BOUNTY_4 "I would like to place a 200 honor bounty."
+#endif
+#if SET_CURRENCY == 2
+#define BOUNTY_1 "I would like to place a 1 token bounty."
+#define BOUNTY_2 "I would like to place a 3 token bounty."
+#define BOUNTY_3 "I would like to place a 5 token bounty."
+#define BOUNTY_4 "I would like to place a 10 token bounty."
+#endif
+
+#define PLACE_BOUNTY "Ich will Jemanden tot sehen!"
+#define LIST_BOUNTY "Zeig mir die Liste der Opfer!"
+#define NVM "Ich moechte doch nichts."
+
+#if SET_CURRENCY != 2
+
+enum BountyPrice
+{
+    BOUNTY_PRICE_1 = 1000,
+    BOUNTY_PRICE_2 = 2000,
+    BOUNTY_PRICE_3 = 5000,
+    BOUNTY_PRICE_4 = 10000,
+};
+#else
+enum BountyPrice
+{
+    BOUNTY_PRICE_1 = 1,
+    BOUNTY_PRICE_2 = 3,
+    BOUNTY_PRICE_3 = 5,
+    BOUNTY_PRICE_4 = 10,
+};
+#endif
+
+bool passChecks(Player * pPlayer, const char * name)
+{
+
+    Player * pBounty = ObjectAccessor::FindPlayerByName(name);
+    WorldSession * m_session = pPlayer->GetSession();
+    if(!pBounty)
+    {
+        m_session->SendNotification("There is no player with this name online!");
+        return false;
+    }
+    QueryResult result = CharacterDatabase.PQuery("SELECT * FROM bounties WHERE guid ='%u'", pBounty->GetGUID());
+    if(result)
+    {
+        m_session->SendNotification("The bounty on these players have been suspended!");
+        return false;
+    }
+    if(pPlayer->GetGUID() == pBounty->GetGUID())
+    {
+        m_session->SendNotification("You can expose yourself to no bounty!");
+        return false;
+    }
+    return true;
+}
+
+void alertServer(const char * name, int msg)
+{
+        std::string message;
+        if(msg == 1)
+        {
+                message = "A bounty has been suspended on ";
+                message += name;
+                message += ". Killed him and gained the gold!";
+        }
+        else if(msg == 2)
+        {
+                message = "The Bounty of ";
+                message += name;
+                message += " was redeemed!";
+        }
+        sWorld->SendServerMessage(SERVER_MSG_STRING, message.c_str(), 0);
+}
+
+
+bool hasCurrency(Player * pPlayer, uint32 required, int currency)
+{
+    WorldSession *m_session = pPlayer->GetSession();
+    switch(currency)
+    {
+        case 0: //gold
+            {
+            uint32 currentmoney = pPlayer->GetMoney();
+            uint32 requiredmoney = (required * 10000);
+            if(currentmoney < requiredmoney)
+            {
+                m_session->SendNotification("You do not have enough gold!");
+                return false;
+            }
+            pPlayer->SetMoney(currentmoney - requiredmoney);
+            break;
+            }
+        case 1: //honor
+            {
+            uint32 currenthonor = pPlayer->GetHonorPoints();
+            if(currenthonor < required)
+            {
+                m_session->SendNotification("You don't have enough honor!");
+                return false;
+            }
+            pPlayer->SetHonorPoints(currenthonor - required);
+            break;
+            }
+        case 2: //tokens
+            {
+            if(!pPlayer->HasItemCount(TOKEN_ID, required))
+            {
+                m_session->SendNotification("You don't have enough tokens!");
+                return false;
+            }
+            pPlayer->DestroyItemCount(TOKEN_ID, required, true, false);
+            break;
+            }
+
+    }
+    return true;
+}
+
+void flagPlayer(const char * name)
+{
+    std::string message;
+    Player * pBounty = ObjectAccessor::FindPlayerByName(name);
+    pBounty->SetPvP(true);
+    pBounty->SetByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP);
+}
+
+class BountyHunter : public CreatureScript
+{
+    public:
+        BountyHunter() : CreatureScript("BountyHunter"){}
+        bool OnGossipHello(Player * Player, Creature * Creature)
+        {
+            Player->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, PLACE_BOUNTY, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+            Player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, LIST_BOUNTY, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
+            Player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, NVM, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+3);
+            Player->PlayerTalkClass->SendGossipMenu(907, Creature->GetGUID());
+            return true;
+        }
+
+        bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 /*uiSender*/, uint32 uiAction)
+        {
+            pPlayer->PlayerTalkClass->ClearMenus();
+            switch(uiAction)
+            {
+                case GOSSIP_ACTION_INFO_DEF+1:
+                {
+                    pPlayer->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_BATTLE, BOUNTY_1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+5, "", 0, true);
+                    pPlayer->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_BATTLE, BOUNTY_2, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+6, "", 0, true);
+                    pPlayer->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_BATTLE, BOUNTY_3, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+7, "", 0, true);
+                    pPlayer->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_BATTLE, BOUNTY_4, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+8, "", 0, true);
+                    pPlayer->PlayerTalkClass->SendGossipMenu(365, pCreature->GetGUID());
+                    break;
+                }
+                case GOSSIP_ACTION_INFO_DEF+2:
+                {
+                    QueryResult Bounties = CharacterDatabase.PQuery("SELECT * FROM bounties");
+
+                    if(!Bounties)
+                    {
+                        pPlayer->PlayerTalkClass->SendCloseGossip();
+                        return false;
+                    }
+#if SET_CURRENCY == 0
+                    if(    Bounties->GetRowCount() > 1)
+                    {
+                        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, "bounty: ", GOSSIP_SENDER_MAIN, 1);
+                        do
+                        {
+                            Field * fields = Bounties->Fetch();
+                            std::string option;
+                            QueryResult name = CharacterDatabase.PQuery("SELECT name FROM characters WHERE guid='%u'", fields[0].GetUInt64());
+                            Field * names = name->Fetch();
+                            option = names[0].GetString();
+                            option +=" ";
+                            option += fields[1].GetString();
+                            option += " gold";
+                            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, option, GOSSIP_SENDER_MAIN, 1);
+                        }while(Bounties->NextRow());
+                    }
+                    else
+                    {
+                        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, "bounty: ", GOSSIP_SENDER_MAIN, 1);
+                        Field * fields = Bounties->Fetch();
+                        std::string option;
+                        QueryResult name = CharacterDatabase.PQuery("SELECT name FROM characters WHERE guid='%u'", fields[0].GetUInt64());
+                        Field * names = name->Fetch();
+                        option = names[0].GetString();
+                        option +=" ";
+                        option += fields[1].GetString();
+                        option += " gold";
+                        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, option, GOSSIP_SENDER_MAIN, 1);
+
+                    }
+#endif
+#if SET_CURRENCY == 1
+                    if(    Bounties->GetRowCount() > 1)
+                    {
+                        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, "bounty: ", GOSSIP_SENDER_MAIN, 1);
+                        do
+                        {
+                            Field * fields = Bounties->Fetch();
+                            std::string option;
+                            QueryResult name = CharacterDatabase.PQuery("SELECT name FROM characters WHERE guid='%u'", fields[0].GetUInt64());
+                            Field * names = name->Fetch();
+                            option = names[0].GetString();
+                            option +=" ";
+                            option += fields[1].GetString();
+                            option += " honor";
+                            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, option, GOSSIP_SENDER_MAIN, 1);
+                        }while(Bounties->NextRow());
+                    }
+                    else
+                    {
+                        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, "bounty: ", GOSSIP_SENDER_MAIN, 1);
+                        Field * fields = Bounties->Fetch();
+                        std::string option;
+                        QueryResult name = CharacterDatabase.PQuery("SELECT name FROM characters WHERE guid='%u'", fields[0].GetUInt64());
+                        Field * names = name->Fetch();
+                        option = names[0].GetString();
+                        option +=" ";
+                        option += fields[1].GetString();
+                        option += " honor";
+                        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, option, GOSSIP_SENDER_MAIN, 1);
+
+                    }
+#endif
+#if SET_CURRENCY == 2
+                    if(    Bounties->GetRowCount() > 1)
+                    {
+                        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, "bounty: ", GOSSIP_SENDER_MAIN, 1);
+                        do
+                        {
+                            Field * fields = Bounties->Fetch();
+                            std::string option;
+                            QueryResult name = CharacterDatabase.PQuery("SELECT name FROM characters WHERE guid='%u'", fields[0].GetUInt64());
+                            Field * names = name->Fetch();
+                            option = names[0].GetString();
+                            option +=" ";
+                            option += fields[1].GetString();
+                            option += " coins";
+                            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, option, GOSSIP_SENDER_MAIN, 1);
+                        }while(Bounties->NextRow());
+                    }
+                    else
+                    {
+                        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, "bounty: ", GOSSIP_SENDER_MAIN, 1);
+                        Field * fields = Bounties->Fetch();
+                        std::string option;
+                        QueryResult name = CharacterDatabase.PQuery("SELECT name FROM characters WHERE guid='%u'", fields[0].GetUInt64());
+                        Field * names = name->Fetch();
+                        option = names[0].GetString();
+                        option +=" ";
+                        option += fields[1].GetString();
+                        option += " coins";
+                        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, option, GOSSIP_SENDER_MAIN, 1);
+
+                    }
+#endif
+                    pPlayer->PlayerTalkClass->SendGossipMenu(878, pCreature->GetGUID());
+                    break;
+                }
+                case GOSSIP_ACTION_INFO_DEF+3:
+                {
+                    pPlayer->PlayerTalkClass->SendCloseGossip();
+                    break;
+                }
+                case GOSSIP_ACTION_INFO_DEF+4:
+                {
+                    CharacterDatabase.PExecute("TRUNCATE TABLE bounties");
+                    pPlayer->PlayerTalkClass->SendCloseGossip();
+                    break;
+                }
+            }
+            return true;
+        }
+
+        bool OnGossipSelectCode(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction, const char * code)
+        {
+            pPlayer->PlayerTalkClass->ClearMenus();
+            if ( uiSender == GOSSIP_SENDER_MAIN )
+            {
+                if(islower(code[0]))
+                    toupper(code[0]);
+
+                if(passChecks(pPlayer, code))
+                {
+                    Player * pBounty = ObjectAccessor::FindPlayerByName(code);
+                    switch (uiAction)
+                    {
+                        case GOSSIP_ACTION_INFO_DEF+5:
+                        {
+                            if(hasCurrency(pPlayer, BOUNTY_PRICE_1, SET_CURRENCY))
+                            {
+                                #if SET_CURRENCY != 2
+                                CharacterDatabase.PExecute("INSERT INTO bounties VALUES('%u','1000', '1')", pBounty->GetGUID());
+                                #else
+                                CharacterDatabase.PExecute("INSERT INTO bounties VALUES('%u','1', '1')", pBounty->GetGUID());
+                                #endif
+                                alertServer(code, 1);
+                                flagPlayer(code);
+                                pPlayer->PlayerTalkClass->SendCloseGossip();
+                            }
+                            break;
+                        }
+
+                        case GOSSIP_ACTION_INFO_DEF+6:
+                        {
+                            if(hasCurrency(pPlayer, BOUNTY_PRICE_2, SET_CURRENCY))
+                            {
+                                #if SET_CURRENCY != 2
+                                CharacterDatabase.PExecute("INSERT INTO bounties VALUES('%u', '2000', '2')", pBounty->GetGUID());
+                                #else
+                                CharacterDatabase.PExecute("INSERT INTO bounties VALUES('%u', '3', '2')", pBounty->GetGUID());
+                                #endif
+                                alertServer(code, 1);
+                                flagPlayer(code);
+                                pPlayer->PlayerTalkClass->SendCloseGossip();
+                            }
+                            break;
+                        }
+                        case GOSSIP_ACTION_INFO_DEF+7:
+                        {
+                            if(hasCurrency(pPlayer, BOUNTY_PRICE_3, SET_CURRENCY))
+                            {
+                                #if SET_CURRENCY != 2
+                                CharacterDatabase.PExecute("INSERT INTO bounties VALUES('%u', '5000', '3')", pBounty->GetGUID());
+                                #else
+                                CharacterDatabase.PExecute("INSERT INTO bounties VALUES('%u', '5', '3')", pBounty->GetGUID());
+                                #endif
+                                alertServer(code, 1);
+                                flagPlayer(code);
+                                pPlayer->PlayerTalkClass->SendCloseGossip();
+                            }
+                            break;
+                        }
+                        case GOSSIP_ACTION_INFO_DEF+8:
+                        {
+                            if(hasCurrency(pPlayer, BOUNTY_PRICE_4, SET_CURRENCY))
+                            {
+                                #if SET_CURRENCY != 2
+                                CharacterDatabase.PExecute("INSERT INTO bounties VALUES('%u', '10000', '4')", pBounty->GetGUID());
+                                #else
+                                CharacterDatabase.PExecute("INSERT INTO bounties VALUES('%u', '10', '3')", pBounty->GetGUID());
+                                #endif
+                                alertServer(code, 1);
+                                flagPlayer(code);
+                                pPlayer->PlayerTalkClass->SendCloseGossip();
+                            }
+                            break;
+                        }
+
+                    }
+                }
+                else
+                {
+                    pPlayer->PlayerTalkClass->SendCloseGossip();
+                }
+            }
+            return true;
+        }
+};
+
+
+class BountyKills : public PlayerScript
+{
+    public:
+        BountyKills() : PlayerScript("BountyKills"){}
+
+        void OnPVPKill(Player * Killer, Player * Bounty)
+        {
+        int32 KillerLevel = Killer->getLevel(); //Get Killer Level
+        int32 BountyLevel = Bounty->getLevel(); //Get Bounty Level
+        int32 LevelDif = std::abs(KillerLevel - BountyLevel);
+            if(Killer->GetGUID() == Bounty->GetGUID())
+                return;
+             if(KillerLevel > BountyLevel)
+                 if(LevelDif > 8) //Check to see if killer is 9+ levels higher than bounty to keep higher level players from killing bounty
+                 return;
+
+            QueryResult result = CharacterDatabase.PQuery("SELECT * FROM bounties WHERE guid='%u'", Bounty->GetGUID());
+            if(!result)
+                return;
+
+            Field * fields = result->Fetch();
+#if SET_CURRENCY == 0
+            switch(fields[2].GetUInt64())
+            {
+            case 1:
+                Killer->SetMoney(Killer->GetMoney() + (BOUNTY_PRICE_1 * 10000));
+                break;
+            case 2:
+                Killer->SetMoney(Killer->GetMoney() + (BOUNTY_PRICE_2 * 10000));
+                break;
+            case 3:
+                Killer->SetMoney(Killer->GetMoney() + (BOUNTY_PRICE_3 * 10000));
+                break;
+            case 4:
+                Killer->SetMoney(Killer->GetMoney() + (BOUNTY_PRICE_4 * 10000));
+                break;
+            }
+#endif
+#if SET_CURRENCY == 1
+            switch(fields[2].GetUInt64())
+            {
+            case 1:
+                Killer->SetHonorPoints(Killer->GetHonorPoints() + (BOUNTY_PRICE_1));
+                break;
+            case 2:
+                Killer->SetHonorPoints(Killer->GetHonorPoints() + (BOUNTY_PRICE_2));
+                break;
+            case 3:
+                Killer->SetHonorPoints(Killer->GetHonorPoints() + (BOUNTY_PRICE_3));
+                break;
+            case 4:
+                Killer->SetHonorPoints(Killer->GetHonorPoints() + (BOUNTY_PRICE_4));
+                break;
+            }
+#endif
+#if SET_CURRENCY == 2
+            switch(fields[2].GetUInt64())
+            {
+            case 1:
+                Killer->AddItem(TOKEN_ID, BOUNTY_PRICE_1);
+                break;
+            case 2:
+                Killer->AddItem(TOKEN_ID, BOUNTY_PRICE_2);
+                break;
+            case 3:
+                Killer->AddItem(TOKEN_ID, BOUNTY_PRICE_3);
+                break;
+            case 4:
+                Killer->AddItem(TOKEN_ID, BOUNTY_PRICE_4);
+                break;
+            }
+#endif
+            CharacterDatabase.PExecute("DELETE FROM bounties WHERE guid='%u'", Bounty->GetGUID());
+            alertServer(Bounty->GetName().c_str(), 2);
+
+        }
+};
+
+void AddSC_BountyHunter()
+{
+    new BountyHunter();
+    new BountyKills();
+}
diff --git a/src/server/scripts/Custom/chat_censor.cpp b/src/server/scripts/Custom/chat_censor.cpp
new file mode 100644
index 0000000..016f7c6
--- /dev/null
+++ b/src/server/scripts/Custom/chat_censor.cpp
@@ -0,0 +1,106 @@
+// Unknown creator
+// Some errors fixed by CyBeR-PrO
+// Edited by Rochet2
+
+#include "Channel.h"
+
+// only use lowercase letters
+// The strings are trimmed of whitespace and compared lowercase
+// To add more checks, just add a new line to the checks array
+static const char* checks[] = {
+    "sytes",
+    "instant",
+    "dyndns",
+    "no-ip",
+    "http:",
+    ".com",
+    ".net",
+    ".org",
+    ".eu",
+    ".fr",
+    ".bg",
+    ".info",
+    ".br",
+    "https:",
+    "wow",
+    "www.",
+    "no-ip",
+    ".zapto",
+    ".biz",
+    ".servegame",
+
+    "trevonwow",
+    "megawow",
+    "fatalwow",
+    "uniforgiven-wow",
+    "wow-autolouco",
+    "heaven-wow",
+    "fireballwow",
+    "wowbrasilpa",
+    "fatalitywow",
+    "demonic-wow",
+    "revenge-wow",
+    "heavenwow",
+    "undead-wow",
+    "linebr",
+    "azralon",
+    "black-wow",
+};
+
+static const size_t checksize = sizeof(checks) / sizeof(*checks);
+class System_Censure : public PlayerScript
+{
+public:
+    System_Censure() : PlayerScript("System_Censure") { }
+
+    void CheckMessage(Player* player, std::string& msg, uint32 lang)
+    {
+        //if (player->isGameMaster() || lang == LANG_ADDON)
+        //    return;
+
+        // remove all space characters and transform to lowercase for simpler checking
+        std::string checkmsg = msg;
+        checkmsg.erase(remove_if(checkmsg.begin(), checkmsg.end(), ::isspace), checkmsg.end());
+        std::transform(checkmsg.begin(), checkmsg.end(), checkmsg.begin(), ::tolower);
+
+        for (size_t i = 0; i < checksize; ++i)
+        {
+            if (checkmsg.find(checks[i]) != std::string::npos)
+            {
+                msg = "";
+                ChatHandler(player->GetSession()).PSendSysMessage("Links/Advertisements are not allowed!");
+                return;
+            }
+        }
+    };
+
+    void OnChat(Player* player, uint32 /*type*/, uint32 lang, std::string& msg) override
+    {
+        CheckMessage(player, msg, lang);
+    }
+
+    void OnChat(Player* player, uint32 /*type*/, uint32 lang, std::string& msg, Player* /*receiver*/) override
+    {
+        CheckMessage(player, msg, lang);
+    }
+
+    void OnChat(Player* player, uint32 /*type*/, uint32 lang, std::string& msg, Group* /*group*/) override
+    {
+        CheckMessage(player, msg, lang);
+    }
+
+    void OnChat(Player* player, uint32 /*type*/, uint32 lang, std::string& msg, Guild* /*guild*/) override
+    {
+        CheckMessage(player, msg, lang);
+    }
+
+    void OnChat(Player* player, uint32 /*type*/, uint32 lang, std::string& msg, Channel* /*channel*/) override
+    {
+        CheckMessage(player, msg, lang);
+    }
+};
+
+void AddSC_System_Censure()
+{
+    new System_Censure();
+}
diff --git a/src/server/scripts/Custom/enchant.cpp b/src/server/scripts/Custom/enchant.cpp
new file mode 100644
index 0000000..682a86a
--- /dev/null
+++ b/src/server/scripts/Custom/enchant.cpp
@@ -0,0 +1,1619 @@
+enum Enchants
+{
+    ENCHANT_WEP_BERSERKING              = 3789,
+    ENCHANT_WEP_BLADE_WARD              = 3869,
+    ENCHANT_WEP_BLOOD_DRAINING          = 3870,
+    ENCHANT_WEP_ACCURACY                = 3788,
+    ENCHANT_WEP_AGILITY_1H              = 1103,
+    ENCHANT_WEP_SPIRIT                  = 3844,
+    ENCHANT_WEP_BATTLEMASTER            = 2675,
+    ENCHANT_WEP_BLACK_MAGIC             = 3790,
+    ENCHANT_WEP_ICEBREAKER              = 3239,
+    ENCHANT_WEP_LIFEWARD                = 3241,
+    ENCHANT_WEP_MIGHTY_SPELL_POWER      = 3834, // One-hand
+    ENCHANT_WEP_EXECUTIONER             = 3225,
+    ENCHANT_WEP_POTENCY                 = 3833,
+    ENCHANT_WEP_TITANGUARD              = 3851,
+    ENCHANT_2WEP_MASSACRE               = 3827,
+    ENCHANT_2WEP_SCOURGEBANE            = 3247,
+    ENCHANT_2WEP_GIANT_SLAYER            = 3251,
+    ENCHANT_2WEP_GREATER_SPELL_POWER    = 3854,
+    ENCHANT_2WEP_AGILITY                = 2670,
+    ENCHANT_2WEP_MONGOOSE               = 2673,
+
+    ENCHANT_SHIELD_DEFENSE              = 1952,
+    ENCHANT_SHIELD_INTELLECT            = 1128,
+    ENCHANT_SHIELD_RESILIENCE           = 3229,
+    ENCHANT_SHIELD_BLOCK                = 2655,
+    ENCHANT_SHIELD_STAMINA                = 1071,
+    ENCHANT_SHIELD_TOUGHSHIELD            = 2653,
+    ENCHANT_SHIELD_TITANIUM_PLATING     = 3849,
+
+    ENCHANT_HEAD_BLISSFUL_MENDING       = 3819,
+    ENCHANT_HEAD_BURNING_MYSTERIES      = 3820,
+    ENCHANT_HEAD_DOMINANCE              = 3796,
+    ENCHANT_HEAD_SAVAGE_GLADIATOR       = 3842,
+    ENCHANT_HEAD_STALWART_PROTECTOR     = 3818,
+    ENCHANT_HEAD_TORMENT                = 3817,
+    ENCHANT_HEAD_TRIUMPH                = 3795,
+    ENCHANT_HEAD_ECLIPSED_MOON            = 3815,
+    ENCHANT_HEAD_FLAME_SOUL                = 3816,
+    ENCHANT_HEAD_FLEEING_SHADOW            = 3814,
+    ENCHANT_HEAD_FROSTY_SOUL            = 3812,
+    ENCHANT_HEAD_TOXIC_WARDING            = 3813,
+
+    ENCHANT_SHOULDER_MASTERS_AXE        = 3835,
+    ENCHANT_SHOULDER_MASTERS_CRAG       = 3836,
+    ENCHANT_SHOULDER_MASTERS_PINNACLE   = 3837,
+    ENCHANT_SHOULDER_MASTERS_STORM      = 3838,
+    ENCHANT_SHOULDER_GREATER_AXE        = 3808,
+    ENCHANT_SHOULDER_GREATER_CRAG       = 3809,
+    ENCHANT_SHOULDER_GREATER_GLADIATOR  = 3852,
+    ENCHANT_SHOULDER_GREATER_PINNACLE   = 3811,
+    ENCHANT_SHOULDER_GREATER_STORM      = 3810,
+    ENCHANT_SHOULDER_DOMINANCE          = 3794,
+    ENCHANT_SHOULDER_TRIUMPH            = 3793,
+
+    ENCHANT_CLOAK_DARKGLOW_EMBROIDERY   = 3728,
+    ENCHANT_CLOAK_SWORDGUARD_EMBROIDERY = 3730,
+    ENCHANT_CLOAK_LIGHTWEAVE_EMBROIDERY = 3722,
+    ENCHANT_CLOAK_SPRINGY_ARACHNOWEAVE  = 3859,
+    ENCHANT_CLOAK_WISDOM                = 3296,
+    ENCHANT_CLOAK_TITANWEAVE            = 1951,
+    ENCHANT_CLOAK_SPELL_PIERCING        = 3243,
+    ENCHANT_CLOAK_SHADOW_ARMOR          = 3256,
+    ENCHANT_CLOAK_MIGHTY_ARMOR          = 3294,
+    ENCHANT_CLOAK_MAJOR_AGILITY         = 1099,
+    ENCHANT_CLOAK_GREATER_SPEED         = 3831,
+
+    ENCHANT_LEG_EARTHEN                    = 3853,
+    ENCHANT_LEG_FROSTHIDE                = 3822,
+    ENCHANT_LEG_ICESCALE                = 3823,
+    ENCHANT_LEG_BRILLIANT_SPELLTHREAD    = 3719,
+    ENCHANT_LEG_SAPPHIRE_SPELLTHREAD    = 3721,
+    ENCHANT_LEG_DRAGONSCALE                = 3331,
+    ENCHANT_LEG_WYRMSCALE                = 3332,
+
+    ENCHANT_GLOVES_GREATER_BLASTING        = 3249,
+    ENCHANT_GLOVES_ARMSMAN                = 3253,
+    ENCHANT_GLOVES_CRUSHER                = 1603,
+    ENCHANT_GLOVES_AGILITY                = 3222,
+    ENCHANT_GLOVES_PRECISION            = 3234,
+    ENCHANT_GLOVES_EXPERTISE            = 3231,
+
+    ENCHANT_BRACERS_MAJOR_STAMINA        = 3850,
+    ENCHANT_BRACERS_SUPERIOR_SP            = 2332,
+    ENCHANT_BRACERS_GREATER_ASSUALT        = 3845,
+    ENCHANT_BRACERS_MAJOR_SPIRT            = 1147,
+    ENCHANT_BRACERS_EXPERTISE            = 3231,
+    ENCHANT_BRACERS_GREATER_STATS        = 2661,
+    ENCHANT_BRACERS_INTELLECT            = 1119,
+    ENCHANT_BRACERS_FURL_ARCANE            = 3763,
+    ENCHANT_BRACERS_FURL_FIRE            = 3759,
+    ENCHANT_BRACERS_FURL_FROST            = 3760,
+    ENCHANT_BRACERS_FURL_NATURE            = 3762,
+    ENCHANT_BRACERS_FURL_SHADOW            = 3761,
+    ENCHANT_BRACERS_FURL_ATTACK            = 3756,
+    ENCHANT_BRACERS_FURL_STAMINA        = 3757,
+    ENCHANT_BRACERS_FURL_SPELLPOWER        = 3758,
+
+    ENCHANT_CHEST_POWERFUL_STATS        = 3832,
+    ENCHANT_CHEST_SUPER_HEALTH            = 3297,
+    ENCHANT_CHEST_GREATER_MAINA_REST        = 2381,
+    ENCHANT_CHEST_EXCEPTIONAL_RESIL        = 3245,
+    ENCHANT_CHEST_GREATER_DEFENSE        = 1953,
+
+    ENCHANT_BOOTS_GREATER_ASSULT        = 1597,
+    ENCHANT_BOOTS_TUSKARS_VITLIATY        = 3232,
+    ENCHANT_BOOTS_SUPERIOR_AGILITY        = 983,
+    ENCHANT_BOOTS_GREATER_SPIRIT        = 1147,
+    ENCHANT_BOOTS_GREATER_VITALITY        = 3244,
+    ENCHANT_BOOTS_ICEWALKER                = 3826,
+    ENCHANT_BOOTS_GREATER_FORTITUDE        = 1075,
+    ENCHANT_BOOTS_NITRO_BOOTS            = 3606,
+    ENCHANT_BOOTS_PYRO_ROCKET            = 3603,
+    ENCHANT_BOOTS_HYPERSPEED            = 3604,
+    ENCHANT_BOOTS_ARMOR_WEBBING            = 3860,
+
+    ENCHANT_RING_ASSULT                    = 3839,
+    ENCHANT_RING_GREATER_SP                = 3840,
+    ENCHANT_RING_STAMINA                = 3791,
+};
+
+void Enchant(Player* player, Item* item, uint32 enchantid)
+{
+    if (!item)
+    {
+        player->GetSession()->SendNotification("You must first equip the item you are trying to enchant in order to enchant it!");
+        return;
+    }
+
+
+
+    item->ClearEnchantment(PERM_ENCHANTMENT_SLOT);
+    item->SetEnchantment(PERM_ENCHANTMENT_SLOT, enchantid, 0, 0);
+    player->GetSession()->SendNotification("|cff800080%s |cffFF0000succesfully enchanted!", item->GetTemplate()->Name1.c_str());
+}
+
+void RemoveEnchant(Player* player, Item* item)
+{
+    if (!item)
+    {
+        player->GetSession()->SendNotification("You don't have the item equipped?");
+        return;
+    }
+
+    item->ClearEnchantment(PERM_ENCHANTMENT_SLOT);
+    player->GetSession()->SendNotification("|cff800080%s's |cffFF0000enchant has successfully been removed!", item->GetTemplate()->Name1.c_str());
+}
+
+class npc_enchantment : public CreatureScript
+{
+public:
+    npc_enchantment() : CreatureScript("npc_enchantment") { }
+
+        bool OnGossipHello(Player* player, Creature* creature)
+        {
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Weapon-]", GOSSIP_SENDER_MAIN, 1);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Off-Hand Weapon-]", GOSSIP_SENDER_MAIN, 13);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant 2H Weapon-]", GOSSIP_SENDER_MAIN, 2);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Shield-]", GOSSIP_SENDER_MAIN, 3);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Head-]", GOSSIP_SENDER_MAIN, 4);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Shoulders-]", GOSSIP_SENDER_MAIN, 5);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Cloak-]", GOSSIP_SENDER_MAIN, 6);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Chest-]", GOSSIP_SENDER_MAIN, 7);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Bracers-]", GOSSIP_SENDER_MAIN, 8);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Gloves-]", GOSSIP_SENDER_MAIN, 9);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Legs-]", GOSSIP_SENDER_MAIN, 10);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Feet-]", GOSSIP_SENDER_MAIN, 11);
+
+            if (player->HasSkill(SKILL_ENCHANTING) && player->GetSkillValue(SKILL_ENCHANTING) == 450)
+            {
+                player->ADD_GOSSIP_ITEM(1, "[-Enchant Rings-]", GOSSIP_SENDER_MAIN, 12);
+            }
+            player->ADD_GOSSIP_ITEM(1, "[-I wish to remove my enchant-]", GOSSIP_SENDER_MAIN, 14);
+
+            player->PlayerTalkClass->SendGossipMenu(100001, creature->GetGUID());
+            return true;
+        }
+
+        bool OnGossipSelect(Player* player, Creature* creature, uint32 /*sender*/, uint32 action)
+        {
+            player->PlayerTalkClass->ClearMenus();
+            Item * item;
+
+            switch (action)
+            {
+
+                case 1: // Enchant Weapon
+                    if (player->HasSkill(SKILL_ENCHANTING) && player->GetSkillValue(SKILL_ENCHANTING) == 450)
+                    {
+                        player->ADD_GOSSIP_ITEM(1, "Blade Ward", GOSSIP_SENDER_MAIN, 102);
+                        player->ADD_GOSSIP_ITEM(1, "Blood Draining", GOSSIP_SENDER_MAIN, 103);
+                    }
+                    player->ADD_GOSSIP_ITEM(1, "Exceptional Agility", GOSSIP_SENDER_MAIN, 100);
+                    player->ADD_GOSSIP_ITEM(1, "Exceptional Spirit", GOSSIP_SENDER_MAIN, 101);
+                    player->ADD_GOSSIP_ITEM(1, "Berserking", GOSSIP_SENDER_MAIN, 104);
+                    player->ADD_GOSSIP_ITEM(1, "Accuracy", GOSSIP_SENDER_MAIN, 105);
+                    player->ADD_GOSSIP_ITEM(1, "Black Magic", GOSSIP_SENDER_MAIN, 106);
+                    player->ADD_GOSSIP_ITEM(1, "Battlemaster", GOSSIP_SENDER_MAIN, 107);
+                    player->ADD_GOSSIP_ITEM(1, "Icebreaker", GOSSIP_SENDER_MAIN, 108);
+                    player->ADD_GOSSIP_ITEM(1, "Lifeward", GOSSIP_SENDER_MAIN, 109);
+                    player->ADD_GOSSIP_ITEM(1, "Titanguard", GOSSIP_SENDER_MAIN, 110);
+                    player->ADD_GOSSIP_ITEM(1, "Superior Potency", GOSSIP_SENDER_MAIN, 111);
+                    player->ADD_GOSSIP_ITEM(1, "Mighty Spellpower", GOSSIP_SENDER_MAIN, 112);
+                    player->ADD_GOSSIP_ITEM(1, "Mongoose", GOSSIP_SENDER_MAIN, 113);
+                    player->ADD_GOSSIP_ITEM(1, "Executioner", GOSSIP_SENDER_MAIN, 114);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100002, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 2: // Enchant 2H Weapon
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+
+                        if (!item)
+                        {
+                            player->GetSession()->SendNotification("You must equip a Two-Handed weapon first.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_2HWEAPON)
+                        {
+                            player->ADD_GOSSIP_ITEM(1, "Berserking", GOSSIP_SENDER_MAIN, 104);
+                            player->ADD_GOSSIP_ITEM(1, "Greater Spellpower", GOSSIP_SENDER_MAIN, 115);
+                            player->ADD_GOSSIP_ITEM(1, "Major Agility", GOSSIP_SENDER_MAIN, 116);
+                            player->ADD_GOSSIP_ITEM(1, "Massacre", GOSSIP_SENDER_MAIN, 117);
+                            player->ADD_GOSSIP_ITEM(1, "Mongoose", GOSSIP_SENDER_MAIN, 113);
+                            player->ADD_GOSSIP_ITEM(1, "Executioner", GOSSIP_SENDER_MAIN, 114);
+                            player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                            player->PlayerTalkClass->SendGossipMenu(100003, creature->GetGUID());
+                            return true;
+                        }
+                        else
+                        {
+                            player->GetSession()->SendNotification("You don't have a Two-Handed weapon equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 3: // Enchant Shield
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if (!item)
+                        {
+                            player->GetSession()->SendNotification("You must equip a shield first.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_SHIELD)
+                        {
+                            player->ADD_GOSSIP_ITEM(1, "Defense", GOSSIP_SENDER_MAIN, 118);
+                            player->ADD_GOSSIP_ITEM(1, "Greater Intellect", GOSSIP_SENDER_MAIN, 119);
+                            player->ADD_GOSSIP_ITEM(1, "Resilience", GOSSIP_SENDER_MAIN, 120);
+                            player->ADD_GOSSIP_ITEM(1, "Titanium Plating", GOSSIP_SENDER_MAIN, 121);
+                            player->ADD_GOSSIP_ITEM(1, "Major Stamina", GOSSIP_SENDER_MAIN, 122);
+                            player->ADD_GOSSIP_ITEM(1, "Tough Shield", GOSSIP_SENDER_MAIN, 123);
+                            player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                            player->PlayerTalkClass->SendGossipMenu(100004, creature->GetGUID());
+                            return true;
+                        }
+                        else
+                        {
+                            player->GetSession()->SendNotification("You don't have a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 4: // Enchant Head
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of Blissful Mending", GOSSIP_SENDER_MAIN, 124);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of Burning Mysteries", GOSSIP_SENDER_MAIN, 125);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of Dominance", GOSSIP_SENDER_MAIN, 126);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of The Savage Gladiator", GOSSIP_SENDER_MAIN, 127);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of The Stalwart Protector", GOSSIP_SENDER_MAIN, 128);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of Torment", GOSSIP_SENDER_MAIN, 129);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of Triumph", GOSSIP_SENDER_MAIN, 130);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of Eclipsed Moon", GOSSIP_SENDER_MAIN, 131);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of the Flame's Soul", GOSSIP_SENDER_MAIN, 132);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of the Fleeing Shadow", GOSSIP_SENDER_MAIN, 133);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of the Frosty Soul", GOSSIP_SENDER_MAIN, 134);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of Toxic Warding", GOSSIP_SENDER_MAIN, 135);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100005, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 5: // Enchant Shoulders
+                    if (player->HasSkill(SKILL_INSCRIPTION) && player->GetSkillValue(SKILL_INSCRIPTION) == 450)
+                    {
+                        player->ADD_GOSSIP_ITEM(1, "Master's Inscription of the Axe", GOSSIP_SENDER_MAIN, 136);
+                        player->ADD_GOSSIP_ITEM(1, "Master's Inscription of the Crag", GOSSIP_SENDER_MAIN, 137);
+                        player->ADD_GOSSIP_ITEM(1, "Master's Inscription of the Pinnacle", GOSSIP_SENDER_MAIN, 138);
+                        player->ADD_GOSSIP_ITEM(1, "Master's Inscription of the Storm", GOSSIP_SENDER_MAIN, 139);
+                    }
+                    player->ADD_GOSSIP_ITEM(1, "Greater Inscription of the Axe", GOSSIP_SENDER_MAIN, 140);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Inscription of the Crag", GOSSIP_SENDER_MAIN, 141);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Inscription of the Pinnacle", GOSSIP_SENDER_MAIN, 142);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Inscription of the Gladiator", GOSSIP_SENDER_MAIN, 143);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Inscription of the Storm", GOSSIP_SENDER_MAIN, 144);
+                    player->ADD_GOSSIP_ITEM(1, "Inscription of Dominance", GOSSIP_SENDER_MAIN, 145);
+                    player->ADD_GOSSIP_ITEM(1, "Inscription of Triumph", GOSSIP_SENDER_MAIN, 146);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100006, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 6: // Enchant Cloak
+                    player->ADD_GOSSIP_ITEM(1, "Springy Arachnoweave", GOSSIP_SENDER_MAIN, 147);
+                    player->ADD_GOSSIP_ITEM(1, "Shadow Armor", GOSSIP_SENDER_MAIN, 148);
+                    player->ADD_GOSSIP_ITEM(1, "Darkglow Embroidery", GOSSIP_SENDER_MAIN, 149);
+                    player->ADD_GOSSIP_ITEM(1, "Lightweave Embroidery", GOSSIP_SENDER_MAIN, 150);
+                    player->ADD_GOSSIP_ITEM(1, "Swordguard Embroidery", GOSSIP_SENDER_MAIN, 151);
+                    player->ADD_GOSSIP_ITEM(1, "Wisdom", GOSSIP_SENDER_MAIN, 152);
+                    player->ADD_GOSSIP_ITEM(1, "Titanweave", GOSSIP_SENDER_MAIN, 153);
+                    player->ADD_GOSSIP_ITEM(1, "Spell Piercing", GOSSIP_SENDER_MAIN, 154);
+                    player->ADD_GOSSIP_ITEM(1, "Mighty Armor", GOSSIP_SENDER_MAIN, 155);
+                    player->ADD_GOSSIP_ITEM(1, "Major Agility", GOSSIP_SENDER_MAIN, 156);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Speed", GOSSIP_SENDER_MAIN, 157);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100007, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 7: //Enchant chest
+                    player->ADD_GOSSIP_ITEM(1, "Powerful Stats", GOSSIP_SENDER_MAIN, 158);
+                    player->ADD_GOSSIP_ITEM(1, "Super Health", GOSSIP_SENDER_MAIN, 159);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Mana Restoration", GOSSIP_SENDER_MAIN, 160);
+                    player->ADD_GOSSIP_ITEM(1, "Exceptional Resilience", GOSSIP_SENDER_MAIN, 161);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Defense", GOSSIP_SENDER_MAIN, 162);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100008, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 8: //Enchant Bracers
+                    player->ADD_GOSSIP_ITEM(1, "Major Stamina", GOSSIP_SENDER_MAIN, 163);
+                    player->ADD_GOSSIP_ITEM(1, "Superior Spell Power", GOSSIP_SENDER_MAIN, 164);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Assult", GOSSIP_SENDER_MAIN, 165);
+                    player->ADD_GOSSIP_ITEM(1, "Major Spirit", GOSSIP_SENDER_MAIN, 166);
+                    player->ADD_GOSSIP_ITEM(1, "Expertise", GOSSIP_SENDER_MAIN, 167);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Stats", GOSSIP_SENDER_MAIN, 168);
+                    player->ADD_GOSSIP_ITEM(1, "Exceptional Intellect", GOSSIP_SENDER_MAIN, 169);
+                    player->ADD_GOSSIP_ITEM(1, "Fur Lining - Arcane Resist", GOSSIP_SENDER_MAIN, 170);
+                    player->ADD_GOSSIP_ITEM(1, "Fur Lining - Fire Resist", GOSSIP_SENDER_MAIN, 171);
+                    player->ADD_GOSSIP_ITEM(1, "Fur Lining - Frost Resist", GOSSIP_SENDER_MAIN, 172);
+                    player->ADD_GOSSIP_ITEM(1, "Fur Lining - Nature Resist", GOSSIP_SENDER_MAIN, 173);
+                    player->ADD_GOSSIP_ITEM(1, "Fur Lining - Shadow Resist", GOSSIP_SENDER_MAIN, 174);
+                    player->ADD_GOSSIP_ITEM(1, "Fur Lining - Attack power", GOSSIP_SENDER_MAIN, 175);
+                    player->ADD_GOSSIP_ITEM(1, "Fur Lining - Stamina", GOSSIP_SENDER_MAIN, 176);
+                    player->ADD_GOSSIP_ITEM(1, "Fur Lining - Spellpower", GOSSIP_SENDER_MAIN, 177);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100009, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 9: //Enchant Gloves
+                    player->ADD_GOSSIP_ITEM(1, "Greater Blasting", GOSSIP_SENDER_MAIN, 178);
+                    player->ADD_GOSSIP_ITEM(1, "Armsman", GOSSIP_SENDER_MAIN, 179);
+                    player->ADD_GOSSIP_ITEM(1, "Crusher", GOSSIP_SENDER_MAIN, 180);
+                    player->ADD_GOSSIP_ITEM(1, "Agility", GOSSIP_SENDER_MAIN, 181);
+                    player->ADD_GOSSIP_ITEM(1, "Precision", GOSSIP_SENDER_MAIN, 182);
+                    player->ADD_GOSSIP_ITEM(1, "Expertise", GOSSIP_SENDER_MAIN, 183);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100010, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 10: //Enchant legs
+                    player->ADD_GOSSIP_ITEM(1, "Earthen Leg Armor", GOSSIP_SENDER_MAIN, 184);
+                    player->ADD_GOSSIP_ITEM(1, "Frosthide Leg Armor", GOSSIP_SENDER_MAIN, 185);
+                    player->ADD_GOSSIP_ITEM(1, "Icescale Leg Armor", GOSSIP_SENDER_MAIN, 186);
+                    player->ADD_GOSSIP_ITEM(1, "Brilliant Spellthread", GOSSIP_SENDER_MAIN, 187);
+                    player->ADD_GOSSIP_ITEM(1, "Sapphire Spellthread", GOSSIP_SENDER_MAIN, 188);
+                    player->ADD_GOSSIP_ITEM(1, "Dragonscale Leg Armor", GOSSIP_SENDER_MAIN, 189);
+                    player->ADD_GOSSIP_ITEM(1, "Wyrmscale Leg Armor", GOSSIP_SENDER_MAIN, 190);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100011, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 11: //Enchant feet
+                    player->ADD_GOSSIP_ITEM(1, "Greater Assult", GOSSIP_SENDER_MAIN, 191);
+                    player->ADD_GOSSIP_ITEM(1, "Tuskars Vitliaty", GOSSIP_SENDER_MAIN, 192);
+                    player->ADD_GOSSIP_ITEM(1, "Superior Agility", GOSSIP_SENDER_MAIN, 193);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Spirit", GOSSIP_SENDER_MAIN, 194);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Vitality", GOSSIP_SENDER_MAIN, 195);
+                    player->ADD_GOSSIP_ITEM(1, "Icewalker", GOSSIP_SENDER_MAIN, 196);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Fortitude", GOSSIP_SENDER_MAIN, 197);
+                    player->ADD_GOSSIP_ITEM(1, "Nitro Boots", GOSSIP_SENDER_MAIN, 198);
+                    player->ADD_GOSSIP_ITEM(1, "Hand-Mounted Pyro Rocket", GOSSIP_SENDER_MAIN, 199);
+                    player->ADD_GOSSIP_ITEM(1, "Hyperspeed Accedlerators", GOSSIP_SENDER_MAIN, 200);
+                    player->ADD_GOSSIP_ITEM(1, "Reticulated Armor Webbing", GOSSIP_SENDER_MAIN, 201);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100012, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 12: //Enchant rings
+                    player->ADD_GOSSIP_ITEM(1, "Assult", GOSSIP_SENDER_MAIN, 202);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Spell Power", GOSSIP_SENDER_MAIN, 203);
+                    player->ADD_GOSSIP_ITEM(1, "Stamina", GOSSIP_SENDER_MAIN, 204);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100013, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 13: //Enchant Off-Hand weapons
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendNotification("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            player->ADD_GOSSIP_ITEM(1, "Blade Ward", GOSSIP_SENDER_MAIN, 205);
+                            player->ADD_GOSSIP_ITEM(1, "Blood Draining", GOSSIP_SENDER_MAIN, 219);
+                            player->ADD_GOSSIP_ITEM(1, "Exceptional Agility", GOSSIP_SENDER_MAIN, 206);
+                            player->ADD_GOSSIP_ITEM(1, "Exceptional Spirit", GOSSIP_SENDER_MAIN, 207);
+                            player->ADD_GOSSIP_ITEM(1, "Berserking", GOSSIP_SENDER_MAIN, 208);
+                            player->ADD_GOSSIP_ITEM(1, "Accuracy", GOSSIP_SENDER_MAIN, 209);
+                            player->ADD_GOSSIP_ITEM(1, "Black Magic", GOSSIP_SENDER_MAIN, 210);
+                            player->ADD_GOSSIP_ITEM(1, "Battlemaster", GOSSIP_SENDER_MAIN, 211);
+                            player->ADD_GOSSIP_ITEM(1, "Icebreaker", GOSSIP_SENDER_MAIN, 212);
+                            player->ADD_GOSSIP_ITEM(1, "Lifeward", GOSSIP_SENDER_MAIN, 213);
+                            player->ADD_GOSSIP_ITEM(1, "Titanguard", GOSSIP_SENDER_MAIN, 214);
+                            player->ADD_GOSSIP_ITEM(1, "Superior Potency", GOSSIP_SENDER_MAIN, 215);
+                            player->ADD_GOSSIP_ITEM(1, "Mighty Spellpower", GOSSIP_SENDER_MAIN, 216);
+                            player->ADD_GOSSIP_ITEM(1, "Mongoose", GOSSIP_SENDER_MAIN, 217);
+                            player->ADD_GOSSIP_ITEM(1, "Executioner", GOSSIP_SENDER_MAIN, 218);
+                            player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                            player->PlayerTalkClass->SendGossipMenu(100002, creature->GetGUID());
+                            return true;
+                        }
+                        else
+                        {
+                            player->GetSession()->SendNotification("Your Off-Hand is not a weapon.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 14: //Remove enchant menu
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Main-hand", GOSSIP_SENDER_MAIN, 400);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Off-hand", GOSSIP_SENDER_MAIN, 401);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Head", GOSSIP_SENDER_MAIN, 402);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Shoulders", GOSSIP_SENDER_MAIN, 403);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Cloak", GOSSIP_SENDER_MAIN, 404);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Chest", GOSSIP_SENDER_MAIN, 405);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Bracers", GOSSIP_SENDER_MAIN, 406);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Gloves", GOSSIP_SENDER_MAIN, 407);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Legs", GOSSIP_SENDER_MAIN, 408);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Feet", GOSSIP_SENDER_MAIN, 409);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Rings", GOSSIP_SENDER_MAIN, 409);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100014, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 100:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_AGILITY_1H);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 101:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_SPIRIT);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 102:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_BLADE_WARD);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 103:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_BLOOD_DRAINING);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 104:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_BERSERKING);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 105:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_ACCURACY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 106:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_BLACK_MAGIC);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 107:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_BATTLEMASTER);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 108:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_ICEBREAKER);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 109:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_LIFEWARD);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 110:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_TITANGUARD);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 111:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_POTENCY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 112:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_MIGHTY_SPELL_POWER);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 113:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_2WEP_MONGOOSE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 114:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_EXECUTIONER);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 115:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+
+                        if (!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a 2H weapon equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_2HWEAPON)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_2WEP_GREATER_SPELL_POWER);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("You don't have a Two-Handed weapon equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 116:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+
+                        if (!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a 2H weapon equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_2HWEAPON)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_2WEP_AGILITY);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("You don't have a Two-Handed weapon equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 117:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+
+                        if (!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a 2H weapon equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_2HWEAPON)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_2WEP_MASSACRE);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("You don't have a Two-Handed weapon equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 118:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_SHIELD)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_SHIELD_DEFENSE);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("You don't have a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 119:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_SHIELD)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_SHIELD_INTELLECT);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("You don't have a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 120:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_SHIELD)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_SHIELD_RESILIENCE);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("You don't have a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 121:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_SHIELD)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_SHIELD_TITANIUM_PLATING);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("You don't have a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 122:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_SHIELD)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_SHIELD_STAMINA);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("You don't have a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 123:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_SHIELD)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_SHIELD_TOUGHSHIELD);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("You don't have a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 124:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_BLISSFUL_MENDING);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 125:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_BURNING_MYSTERIES);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 126:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_DOMINANCE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 127:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_SAVAGE_GLADIATOR);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 128:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_STALWART_PROTECTOR);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 129:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_TORMENT);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 130:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_TRIUMPH);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 131:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_ECLIPSED_MOON);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 132:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_FLAME_SOUL);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 133:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_FLEEING_SHADOW);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 134:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_FROSTY_SOUL);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 135:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_TOXIC_WARDING);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 136:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_MASTERS_AXE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 137:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_MASTERS_CRAG);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 138:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_MASTERS_PINNACLE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 139:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_MASTERS_STORM);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 140:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_GREATER_AXE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 141:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_GREATER_CRAG);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 142:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_GREATER_GLADIATOR);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 143:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_GREATER_PINNACLE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 144:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_GREATER_STORM);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 145:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_DOMINANCE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 146:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_TRIUMPH);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 147:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_SPRINGY_ARACHNOWEAVE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 148:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_SHADOW_ARMOR);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 149:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_DARKGLOW_EMBROIDERY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 150:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_LIGHTWEAVE_EMBROIDERY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 151:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_SWORDGUARD_EMBROIDERY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 152:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_WISDOM);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 153:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_TITANWEAVE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 154:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_SPELL_PIERCING);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 155:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_MIGHTY_ARMOR);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 156:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_MAJOR_AGILITY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 157:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_GREATER_SPEED);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 158:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_CHEST), ENCHANT_CHEST_POWERFUL_STATS);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 159:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_CHEST), ENCHANT_CHEST_SUPER_HEALTH);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 160:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_CHEST), ENCHANT_CHEST_GREATER_MAINA_REST);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 161:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_CHEST), ENCHANT_CHEST_EXCEPTIONAL_RESIL);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 162:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_CHEST), ENCHANT_CHEST_GREATER_DEFENSE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 163:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_MAJOR_STAMINA);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 164:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_SUPERIOR_SP);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 165:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_GREATER_ASSUALT);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 166:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_MAJOR_SPIRT);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 167:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_EXPERTISE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 168:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_GREATER_STATS);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 169:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_INTELLECT);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 170:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_FURL_ARCANE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 171:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_FURL_FIRE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 172:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_FURL_FROST);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 173:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_FURL_NATURE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 174:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_FURL_SHADOW);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 175:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_FURL_ATTACK);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 176:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_FURL_STAMINA);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 177:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_FURL_SPELLPOWER);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 178:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HANDS), ENCHANT_GLOVES_GREATER_BLASTING);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 179:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HANDS), ENCHANT_GLOVES_ARMSMAN);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 180:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HANDS), ENCHANT_GLOVES_CRUSHER);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 181:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HANDS), ENCHANT_GLOVES_AGILITY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 182:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HANDS), ENCHANT_GLOVES_PRECISION);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 183:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HANDS), ENCHANT_GLOVES_EXPERTISE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 184:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_LEGS), ENCHANT_LEG_EARTHEN);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 185:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_LEGS), ENCHANT_LEG_FROSTHIDE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 186:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_LEGS), ENCHANT_LEG_ICESCALE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 187:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_LEGS), ENCHANT_LEG_BRILLIANT_SPELLTHREAD);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 188:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_LEGS), ENCHANT_LEG_SAPPHIRE_SPELLTHREAD);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 189:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_LEGS), ENCHANT_LEG_DRAGONSCALE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 190:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_LEGS), ENCHANT_LEG_WYRMSCALE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 191:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_GREATER_ASSULT);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 192:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_TUSKARS_VITLIATY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 193:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_SUPERIOR_AGILITY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 194:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_GREATER_SPIRIT);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 195:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_GREATER_VITALITY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 196:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_ICEWALKER);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 197:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_GREATER_FORTITUDE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 198:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_NITRO_BOOTS);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 199:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_PYRO_ROCKET);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 200:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_HYPERSPEED);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 201:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_ARMOR_WEBBING);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 202:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FINGER1), ENCHANT_RING_ASSULT);
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FINGER2), ENCHANT_RING_ASSULT);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 203:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FINGER1), ENCHANT_RING_GREATER_SP);
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FINGER2), ENCHANT_RING_GREATER_SP);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 204:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FINGER1), ENCHANT_RING_STAMINA);
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FINGER2), ENCHANT_RING_STAMINA);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 205:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_BLADE_WARD);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 206:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_AGILITY_1H);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 207:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_SPIRIT);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 208:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_BERSERKING);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 209:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_ACCURACY);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 210:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_BLACK_MAGIC);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 211:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_BATTLEMASTER);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 212:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_ICEBREAKER);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 213:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_LIFEWARD);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 214:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_TITANGUARD);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 215:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_POTENCY);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 216:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_MIGHTY_SPELL_POWER);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 217:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_2WEP_MONGOOSE);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 218:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_EXECUTIONER);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 219:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_BLOOD_DRAINING);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 300: //<-Back menu
+                    {
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Weapon-]", GOSSIP_SENDER_MAIN, 1);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Off-Hand Weapon-]", GOSSIP_SENDER_MAIN, 13);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant 2H Weapon-]", GOSSIP_SENDER_MAIN, 2);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Shield-]", GOSSIP_SENDER_MAIN, 3);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Head-]", GOSSIP_SENDER_MAIN, 4);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Shoulders-]", GOSSIP_SENDER_MAIN, 5);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Cloak-]", GOSSIP_SENDER_MAIN, 6);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Chest-]", GOSSIP_SENDER_MAIN, 7);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Bracers-]", GOSSIP_SENDER_MAIN, 8);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Gloves-]", GOSSIP_SENDER_MAIN, 9);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Legs-]", GOSSIP_SENDER_MAIN, 10);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Feet-]", GOSSIP_SENDER_MAIN, 11);
+
+                        if (player->HasSkill(SKILL_ENCHANTING) && player->GetSkillValue(SKILL_ENCHANTING) == 450)
+                        {
+                            player->ADD_GOSSIP_ITEM(1, "[-Enchant Rings-]", GOSSIP_SENDER_MAIN, 12);
+                        }
+                        player->ADD_GOSSIP_ITEM(1, "[-I wish to remove my enchant-]", GOSSIP_SENDER_MAIN, 14);
+
+                        player->PlayerTalkClass->SendGossipMenu(100001, creature->GetGUID());
+                        return true;
+                    }
+                        break;
+
+                case 400: //Remove enchant for mainhand
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 401: //Remove enchant for offhand
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 402: //Remove enchant for head
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 403: //Remove enchant for shoulders
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 404: //remove enchant for cloak
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 405: //remove enchant for chest
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_CHEST));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 406: //remove enchant for bracers
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 407: //remove enchant for gloves
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HANDS));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 408: //remove enchant for legs
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_LEGS));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 409: //remove enchant for feet
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 410:
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FINGER1));
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FINGER2));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                }
+            return true;
+        }
+    };
+
+
+void AddSC_npc_enchantment()
+{
+  new npc_enchantment();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/gon_playerscripts.cpp b/src/server/scripts/Custom/gon_playerscripts.cpp
new file mode 100644
index 0000000..ffe7528
--- /dev/null
+++ b/src/server/scripts/Custom/gon_playerscripts.cpp
@@ -0,0 +1,31 @@
+#include "ScriptMgr.h"
+#include "Player.h"
+#include "GuildMgr.h"
+#include "Config.h"
+/*
+#define GUILD_ID_ALLIANCE 45 //Guild ID
+#define GUILD_ID_HORDE   46 //Guild ID
+*/
+class gon_playerscripts : public PlayerScript
+{
+    public:
+        gon_playerscripts() : PlayerScript("gon_playerscripts") { }
+
+   void OnLogin(Player* player, bool firstLogin)
+    {
+        if (firstLogin)
+        {
+            uint32 GUILD_ID_ALLIANCE = sConfigMgr->GetIntDefault("StartGuild.Alliance", 0);
+            uint32 GUILD_ID_HORDE = sConfigMgr->GetIntDefault("StartGuild.Horde", 0);
+            Guild* guild = sGuildMgr->GetGuildById(player->GetTeam() == ALLIANCE ? GUILD_ID_ALLIANCE : GUILD_ID_HORDE);
+
+            if (guild)
+                guild->AddMember(player->GetGUID());
+        }
+    }
+};
+
+void AddSC_gon_playerscripts()
+{
+    new gon_playerscripts();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/guildmaster.cpp b/src/server/scripts/Custom/guildmaster.cpp
new file mode 100644
index 0000000..835f87c
--- /dev/null
+++ b/src/server/scripts/Custom/guildmaster.cpp
@@ -0,0 +1,308 @@
+#include "Config.h"
+
+#define MSG_GOSSIP_TELE          "Teleport to GuildHouse"
+#define MSG_GOSSIP_BUY           "Buy GuildHouse"
+#define MSG_GOSSIP_SELL          "Sell GuildHouse"
+#define MSG_GOSSIP_NEXTPAGE      "Next -->"
+#define MSG_INCOMBAT             "You are in combat and cannot be teleported to your GuildHouse."
+#define MSG_NOGUILDHOUSE         "Your guild currently does not own a GuildHouse."
+#define MSG_NOFREEGH             "Unfortunately, all GuildHouses are in use."
+#define MSG_ALREADYHAVEGH        "Sorry, but you already own a GuildHouse (%s)."
+#define MSG_NOTENOUGHMONEY       "You do not have the %u gold required to purchase a GuildHouse."
+#define MSG_GHOCCUPIED           "This GuildHouse is unavailable for purchase as it is currently in use."
+#define MSG_CONGRATULATIONS      "Congratulations! You have successfully purchased a GuildHouse."
+#define MSG_SOLD                 "You have sold your GuildHouse and have received %u gold."
+#define MSG_NOTINGUILD           "You need to be in a guild before you can use a GuildHouse."
+#define MSG_SELL_CONFIRM         "Are you sure you want to sell your guildhouse for half the buy price?"
+
+#define OFFSET_GH_ID_TO_ACTION 1500
+#define OFFSET_SHOWBUY_FROM 10000
+
+#define ACTION_TELE 1001
+#define ACTION_SHOW_BUYLIST 1002 //deprecated. Use (OFFSET_SHOWBUY_FROM + 0) instead
+#define ACTION_SELL_GUILDHOUSE 1003
+
+#define ICON_GOSSIP_BALOON 0
+#define ICON_GOSSIP_WING 2
+#define ICON_GOSSIP_BOOK 3
+#define ICON_GOSSIP_WHEEL1 4
+#define ICON_GOSSIP_WHEEL2 5
+#define ICON_GOSSIP_GOLD 6
+#define ICON_GOSSIP_BALOONDOTS 7
+#define ICON_GOSSIP_TABARD 8
+#define ICON_GOSSIP_XSWORDS 9
+
+#define COST_GH_BUY 10000000 //1000 g.
+#define COST_GH_SELL 5000000 //500 g.
+
+#define GOSSIP_COUNT_MAX 10
+
+class guildmaster : public CreatureScript
+{
+ public:
+ guildmaster() : CreatureScript("guildmaster") { }
+
+bool isPlayerGuildLeader(Player *player)
+{
+ return (player->GetRank() == 0) && (player->GetGuildId() != 0);
+}
+
+bool getGuildHouseCoords(uint32 guildId, float &x, float &y, float &z, uint32 &map)
+{
+ if (guildId == 0)
+ {
+ //if player has no guild
+ return false;
+ }
+
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `x`, `y`, `z`, `map` FROM `guildhouses` WHERE `guildId` = %u", guildId);
+ if (result)
+ {
+ Field *fields = result->Fetch();
+ x = fields[0].GetFloat();
+ y = fields[1].GetFloat();
+ z = fields[2].GetFloat();
+ map = fields[3].GetUInt32();
+ return true;
+ }
+
+ return false;
+}
+
+void teleportPlayerToGuildHouse(Player *player, Creature *_creature)
+{
+ if (player->GetGuildId() == 0)
+ {
+ //if player has no guild
+ _creature->Whisper(MSG_NOTINGUILD, LANG_UNIVERSAL, player);
+ return;
+ }
+
+ if (!player->getAttackers().empty())
+ {
+ //if player in combat
+ _creature->Say(MSG_INCOMBAT, LANG_UNIVERSAL, player);
+ return;
+ }
+
+ float x, y, z;
+ uint32 map;
+
+ if (getGuildHouseCoords(player->GetGuildId(), x, y, z, map))
+ {
+ //teleport player to the specified location
+ player->TeleportTo(map, x, y, z, 0.0f);
+ }
+ else
+ _creature->Whisper(MSG_NOGUILDHOUSE, LANG_UNIVERSAL, player);
+}
+
+bool showBuyList(Player *player, Creature *_creature, uint32 showFromId = 0)
+{
+ //show not occupied guildhouses
+
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `id`, `comment` FROM `guildhouses` WHERE `guildId` = 0 AND `id` > %u ORDER BY `id` ASC LIMIT %u",
+ showFromId, GOSSIP_COUNT_MAX);
+
+ if (result)
+ {
+ uint32 guildhouseId = 0;
+ std::string comment = "";
+ do
+ {
+ Field *fields = result->Fetch();
+ guildhouseId = fields[0].GetInt32();
+ comment = fields[1].GetString();
+
+ //send comment as a gossip item
+ //transmit guildhouseId in Action variable
+ player->ADD_GOSSIP_ITEM(ICON_GOSSIP_TABARD, comment, GOSSIP_SENDER_MAIN,
+ guildhouseId + OFFSET_GH_ID_TO_ACTION);
+ }
+ while (result->NextRow());
+
+ if (result->GetRowCount() == GOSSIP_COUNT_MAX)
+ {
+ //assume that we have additional page
+ //add link to next GOSSIP_COUNT_MAX items
+ player->ADD_GOSSIP_ITEM(ICON_GOSSIP_BALOONDOTS, MSG_GOSSIP_NEXTPAGE, GOSSIP_SENDER_MAIN,
+ guildhouseId + OFFSET_SHOWBUY_FROM);
+ }
+
+ player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, _creature->GetGUID());
+
+ return true;
+ }
+ else if (!result)
+ {
+ //all guildhouses are occupied
+ _creature->Whisper(MSG_NOFREEGH, LANG_UNIVERSAL, player);
+ player->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+ //this condition occurs when COUNT(guildhouses) % GOSSIP_COUNT_MAX == 0
+ //just show GHs from beginning
+ showBuyList(player, _creature, 0);
+ }
+
+ return false;
+}
+
+bool isPlayerHasGuildhouse(Player *player, Creature *_creature, bool whisper = false)
+{
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `comment` FROM `guildhouses` WHERE `guildId` = %u",
+ player->GetGuildId());
+
+ if (result)
+ {
+ if (whisper)
+ {
+ //whisper to player "already have etc..."
+ Field *fields = result->Fetch();
+ char msg[100];
+ sprintf(msg, MSG_ALREADYHAVEGH, fields[0].GetCString());
+ _creature->Whisper(msg, LANG_UNIVERSAL, player);
+ }
+
+ return true;
+ }
+
+ return false;
+}
+
+void buyGuildhouse(Player *player, Creature *_creature, uint32 guildhouseId)
+{
+
+ bool token = sConfigMgr->GetBoolDefault("GuildHouse.TokenOrGold", false);
+ int cost = sConfigMgr->GetBoolDefault("GuildHouse.Cost", false);
+
+ if (player->GetMoney() < COST_GH_BUY)
+ {
+ //show how much money player need to buy GH (in gold)
+ char msg[100];
+ sprintf(msg, MSG_NOTENOUGHMONEY, COST_GH_BUY - sConfigMgr->GetBoolDefault("GuildHouse.Cost", false));
+ _creature->Whisper(msg, LANG_UNIVERSAL, player);
+ return;
+ }
+
+ if (isPlayerHasGuildhouse(player, _creature, true))
+ {
+ //player already have GH
+ return;
+ }
+
+ QueryResult result;
+
+ //check if somebody already occupied this GH
+ result = WorldDatabase.PQuery("SELECT `id` FROM `guildhouses` WHERE `id` = %u AND `guildId` <> 0", guildhouseId);
+
+ if (result)
+ {
+ _creature->Whisper(MSG_GHOCCUPIED, LANG_UNIVERSAL, player);
+ return;
+ }
+
+ //update DB
+ result = WorldDatabase.PQuery("UPDATE `guildhouses` SET `guildId` = %u WHERE `id` = %u",
+ player->GetGuildId(), guildhouseId);
+
+
+ player->ModifyMoney(-sConfigMgr->GetIntDefault("GuildHouse.BuyCost", false) * 10000);
+
+ //player->DestroyItemCount(token, cost, true);
+ _creature->Say(MSG_CONGRATULATIONS, LANG_UNIVERSAL, player);
+
+}
+
+void sellGuildhouse(Player *player, Creature *_creature)
+{
+ if (isPlayerHasGuildhouse(player, _creature))
+ {
+ QueryResult result;
+ result = WorldDatabase.PQuery("UPDATE `guildhouses` SET `guildId` = 0 WHERE `guildId` = %u",
+ player->GetGuildId());
+
+ player->ModifyMoney(sConfigMgr->GetIntDefault("GuildHouse.SellCost", false) * 10000);
+
+ //display message e.g. "here your money etc."
+ char msg[100];
+ sprintf(msg, MSG_SOLD, sConfigMgr->GetIntDefault("GuildHouse.SellCost", false));
+ _creature->Whisper(msg, LANG_UNIVERSAL, player);
+ }
+}
+
+ bool OnGossipSelect(Player *player, Creature *_creature, uint32 sender, uint32 action)
+ {
+ player->PlayerTalkClass->ClearMenus();
+ if (sender != GOSSIP_SENDER_MAIN)
+ return false;
+
+ switch (action)
+ {
+ case ACTION_TELE:
+ //teleport player to GH
+ player->CLOSE_GOSSIP_MENU();
+ teleportPlayerToGuildHouse(player, _creature);
+ break;
+ case ACTION_SHOW_BUYLIST:
+ //show list of GHs which currently not occupied
+ showBuyList(player, _creature);
+ break;
+ case ACTION_SELL_GUILDHOUSE:
+  sellGuildhouse(player, _creature);
+  player->CLOSE_GOSSIP_MENU();
+ break;
+ default:
+ if (action > OFFSET_SHOWBUY_FROM)
+ {
+ showBuyList(player, _creature, action - OFFSET_SHOWBUY_FROM);
+ }
+ else if (action > OFFSET_GH_ID_TO_ACTION)
+ {
+ //player clicked on buy list
+ player->CLOSE_GOSSIP_MENU();
+
+ //get guildhouseId from action
+ //guildhouseId = action - OFFSET_GH_ID_TO_ACTION
+ buyGuildhouse(player, _creature, action - OFFSET_GH_ID_TO_ACTION);
+ }
+ break;
+ }
+
+ return true;
+ }
+
+
+ bool OnGossipHello(Player *player, Creature *_creature)
+ {
+ player->ADD_GOSSIP_ITEM(ICON_GOSSIP_BALOON, MSG_GOSSIP_TELE, GOSSIP_SENDER_MAIN, ACTION_TELE);
+
+ if (isPlayerGuildLeader(player))
+ {
+ if (isPlayerHasGuildhouse(player, _creature))
+ {
+ //and additional for guildhouse owner (Removed :
+ player->ADD_GOSSIP_ITEM_EXTENDED(ICON_GOSSIP_GOLD, MSG_GOSSIP_SELL, GOSSIP_SENDER_MAIN, ACTION_SELL_GUILDHOUSE, MSG_SELL_CONFIRM, 0, false);
+
+ }
+ else
+ {
+ //show additional menu for guild leader
+ player->ADD_GOSSIP_ITEM(ICON_GOSSIP_GOLD, MSG_GOSSIP_BUY, GOSSIP_SENDER_MAIN, ACTION_SHOW_BUYLIST);
+ }
+ }
+
+ player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, _creature->GetGUID());
+ return true;
+ }
+
+
+};
+void AddSC_guildmaster()
+{
+ new guildmaster();
+}
diff --git a/src/server/scripts/Custom/killstreak.cpp b/src/server/scripts/Custom/killstreak.cpp
new file mode 100644
index 0000000..4a0e831
--- /dev/null
+++ b/src/server/scripts/Custom/killstreak.cpp
@@ -0,0 +1,61 @@
+/*
+Originally by Kjanko
+Edited by Tommy
+Edited by Rochet2 ~ Made dynamic
+Last Edit By Estorn
+Change : Fix For Last Rev
+*/
+
+class System_OnKill : public PlayerScript
+{
+public:
+    System_OnKill() : PlayerScript("System_OnKill") {}
+
+    void OnPVPKill(Player * Killer, Player * Victim)
+    {
+        uint32 KillerGUID = Killer->GetGUID().GetCounter();
+        uint32 VictimGUID = Victim->GetGUID().GetCounter();
+
+        struct KillStreak_Info
+        {
+            uint32 killstreak;
+            uint32 lastkill;
+        };
+
+        static std::map<uint32, KillStreak_Info> KillStreakData;
+
+        if (KillerGUID == VictimGUID || KillStreakData[KillerGUID].lastkill == VictimGUID)
+            return;
+
+        if (KillStreakData[VictimGUID].killstreak >= 3)
+        {
+            std::ostringstream ss;
+            ss << "|cFF81CF42" << Killer->GetName() << "|r Server Killer Has Ended |cFFFFFFFF" << Victim->GetName() << " !!!! ";
+            sWorld->SendServerMessage(SERVER_MSG_STRING, ss.str().c_str());
+        }
+
+        ++KillStreakData[KillerGUID].killstreak;
+        KillStreakData[KillerGUID].lastkill = VictimGUID;
+        KillStreakData[VictimGUID].killstreak = 0;
+        KillStreakData[VictimGUID].lastkill = 0;
+
+        if (KillStreakData[KillerGUID].killstreak % 10 == 0) // send killstreak message every 10 kills
+        {
+            std::ostringstream ss;
+            ss << "|cFF81CF42" << Killer->GetName() << "|r Server Killer Has A KillStreak Of |cFF42A0CF" << KillStreakData[KillerGUID].killstreak << "|r!!!!!";
+            sWorld->SendServerMessage(SERVER_MSG_STRING, ss.str().c_str());
+        }
+        else if (KillStreakData[KillerGUID].killstreak == 3)
+        {
+            std::ostringstream ss;
+            ss << "|cFF81CF42" << Killer->GetName() << "|r Server Killer Is On A KillingSpree!!!!!!";
+            sWorld->SendServerMessage(SERVER_MSG_STRING, ss.str().c_str());
+        }
+
+    }
+};
+
+void AddSC_PvP_System()
+{
+    new System_OnKill;
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/levelnpc.cpp b/src/server/scripts/Custom/levelnpc.cpp
new file mode 100644
index 0000000..16fd4e8
--- /dev/null
+++ b/src/server/scripts/Custom/levelnpc.cpp
@@ -0,0 +1,191 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Created by LordPsyan for Flaminglegion.net
+ *
+ */
+
+#include "Config.h"
+
+#define GOSSIP_SENDER_MAIN      1000
+#define SPELL_RESURRECTION_SICKNESS_15007  15007
+
+class levelnpc : public CreatureScript
+{
+public:
+    levelnpc() : CreatureScript("levelnpc") {}
+
+
+bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+{
+    if(sConfigMgr->GetBoolDefault("LevelNPC.OnlyGMs", false)) // If LevelNPC.OnlyGMs is enabled in trinitycore.conf
+        if (pPlayer->GetSession()->GetSecurity() == SEC_PLAYER)
+        {
+            pCreature->Whisper("Sorry, I can only add levels to Platinum Members.", LANG_UNIVERSAL, pPlayer);
+            return true;
+        }
+
+    bool EnableLevel80 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel80", true);
+    bool EnableLevel100 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel100", true);
+    bool EnableLevel150 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel150", true);
+    bool EnableLevel200 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel200", true);
+    bool EnableLevel255 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel255", true);
+    if (pPlayer->GetTeam() == ALLIANCE)
+    {
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Instant Levels ->"        , GOSSIP_SENDER_MAIN, 1000);
+        pPlayer->ADD_GOSSIP_ITEM( 10, "Remove Resurrect Sickness" , GOSSIP_SENDER_MAIN, 5000);
+    }
+    else
+    {
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Instant Levels ->"        , GOSSIP_SENDER_MAIN, 1000);
+        pPlayer->ADD_GOSSIP_ITEM( 10, "Remove Resurrect Sickness" , GOSSIP_SENDER_MAIN, 5000);
+    }
+    pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,pCreature->GetGUID());
+
+return true;
+}
+
+void SendDefaultMenu(Player* pPlayer, Creature* pCreature, uint32 uiAction)
+{
+
+// Not allow in combat
+if (pPlayer->IsInCombat())
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->Say("You are in combat!", LANG_UNIVERSAL);
+    return;
+}
+
+    bool EnableLevel80 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel80", true);
+    bool EnableLevel100 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel100", true);
+    bool EnableLevel150 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel150", true);
+    bool EnableLevel200 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel200", true);
+    bool EnableLevel255 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel255", true);
+
+//Mony Check
+if(sConfigMgr->GetBoolDefault("LevelNPC.UseTokens", true))
+{
+if (!pPlayer->HasItemCount((sConfigMgr->GetIntDefault("LevelNPC.ItemEntryNum",0)), 0))
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->Whisper("You ain't gots no darn chips.", LANG_UNIVERSAL, pPlayer);
+    return;
+}
+}
+else if(pPlayer->GetMoney() < (sConfigMgr->GetIntDefault("LevelNPC.SkillGoldCost",0)))
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->Whisper("You don't have enough money.", LANG_UNIVERSAL, pPlayer);
+    return;
+}
+
+switch(uiAction)
+{
+
+//////////////////////////////////////////////////Leveling///////////////////////////////////////////////////////////////
+case 1000: //Leveling
+    if(EnableLevel80 && pPlayer->getLevel() < 80)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "(1 Donation Chip) Instant 80 ->"         , GOSSIP_SENDER_MAIN, 1001);
+    if(EnableLevel100 && pPlayer->getLevel() < 100 && pPlayer->getLevel() >= 80)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "(2 Donation Chips) Instant 100 ->"        , GOSSIP_SENDER_MAIN, 1002);
+    if(EnableLevel150 && pPlayer->getLevel() < 150 && pPlayer->getLevel() >= 100)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "(5 Donation Chips) Instant 150 ->"        , GOSSIP_SENDER_MAIN, 1003);
+    if(EnableLevel200 && pPlayer->getLevel() < 200 && pPlayer->getLevel() >= 150)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "(10 Donation Chips) Instant 200 ->"       , GOSSIP_SENDER_MAIN, 1004);
+    if(EnableLevel255 && pPlayer->getLevel() < 255 && pPlayer->getLevel() >= 200)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "(20 Donation Chips) Instant 255 ->"       , GOSSIP_SENDER_MAIN, 1005);
+        pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                       , GOSSIP_SENDER_MAIN, 3000);
+    pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,pCreature->GetGUID());
+break;
+case 3000: //Leveling
+    if(EnableLevel80)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Instant Levels ->"        , GOSSIP_SENDER_MAIN, 1000);
+    pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,pCreature->GetGUID());
+break;
+case 1001: // Leveling
+    pPlayer->GiveLevel(80);
+    if(sConfigMgr->GetBoolDefault("LevelNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99998, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("LevelNPC.SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+case 1002: // Leveling
+    pPlayer->GiveLevel(100);
+    if(sConfigMgr->GetBoolDefault("LevelNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99998, 2, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("LevelNPC.SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+case 1003: // Leveling
+    pPlayer->GiveLevel(150);
+    if(sConfigMgr->GetBoolDefault("LevelNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99998, 5, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("LevelNPC.SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+case 1004: // Leveling
+    pPlayer->GiveLevel(200);
+    if(sConfigMgr->GetBoolDefault("LevelNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99998, 10, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("LevelNPC.SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+case 1005: // Leveling
+    pPlayer->GiveLevel(255);
+    if(sConfigMgr->GetBoolDefault("LevelNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99998, 20, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("LevelNPC.SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+case 5000://Remove Res Sickness
+    if(!pPlayer->HasAura(SPELL_RESURRECTION_SICKNESS_15007))
+    {
+        pCreature->Whisper("You don't have resurrection sickness.", LANG_UNIVERSAL, pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pCreature->CastSpell(pPlayer,38588,false); // Healing effect
+    pPlayer->RemoveAurasDueToSpell(SPELL_RESURRECTION_SICKNESS_15007);
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+ pPlayer->CLOSE_GOSSIP_MENU();
+
+} // end of switch
+} //end of function
+
+bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+    // Main menu
+    pPlayer->PlayerTalkClass->ClearMenus();
+    if (uiSender == GOSSIP_SENDER_MAIN)
+    SendDefaultMenu(pPlayer, pCreature, uiAction);
+
+return true;
+}
+};
+
+void AddSC_levelnpc()
+{
+
+new levelnpc();
+
+}
diff --git a/src/server/scripts/Custom/login_reset.cpp b/src/server/scripts/Custom/login_reset.cpp
new file mode 100644
index 0000000..a791a6e
--- /dev/null
+++ b/src/server/scripts/Custom/login_reset.cpp
@@ -0,0 +1,28 @@
+//script made by SymbolixDEV
+class login_script : public PlayerScript
+{
+public:
+    login_script() : PlayerScript("login_script") { }
+
+    void OnLogin(Player* player)
+    {
+        std::string msg;
+        if (player->GetSession()->GetSecurity() != SEC_PLAYER)
+            msg = "[GM]:";
+        else
+            msg = "[PLAYER]:";
+        msg += player->GetName()+" has logged in!";
+        sWorld->SendGlobalText(msg.c_str(), NULL);
+        player->SetPower(POWER_MANA, player->GetMaxPower(POWER_MANA)); // set max mana
+        player->SetPower(POWER_ENERGY, player->GetMaxPower(POWER_ENERGY)); //set max rogue/druid enery go on login!
+        player->SetPower(POWER_RAGE, player->GetMaxPower(POWER_RAGE)); //set max warrior rage on login!
+        player->SetPower(POWER_RUNIC_POWER, player->GetMaxPower(POWER_RUNIC_POWER));  //set max runic power on Death Knight on login!
+        player->SetFullHealth(); // set max health on login on game !
+        player->GetSpellHistory()->ResetAllCooldowns(); //reset cooldowns on login!
+    }
+};
+
+void AddSC_login_script()
+{
+    new login_script();
+}
diff --git a/src/server/scripts/Custom/npc_arena1v1.cpp b/src/server/scripts/Custom/npc_arena1v1.cpp
new file mode 100644
index 0000000..c2f6792
--- /dev/null
+++ b/src/server/scripts/Custom/npc_arena1v1.cpp
@@ -0,0 +1,309 @@
+/*
+ *
+ * Copyright (C) 2013 Emu-Devstore <http://emu-devstore.com/>
+ * Written by Teiby <http://www.teiby.de/>
+ *
+ */
+
+#include "ScriptMgr.h"
+#include "ArenaTeamMgr.h"
+#include "Common.h"
+#include "DisableMgr.h"
+#include "BattlegroundMgr.h"
+#include "Battleground.h"
+#include "ArenaTeam.h"
+#include "Language.h"
+#include "npc_arena1v1.h"
+
+
+class npc_1v1arena : public CreatureScript
+{
+public:
+    npc_1v1arena() : CreatureScript("npc_1v1arena")
+    {
+    }
+
+
+    bool JoinQueueArena(Player* player, Creature* me, bool isRated)
+    {
+        if(!player || !me)
+            return false;
+
+        if(sWorld->getIntConfig(CONFIG_ARENA_1V1_MIN_LEVEL) > player->getLevel())
+            return false;
+
+        ObjectGuid guid = player->GetGUID();
+        uint8 arenaslot = ArenaTeam::GetSlotByType(ARENA_TEAM_5v5);
+        uint8 arenatype = ARENA_TYPE_5v5;
+        uint32 arenaRating = 0;
+        uint32 matchmakerRating = 0;
+
+        // ignore if we already in BG or BG queue
+        if (player->InBattleground())
+            return false;
+
+        //check existance
+        Battleground* bg = sBattlegroundMgr->GetBattlegroundTemplate(BATTLEGROUND_AA);
+        if (!bg)
+        {
+            TC_LOG_ERROR("Arena", "Battleground: template bg (all arenas) not found");
+            return false;
+        }
+
+        if (DisableMgr::IsDisabledFor(DISABLE_TYPE_BATTLEGROUND, BATTLEGROUND_AA, NULL))
+        {
+            ChatHandler(player->GetSession()).PSendSysMessage(LANG_ARENA_DISABLED);
+            return false;
+        }
+
+        BattlegroundTypeId bgTypeId = bg->GetTypeID();
+        BattlegroundQueueTypeId bgQueueTypeId = BattlegroundMgr::BGQueueTypeId(bgTypeId, arenatype);
+        PvPDifficultyEntry const* bracketEntry = GetBattlegroundBracketByLevel(bg->GetMapId(), player->getLevel());
+        if (!bracketEntry)
+            return false;
+
+        GroupJoinBattlegroundResult err = ERR_GROUP_JOIN_BATTLEGROUND_FAIL;
+
+        // check if already in queue
+        if (player->GetBattlegroundQueueIndex(bgQueueTypeId) < PLAYER_MAX_BATTLEGROUND_QUEUES)
+            //player is already in this queue
+            return false;
+        // check if has free queue slots
+        if (!player->HasFreeBattlegroundQueueId())
+            return false;
+
+        uint32 ateamId = 0;
+
+        if(isRated)
+        {
+            ateamId = player->GetArenaTeamId(arenaslot);
+            ArenaTeam* at = sArenaTeamMgr->GetArenaTeamById(ateamId);
+            if (!at)
+            {
+                player->GetSession()->SendNotInArenaTeamPacket(arenatype);
+                return false;
+            }
+
+            // get the team rating for queueing
+            arenaRating = at->GetRating();
+            matchmakerRating = arenaRating;
+            // the arenateam id must match for everyone in the group
+
+            if (arenaRating <= 0)
+                arenaRating = 1;
+        }
+
+        BattlegroundQueue &bgQueue = sBattlegroundMgr->GetBattlegroundQueue(bgQueueTypeId);
+        bg->SetRated(isRated);
+
+        GroupQueueInfo* ginfo = bgQueue.AddGroup(player, NULL, bgTypeId, bracketEntry, arenatype, isRated, false, arenaRating, matchmakerRating, ateamId);
+        uint32 avgTime = bgQueue.GetAverageQueueWaitTime(ginfo, bracketEntry->GetBracketId());
+        uint32 queueSlot = player->AddBattlegroundQueueId(bgQueueTypeId);
+
+        WorldPacket data;
+        // send status packet (in queue)
+        sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, bg, queueSlot, STATUS_WAIT_QUEUE, avgTime, 0, arenatype, 0);
+        player->GetSession()->SendPacket(&data);
+
+        sBattlegroundMgr->ScheduleQueueUpdate(matchmakerRating, arenatype, bgQueueTypeId, bgTypeId, bracketEntry->GetBracketId());
+
+        return true;
+    }
+
+
+    bool CreateArenateam(Player* player, Creature* me)
+    {
+        if(!player || !me)
+            return false;
+
+        uint8 slot = ArenaTeam::GetSlotByType(ARENA_TEAM_5v5);
+        if (slot >= MAX_ARENA_SLOT)
+            return false;
+
+        // Check if player is already in an arena team
+        if (player->GetArenaTeamId(slot))
+        {
+            player->GetSession()->SendArenaTeamCommandResult(ERR_ARENA_TEAM_CREATE_S, player->GetName(), "", ERR_ALREADY_IN_ARENA_TEAM);
+            return false;
+        }
+
+
+        // Teamname = playername
+        // if teamname exist, we have to choose another name (playername + number)
+        int i = 1;
+        std::stringstream teamName;
+        teamName << player->GetName();
+        do
+        {
+            if(sArenaTeamMgr->GetArenaTeamByName(teamName.str()) != NULL) // teamname exist, so choose another name
+            {
+                teamName.str(std::string());
+                teamName << player->GetName() << (i++);
+            }
+            else
+                break;
+        } while (i < 100); // should never happen
+
+        // Create arena team
+        ArenaTeam* arenaTeam = new ArenaTeam();
+
+        if (!arenaTeam->Create(player->GetGUID(), ARENA_TEAM_5v5, teamName.str(), 4283124816, 45, 4294242303, 5, 4294705149))
+        {
+            delete arenaTeam;
+            return false;
+        }
+
+        // Register arena team
+        sArenaTeamMgr->AddArenaTeam(arenaTeam);
+        arenaTeam->AddMember(player->GetGUID());
+
+        ChatHandler(player->GetSession()).SendSysMessage("1v1 Arenateam successful created!");
+
+        return true;
+    }
+
+
+    bool OnGossipHello(Player* player, Creature* me)
+    {
+        if(!player || !me)
+            return true;
+
+        if(sWorld->getBoolConfig(CONFIG_ARENA_1V1_ENABLE) == false)
+        {
+            ChatHandler(player->GetSession()).SendSysMessage("1v1 disabled!");
+            return true;
+        }
+
+        if(player->InBattlegroundQueueForBattlegroundQueueType(BATTLEGROUND_QUEUE_5v5))
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, "Leave queue 1v1 Arena", GOSSIP_SENDER_MAIN, 3, "Are you sure?", 0, false);
+        else
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Sign up 1v1 Arena (unrated)", GOSSIP_SENDER_MAIN, 20);
+
+        if(player->GetArenaTeamId(ArenaTeam::GetSlotByType(ARENA_TEAM_5v5)) == 0)
+            player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, "Create new 1v1 Arenateam", GOSSIP_SENDER_MAIN, 1, "Create 1v1 arenateam?", sWorld->getIntConfig(CONFIG_ARENA_1V1_COSTS), false);
+        else
+        {
+            if(player->InBattlegroundQueueForBattlegroundQueueType(BATTLEGROUND_QUEUE_5v5) == false)
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Sign up 1v1 Arena (rated)", GOSSIP_SENDER_MAIN, 2);
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, "Disband arenateam", GOSSIP_SENDER_MAIN, 5, "Are you sure?", 0, false);
+            }
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Show statistics", GOSSIP_SENDER_MAIN, 4);
+        }
+
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Script Info", GOSSIP_SENDER_MAIN, 8);
+        player->SEND_GOSSIP_MENU(68, me->GetGUID());
+        return true;
+    }
+
+
+
+    bool OnGossipSelect(Player* player, Creature* me, uint32 /*uiSender*/, uint32 uiAction)
+    {
+        if(!player || !me)
+            return true;
+
+        player->PlayerTalkClass->ClearMenus();
+
+        switch (uiAction)
+        {
+        case 1: // Create new Arenateam
+            {
+                if(sWorld->getIntConfig(CONFIG_ARENA_1V1_MIN_LEVEL) <= player->getLevel())
+                {
+                    if(player->GetMoney() >= sWorld->getIntConfig(CONFIG_ARENA_1V1_COSTS) && CreateArenateam(player, me))
+                        player->ModifyMoney(sWorld->getIntConfig(CONFIG_ARENA_1V1_COSTS) * -1);
+                }
+                else
+                {
+                    ChatHandler(player->GetSession()).PSendSysMessage("You need level %u+ to create an 1v1 arenateam.", sWorld->getIntConfig(CONFIG_ARENA_1V1_MIN_LEVEL));
+                    player->CLOSE_GOSSIP_MENU();
+                    return true;
+                }
+            }
+            break;
+
+        case 2: // Join Queue Arena (rated)
+            {
+                if(Arena1v1CheckTalents(player) && JoinQueueArena(player, me, true) == false)
+                    ChatHandler(player->GetSession()).SendSysMessage("Something went wrong while join queue.");
+
+                player->CLOSE_GOSSIP_MENU();
+                return true;
+            }
+            break;
+
+        case 20: // Join Queue Arena (unrated)
+            {
+                if(Arena1v1CheckTalents(player) && JoinQueueArena(player, me, false) == false)
+                    ChatHandler(player->GetSession()).SendSysMessage("Something went wrong while join queue.");
+
+                player->CLOSE_GOSSIP_MENU();
+                return true;
+            }
+            break;
+
+        case 3: // Leave Queue
+            {
+                WorldPacket Data;
+                Data << (uint8)0x1 << (uint8)0x0 << (uint32)BATTLEGROUND_AA << (uint16)0x0 << (uint8)0x0;
+                player->GetSession()->HandleBattleFieldPortOpcode(Data);
+                player->CLOSE_GOSSIP_MENU();
+                return true;
+            }
+            break;
+
+        case 4: // get statistics
+            {
+                ArenaTeam* at = sArenaTeamMgr->GetArenaTeamById(player->GetArenaTeamId(ArenaTeam::GetSlotByType(ARENA_TEAM_5v5)));
+                if(at)
+                {
+                    std::stringstream s;
+                    s << "Rating: " << at->GetStats().Rating;
+                    s << "\nRank: " << at->GetStats().Rank;
+                    s << "\nSeason Games: " << at->GetStats().SeasonGames;
+                    s << "\nSeason Wins: " << at->GetStats().SeasonWins;
+                    s << "\nWeek Games: " << at->GetStats().WeekGames;
+                    s << "\nWeek Wins: " << at->GetStats().WeekWins;
+
+                    ChatHandler(player->GetSession()).PSendSysMessage(s.str().c_str());
+                }
+            }
+            break;
+
+
+        case 5: // Disband arenateam
+            {
+                WorldPacket Data;
+                Data << (uint32)player->GetArenaTeamId(ArenaTeam::GetSlotByType(ARENA_TEAM_5v5));
+                player->GetSession()->HandleArenaTeamLeaveOpcode(Data);
+                ChatHandler(player->GetSession()).SendSysMessage("Arenateam deleted!");
+                player->CLOSE_GOSSIP_MENU();
+                return true;
+            }
+            break;
+
+        case 8: // Script Info
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Developer: Teiby", GOSSIP_SENDER_MAIN, uiAction);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Website: www.teiby.de", GOSSIP_SENDER_MAIN, uiAction);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Version: 2.1", GOSSIP_SENDER_MAIN, uiAction);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<-- Back", GOSSIP_SENDER_MAIN, 7);
+                player->SEND_GOSSIP_MENU(68, me->GetGUID());
+                return true;
+            }
+            break;
+
+        }
+
+        OnGossipHello(player, me);
+        return true;
+    }
+};
+
+
+void AddSC_npc_1v1arena()
+{
+    new npc_1v1arena();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/npc_arena1v1.h b/src/server/scripts/Custom/npc_arena1v1.h
new file mode 100644
index 0000000..caa75a2
--- /dev/null
+++ b/src/server/scripts/Custom/npc_arena1v1.h
@@ -0,0 +1,69 @@
+/*
+ *
+ * Copyright (C) 2013 Emu-Devstore <http://emu-devstore.com/>
+ * Written by Teiby <http://www.teiby.de/>
+ *
+ */
+
+#ifndef ARENA_1V1_H
+#define ARENA_1V1_H
+
+// TalentTab.dbc -> TalentTabID
+const uint32 FORBIDDEN_TALENTS_IN_1V1_ARENA[] =
+{
+    // Healer
+    201, // PriestDiscipline
+    202, // PriestHoly
+    382, // PaladinHoly
+    262, // ShamanRestoration
+    282, // DruidRestoration
+
+    // Tanks
+    //383, // PaladinProtection
+    //163, // WarriorProtection
+
+    0 // End
+};
+
+
+// Return false, if player have invested more than 35 talentpoints in a forbidden talenttree.
+static bool Arena1v1CheckTalents(Player* player)
+{
+    if(!player)
+        return false;
+
+    if(sWorld->getBoolConfig(CONFIG_ARENA_1V1_BLOCK_FORBIDDEN_TALENTS) == false)
+        return true;
+
+    uint32 count = 0;
+    for (uint32 talentId = 0; talentId < sTalentStore.GetNumRows(); ++talentId)
+    {
+        TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentId);
+
+        if (!talentInfo)
+            continue;
+
+        for (int8 rank = MAX_TALENT_RANK-1; rank >= 0; --rank)
+        {
+            if (talentInfo->RankID[rank] == 0)
+                continue;
+
+            if (player->HasTalent(talentInfo->RankID[rank], player->GetActiveSpec()))
+            {
+                for(int8 i = 0; FORBIDDEN_TALENTS_IN_1V1_ARENA[i] != 0; i++)
+                    if(FORBIDDEN_TALENTS_IN_1V1_ARENA[i] == talentInfo->TalentTab)
+                        count += rank + 1;
+            }
+        }
+    }
+
+    if(count >= 36)
+    {
+        ChatHandler(player->GetSession()).SendSysMessage("You can't join, because you have invested too many points in a forbidden talent. Please edit your talents.");
+        return false;
+    }
+    else
+        return true;
+}
+
+#endif
\ No newline at end of file
diff --git a/src/server/scripts/Custom/npc_lottery.cpp b/src/server/scripts/Custom/npc_lottery.cpp
new file mode 100644
index 0000000..2a9c3a2
--- /dev/null
+++ b/src/server/scripts/Custom/npc_lottery.cpp
@@ -0,0 +1,360 @@
+/*
+ *
+ * Copyright (C) 2013 Emu-Devstore <http://emu-devstore.com/>
+ * Written by Teiby <http://www.teiby.de/>
+ *
+ */
+
+#include "Config.h"
+#include "Language.h"
+
+#define EVENT_LOTTERY        132 // Use '.event start 132' or '.event stop 132' to start and stop manually. Event will start automatically every 24h (08:00pm)
+
+#define LOTTERY_ENABLE        true
+#define LOTTERY_MINLVL        1
+#define LOTTERY_BETCOST        10    * 10000 // 10 Gold
+#define LOTTERY_MAXNUMBER    30    // 1 - 30
+#define LOTTERY_FIELDS        5    // how many numbers? (e.g. '5 10 22 3 25')
+#define LOTTERY_BETCOUNT    1    // how many bets each player?
+
+
+class npc_lottery : public CreatureScript
+{
+public:
+    npc_lottery() : CreatureScript("npc_lottery") { }
+
+    bool OnGossipHello(Player* player, Creature* pCreature)
+    {
+        if (player && LOTTERY_ENABLE)
+        {
+            if (player->getLevel() >= uint32(LOTTERY_MINLVL) && player->GetMoney() >= uint32(LOTTERY_BETCOST))
+            {
+                std::stringstream str;
+                str << "Willst du dein Glck versuchen? " << LOTTERY_FIELDS << " Nummern zwischen 1 und " << LOTTERY_MAXNUMBER << " (durch Leerzeichen trennen), bezahle " << (uint32)(LOTTERY_BETCOST*0.0001f) << " Gold und warte auf die Auslosung (20:00).";
+                str << " Du kannst nur " << LOTTERY_BETCOUNT << " Los kaufen" << (LOTTERY_BETCOUNT > 1 ? "s." : ".");
+
+
+                pCreature->Whisper(str.str().c_str(), LANG_UNIVERSAL, player);
+                player->ADD_GOSSIP_ITEM_EXTENDED(0, "Kaufe ein Los", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF, "", 0, true);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Script Info", GOSSIP_SENDER_MAIN, 9998);
+                player->SEND_GOSSIP_MENU(player->GetGossipTextId(pCreature), pCreature->GetGUID());
+            }
+            else
+           {
+                std::stringstream str;
+                str << "Du brauchst " << LOTTERY_MINLVL << " Gold and Level " << (uint32)(LOTTERY_BETCOST*0.0001f) << "+ um ein Los zu kaufen.";
+                pCreature->Whisper(str.str().c_str(), LANG_UNIVERSAL, player);
+            }
+        }
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* pCreature, uint32 uiSender, uint32 uiAction, const char* code)
+    {
+        player->PlayerTalkClass->ClearMenus();
+       if (uiSender == GOSSIP_SENDER_MAIN)
+        {
+            switch (uiAction)
+           {
+                case GOSSIP_ACTION_INFO_DEF:
+                {
+                   char * charCode = (char*)code;
+                    std::string strCode = (char*)code;
+                    char * tmp;
+                   int32 number[LOTTERY_FIELDS];
+                    std::stringstream error;
+                    error << "Du hast eine falsche Nummer eingegeben. Du musst " << LOTTERY_FIELDS << " Nummer (durch Leerzeichen trennen) zwischen 1 - " << LOTTERY_MAXNUMBER << "eingeben.";
+                    std::string errordub = ("Du hast schon getipt");
+                    std::string sNumbers;
+
+
+                    QueryResult pBetGuid = WorldDatabase.PQuery("SELECT COUNT(*) FROM lottery_bets WHERE guid = %u", player->GetGUID().GetCounter());
+                    if (pBetGuid && pBetGuid->Fetch()->GetUInt32() >= LOTTERY_BETCOUNT)
+                    {
+                        pCreature->Whisper(errordub.c_str(), LANG_UNIVERSAL, player);
+                        player->CLOSE_GOSSIP_MENU();
+                        return false;
+                    }
+
+
+                    tmp = strtok (charCode," ");
+                    for (int8 n = 0; n < LOTTERY_FIELDS; n++)
+                    {
+                        if (tmp != NULL)
+                        {
+                            number[n] = atoi(tmp);
+                            if (number[n] <= 0 || number[n] > LOTTERY_MAXNUMBER)
+                            {
+                                pCreature->Whisper(error.str().c_str(), LANG_UNIVERSAL, player);
+                                player->CLOSE_GOSSIP_MENU();
+                                return false;
+                            }
+                            tmp = strtok (NULL, " ");
+                        }
+                        else
+                        {
+                            pCreature->Whisper(error.str().c_str(), LANG_UNIVERSAL, player);
+                            player->CLOSE_GOSSIP_MENU();
+                            return false;
+                        }
+                    }
+
+                    std::stringstream ssNumber;
+                    for(int i = 0; i < LOTTERY_FIELDS; i++)
+                    {
+                        ssNumber << number[i];
+
+                        if(i < LOTTERY_FIELDS-1)
+                            ssNumber << " ";
+                    }
+
+                    sNumbers = "Du hast folgende Zahlen getipt: " + ssNumber.str();
+
+                    uint32 betMaxID = 0;
+                    QueryResult qbetMaxID = WorldDatabase.Query("SELECT MAX(id) FROM lottery_bets");
+
+                    if (qbetMaxID)
+                        betMaxID = qbetMaxID->Fetch()->GetUInt32();
+
+                    WorldDatabase.PExecute("INSERT INTO lottery_bets (id, name, guid, bet) VALUES ('%u', '%s', '%u', '%s');", betMaxID+1, player->GetName().c_str(), player->GetGUID().GetCounter(), ssNumber.str().c_str());
+                    pCreature->Whisper(sNumbers.c_str(), LANG_UNIVERSAL, player);
+                    player->ModifyMoney(-LOTTERY_BETCOST);
+
+                    player->CLOSE_GOSSIP_MENU();
+
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+    {
+        if(uiAction == 9998) // Script Info
+        {
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Entwickelt von: Teiby", GOSSIP_SENDER_MAIN, uiAction);
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Website: www.teiby.de", GOSSIP_SENDER_MAIN, uiAction);
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Version: 1.2", GOSSIP_SENDER_MAIN, uiAction);
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<-- Zurck", GOSSIP_SENDER_MAIN, 9999);
+            pPlayer->SEND_GOSSIP_MENU(68, pCreature->GetGUID());
+        }
+        else if(uiAction == 9999)
+        {
+            pPlayer->PlayerTalkClass->ClearMenus();
+            OnGossipHello(pPlayer, pCreature);
+        }
+
+        return true;
+    }
+
+    CreatureAI* GetAI(Creature* pCreature) const
+    {
+        return new npc_lotteryAI (pCreature);
+    }
+
+    struct npc_lotteryAI : public ScriptedAI
+    {
+        npc_lotteryAI(Creature* pCreature) : ScriptedAI(pCreature) { }
+
+        struct sWinner
+        {
+            uint32 guid;
+            std::string name;
+            std::string bets;
+            uint32 points;
+        };
+
+        void UpdateAI(uint32 diff)
+        {
+            if (IsEventActive(EVENT_LOTTERY))
+            {
+                if (me->IsVisible())
+                {
+                    QueryResult qMaxID = WorldDatabase.Query("SELECT MAX(id) FROM lottery_bets");
+                    if (!qMaxID)
+                    {
+                        me->SetVisible(false);
+                        return;
+                    }
+
+                    uint32 betMaxID = qMaxID->Fetch()->GetUInt32();
+                    uint32 luckyNumber[LOTTERY_FIELDS];
+                    std::stringstream sLuckyNumber;
+                    uint32 lotteryID;
+                    const uint32 stakes = betMaxID * LOTTERY_BETCOST * 0.7f; // 70% (rest is added to the jackpot)
+
+                    uint32 winnerCount[LOTTERY_FIELDS];
+
+                    typedef std::list<sWinner> tdJW;
+                    tdJW lJackpotWinners;
+                    tdJW lWinners;
+
+                    SQLTransaction ctrans = CharacterDatabase.BeginTransaction();
+                    SQLTransaction wtrans = WorldDatabase.BeginTransaction();
+
+                    for(int i = 0; i < LOTTERY_FIELDS; i++)
+                        winnerCount[i] = 0;
+
+                    QueryResult qlotteryID = WorldDatabase.Query("SELECT MAX(id) FROM lottery");
+                    if (!qlotteryID)
+                        lotteryID = 0;
+                    else
+                        lotteryID = qlotteryID->Fetch()->GetUInt32();
+
+                    QueryResult qBets  = WorldDatabase.Query("SELECT guid, bet, name FROM lottery_bets");
+                    if (qBets)
+                    {
+                        for (int8 n = 0; n < LOTTERY_FIELDS; n++)
+                            luckyNumber[n] = urand(1, LOTTERY_MAXNUMBER);
+
+                        for(int i = 0; i < LOTTERY_FIELDS; i++)
+                        {
+                            sLuckyNumber << luckyNumber[i];
+
+                            if(i < LOTTERY_FIELDS-1)
+                                sLuckyNumber << " ";
+                        }
+
+                        do
+                        {
+                            Field *fBets = qBets->Fetch();
+                            uint32 guid = fBets[0].GetUInt32();
+                            std::string bet = fBets[1].GetString();
+                            std::string rBet = bet;
+                            std::string name = fBets[2].GetString();
+                            uint32 points = 0;
+
+                            int32 number[LOTTERY_FIELDS];
+                            char * tmp;
+
+                            tmp = strtok ((char*)bet.c_str()," ");
+
+                            for (int8 n = 0; n < LOTTERY_FIELDS; ++n)
+                            {
+                                if (tmp != NULL)
+                                {
+                                    number[n] = atoi(tmp);
+                                    tmp = strtok (NULL, " ");
+                                }
+                            }
+
+                            for (int8 n = 0; n < LOTTERY_FIELDS; ++n)
+                                for (int8 i = 0; i < LOTTERY_FIELDS; ++i)
+                                    if (number[i] == luckyNumber[n])
+                                    {
+                                        points++;
+                                        number[i] = 0;
+                                        break;
+                                    }
+
+                            if(points == 0)
+                                continue;
+
+                            sWinner winner;
+                            winner.guid = guid;
+                            winner.bets = rBet;
+                            winner.name = name;
+                            winner.points = points;
+
+                            if(points == LOTTERY_FIELDS)
+                                lJackpotWinners.push_back(winner);
+                            else
+                                lWinners.push_back(winner);
+
+                            winnerCount[points-1]++;
+
+                        } while (qBets->NextRow());
+
+
+                        for(tdJW::const_iterator itr = lWinners.begin(); itr != lWinners.end(); itr++)
+                        {
+                            uint32 cash = stakes / pow(2, LOTTERY_FIELDS - itr->points) / winnerCount[itr->points-1];
+
+                            std::stringstream text;
+                            text << "Gratulation du hast die Richtigen Zahlen getipt!\n\n";
+                            text << "Dein Los: " << itr->bets.c_str() << "\n";
+                            text << "Lotto Resultat: " << sLuckyNumber.str().c_str() << "\n\n";
+                            text << "Hits: " << itr->points << "\n";
+                            text << "Sum of bets with " << itr->points << " hits: " << winnerCount[itr->points-1];
+
+                            Player *pWinner = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+                            MailDraft("Won", text.str())
+                                .AddMoney(cash)
+                                .SendMailTo(ctrans, MailReceiver(pWinner, itr->guid), MailSender(MAIL_NORMAL, 0, MAIL_STATIONERY_GM));
+
+                            wtrans->PAppend("INSERT INTO lottery_winners (id, name, guid, bet, betPoints) VALUES ('%u', '%s', '%u', '%s', '%u')", lotteryID+1, itr->name.c_str(), itr->guid, itr->bets.c_str(), itr->points);
+                        }
+
+                        uint32 jackpot;
+                        QueryResult qJackpot  = WorldDatabase.PQuery("SELECT jackpot FROM lottery WHERE id = '%u'", lotteryID);
+                        if (qJackpot)
+                            jackpot = qJackpot->Fetch()->GetUInt32();
+                        else
+                            jackpot = 0;
+
+                        jackpot += betMaxID * LOTTERY_BETCOST * 0.3f; // 30%
+
+                        for(int i = 0; i < LOTTERY_FIELDS-1; i++)
+                        {
+                            if(winnerCount[i] == 0)
+                                jackpot += stakes / pow(2, LOTTERY_FIELDS-i-1); // Add money to jackpot if there are no winners
+                        }
+
+                        if (winnerCount[LOTTERY_FIELDS-1] > 0)
+                        {
+                            jackpot /= winnerCount[LOTTERY_FIELDS-1];
+
+                            for(tdJW::const_iterator itr = lJackpotWinners.begin(); itr != lJackpotWinners.end(); itr++)
+                            {
+                                std::stringstream text;
+                                text << "Glckwunsch du hast den Jackpot geknackt\n\n";
+                                text << "Dein Los: " << itr->bets.c_str() << "\n";
+                                text << "Lotto Resultat: " << sLuckyNumber.str().c_str() << "\n\n";
+                                text << "Hits: " << itr->points << "\n";
+                                text << "Sum of bets with " << itr->points << " hits: " << winnerCount[itr->points-1];
+
+                                Player *pJPWinner = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+                                MailDraft("Jackpot!", text.str())
+                                    .AddMoney(jackpot)
+                                    .SendMailTo(ctrans, MailReceiver(pJPWinner, itr->guid), MailSender(MAIL_NORMAL, 0, MAIL_STATIONERY_GM));
+                            }
+
+                            if (winnerCount[LOTTERY_FIELDS-1] == 1)
+                                sWorld->SendWorldText(LANG_LOTTERY_ANNOUNCE_JACKPOT, betMaxID, sLuckyNumber.str().c_str(), lJackpotWinners.begin()->name.c_str(), uint32(jackpot * 0.0001f));
+                            else
+                                sWorld->SendWorldText(LANG_LOTTERY_ANNOUNCE_JACKPOT_M_PLAYERS, betMaxID, sLuckyNumber.str().c_str(), winnerCount[LOTTERY_FIELDS-1], uint32(jackpot * 0.0001f));
+
+                            jackpot = 0;
+                        }
+                        else
+                        {
+                            sWorld->SendWorldText(LANG_LOTTERY_ANNOUNCE, betMaxID, sLuckyNumber.str().c_str(), uint32(jackpot * 0.0001f));
+                        }
+
+                        wtrans->PAppend("INSERT INTO lottery (numbers, jackpot) VALUES ('%s', '%u')", sLuckyNumber.str().c_str(), jackpot);
+                        wtrans->PAppend("DELETE FROM lottery_bets");
+
+                        WorldDatabase.CommitTransaction(wtrans);
+                        CharacterDatabase.CommitTransaction(ctrans);
+
+                        me->SetVisible(false);
+                    }
+                }
+            }
+            else
+            {
+                if (!me->IsVisible())
+                    me->SetVisible(true);
+            }
+        }
+    };
+
+};
+
+
+void AddSC_npc_lottery()
+{
+    new npc_lottery;
+}
diff --git a/src/server/scripts/Custom/npc_teleport.cpp b/src/server/scripts/Custom/npc_teleport.cpp
new file mode 100644
index 0000000..754a604
--- /dev/null
+++ b/src/server/scripts/Custom/npc_teleport.cpp
@@ -0,0 +1,219 @@
+/**
+ *
+ * @File : npc_teleport.cpp
+ *
+ * @Authors : Wilibald09
+ *
+ * @Date : 19/08/2008
+ *
+ * @Version : 1.2
+ *
+ **/
+
+#include "sc_npc_teleport.h"
+#include <sstream>
+
+#define GOSSIP_SHOW_DEST        1000
+#define GOSSIP_TELEPORT         1001
+#define GOSSIP_NEXT_PAGEC       1002
+#define GOSSIP_PREV_PAGEC       1003
+#define GOSSIP_NEXT_PAGED       1004
+#define GOSSIP_PREV_PAGED       1005
+#define GOSSIP_MAIN_MENU        1006
+
+#define SPELL_ID_PASSIVE_RESURRECTION_SICKNESS  15007
+#define SPELL_VISUAL_TELEPORT   35517
+
+#define NB_ITEM_PAGE            15
+#define MSG_CAT                 100000
+#define MSG_DEST                100001
+
+#define NEXT_PAGE               "-> [Next Page]"
+#define PREV_PAGE               "<- [Previous Page]"
+#define MAIN_MENU               "<= [Main Menu]"
+
+
+using namespace nsNpcTel;
+
+
+namespace
+{
+    Page PageC, PageD;
+    Page Cat;
+
+    // Conversion function int->string
+    std::string ConvertStr(const int64 &val)
+    {
+        std::ostringstream ostr;
+        ostr << val;
+        return ostr.str();
+    }
+
+    // Conversion function intMoney->stringMoney
+    std::string ConvertMoney(const uint32 &Money)
+    {
+        std::string Str(ConvertStr(Money));
+        uint32 SizeStr = Str.length();
+
+        if (SizeStr > 4)
+            Str = Str.insert(Str.length()-4, "g");
+        if (SizeStr > 2)
+            Str = Str.insert(Str.length()-2, "s");
+        Str += "c";
+
+        return Str;
+    }
+
+    // Teleport Player
+    void Teleport(Player * const player, const uint16 &map,
+                  const float &X, const float &Y, const float &Z, const float &orient)
+    {
+        player->CastSpell(player, SPELL_VISUAL_TELEPORT, true);
+        player->TeleportTo(map, X, Y, Z, orient);
+    }
+
+    // Display categories
+    void AffichCat(Player * const player, Creature * const creature)
+    {
+        if (PageC[player] > 0)
+            player->ADD_GOSSIP_ITEM(7, PREV_PAGE, GOSSIP_PREV_PAGEC, 0);
+
+        VCatDest_t i (PageC[player] * NB_ITEM_PAGE);
+        for ( ; i < TabCatDest.size() && i < (NB_ITEM_PAGE * (PageC[player] + 1)); ++i)
+        {
+            if (TabCatDest[i].IsAllowedToTeleport(player))
+                player->ADD_GOSSIP_ITEM(7, TabCatDest[i].GetName(player->IsGameMaster()).c_str(), GOSSIP_SHOW_DEST, i);
+        }
+
+        if (i < TabCatDest.size())
+            player->ADD_GOSSIP_ITEM(7, NEXT_PAGE, GOSSIP_NEXT_PAGEC, 0);
+
+        player->SEND_GOSSIP_MENU(MSG_CAT, creature->GetGUID());
+    }
+
+    // Display destination categories
+    void AffichDest(Player * const player, Creature * const creature)
+    {
+        if (PageD[player] > 0)
+            player->ADD_GOSSIP_ITEM(7, PREV_PAGE, GOSSIP_PREV_PAGED, 0);
+
+        CatDest::VDest_t i (PageD[player] * NB_ITEM_PAGE);
+        for ( ; i < TabCatDest[Cat[player]].size() && i < (NB_ITEM_PAGE * (PageD[player] + 1)); ++i)
+        {
+            player->ADD_GOSSIP_ITEM(5, TabCatDest[Cat[player]].GetDest(i).m_name.c_str(), GOSSIP_TELEPORT, i);
+        }
+
+        if (i < TabCatDest[Cat[player]].size())
+            player->ADD_GOSSIP_ITEM(7, NEXT_PAGE, GOSSIP_NEXT_PAGED, 0);
+
+        if (CatDest::CountOfCategoryAllowedBy(player) > 1)
+            player->ADD_GOSSIP_ITEM(7, MAIN_MENU, GOSSIP_MAIN_MENU, 0);
+
+        player->SEND_GOSSIP_MENU(MSG_DEST, creature->GetGUID());
+    }
+
+    // Verification before teleportation
+    void ActionTeleport(Player * const player, Creature * const creature, const uint32 &id)
+    {
+        Dest dest (TabCatDest[Cat[player]].GetDest(id));
+
+        if (player->getLevel() < dest.m_level && !player->IsGameMaster())
+        {
+            std::string msg ("You do not have the required level. This destination requires level " + ConvertStr(dest.m_level) + ".");
+            creature->Whisper(msg.c_str(), LANG_UNIVERSAL, player);
+            return;
+        }
+
+        if (player->GetMoney() < dest.m_cost && !player->IsGameMaster())
+        {
+            std::string msg ("You do not have enough money. The price for teleportation is " + ConvertMoney(dest.m_cost) + ".");
+            creature->Whisper(msg.c_str(), LANG_UNIVERSAL, player);
+            return;
+        }
+
+        if (!player->IsGameMaster() && dest.m_cost)
+            player->ModifyMoney(-1 * dest.m_cost);
+
+        Teleport(player, dest.m_map, dest.m_X, dest.m_Y, dest.m_Z, dest.m_orient);
+    }
+}
+
+class npc_teleport : public CreatureScript
+{
+public:
+    npc_teleport() : CreatureScript("npc_teleport") {}
+
+bool OnGossipHello(Player *player, Creature *creature)
+{
+    PageC(player) = PageD(player) = Cat(player) = 0;
+
+    if(player->IsInCombat())
+    {
+        player->CLOSE_GOSSIP_MENU();
+        creature->Whisper("You are in combat. Come back later", LANG_UNIVERSAL, player);
+        return true;
+    }
+    AffichCat(player, creature);
+    return true;
+}
+
+bool OnGossipSelect(Player *player, Creature *creature, uint32 sender, uint32 param)
+{
+    player->PlayerTalkClass->ClearMenus();
+    switch(sender)
+    {
+      // Display destinations
+      case GOSSIP_SHOW_DEST:
+        Cat(player) = param;
+        AffichDest(player, creature);
+        break;
+
+      // Previous categories page
+      case GOSSIP_PREV_PAGEC:
+        --PageC(player);
+        AffichCat(player, creature);
+        break;
+
+      // Next page categories
+      case GOSSIP_NEXT_PAGEC:
+        ++PageC(player);
+        AffichCat(player, creature);
+        break;
+
+      // Previous destinations page
+      case GOSSIP_PREV_PAGED:
+        --PageD(player);
+        AffichDest(player, creature);
+        break;
+
+      // Next destination page
+      case GOSSIP_NEXT_PAGED:
+        ++PageD(player);
+        AffichDest(player, creature);
+        break;
+
+      // Display main menu
+      case GOSSIP_MAIN_MENU:
+        OnGossipHello(player, creature);
+        break;
+
+      // Teleportation
+      case GOSSIP_TELEPORT:
+        player->CLOSE_GOSSIP_MENU();
+        if(player->HasAura(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS)) {
+            creature->CastSpell(player,38588,false); // Healing effect
+            player->RemoveAurasDueToSpell(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS);
+        }
+
+        ActionTeleport(player, creature, param);
+        break;
+    }
+    return true;
+}
+};
+
+void AddSC_npc_teleport()
+{
+    new npc_teleport;
+}
+// End of TeleNPC2
diff --git a/src/server/scripts/Custom/npc_vote_rewarder.cpp b/src/server/scripts/Custom/npc_vote_rewarder.cpp
new file mode 100644
index 0000000..7b74860
--- /dev/null
+++ b/src/server/scripts/Custom/npc_vote_rewarder.cpp
@@ -0,0 +1,386 @@
+/*
+* Copyright (C) 2008-2014 TrinityCore <http://www.trinitycore.org/>
+* Copyright (C) 2014 Roca <http://wow-studio.eu/>
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program. If not, see <http://www.gnu.org/licenses/>.
+*
+* Standard Copyrightgezuppel, kannst du ruhig entfernen, wenn du moechtest
+*/
+
+#include "ScriptMgr.h"
+#include "ScriptedCreature.h"
+#include "ScriptedGossip.h"
+#include "Player.h"
+
+enum VoteRewarder
+{
+                     //Hier beliebige entry aus der Tabelle npc_text eintragen. Momentan halt standard Text :)
+    GOSSIP_MESSAGE = DEFAULT_GOSSIP_MESSAGE,
+
+    MAIN_MENU  = 1,
+    MENU_60P   = 2,
+    MENU_250P  = 3,
+    MENU_500P  = 4,
+    MENU_1000P = 5,
+    MENU_2000P = 6,
+    MENU_MISC  = 7,
+};
+
+class npc_vote_rewarder : public CreatureScript
+{
+public:
+    npc_vote_rewarder() : CreatureScript("npc_vote_rewarder") { }
+
+    uint32 votePoints = 0;
+    uint32 accId = 0;
+
+    bool OnGossipHello(Player* player, Creature* creature) override
+    {
+        accId = player->GetSession()->GetAccountId();
+
+        QueryResult result = LoginDatabase.PQuery("SELECT points FROM voting_points WHERE id = %u", accId);
+
+        if (result)
+        {
+            Field* fields = result->Fetch();
+            votePoints = fields[0].GetUInt32();
+        }
+
+        player->ADD_GOSSIP_ITEM(7, "Votepunkte eintauschen.", MAIN_MENU, 1);
+        player->ADD_GOSSIP_ITEM(0, "Bis bald.",               MENU_MISC, 1);
+        player->PlayerTalkClass->SendGossipMenu(GOSSIP_MESSAGE, creature->GetGUID());
+        return true;
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action) override
+    {
+        player->PlayerTalkClass->ClearMenus();
+
+        if (sender == MAIN_MENU)
+        {
+            player->ADD_GOSSIP_ITEM(7, "Belohnungen f\303\274r 60 Punkte.",   MENU_60P,   1);
+            player->ADD_GOSSIP_ITEM(7, "Belohnungen f\303\274r 250 Punkte.",  MENU_250P,  1);
+            player->ADD_GOSSIP_ITEM(7, "Belohnungen f\303\274r 500 Punkte.",  MENU_500P,  1);
+            player->ADD_GOSSIP_ITEM(7, "Belohnungen f\303\274r 1000 Punkte.", MENU_1000P, 1);
+            player->ADD_GOSSIP_ITEM(7, "Belohnungen f\303\274r 2000 Punkte.", MENU_2000P, 1);
+            player->ADD_GOSSIP_ITEM(0, "Bis bald.",                           MENU_MISC,  1);
+            player->PlayerTalkClass->SendGossipMenu(GOSSIP_MESSAGE, creature->GetGUID());
+        }
+
+        if (sender == MENU_60P)
+        {
+            switch (action)
+            {
+                case 1:
+                    player->ADD_GOSSIP_ITEM(2, "60 Punkte gegen 100 Gold tauschen.", MENU_60P,  2);
+                    player->ADD_GOSSIP_ITEM(7, "Hauptmen\303\274.",                  MAIN_MENU, 1);
+                    player->ADD_GOSSIP_ITEM(0, "Bis bald.",                          MENU_MISC, 1);
+                    player->PlayerTalkClass->SendGossipMenu(GOSSIP_MESSAGE, creature->GetGUID());
+                    break;
+                case 2:
+                    if (votePoints < 60)
+                    {
+                        creature->Whisper("Du hast nicht gen\303\274gend Votepunkte", LANG_UNIVERSAL, player);
+                        player->CLOSE_GOSSIP_MENU();
+                        return false;
+                    }
+
+                    if ((player->GetMoney() + (100 * GOLD)) > MAX_MONEY_AMOUNT)
+                    {
+                        creature->Whisper("Du kannst so viel Gold nicht bei dir tragen.", LANG_UNIVERSAL, player);
+                        player->CLOSE_GOSSIP_MENU();
+                        return false;
+                    }
+                    else
+                    {
+                        player->ModifyMoney(100 * GOLD);
+                        LoginDatabase.PExecute("UPDATE voting_points SET points = (points - %u) WHERE id = %u;", 60, accId);
+                        player->CLOSE_GOSSIP_MENU();
+                    }
+                    break;
+            }
+        }
+
+        if (sender == MENU_250P)
+        {
+            switch (action)
+            {
+                case 1:
+                    player->ADD_GOSSIP_ITEM(2, "250 Punkte gegen 10x Emblem des Heldentums tauschen.", MENU_250P, 2);
+                    player->ADD_GOSSIP_ITEM(2, "250 Punkte gegen 10x Emblem der Eroberung tauschen.",  MENU_250P, 3);
+                    player->ADD_GOSSIP_ITEM(2, "250 Punkte gegen 10x Emblem der Ehre tauschen.",       MENU_250P, 4);
+                    player->ADD_GOSSIP_ITEM(2, "250 Punkte gegen 10x Emblem des Triumphs tauschen.",   MENU_250P, 5);
+                    player->ADD_GOSSIP_ITEM(2, "250 Punkte gegen 10x Emblem des Frosts tauschen.",     MENU_250P, 6);
+                    player->ADD_GOSSIP_ITEM(7, "Hauptmen\303\274.",                                    MAIN_MENU, 1);
+                    player->ADD_GOSSIP_ITEM(0, "Bis bald.",                                            MENU_MISC, 1);
+                    player->PlayerTalkClass->SendGossipMenu(GOSSIP_MESSAGE, creature->GetGUID());
+                    break;
+                case 2:
+                    SendVotereward(player, 40752, 10, 250);
+                    break;
+                case 3:
+                    SendVotereward(player, 45624, 10, 250);
+                    break;
+                case 4:
+                    SendVotereward(player, 40753, 10, 250);
+                    break;
+                case 5:
+                    SendVotereward(player, 47241, 10, 250);
+                    break;
+                case 6:
+                    SendVotereward(player, 49426, 10, 250);
+                    break;
+            }
+        }
+
+        if (sender == MENU_500P)
+        {
+            switch (action)
+            {
+                case 1:
+                    player->ADD_GOSSIP_ITEM(2, "500 Punkte gegen 1000 Gold tauschen.",           MENU_500P, 2);
+                    player->ADD_GOSSIP_ITEM(2, "500 Punkte gegen Katzentransportkorb tauschen.", MENU_500P, 3);
+                    player->ADD_GOSSIP_ITEM(7, "Hauptmen\303\274.",                              MAIN_MENU, 1);
+                    player->ADD_GOSSIP_ITEM(0, "Bis bald.",                                      MENU_MISC, 1);
+                    player->PlayerTalkClass->SendGossipMenu(GOSSIP_MESSAGE, creature->GetGUID());
+                    break;
+                case 2:
+                    if (votePoints < 500)
+                    {
+                        creature->Whisper("Du hast nicht gen\303\274gend Votepunkte", LANG_UNIVERSAL, player);
+                        player->CLOSE_GOSSIP_MENU();
+                        return false;
+                    }
+
+                    if ((player->GetMoney() + (1000 * GOLD)) > MAX_MONEY_AMOUNT)
+                    {
+                        creature->Whisper("Du kannst so viel Gold nicht bei dir tragen.", LANG_UNIVERSAL, player);
+                        player->CLOSE_GOSSIP_MENU();
+                        return false;
+                    }
+                    else
+                    {
+                        player->ModifyMoney(1000 * GOLD);
+                        LoginDatabase.PExecute("UPDATE voting_points SET points = (points - %u) WHERE id = %u;", 500, accId);
+                        player->CLOSE_GOSSIP_MENU();
+                    }
+                    break;
+                case 3:
+                    SendVotereward(player, 8491, 1, 500);
+                    break;
+            }
+        }
+
+        if (sender == MENU_1000P)
+        {
+            switch (action)
+            {
+                case 1:
+                    player->ADD_GOSSIP_ITEM(2, "1000 Punkte gegen XT der Kleine tauschen.",         MENU_1000P,  2);
+                    player->ADD_GOSSIP_ITEM(2, "1000 Punkte gegen Pandarenm\303\266nch tauschen.",  MENU_1000P,  3);
+                    player->ADD_GOSSIP_ITEM(2, "1000 Punkte gegen Hippogryphenjunges tauschen.",    MENU_1000P,  4);
+                    player->ADD_GOSSIP_ITEM(2, "1000 Punkte gegen Papierdrachen tauschen.",         MENU_1000P,  5);
+                    player->ADD_GOSSIP_ITEM(2, "1000 Punkte gegen Papageienk\303\244fig tauschen.", MENU_1000P,  6);
+                    player->ADD_GOSSIP_ITEM(2, "1000 Punkte gegen Tuskarrdrachen tauschen.",        MENU_1000P,  7);
+                    player->ADD_GOSSIP_ITEM(2, "1000 Punkte gegen Eingefangene Flamme tauschen.",   MENU_1000P,  8);
+                    player->ADD_GOSSIP_ITEM(2, "1000 Punkte gegen Wunschwettermaschine tauschen.",  MENU_1000P,  9);
+                    player->ADD_GOSSIP_ITEM(2, "1000 Punkte gegen Fetisch aus Senjin tauschen.",   MENU_1000P, 10);
+                    player->ADD_GOSSIP_ITEM(2, "1000 Punkte gegen Makabre Marionette tauschen.",    MENU_1000P, 11);
+                    player->ADD_GOSSIP_ITEM(7, "Hauptmen\303\274.",                                 MAIN_MENU,   1);
+                    player->ADD_GOSSIP_ITEM(0, "Bis bald.",                                         MENU_MISC,   1);
+                    player->PlayerTalkClass->SendGossipMenu(GOSSIP_MESSAGE, creature->GetGUID());
+                    break;
+                case 2:
+                    SendVotereward(player, 54847, 1, 1000);
+                    break;
+                case 3:
+                    SendVotereward(player, 49665, 1, 1000);
+                    break;
+                case 4:
+                    SendVotereward(player, 23713, 1, 1000);
+                    break;
+                case 5:
+                    SendVotereward(player, 34493, 10, 1000);
+                    break;
+                case 6:
+                    SendVotereward(player, 8494, 1, 1000);
+                    break;
+                case 7:
+                    SendVotereward(player, 49287, 1, 1000);
+                    break;
+                case 8:
+                    SendVotereward(player, 23083, 1, 1000);
+                    break;
+                case 9:
+                    SendVotereward(player, 35227, 1, 1000);
+                    break;
+                case 10:
+                    SendVotereward(player, 45606, 1, 1000);
+                    break;
+                case 11:
+                    SendVotereward(player, 46831, 1, 1000);
+                    break;
+            }
+        }
+
+        if (sender == MENU_2000P)
+        {
+            switch (action)
+            {
+                case 1:
+                    player->ADD_GOSSIP_ITEM(2, "2000 Punkte gegen Z\303\274gel des schnellen Spektraltiger tauschen.",               MENU_2000P,  2);
+                    player->ADD_GOSSIP_ITEM(2, "2000 Punkte gegen Z\303\274gel des wei\303\237en Eisb\303\244ren tauschen.",         MENU_2000P,  3);
+                    player->ADD_GOSSIP_ITEM(2, "2000 Punkte gegen Z\303\274gel des gro\303\237en schwarzen Kriegsmammuts tauschen.", MENU_2000P,  4);
+                    player->ADD_GOSSIP_ITEM(2, "2000 Punkte gegen Chopper/Feuerstuhl tauschen.",                                     MENU_2000P,  5);
+                    player->ADD_GOSSIP_ITEM(2, "2000 Punkte gegen Schneller Netherdrachen tauschen.",                                MENU_2000P,  6);
+                    player->ADD_GOSSIP_ITEM(2, "2000 Punkte gegen Netherdrachen des Erbarmungslosen tauschen.",                      MENU_2000P,  7);
+                    player->ADD_GOSSIP_ITEM(2, "2000 Punkte gegen Rachs\303\274chtiger Netherdrachen tauschen.",                     MENU_2000P,  8);
+                    player->ADD_GOSSIP_ITEM(2, "2000 Punkte gegen Brutaler Netherdrachen tauschen.",                                 MENU_2000P,  9);
+                    player->ADD_GOSSIP_ITEM(2, "2000 Punkte gegen Frostwyrm des t\303\266dlichen Gladiators tauschen.",              MENU_2000P, 10);
+                    player->ADD_GOSSIP_ITEM(2, "2000 Punkte gegen Reitschildkr\303\266te tauschen.",                                 MENU_2000P, 11);
+                    player->ADD_GOSSIP_ITEM(2, "2000 Punkte gegen Himmelsross tauschen.",                                            MENU_2000P, 12);
+                    player->ADD_GOSSIP_ITEM(2, "2000 Punkte gegen Flammender Hippogryph tauschen.",                                  MENU_2000P, 13);
+                    player->ADD_GOSSIP_ITEM(2, "2000 Punkte gegen X-51 Netherrakete tauschen.",                                      MENU_2000P, 14);
+                    player->ADD_GOSSIP_ITEM(2, "2000 Punkte gegen X-51 Netherrakete X-Trem tauschen.",                               MENU_2000P, 15);
+                    player->ADD_GOSSIP_ITEM(7, "Hauptmen\303\274.",                                                                  MAIN_MENU,   1);
+                    player->ADD_GOSSIP_ITEM(0, "Bis bald.",                                                                          MENU_MISC,   1);
+                    player->PlayerTalkClass->SendGossipMenu(GOSSIP_MESSAGE, creature->GetGUID());
+                    break;
+                case 2:
+                    SendVotereward(player, 49284, 1, 2000);
+                    break;
+                case 3:
+                    SendVotereward(player, 43962, 1, 2000);
+                    break;
+                case 4:
+                    SendVotereward(player, player->GetTeam() == ALLIANCE ? 43959 : 44083, 1, 2000);
+                    break;
+                case 5:
+                    SendVotereward(player, player->GetTeam() == ALLIANCE ? 44413 : 41508, 1, 2000);
+                    break;
+                case 6:
+                    SendVotereward(player, 30609, 1, 2000);
+                    break;
+                case 7:
+                    SendVotereward(player, 34092, 1, 2000);
+                    break;
+                case 8:
+                    SendVotereward(player, 37676, 1, 2000);
+                    break;
+                case 9:
+                    SendVotereward(player, 43516, 1, 2000);
+                    break;
+                case 10:
+                    SendVotereward(player, 46171, 1, 2000);
+                    break;
+                case 11:
+                    SendVotereward(player, 23720, 1, 2000);
+                    break;
+                case 12:
+                    SendVotereward(player, 54811, 1, 2000);
+                    break;
+                case 13:
+                    SendVotereward(player, 54069, 1, 2000);
+                    break;
+                case 14:
+                    SendVotereward(player, 49285, 1, 2000);
+                    break;
+                case 15:
+                    SendVotereward(player, 49286, 1, 2000);
+                    break;
+            }
+        }
+
+        if (sender == MENU_MISC)
+        {
+            if (action == 1)
+            {
+                creature->Whisper("Bis bald.", LANG_UNIVERSAL, player);
+                player->CLOSE_GOSSIP_MENU();
+            }
+        }
+
+        return true;
+    }
+
+    void SendVotereward(Player* player, uint32 itemEntry, uint32 count, uint32 vp)
+    {
+        if (votePoints < vp)
+        {
+            player->Whisper("Du hast nicht gen\303\274gend Votepunkte", LANG_UNIVERSAL, player);
+            player->CLOSE_GOSSIP_MENU();
+            return;
+        }
+
+        uint32 noSpaceForCount = 0;
+
+        ItemPosCountVec dest;
+        InventoryResult msg = player->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemEntry, count, &noSpaceForCount);
+
+        //Der Spieler bekommt die Belohnung via IngameMail, wenn er keinen Platz mehr in seinen Taschen hat.
+        if (msg != EQUIP_ERR_OK)
+        {
+            //Texte kannst du aendern, wie du lustig bist.
+            std::string subject = "Votebelohnung";
+            std::string text = "Hier deine Belohnung. Vielen dank f\303\274r deine Unterst\303\274tzung. Bitte vote auch in zukunft f\303\274r unseren Server.";
+
+            typedef std::pair<uint32, uint32> ItemPair;
+            typedef std::list< ItemPair > ItemPairs;
+            ItemPairs items;
+
+            ItemTemplate const* item_proto = sObjectMgr->GetItemTemplate(itemEntry);
+
+            while (count > item_proto->GetMaxStackSize())
+            {
+                items.push_back(ItemPair(itemEntry, item_proto->GetMaxStackSize()));
+                count -= item_proto->GetMaxStackSize();
+            }
+
+            items.push_back(ItemPair(itemEntry, count));
+
+            if (items.size() > MAX_MAIL_ITEMS)
+                return;
+
+            MailSender sender(MAIL_NORMAL, 0, MAIL_STATIONERY_GM);
+            MailDraft draft(subject, text);
+
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+            for (ItemPairs::const_iterator itr = items.begin(); itr != items.end(); ++itr)
+            {
+                if (Item* item = Item::CreateItem(itr->first, itr->second, 0))
+                {
+                    item->SaveToDB(trans);
+                    draft.AddItem(item);
+                }
+            }
+
+            draft.SendMailTo(trans, MailReceiver(player, ObjectGuid(player->GetGUID())), sender);
+            CharacterDatabase.CommitTransaction(trans);
+        }
+        else
+        {
+            player->AddItem(itemEntry, count);
+        }
+
+        LoginDatabase.PExecute("UPDATE voting_points SET points = (points - %u) WHERE id = %u;", vp, accId);
+
+        player->Whisper("Hier deine Belohnung. Vielen dank f\303\274r deine Unterst\303\274tzung. Bitte vote auch in zukunft f\303\274r unseren Server.", LANG_UNIVERSAL, player);
+    }
+};
+
+void AddSC_npc_vote_rewarder()
+{
+    new npc_vote_rewarder();
+}
diff --git a/src/server/scripts/Custom/npcbuff.cpp b/src/server/scripts/Custom/npcbuff.cpp
new file mode 100644
index 0000000..37f0e86
--- /dev/null
+++ b/src/server/scripts/Custom/npcbuff.cpp
@@ -0,0 +1,424 @@
+/* Copyright (C) 2010 SAMCC Studios <http://www.samccstudios.com/>
+ * Written by LordPsyan
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+ /*
+Script Name: npc_buff v1.1
+Complete: 100%
+Comment: Database Driven Buff Master
+*/
+
+#include "Config.h"
+
+#define GOSSIP_SENDER_MAIN      1000
+#define GOSSIP_SMALLBUFF        2000
+#define GOSSIP_LARGEBUFF        3000
+#define GOSSIP_GMBUFF           4000
+#define GOSSIP_PLAYERTOOLS      5000
+
+#define SPELL_RESURRECTION_SICKNESS_15007  15007
+
+#define NB_BUFF_PAGE            10
+#define MSG_TYPE                100002
+#define MSG_BUFF                100003
+
+#define NEXT_PAGE               "-> [Next Page]"
+#define PREV_PAGE               "<- [Previous Page]"
+#define MAIN_MENU               "<= [Main Menu]"
+
+class npc_buff : public CreatureScript
+{
+public:
+    npc_buff() : CreatureScript("npc_buff") {}
+
+bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+{
+    if(sConfigMgr->GetBoolDefault("Npc_Buff.OnlyGMs", false)) // If Npc_Buff.OnlyGMs is enabled in worldserver.conf
+        if (pPlayer->GetSession()->GetSecurity() == SEC_PLAYER)
+        {
+            pCreature->Whisper("Sorry, I can only Buff Platinum Members.", LANG_UNIVERSAL, pPlayer);
+            return true;
+        }
+
+    bool EnableSmallBuff = sConfigMgr->GetBoolDefault("Npc_Buff.EnableSmallBuff", true);
+    bool EnableGreatBuff = sConfigMgr->GetBoolDefault("Npc_Buff.EnableGreatBuff", true);
+    bool EnableGMBuff = sConfigMgr->GetBoolDefault("Npc_Buff.EnableGMBuff", true);
+    bool EnablePlayerTools = sConfigMgr->GetBoolDefault("Npc_Buff.EnablePlayerTools", true);
+    bool EnableResSickness = sConfigMgr->GetBoolDefault("Npc_Buff.EnableRemoveResSickness", true);
+    bool EnableGivemeGold = sConfigMgr->GetBoolDefault("Npc_Buff.EnableGivemeGold", false);
+
+    // Main Menu
+
+    // Check config if "Small  Buff " is enabled or not
+    if(EnableSmallBuff)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Small Buff ->"              , GOSSIP_SENDER_MAIN, 1000);
+    // Check config if "Great Buff" is enabled or not
+    if(EnableGreatBuff)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Great Buff ->"              , GOSSIP_SENDER_MAIN, 2000);
+    // Check config if "GM Buff" is enabled or not
+    if(EnableGMBuff)
+    {
+    if (pPlayer->GetSession()->GetSecurity() > SEC_PLAYER)
+        {
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Platinum Members Buff ->"                 , GOSSIP_SENDER_MAIN, 3000);
+        }
+    }
+    // Check config if "Player Tools" is enabled or not
+    if(EnablePlayerTools)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Player Tools ->"            , GOSSIP_SENDER_MAIN, 4000);
+
+    // Check config file if "Remove res sickness" option is enabled or not
+    if(EnableResSickness)
+        pPlayer->ADD_GOSSIP_ITEM( 10, "Remove Resurrect Sickness" , GOSSIP_SENDER_MAIN, 5000);
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_TYPE, pCreature->GetGUID());
+
+return true;
+}
+
+bool showSmallBuff(Player *pPlayer, Creature *pCreature, uint32 showFromId = 0)
+{
+
+
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `name`, `cat_number` FROM `npc_buff_spells` WHERE `cat_number` < 2000 ORDER BY `cat_number` ASC");
+
+ if (result)
+ {
+ std::string name = "";
+ uint32 catNumber = 0;
+  do
+ {
+ Field *fields = result->Fetch();
+ name = fields[0].GetString();
+ catNumber = fields[1].GetInt32();
+
+    pPlayer->ADD_GOSSIP_ITEM(9, name, GOSSIP_SENDER_MAIN, catNumber);
+}
+ while (result->NextRow());
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_BUFF, pCreature->GetGUID());
+ return true;
+ }
+ else
+ {
+ if (showFromId = 0)
+ {
+ //you are too poor
+ pCreature->Whisper("You don't have enough money.", LANG_UNIVERSAL, pPlayer);
+ pPlayer->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+
+ //show Spells from beginning
+ showSmallBuff(pPlayer, pCreature, 0);
+ }
+ }
+
+ return false;
+}
+
+bool showGreatBuff(Player *pPlayer, Creature *pCreature, uint32 showFromId = 0)
+{
+
+
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `name`, `cat_number` FROM `npc_buff_spells` WHERE `cat_number` < 3000 AND `cat_number` > 2000 ORDER BY `cat_number` ASC");
+
+ if (result)
+ {
+ std::string name = "";
+ uint32 catNumber = 0;
+  do
+ {
+ Field *fields = result->Fetch();
+ name = fields[0].GetString();
+ catNumber = fields[1].GetInt32();
+
+    pPlayer->ADD_GOSSIP_ITEM(9, name, GOSSIP_SENDER_MAIN, catNumber);
+}
+ while (result->NextRow());
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_BUFF, pCreature->GetGUID());
+ return true;
+ }
+ else
+ {
+ if (showFromId = 0)
+ {
+ //you are too poor
+ pCreature->Whisper("You don't have enough money.", LANG_UNIVERSAL, pPlayer);
+ pPlayer->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+
+ //show Spells from beginning
+ showGreatBuff(pPlayer, pCreature, 0);
+ }
+ }
+
+ return false;
+}
+
+bool showGmBuff(Player *pPlayer, Creature *pCreature, uint32 showFromId = 0)
+{
+
+
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `name`, `cat_number` FROM `npc_buff_spells` WHERE `cat_number` < 4000 AND `cat_number` > 3000 ORDER BY `cat_number` ASC");
+
+ if (result)
+ {
+ std::string name = "";
+ uint32 catNumber = 0;
+  do
+ {
+ Field *fields = result->Fetch();
+ name = fields[0].GetString();
+ catNumber = fields[1].GetInt32();
+
+    pPlayer->ADD_GOSSIP_ITEM(9, name, GOSSIP_SENDER_MAIN, catNumber);
+}
+ while (result->NextRow());
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_BUFF, pCreature->GetGUID());
+ return true;
+ }
+ else
+ {
+ if (showFromId = 0)
+ {
+ //you are too poor
+ pCreature->Whisper("You don't have enough money.", LANG_UNIVERSAL, pPlayer);
+ pPlayer->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+
+ //show Spells from beginning
+ showGmBuff(pPlayer, pCreature, 0);
+ }
+ }
+
+ return false;
+}
+
+bool showPlayerTools(Player *pPlayer, Creature *pCreature, uint32 showFromId = 0)
+{
+
+
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `name`, `cat_number` FROM `npc_buff_spells` WHERE `cat_number` < 5000 AND `cat_number` > 4000 ORDER BY `cat_number` ASC");
+
+ if (result)
+ {
+ std::string name = "";
+ uint32 catNumber = 0;
+  do
+ {
+ Field *fields = result->Fetch();
+ name = fields[0].GetString();
+ catNumber = fields[1].GetInt32();
+
+    pPlayer->ADD_GOSSIP_ITEM(9, name, GOSSIP_SENDER_MAIN, catNumber);
+}
+ while (result->NextRow());
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_BUFF, pCreature->GetGUID());
+ return true;
+ }
+ else
+ {
+ if (showFromId = 0)
+ {
+ //you are too poor
+ pCreature->Whisper("You don't have enough money.", LANG_UNIVERSAL, pPlayer);
+ pPlayer->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+
+ //show Spells from beginning
+ showPlayerTools(pPlayer, pCreature, 0);
+ }
+ }
+
+ return false;
+}
+
+void SendDefaultMenu(Player* pPlayer, Creature* pCreature, uint32 uiAction)
+{
+
+// Not allow in combat
+if (pPlayer->IsInCombat())
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->Say("You are in combat!", LANG_UNIVERSAL);
+    return;
+}
+
+    bool EnableSmallBuff = sConfigMgr->GetBoolDefault("Npc_Buff.EnableSmallBuff", true);
+    bool EnableGreatBuff = sConfigMgr->GetBoolDefault("Npc_Buff.EnableGreatBuff", true);
+    bool EnableGMBuff = sConfigMgr->GetBoolDefault("Npc_Buff.EnableGMBuff", true);
+    bool EnablePlayerTools = sConfigMgr->GetBoolDefault("Npc_Buff.EnablePlayerTools", true);
+    bool EnableResSickness = sConfigMgr->GetBoolDefault("Npc_Buff.EnableRemoveResSickness", true);
+    bool EnableGivemeGold = sConfigMgr->GetBoolDefault("Npc_Buff.EnableGivemeGold", false);
+
+//Money Check
+if (pPlayer->GetMoney() < (sConfigMgr->GetFloatDefault("BuffGoldCost",0)))
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->Whisper("You don't have enough money.", LANG_UNIVERSAL, pPlayer);
+    return;
+}
+
+
+  // send name as gossip item
+
+
+       QueryResult result;
+        uint32 spellId = 0;
+        uint32 catNumber = 0;
+        uint32 goldCost = 0;
+        std::string spellName = "";
+
+        result = WorldDatabase.PQuery("SELECT `spell_id`, `cat_number`, `cost`, `name` FROM `npc_buff_spells` WHERE `cat_number` = %u LIMIT 1", uiAction);
+
+        if (result)
+        {
+
+            do {
+
+            Field *fields = result->Fetch();
+            spellId = fields[0].GetInt32();
+            catNumber = fields[1].GetInt32();
+            goldCost = fields[2].GetInt32();
+            spellName = fields[3].GetString();
+
+            if (pPlayer->GetMoney() < goldCost)
+            {
+                pCreature->Whisper("You dont have enough money!", LANG_UNIVERSAL, pPlayer);
+                pPlayer->CLOSE_GOSSIP_MENU();
+                return;
+            }
+            else if (uiAction < 5000 && uiAction != 1000 && uiAction != 2000 && uiAction != 3000 && uiAction != 4000 && uiAction != 5005)
+            {
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pPlayer->CastSpell(pPlayer,spellId,false);
+    pPlayer->ModifyMoney(-goldCost);
+
+            }
+
+            } while (result->NextRow());
+        } else {
+            //pPlayer->ADD_GOSSIP_ITEM( 7, MAIN_MENU, GOSSIP_SENDER_MAIN, 5005);
+        }
+
+ switch(uiAction)
+{
+
+case 1000: //Small  Buff
+         showSmallBuff(pPlayer, pCreature, 0);
+        //pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                            , GOSSIP_SENDER_MAIN, 5005);
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_BUFF, pCreature->GetGUID());
+break;
+
+case 2000: //Great Buff
+
+
+        showGreatBuff(pPlayer, pCreature, 0);
+        //pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                            , GOSSIP_SENDER_MAIN, 5005);
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_BUFF, pCreature->GetGUID());
+break;
+
+case 3000: //GM  Buff
+
+        showGmBuff(pPlayer, pCreature, 0);
+        //pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                            , GOSSIP_SENDER_MAIN, 5005);
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_BUFF,pCreature->GetGUID());
+break;
+
+case 4000: //Player Tools
+    // Check config if "Give me Gold" is enabled or not
+
+        showPlayerTools(pPlayer, pCreature, 0);
+        //pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                            , GOSSIP_SENDER_MAIN, 5005);
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_BUFF,pCreature->GetGUID());
+break;
+
+case 5005: //Back To Main Menu
+    // Main Menu
+    // Check config if "Small  Buff " is enabled or not
+    if(EnableSmallBuff)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Small Buff ->"              , GOSSIP_SMALLBUFF, 1000);
+    // Check config if "Great Buff" is enabled or not
+    if(EnableGreatBuff)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Great Buff ->"              , GOSSIP_LARGEBUFF, 2000);
+    // Check config if "GM Buff" is enabled or not
+    if(EnableGMBuff)
+    {
+    if (pPlayer->GetSession()->GetSecurity() > SEC_PLAYER)
+        {
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Platinum Members Buff ->"                 , GOSSIP_SENDER_MAIN, 3000);
+        }
+    }
+    // Check config if "Player Tools" is enabled or not
+    if(EnablePlayerTools)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Player Tools ->"            , GOSSIP_PLAYERTOOLS, 4000);
+    // Check if Ress Sickness option is enabled
+    if(EnableResSickness)
+        pPlayer->ADD_GOSSIP_ITEM( 10, "Remove Resurrect Sickness" , GOSSIP_SENDER_MAIN, 5000);
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_TYPE, pCreature->GetGUID());
+break;
+
+case 5000://Remove Res Sickness
+    if(!pPlayer->HasAura(SPELL_RESURRECTION_SICKNESS_15007))
+    {
+        pCreature->Whisper("You don't have resurrection sickness.", LANG_UNIVERSAL, pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pCreature->CastSpell(pPlayer,38588,false); // Healing effect
+    pPlayer->RemoveAurasDueToSpell(SPELL_RESURRECTION_SICKNESS_15007);
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+ pPlayer->CLOSE_GOSSIP_MENU();
+ }
+
+} //end of function
+
+bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+    // Main menu
+    pPlayer->PlayerTalkClass->ClearMenus();
+    if (uiSender == GOSSIP_SENDER_MAIN)
+    SendDefaultMenu(pPlayer, pCreature, uiAction);
+
+return true;
+}
+};
+void AddSC_Npc_Buff()
+{
+    new npc_buff();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/professionnpc.cpp b/src/server/scripts/Custom/professionnpc.cpp
new file mode 100644
index 0000000..699621f
--- /dev/null
+++ b/src/server/scripts/Custom/professionnpc.cpp
@@ -0,0 +1,394 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "Config.h"
+
+class professionnpc : public CreatureScript
+{
+public:
+    professionnpc() : CreatureScript("professionnpc") {}
+
+
+bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+{
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.OnlyGMs", false)) // If ProfessionNPC.OnlyGMs is enabled in trinitycore.conf
+        if (pPlayer->GetSession()->GetSecurity() == SEC_PLAYER)
+        {
+            pCreature->Whisper("Sorry, I can only trade to game masters.", LANG_UNIVERSAL, pPlayer);
+            return true;
+        }
+
+    bool EnableProfessions = sConfigMgr->GetBoolDefault("ProfessionNPC.EnableProfessions", true);
+    bool EnableSecondarySkills = sConfigMgr->GetBoolDefault("ProfessionNPC.EnableSecondarySkills", true);
+
+    // Main Menu for Alliance
+    if (pPlayer->GetTeam() == ALLIANCE)
+    {
+    // Check config if "Professions" is enabled or not
+    if(EnableProfessions)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Professions ->"        , GOSSIP_SENDER_MAIN, 1000);
+    // Check config if "Secondary Skills" is enabled or not
+    if(EnableSecondarySkills)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Secondary Skills ->"   , GOSSIP_SENDER_MAIN, 2000);
+    }
+    else // Main Menu for Horde
+    {
+    // Check config if "Professions" is enabled or not
+    if(EnableProfessions)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Professions ->"        , GOSSIP_SENDER_MAIN, 1000);
+    // Check config if "Secondary Skills" is enabled or not
+    if(EnableSecondarySkills)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Secondary Skills ->"   , GOSSIP_SENDER_MAIN, 2000);
+    }
+
+    pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,pCreature->GetGUID());
+
+return true;
+}
+
+void SendDefaultMenu(Player* pPlayer, Creature* pCreature, uint32 uiAction)
+{
+
+// Not allow in combat
+if (pPlayer->IsInCombat())
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->Say("You are in combat!", LANG_UNIVERSAL);
+    return;
+}
+
+    bool EnableProfessions = sConfigMgr->GetBoolDefault("ProfessionNPC.EnableProfessions", true);
+    bool EnableSecondarySkills = sConfigMgr->GetBoolDefault("ProfessionNPC.EnableSecondarySkills", true);
+
+//Mony Check
+if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+{
+if (!pPlayer->HasItemCount((sConfigMgr->GetIntDefault("ProfessionNPC.ItemEntryNum",0)), 1))
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->Whisper("You ain't gots no darn chips.", LANG_UNIVERSAL, pPlayer);
+    return;
+}
+else if(pPlayer->GetMoney() < (sConfigMgr->GetIntDefault("SkillGoldCost",0)))
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->Whisper("You don't have enough money.", LANG_UNIVERSAL, pPlayer);
+    return;
+}
+}
+switch(uiAction)
+{
+
+case 1000: //Profession
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Alchemy."              , GOSSIP_SENDER_MAIN, 1001);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Blacksmithing."        , GOSSIP_SENDER_MAIN, 1002);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Enchanting."           , GOSSIP_SENDER_MAIN, 1003);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Engineering."          , GOSSIP_SENDER_MAIN, 1004);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Herbalism."            , GOSSIP_SENDER_MAIN, 1005);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Inscription."          , GOSSIP_SENDER_MAIN, 1006);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Jewelcrafting."        , GOSSIP_SENDER_MAIN, 1007);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Leatherworking."       , GOSSIP_SENDER_MAIN, 1008);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Mining."               , GOSSIP_SENDER_MAIN, 1009);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Skinning."             , GOSSIP_SENDER_MAIN, 1010);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Tailoring."            , GOSSIP_SENDER_MAIN, 1011);
+            pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"          , GOSSIP_SENDER_MAIN, 3000);
+
+    pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,pCreature->GetGUID());
+break;
+
+case 2000: //Secondary Skills
+            pPlayer->ADD_GOSSIP_ITEM( 5, "Cooking."              , GOSSIP_SENDER_MAIN, 2001);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "First Aid."            , GOSSIP_SENDER_MAIN, 2002);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "Fishing."              , GOSSIP_SENDER_MAIN, 2003);
+            pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"          , GOSSIP_SENDER_MAIN, 3000);
+
+    pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,pCreature->GetGUID());
+break;
+
+case 3000: //Back To Main Menu
+    // Main Menu for Alliance
+    if (pPlayer->GetTeam() == ALLIANCE)
+    {
+    // Check config if "Professions" is enabled or not
+    if(EnableProfessions)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Professions ->"        , GOSSIP_SENDER_MAIN, 1000);
+    // Check config if "Secondary Skills" is enabled or not
+    if(EnableSecondarySkills)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Secondary Skills ->"   , GOSSIP_SENDER_MAIN, 2000);
+    }
+    else // Main Menu for Horde
+    {
+    // Check config if "Professions" is enabled or not
+    if(EnableProfessions)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Professions ->"        , GOSSIP_SENDER_MAIN, 1000);
+    // Check config if "Secondary Skills" is enabled or not
+    if(EnableSecondarySkills)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Secondary Skills ->"   , GOSSIP_SENDER_MAIN, 2000);
+    }
+
+    pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,pCreature->GetGUID());
+break;
+
+//////////////////////////////////////////////////Professions///////////////////////////////////////////////////////////////
+
+case 1001: // Alchemy
+    if(!pPlayer->UpdateSkill(171,0))
+      {
+        pCreature->Whisper("You don't have this skill or you already have the maximum skill value $C.", LANG_UNIVERSAL, pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(171,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1002: // Blacksmithing
+    if(!pPlayer->UpdateSkill(164,0))
+      {
+        pCreature->Whisper("You don't have this skill or you already have the maximum skill value $C.", LANG_UNIVERSAL, pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(164,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1003: // Enchanting
+    if(!pPlayer->UpdateSkill(333,0))
+      {
+        pCreature->Whisper("You don't have this skill or you already have the maximum skill value $C.", LANG_UNIVERSAL, pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(333,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1004: // Engineering
+    if(!pPlayer->UpdateSkill(202,0))
+      {
+        pCreature->Whisper("You don't have this skill or you already have the maximum skill value $C.", LANG_UNIVERSAL, pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(202,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1005: // Herbalism
+    if(!pPlayer->UpdateSkill(182,0))
+      {
+        pCreature->Whisper("You don't have this skill or you already have the maximum skill value $C.", LANG_UNIVERSAL, pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(182,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1006: // Inscription
+    if(!pPlayer->UpdateSkill(773,0))
+      {
+        pCreature->Whisper("You don't have this skill or you already have the maximum skill value $C.", LANG_UNIVERSAL, pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(773,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1007: // Jewelcrafting
+    if(!pPlayer->UpdateSkill(755,0))
+      {
+        pCreature->Whisper("You don't have this skill or you already have the maximum skill value $C.", LANG_UNIVERSAL, pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(755,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1008: // Leatherworking
+    if(!pPlayer->UpdateSkill(165,0))
+      {
+        pCreature->Whisper("You don't have this skill or you already have the maximum skill value $C.", LANG_UNIVERSAL, pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(165,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1009: // Mining
+    if(!pPlayer->UpdateSkill(186,0))
+      {
+        pCreature->Whisper("You don't have this skill or you already have the maximum skill value $C.", LANG_UNIVERSAL, pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(186,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1010: // Skinning
+    if(!pPlayer->UpdateSkill(393,0))
+      {
+        pCreature->Whisper("You don't have this skill or you already have the maximum skill value $C.", LANG_UNIVERSAL, pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(393,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1011: // Tailoring
+    if(!pPlayer->UpdateSkill(197,0))
+      {
+        pCreature->Whisper("You don't have this skill or you already have the maximum skill value $C.", LANG_UNIVERSAL, pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(197,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+//////////////////////////////////////////////////Secondary Skills///////////////////////////////////////////////////////////////
+
+case 2001: // Cooking
+    if(!pPlayer->UpdateSkill(185,0))
+      {
+        pCreature->Whisper("You don't have this skill or you already have the maximum skill value $C.", LANG_UNIVERSAL, pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(185,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 2002: // First Aid
+    if(!pPlayer->UpdateSkill(129,0))
+      {
+        pCreature->Whisper("You don't have this skill or you already have the maximum skill value $C.", LANG_UNIVERSAL, pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(129,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 2003: // Fishing
+    if(!pPlayer->UpdateSkill(356,0))
+      {
+        pCreature->Whisper("You don't have this skill or you already have the maximum skill value $C.", LANG_UNIVERSAL, pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(356,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+ pPlayer->CLOSE_GOSSIP_MENU();
+
+} // end of switch
+} //end of function
+
+bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+    // Main menu
+    pPlayer->PlayerTalkClass->ClearMenus();
+    if (uiSender == GOSSIP_SENDER_MAIN)
+    SendDefaultMenu(pPlayer, pCreature, uiAction);
+
+return true;
+}
+};
+
+void AddSC_professionnpc()
+{
+
+new professionnpc();
+
+}
diff --git a/src/server/scripts/Custom/summon.cpp b/src/server/scripts/Custom/summon.cpp
new file mode 100644
index 0000000..7729f0d
--- /dev/null
+++ b/src/server/scripts/Custom/summon.cpp
@@ -0,0 +1,46 @@
+//#include "ScriptPCH.h"
+
+class summon : public ItemScript
+{
+        public:
+                summon() : ItemScript("summon")
+                {
+                }
+                bool OnUse(Player* pPlayer, Item* pItem, SpellCastTargets const& /*targets*/)
+                {
+   uint32 sSpell = 18282; //Icerune Visual Spell when used
+   if (pPlayer->IsInCombat())
+   {
+        pPlayer->GetSession()->SendNotification("You are in combat.");
+   }
+
+   else if (pPlayer->isMoving())
+   {
+        pPlayer->GetSession()->SendNotification("You can not do that while moving.");
+   }
+
+   else if (pPlayer->FindNearestCreature(80410, 40) || pPlayer->FindNearestCreature(100000, 8))
+   {
+        pPlayer->GetSession()->SendNotification("Teleportercan not be summoned because another Teleporter is within range.");
+   }
+
+   else
+   {
+        float x, y, z, o = pPlayer->GetOrientation();
+
+        if (o >= 3.141592)
+         o = o - 3.141592;
+        else
+         o = o + 3.141592;
+        pPlayer->GetClosePoint(x, y, z, pPlayer->GetObjectSize());
+        Creature* pCreature = pPlayer->SummonCreature(100000, x, y, z+2.2, o, TEMPSUMMON_TIMED_DESPAWN, 50000);
+        pCreature->CastSpell(pCreature, 63660);
+        return false;
+   }
+  return false;
+                }
+};
+void AddSC_summon()
+{
+        new summon();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Spells/spell_generic.cpp b/src/server/scripts/Spells/spell_generic.cpp
index 5c3ee1d..b042950 100644
--- a/src/server/scripts/Spells/spell_generic.cpp
+++ b/src/server/scripts/Spells/spell_generic.cpp
@@ -22,6 +22,7 @@
  * Scriptnames of files in this file should be prefixed with "spell_gen_"
  */
 
+#include "../Custom/TransmogDisplayVendorConf.h"
 #include "ScriptMgr.h"
 #include "Battleground.h"
 #include "Cell.h"
@@ -38,6 +39,7 @@
 #include "SpellScript.h"
 #include "SpellAuraEffects.h"
 #include "Vehicle.h"
+#include "../Custom/Transmogrification.h"
 
 class spell_gen_absorb0_hitlimit1 : public SpellScriptLoader
 {
@@ -861,7 +863,14 @@ class spell_gen_clone_weapon_aura : public SpellScriptLoader
                         if (Player* player = caster->ToPlayer())
                         {
                             if (Item* mainItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND))
-                                target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID, mainItem->GetEntry());
+                            {
+                                if (uint32 entry = TransmogDisplayVendorMgr::GetFakeEntry(mainItem))
+                                    target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID, entry);
+                                else if (uint32 entry = sTransmogrification->GetFakeEntry(mainItem))
+                                    target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID, entry);
+                                else
+                                    target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID, mainItem->GetEntry());
+                            }
                         }
                         else
                             target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID, caster->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID));
@@ -875,7 +884,14 @@ class spell_gen_clone_weapon_aura : public SpellScriptLoader
                         if (Player* player = caster->ToPlayer())
                         {
                             if (Item* offItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
-                                target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1, offItem->GetEntry());
+                            {
+                                if (uint32 entry = TransmogDisplayVendorMgr::GetFakeEntry(offItem))
+                                    target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1, entry);
+                                else if (uint32 entry = sTransmogrification->GetFakeEntry(offItem))
+                                    target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1, entry);
+                                else
+                                    target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1, offItem->GetEntry());
+                            }
                         }
                         else
                             target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1, caster->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1));
@@ -888,7 +904,14 @@ class spell_gen_clone_weapon_aura : public SpellScriptLoader
                         if (Player* player = caster->ToPlayer())
                         {
                             if (Item* rangedItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_RANGED))
-                                target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2, rangedItem->GetEntry());
+                            {
+                                if (uint32 entry = TransmogDisplayVendorMgr::GetFakeEntry(rangedItem))
+                                    target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2, entry);
+                                else if (uint32 entry = sTransmogrification->GetFakeEntry(rangedItem))
+                                    target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2, entry);
+                                else
+                                    target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2, rangedItem->GetEntry());
+                            }
                         }
                         else
                             target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2, caster->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2));
diff --git a/src/server/worldserver/CMakeLists.txt b/src/server/worldserver/CMakeLists.txt
index 535383a..8a2c945 100644
--- a/src/server/worldserver/CMakeLists.txt
+++ b/src/server/worldserver/CMakeLists.txt
@@ -78,11 +78,14 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Item/Container
   ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Object
   ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Object/Updates
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Pet
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Player
   ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Unit
   ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Vehicle
   ${CMAKE_SOURCE_DIR}/src/server/game/Globals
   ${CMAKE_SOURCE_DIR}/src/server/game/Grids
   ${CMAKE_SOURCE_DIR}/src/server/game/Grids/Cells
+  ${CMAKE_SOURCE_DIR}/src/server/game/Groups
   ${CMAKE_SOURCE_DIR}/src/server/game/Handlers
   ${CMAKE_SOURCE_DIR}/src/server/game/Instances
   ${CMAKE_SOURCE_DIR}/src/server/game/Loot
@@ -95,7 +98,9 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/game/Scripting
   ${CMAKE_SOURCE_DIR}/src/server/game/Server
   ${CMAKE_SOURCE_DIR}/src/server/game/Server/Protocol
+  ${CMAKE_SOURCE_DIR}/src/server/game/Spells
   ${CMAKE_SOURCE_DIR}/src/server/game/Spells/Auras
+  ${CMAKE_SOURCE_DIR}/src/server/game/TriniChat
   ${CMAKE_SOURCE_DIR}/src/server/game/Weather
   ${CMAKE_SOURCE_DIR}/src/server/game/World
   ${CMAKE_SOURCE_DIR}/src/server/shared
diff --git a/src/server/worldserver/CommandLine/CliRunnable.cpp b/src/server/worldserver/CommandLine/CliRunnable.cpp
index 9936143..c3bbbd4 100644
--- a/src/server/worldserver/CommandLine/CliRunnable.cpp
+++ b/src/server/worldserver/CommandLine/CliRunnable.cpp
@@ -28,6 +28,7 @@
 #include "CliRunnable.h"
 #include "Log.h"
 #include "Util.h"
+#include "IRCClient.h"
 
 #if PLATFORM != PLATFORM_WINDOWS
 #include <readline/readline.h>
@@ -108,6 +109,14 @@ void commandFinished(void*, bool /*success*/)
     printf("TC> ");
     fflush(stdout);
 }
+//Reconnect TriniChat to IRC server via CLI command
+bool HandleIRCRelogCommand(bool, const char *args)
+{
+    TC_LOG_ERROR("misc" "TriniChat is dropping from IRC Server","");
+    sIRC->ResetIRC();
+    TC_LOG_ERROR("misc" "TriniChat is reconnecting to IRC Server","");
+    return true;
+}
 
 #ifdef linux
 // Non-blocking keypress detector, when return pressed, return 1, else always return 0
diff --git a/src/server/worldserver/Main.cpp b/src/server/worldserver/Main.cpp
index 53c5f25..192e465 100644
--- a/src/server/worldserver/Main.cpp
+++ b/src/server/worldserver/Main.cpp
@@ -49,8 +49,10 @@
 #include "WorldSocketMgr.h"
 #include "DatabaseLoader.h"
 #include "AppenderDB.h"
+#include "../../game/TriniChat/IRCClient.h"
 
 using namespace boost::program_options;
+#include "IRCClient.h"
 
 #ifndef _TRINITY_CORE_CONFIG
     #define _TRINITY_CORE_CONFIG  "worldserver.conf"
@@ -216,6 +218,15 @@ extern int main(int argc, char** argv)
         soapThread = new std::thread(TCSoapThread, sConfigMgr->GetStringDefault("SOAP.IP", "127.0.0.1"), uint16(sConfigMgr->GetIntDefault("SOAP.Port", 7878)));
     }
 
+    // Start up TriniChat
+    boost::thread* triniChatThread = nullptr;
+    if (sIRC->Active == 1)
+    {
+        triniChatThread = new boost::thread(TrinityChatThread);
+    }
+    else
+        TC_LOG_ERROR("misc", "*** TriniChat Is Disabled. *");
+
     // Launch the worldserver listener socket
     uint16 worldPort = uint16(sWorld->getIntConfig(CONFIG_PORT_WORLD));
     std::string worldListener = sConfigMgr->GetStringDefault("BindIP", "0.0.0.0");
@@ -270,6 +281,18 @@ extern int main(int argc, char** argv)
 
     delete raAcceptor;
 
+    // Clean TrinityChat
+    if (triniChatThread != nullptr)
+    {
+        // for some reason on win32 "sIRC->Active && !World::IsStopped()" fail to go false in time and the thread is stalled
+        // so we make sure the condition to live will fail from here, since we are shutting down...
+        sIRC->Active = 0;
+        triniChatThread->join();
+        delete triniChatThread;
+    }
+
+    if (raAcceptor != nullptr)
+        delete raAcceptor;
     ///- Clean database before leaving
     ClearOnlineAccounts();
 
@@ -277,6 +300,7 @@ extern int main(int argc, char** argv)
 
     TC_LOG_INFO("server.worldserver", "Halting process...");
 
+
     ShutdownCLIThread(cliThread);
 
     OpenSSLCrypto::threadsCleanup();
@@ -456,6 +480,17 @@ bool StartDB()
     if (!loader.Load())
         return false;
 
+
+
+
+
+
+
+
+
+
+
+
     ///- Get the realm Id from the configuration file
     realmID = sConfigMgr->GetIntDefault("RealmID", 0);
     if (!realmID)
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index 03d527b..f794293 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -55,6 +55,7 @@ PrepatchGI.Added = 0
 #    AUCTION HOUSE BOT BUYER CONFIG
 #    LOGGING SYSTEM SETTINGS
 #    PACKET SPOOF PROTECTION SETTINGS
+#    VAS AUTOBALANCE OPTIONS
 #
 ###################################################################################################
 
@@ -812,6 +813,13 @@ RecruitAFriend.MaxDifference = 4
 DisableWaterBreath = 4
 
 #
+#    Enable or Disable "Fatigue" timer
+#           default = 1 (enabled)
+#                   = 0 (disabled)
+
+fatigue.enabled = 1
+
+#
 #    AllFlightPaths
 #        Description: Character knows all flight paths (of both factions) after creation.
 #        Default:     0 - (Disabled)
@@ -2503,6 +2511,68 @@ ArenaLog.ExtendedInfo = 0
 
 #
 ###################################################################################################
+# 1V1 ARENA CONFIG
+#
+#     Arena.1v1.Enable
+#         Description: Enable the 1v1 arena.
+#         Default:     0 - (Disabled)
+#                      1 - (Enabled)
+
+Arena.1v1.Enable = 1
+
+#
+#    Arena.1v1.Announcer
+#        Description: Announce 1v1 arena queue status to chat.
+#                      Arena.QueueAnnouncer.Enable must be enabled.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+Arena.1v1.Announcer = 0
+
+#
+#    Arena.1v1.MinLevel
+#        Description: Min level to create an arena team
+#        Default:     80
+
+Arena.1v1.MinLevel = 80
+
+#
+#    Arena.1v1.Costs
+#        Description: Costs for create an arena team
+#        Default:     400000 - (40 gold)
+
+Arena.1v1.Costs = 400000
+
+#
+#    Arena.1v1.VendorRating
+#        Description: If true, 1v1 rating will use to calculate highest personal-rating (extended costs).
+#                      Note: The vendor-item will show as not buyable (red), but players can buy it, if enabled and rating is high enough.
+#        Default:     0 - (false)
+#                      1 - (true)
+
+Arena.1v1.VendorRating = 0
+
+#
+#    Arena.1v1.ArenaPointsMulti
+#        Description: An 5v5 arena team with 1500 rating will gain 344 points per week (blizzlike).
+#                      3v3 with same rating will gain 302 points (5v5points * 0.88)
+#                      2v2 will gain 261 points (5v5points * 0.76)
+#                      and 1v1 will gain 167 points (5v5points * 0.64)
+#                      With this multiplier you can modify the arenapoints for 1v1.
+#        Default:     0.64
+
+Arena.1v1.ArenaPointsMulti = 0.64
+
+#
+#    Arena.1v1.BlockForbiddenTalents
+#        Description: If true, healers can't join 1v1 arena, if they invested more than 35 talentpoints in a healing-talenttree.
+#                      You can also block tanks and other talents, if you modify FORBIDDEN_TALENTS_IN_1V1_ARENA in the npc_arena1v1.h file (hardcoding). See TalentTab.dbc for available talents (you will need an DBC-Editor).
+#        Default:     1 - (true)
+#                      0 - (false)
+
+Arena.1v1.BlockForbiddenTalents = 1
+
+###################################################################################################
 
 ###################################################################################################
 # NETWORK CONFIG
@@ -2640,6 +2710,20 @@ CharDelete.Heroic.MinLevel = 0
 CharDelete.KeepDays = 30
 
 #
+#    External.Mail.Enable
+#        Enable external mail delivery from mail_external table.
+#        Default: 0 (disabled)
+#                 1 (enabled)
+#
+#    External.Mail.Interval
+#        Mail delivery delay time for item sending from mail_external table, in minutes.
+#        Default: 5 minutes
+#
+
+External.Mail.Enable = 1
+External.Mail.Interval = 5
+
+#
 ###################################################################################################
 
 ###################################################################################################
@@ -2933,6 +3017,13 @@ AuctionHouseBot.Alliance.Items.Amount.Ratio = 100
 
 AuctionHouseBot.Horde.Items.Amount.Ratio = 100
 
+#    Armory.Enable
+#        Description: Activates the WowArmory.
+#        Default:     0 - (Disable)
+#                     1 - (Enable)
+
+Armory.Enable = 1
+
 #
 #    AuctionHouseBot.Neutral.Items.Amount.Ratio
 #       Description: Enable/Disable (disabled if 0) the part of AHBot that puts items up for auction on Neutral AH
@@ -3332,6 +3423,8 @@ AuctionHouseBot.Buyer.Recheck.Interval = 20
 #
 ###################################################################################################
 
+
+
 ###################################################################################################
 # LOGGING SYSTEM SETTINGS
 #
@@ -3528,6 +3621,864 @@ PacketSpoof.BanDuration = 86400
 #
 ###################################################################################################
 
+###################################################################################################
+#
+# Custom.SpeedGame
+# Set it to a number upper than 1 to speed up realm timer
+# Default : 1 (Real Time)
+# Example : 60 to force 1scde (real time) = 1 minute (realm timer)
+#
+
+Custom.SpeedGame = 1
+
+#
+# Custom.NoCastTime
+# Set it to 1 to disable cast time
+# Default : 0 (Cast Time Enable)
+#
+
+Custom.NoCastTime = 0
+
+#
+# Custom.HurtInRealTime
+# Set it to 1 to disable autohurt with weapon
+# Default : 0 (Autohurt Enable)
+#
+
+Custom.HurtInRealTime = 0
+
+#
+###################################################################################################
+
+###################################################################################################
+#
+# Custom.FastFishing
+# Set it to 1 to make fishing a lot faster!
+# Default : 0 (Fishing is normal)
+#
+
+Custom.FastFishing = 0
+
+#
+###################################################################################################
+
+###################################################################################################
+#
+# Custom.RespawnSpeed
+# Set it to a number upper than 1 to speed up the respawn of mobs (and lower than 1 to slow down).
+# Default : 1.0 (Normal speed)
+#
+
+Custom.RespawnSpeed = 1.0
+
+#
+###################################################################################################
+
+#
+# Custom.AttackSpeedForPlayer
+# Set it to a number upper than 1 to speed up the attack of the player
+# Default : 1.0 (Normal speed)
+# Example : 2.0 (Player attack speed is 200% faster)
+#
+
+Custom.AttackSpeedForPlayer = 1.0
+
+#
+# Custom.AttackSpeedForMobs
+# Set it to a number upper than 1 to speed up the attack of the mobs
+# Default : 1.0 (Normal speed)
+# Example : 0.5 (Mobs attack speed is 50% slower)
+#
+
+Custom.AttackSpeedForMobs = 1.0
+
+#
+###################################################################################################
+
+###################################################################################################
+#
+# Custom.GainHonorOnGuardKill
+# Set it to 1 to gain honor when you kill a guard.
+# Note that not all city guards will give you honor. It seems only capital and big city guards are flagged
+# as so in the database.
+# Default : 0 (No honor when you kill a guard)
+#
+
+Custom.GainHonorOnGuardKill = 0
+
+#
+# Custom.GainHonorOnEliteKill
+# Set it to 1 to gain honor when you kill an elite mob (this does not apply on rare mob, unless he is also elite).
+# Default : 0 (No honor when you kill an elite mob)
+#
+
+Custom.GainHonorOnEliteKill = 0
+
+#
+###################################################################################################
+#
+
+PlayedTimeReward.Interval = 0
+PlayedTimeReward.Money    = 0
+PlayedTimeReward.Honor    = 0
+PlayedTimeReward.Arena    = 0
+
+#
+###################################################################################################
+
+# Start Guild
+#
+# These settings set all new characters into a starting guild based on faction.
+#
+#    StartGuild.Alliance
+#        Description: Guild entry number for Alliance(Taken from guildid field in characters.guild table)
+#        Default: 45 (Default guildid)
+#                 1+ (guildid entry)
+#
+
+StartGuild.Alliance = 45
+
+#
+#    StartGuild.Horde
+#        Description: Guild entry number for Horde (Taken from guildid field in characters.guild table)
+#        Default: 46 (Default guildid)
+#                 1+ (guildid entry)
+
+#
+
+StartGuild.Horde = 46
+
+#
+###################################################################################################
+
+###################################################################################################
+# GuildHouse
+#
+# Settings for the GuildHouse Keeper.
+#
+#    Guildhouse.TokenOrGold
+#        Description: Use tokens or money to buy guild houses.
+#        Default:     0 - Use Money
+#                     1 - Use Token
+#
+
+Guildhouse.TokenOrGold = 0
+
+#    GuildHouse.BuyCost
+#        Description: Amount of gold or quantity of tokens to buy guildhouse.
+#        Default:     1000 - 1000 gold
+#
+
+Guildhouse.BuyCost = 1000
+
+#    GuildHouse.BuyCost
+#        Description: Amount of gold or quantity of tokens gained when selling guildhouse.
+#        Default:     5000000 - 500 gold
+#
+
+Guildhouse.SellCost = 500
+
+#
+###################################################################################################
+
+###################################################################################################
+#
+# BeastMaster Configuration
+#
+# BeastMaster Hunter Only
+#                 = 0 (Anyone can use)
+#         default = 1 (Hunter only)
+
+BeastMaster.OnlyHunter = 1
+
+#
+# BeastMaster Enable Normal Pets
+#                 = 0  (Normal pets disabled)
+#         default = 1  (Normal Pets enabled)
+#
+
+BeastMaster.EnableNormalPet = 1
+
+#
+# BeastMaster Enable Exotic Pets
+#                 = 0  (Anyone Can get Exotic pets)
+#         default = 1  (Can only get Exotic Pets if you know how)
+#
+
+BeastMaster.EnableExoticPet = 1
+
+#
+###################################################################################################
+
+###################################################################################################
+#    Level NPC
+###################################################################################################
+
+LevelNPC.OnlyGMs = 0
+LevelNPC.EnableLevel80 = 1
+LevelNPC.EnableLevel100 = 1
+LevelNPC.EnableLevel150 = 1
+LevelNPC.EnableLevel200 = 0
+LevelNPC.EnableLevel255 = 0
+LevelNPC.UseTokens = 0
+LevelNPC.ItemEntryNum = 99999
+LevelNPC.SkillGoldCost = 10
+
+#
+###################################################################################################
+
+###################################################################################################
+#
+# NPC Buff rewritten by LordPsyan
+#
+#        GM Only
+#         Default 0 = Any Player
+#                 1 = GM1 or higher
+
+Npc_Buff.OnlyGMs = 0
+
+#     Enables Small Buff
+#         Default 0 = Disable
+#                 1 = Enable
+
+Npc_Buff.EnableSmallBuff = 1
+
+#     Enables Geat Buff
+#         Default 0 = Disable
+#                 1 = Enable
+
+Npc_Buff.EnableGreatBuff = 1
+
+#     Enables GM Only Buff
+#         Default 0 = Disable
+#                 1 = Enable
+
+Npc_Buff.EnableGMBuff = 1
+
+#     Enables Player Tools
+#         Default 0 = Disable
+#                 1 = Enable
+
+Npc_Buff.EnablePlayerTools = 1
+
+#     Enables Remove Res Sickness
+#         Default 0 = Disable
+#                 1 = Enable
+
+Npc_Buff.EnableRemoveResSickness = 1
+
+#
+###################################################################################################
+
+###################################################################################################
+#
+#       Profession NPC
+#
+# Enable or Disable Primary Professions
+#         default = 1 (Enabled)
+#                   = 0 (Disabled)
+
+ProfessionNPC.EnableProfessions = 1
+
+# Enable or Disable Secondary Professions
+#         default = 1 (Enabled)
+#                   = 0 (Disabled)
+
+ProfessionNPC.EnableSecondarySkills = 1
+
+# Number of Skill points
+#         default = 10
+
+SkillPoints = 10
+
+# GM Only
+#         default = 0 (Anyone can use)
+#                   = 1 (GM only)
+
+ProfessionNPC.OnlyGMs = 0
+
+# Cost of skill points (in copper)
+#         default = 10000 (10 gold)
+
+SkillGoldCost = 10000
+
+# Use Tokens instead of gold
+#         default = 0 (Use Gold)
+#                 = 1 (Use Tokens)
+
+ProfessionNPC.UseTokens = 1
+
+# Entry number of "token" Item
+#         default = 0 (No item. ProfessionNPC.UseTokens must = 0)
+#                 = n (n = entry number of item)
+
+ProfessionNPC.ItemEntryNum = 99999
+
+#
+###################################################################################################
+#
+# VAS AUTOBALANCE OPTIONS
+#
+#     VAS.AutoBalance.XPlayer
+#        Set Server to level of solo mode.
+#        Set to 0 to Disable VAS-SOLO Mod.
+#        Example: VAS.AutoBalance.XPlayer = 1 will set everything for a 1 player game.
+#        Default:     1
+
+VAS.AutoBalance.XPlayer = 1
+
+#
+#     VAS.AutoBalance.AutoInstance
+#        Set instances to Auto chance XPlayer depending on players in it.
+#        Default:     1 (1 = ON, 0 = OFF)
+
+VAS.AutoBalance.AutoInstance = 1
+
+#
+#     VAS.AutoBalance.Debug
+#        0 = None
+#        1 = Errors Only
+#        2 = Errors and Basic Information
+#        3 = All VAS Info
+#        Default:     1
+
+VAS.AutoBalance.Debug = 2
+
+#
+#     VAS.AutoBalance.PlayerChangeNotify
+#        Set Auto Notifications to all players in Instance that player count has changed.
+#        Default:     1 (1 = ON, 0 = OFF)
+
+VAS.AutoBalance.PlayerChangeNotify = 1
+
+#
+#     VAS.AutoBalance.Color
+#        In Game Color for mod information in chat window.
+#        Default:     cffFF8000 (Orange)
+
+VAS.AutoBalance.Color = cffFF8000
+
+#
+#     Min.HP.Mod
+#        Minimum Modifier setting for Health Modification
+#        Default:     0.20
+
+Min.HP.Mod = 0.20
+
+#
+#     Min.D.Mod
+#        Minimum Modifier setting for Damage Modification
+#        Default:     0.10
+
+Min.D.Mod = 0.10
+
+#
+#     VAS.AutoBalance.XX.Name
+#        Sets MobIDs for the group they belong to.
+#        All 5 Man Mobs should go in VAS.AutoBalance.5.Name
+#        All 10 Man Mobs should go in VAS.AutoBalance.10.Name etc.
+
+VAS.AutoBalance.40.Name = "11583,16441,30057,13020,15589,14435,18192,14889,14888,14887,14890,15302,15818,15742,15741,15740,18338"
+VAS.AutoBalance.25.Name = "22997,21966,21965,21964,21806,21215,21845,19728,12397,17711,18256,18192,"
+VAS.AutoBalance.10.Name = "15689,15550,16152,17521,17225,16028,29324,31099"
+VAS.AutoBalance.5.Name = "15203,15204,15205,15305,6109,26801,30508,26799,30495,26803,30497,27859,27249"
+VAS.AutoBalance.2.Name = "25549,24558,25574,24559,25556,25557,25578,24561,25555,24555,25541,24553,25550,24554,24552,25564,15931,29373"
+
+
+#
+###################################################################################################
+
+###################################################################################################
+#    Transmogrification config
+###################################################################################################
+#
+#    SETTINGS
+#
+#    Logger.custom.transmog
+#        Description: Transmogrification logging setting, see logger settings
+#        Default:    3, Console Server
+#
+#    Transmogrification.EnableTransmogInfo
+#        Description: Enables / Disables the info button for transmogrification
+#        Default:    1
+#
+#    Transmogrification.TransmogNpcText
+#        Description: The npc_text entry of the info menu for transmogrification
+#        Default:    50000
+#
+#    Transmogrification.Allowed
+#        Description: A list of item entries that are allowed for transmogrification (skips quality and CanUseItem check)
+#                     Example: "25 35674 5623"
+#        Default:    ""
+#
+#    Transmogrification.NotAllowed
+#        Description: A list of item entries that are NOT allowed for transmogrification
+#                     Example: "25 35674 5623"
+#        Default:    ""
+
+Logger.custom.transmog = 3, Console Server
+
+Transmogrification.EnableTransmogInfo = 1
+Transmogrification.TransmogNpcText = 50000
+
+Transmogrification.Allowed = ""
+Transmogrification.NotAllowed = ""
+
+#
+#    COPPER COST
+#
+#    Transmogrification.ScaledCostModifier
+#        Description: A multiplier for the default gold cost (change to 0 for no default cost)
+#        Default:    1.0
+#
+#    Transmogrification.CopperCost
+#        Description: Cost added on top of other costs (can be negative)
+#        Default:    0
+#
+#    For custom gold cost set ScaledCostModifier to 0.0 and CopperCost to what ever cost you want
+
+Transmogrification.ScaledCostModifier = 1.0
+Transmogrification.CopperCost = 0
+
+#
+#    TOKEN COST
+#
+#    Transmogrification.RequireToken
+#        Description: Adds/disables token cost
+#        Default:    0
+#
+#    Transmogrification.TokenEntry
+#        Description: Entry of the token item
+#        Default:    49426
+#
+#    Transmogrification.TokenAmount
+#        Description: Amount of tokens required
+#        Default:    1
+
+Transmogrification.RequireToken = 0
+Transmogrification.TokenEntry = 49426
+Transmogrification.TokenAmount = 1
+
+#
+#    REQUIREMENTS
+#
+#    Transmogrification.AllowPoor
+#        Description: Allow poor quality items to be used as source and target items
+#        Default:    0
+#
+#    Transmogrification.AllowCommon
+#        Description: Allow common quality items to be used as source and target items
+#        Default:    0
+#
+#    Transmogrification.AllowUncommon
+#        Description: Allow uncommon quality items to be used as source and target items
+#        Default:    1
+#
+#    Transmogrification.AllowRare
+#        Description: Allow rare quality items to be used as source and target items
+#        Default:    1
+#
+#    Transmogrification.AllowEpic
+#        Description: Allow epic quality items to be used as source and target items
+#        Default:    1
+#
+#    Transmogrification.AllowLegendary
+#        Description: Allow legendary quality items to be used as source and target items
+#        Default:    0
+#
+#    Transmogrification.AllowArtifact
+#        Description: Allow artifact quality items to be used as source and target items
+#        Default:    0
+#
+#    Transmogrification.AllowHeirloom
+#        Description: Allow heirloom quality items to be used as source and target items
+#        Default:    1
+#
+#    Transmogrification.AllowMixedArmorTypes
+#        Description: Allow cloth items to be transmogrified with plate for example
+#        Default:    0
+#
+#    Transmogrification.AllowMixedWeaponTypes
+#        Description: Allow axe to be transmogrified with dagger for example
+#        Default:    0
+#
+#    Transmogrification.AllowFishingPoles
+#        Description: Allow fishing poles to be transmogrified
+#        Default:    0
+#
+#    Transmogrification.IgnoreReqRace
+#        Description: Ignore required race for source items
+#        Default:    0
+#
+#    Transmogrification.IgnoreReqClass
+#        Description: Ignore required class for source items
+#        Default:    0
+#
+#    Transmogrification.IgnoreReqSkill
+#        Description: Ignore required skill for source items
+#        Default:    0
+#
+#    Transmogrification.IgnoreReqSpell
+#        Description: Ignore required spell for source items
+#        Default:    0
+#
+#    Transmogrification.IgnoreReqLevel
+#        Description: Ignore required level for source items
+#        Default:    0
+#
+#    Transmogrification.IgnoreReqEvent
+#        Description: Ignore required event for source items
+#        Default:    0
+#
+#    Transmogrification.IgnoreReqStats
+#        Description: Ignore stat count > 0 requirement for source items
+#        Default:    0
+
+Transmogrification.AllowPoor = 0
+Transmogrification.AllowCommon = 0
+Transmogrification.AllowUncommon = 1
+Transmogrification.AllowRare = 1
+Transmogrification.AllowEpic = 1
+Transmogrification.AllowLegendary = 0
+Transmogrification.AllowArtifact = 0
+Transmogrification.AllowHeirloom = 1
+
+Transmogrification.AllowMixedArmorTypes = 0
+Transmogrification.AllowMixedWeaponTypes = 0
+Transmogrification.AllowFishingPoles = 0
+
+Transmogrification.IgnoreReqRace = 0
+Transmogrification.IgnoreReqClass = 0
+Transmogrification.IgnoreReqSkill = 0
+Transmogrification.IgnoreReqSpell = 0
+Transmogrification.IgnoreReqLevel = 0
+Transmogrification.IgnoreReqEvent = 0
+Transmogrification.IgnoreReqStats = 0
+
+#
+#    SET FEATURE
+#
+#    Transmogrification.EnableSets
+#        Description: Enables / Disables the set feature. If you want permanent disable, check Transmogrification.h
+#        Default:    1
+#
+#    Transmogrification.MaxSets
+#        Description: Maximum amount of sets a player can save (hardcap at 25)
+#        Default:    10
+#
+#    Transmogrification.EnableSetInfo
+#        Description: Enables / Disables the info button for set fature
+#        Default:    1
+#
+#    Transmogrification.SetNpcText
+#        Description: The npc_text entry of the info menu for the set feature
+#        Default:    50001
+#
+#    Transmogrification.SetCostModifier
+#        Description: A multiplier for the default gold cost (all costs summed together) (change to 0 for no default cost)
+#        Default:    3.0
+#
+#    Transmogrification.SetCopperCost
+#        Description: Cost added on top of other costs (can be negative)
+#        Default:    0
+
+Transmogrification.EnableSets = 1
+Transmogrification.MaxSets = 10
+
+Transmogrification.EnableSetInfo = 1
+Transmogrification.SetNpcText = 50001
+
+Transmogrification.SetCostModifier = 3.0
+Transmogrification.SetCopperCost = 0
+
+#
+###################################################################################################
+
+###################################################################################################
+#
+# CROSSFACTION SYSTEM
+#
+#    CrossFactionSystem.Battlegrounds = 1 - Mixed battleground enabled.
+#    CrossFactionSystem.Battlegrounds = 0 - Mixed battleground disabled.
+
+CrossFactionSystem.Battlegrounds = 1
+
+#
+###################################################################################################
+
+#########################################################
+# TriniChat IRC BOT For Trinity Core Configuration File #
+#########################################################
+# irc.active
+# Enable TriniChat Addon
+# Default: 1 - Enable
+# 0 - Disable
+#
+irc.active = 1
+
+##################################################
+# irc.icc
+# IRC connect code
+# Default: 001 - Welcome To Network msg
+# 375 - Beginning Of MOTD
+# 376 - End Of MOTD
+#
+irc.icc = 001
+
+##################################################
+# irc.host
+# IRC server to have TriniChat connect to
+#
+irc.host = "irc.xxxx.net"
+
+##################################################
+# irc.port
+# IRC server port to use
+#
+irc.port = "1337"
+
+##################################################
+# irc.user
+# The username to have TriniChat use to connect to the IRC server
+# irc.nick
+# IRC nickname to be used by the bot
+# irc.pass
+# The password to be used to identify to NickServ (IRC NickName Enforcement Services)
+#
+irc.user = "Trini_Chat"
+irc.nick = "Trini_Chat"
+irc.pass = "ServicesPass"
+
+##################################################
+# irc.auth
+# IRC Authentication Method
+# Default: 0 - Disable
+# 1 - NickServ - Normal Method - PRIVMSG NickServ :IDENTIFY Password
+# 2 - NickServ - Alternate Method To Identify To A Different Nick - PRIVMSG NickServ :IDENTIFY irc.auth.nick Password
+# 3 - QuakeNet - Normal Method - PRIVMSG Q@CServe.quakenet.org :AUTH irc.nick Password
+# 4 - QuakeNet - Alternate Method To Identify To A Different Nick - PRIVMSG Q@CServe.quakenet.org :AUTH irc.auth.nick Password
+# irc.auth.nick
+# IRC Nickname to use if Auth method 2 or 4 is used
+#
+irc.auth = 0
+irc.auth.nick = "AuthNick"
+
+##################################################
+# irc.ldef
+# Leave a defined IRC channel on server connect
+# Default: 0 - Disable
+# 1 - Enable
+# irc.defchan
+# IRC channel to leave on server connect if irc.ldef is on
+#
+irc.ldef = 0
+irc.defchan = "lobby"
+
+##################################################
+# irc.wct
+# Time to wait before (re)attemptimg connection to IRC server
+# Default: 30000 - (30 Seconds)
+# irc.maxattempt
+# Maximum attempts to try IRC server
+# Default: 20
+#
+irc.wct = 30000
+irc.maxattempt = 20
+
+##################################################
+# irc.auto.announce
+# Time to wait in Minutes to announce random messages from database.
+# Default: 30 - (30 Minutes)
+#
+irc.auto.announce = 30
+
+##################################################
+# irc.autojoin_kick
+# Autojoin IRC channel if kicked
+# Default: 1 - Enable
+# 0 - Disable
+#
+irc.autojoin_kick = 1
+
+##################################################
+# irc.command_prefix
+# IRC command prefix
+# Example: (.)online all
+#
+irc.command_prefix = "\"
+
+##################################################
+# irc.joinmsg
+# irc.rstmsg
+# irc.kickmsg
+# TriniChat bot join/restart/kick messages
+#
+irc.joinmsg = "Trinity Core With TriniChat $Ver Is Up And Running! Command Trigger Is: $Trigger"
+irc.rstmsg = "TriniChat Is Restarting, I Will Be Right Back."
+irc.kickmsg = "Do Not Kick Me Again, Severe Actions Will Be Taken!"
+
+##################################################
+# irc.chan_#
+# wow.chan_#
+# IRC and WOW channels to link. Leave # out of IRC channel. Both channels _ARE_ case sensitive
+# NOTE: you can have more than 1 IRC channel linked to wow channels, as in example:
+# Example: irc.chan_1 = "Trinity"
+# irc.chan_2 = "trinity2"
+# wow.chan_1 = "world"
+# wow.chan_2 = "LookingForGroup"
+# irc.pass_#
+# Passwords for said IRC channels (IRC server side)
+# Example:
+# irc.pass_1 = "password" password for irc channel #1
+# irc.pass_2 = "password2" password for irc channel #2
+irc.chan_1 = "ircchan"
+wow.chan_1 = "world"
+irc.pass_1 = "pass"
+
+##################################################
+# irc.staff_link
+# if set to 1 will link gm name announce to irc channel
+# Default: 0
+# irc.staff_chan
+# Print IRC messages to GM Name Announce and Gm Name Announce to IRC Channel
+# Default: "staff"
+# irc.ignore_bots
+# enter nicks of bots to ignore seprated by commas
+# Default: ""
+#
+irc.staff_link = 0
+irc.staff_chan = "staff"
+irc.ignore_bots = ""
+
+##################################################
+# irc.StatusChannel
+# Channel Name To Display Status Messages In (AuctionHouse, Levels, Deaths, Etc)
+# Default: ""
+# irc.AnnounceChannel
+# Channel Name To Display Announcements In (Announces, Notifies, Event)
+# Default: ""
+# irc.Tickets
+# Channel Name To Display Ticket Announcment in (Create, Edit, Closed, lag Reports)
+# Default: ""
+# Note: Botmask : Enable Ticket Announment must be activ
+#
+irc.StatusChannel = ""
+irc.StatusChannelPW = ""
+irc.AnnounceChannel = ""
+irc.AnnounceChannelPW = ""
+irc.Tickets = ""
+irc.TicketsPW = ""
+
+##################################################
+# irc.op_gm_login
+# Op The GM In All Channels The Bot Is On When They Log In To TriniChat
+# Default: 0 - Disable
+# 1 - Enable
+# irc.op_gm_level
+# The Minimum GM Level Required To Have The Bot Op The User
+# Default: 3 - GM Level 3
+#
+irc.op_gm_login = 0
+irc.op_gm_level = 3
+
+##################################################
+# irc.ajoin (Experimental/Under Development)
+# Force players to autojoin a WOW in game channel
+# Atleast one player must be in the channel on server start, and atleast one person online for invite to work
+# Default: 0 - Disable
+# 1 - Enable
+# irc.ajchan
+# Channel to join if above is Enabled.
+#
+irc.ajoin = 1
+irc.ajchan = "world"
+
+##################################################
+# irc.online.result
+# Maximum number of results per line for the online command
+#
+irc.online.result = 30
+
+##################################################
+# chat.*** (Defineable Strings) (maybe more in future)
+# wow_* - String is displayed in IRC channel
+# irc_* - String is displayed in WOW channel
+# Options: $Name, $Level, $Class, $Msg, $GM (not all options work in every string)
+#
+chat.wow_irc = "<WoW>[$Name($Level)[$Class]] $Msg"
+chat.irc_wow = "<IRC>[$Name]: $Msg"
+chat.join_wow = "12>>04 $GM$Name Joined The $Channel Channel!"
+chat.join_irc = "[$Name]: Has Joined IRC!"
+chat.leave_wow = "12<<04 $GM$Name Left The $Channel Channel!"
+chat.leave_irc = "[$Name]: Has Left IRC!"
+chat.change_nick = "<> $Name Is Now Known As $NewName!"
+
+##################################################
+# Botmask
+# This defines what the bot announces, if its 0 everything is disabled
+# simply add the values of the elements you want to create this mask.
+# Example: WoW join/leaves are 1 and IRC join/leaves are 2, if you want both of these active then the BotMask is 3.
+# (1)Display WoW Chan Join/Leaves In IRC
+# (2)Display IRC Chan Join/Leaves/NickChanges In WoW
+# (4)Display Unknown Command Message When Trigger Is Used And No Command Exists
+# (8)Announce Security Level > 0 As GM At Login
+# (16)Announce GM In GM ON State AS GM At Login
+# (32)Return Errors To Notice. (If disabled then default is Private Message)
+# (64)Display WoW Status Messages (Levels/Deaths)
+# (128)Display Nick Changes From IRC In WOW
+# (256)Display WoW Announces/Notifies In IRC
+# (512)Do Not Let Players Use Commands On Higher GM Level Players
+# (1024)Enable AuctionHouse Announcements !!DISSABLED!!
+#
+Botmask = 1023
+
+##################################################
+# irc.gmlog
+# Minimum GM level to not show login/pass info in IRC logs
+# irc.logfile.prefix
+# The prefix of the IRC logfile. Directories can be added here.
+# Example: "IRC/IRC_" outputs IRC_YYYY-MM-DD.log to the IRC subdirectory in your logs dir
+# irc.logchannel
+# Specefies the channel where logged output gets broadcasted.
+# Default: "" (none)
+# irc.logchannelpw
+# The password for the log channel.
+# irc.logmask
+# Bitmask, see Botmask for explanation. Determines what gets logged to the logchannel.
+# (0) Do not broadcast into logchannel.
+# (1) Broadcast IRC Commands into logchannel.
+# (2) Broadcast Ingame GM Commands into logchannel.
+# (3) Broadcast both IRC Commands and GM Commands into logchannel.
+irc.gmlog = 1
+irc.logfile.prefix = "IRC_"
+irc.logchannel = "testlog"
+irc.logchannelpw = ""
+irc.logmask = 3
+
+##################################################
+# irc.fun.games (Experimental/Under Development)
+# Enable TriniChat Games
+# Default: 0 - Disable
+# 1 - Enable
+#
+irc.fun.games = 0
+
+##################################################
+# irc.gm#
+# GM tag to append to (GM onjoin / online command) IRC color codes are acceptable
+#
+irc.gm1 = "[VIP]"
+irc.gm2 = "[Donator]"
+irc.gm3 = "[Bug Tracker]"
+irc.gm4 = "[Moderator]"
+irc.gm5 = "[Game Master]"
+irc.gm6 = "[Admin]"
+irc.gm7 = "[Developer]"
+irc.gm8 = "[Owner]"
+
+#
+###################################################################################################
+
 #
 # Prepatch by LordPsyan.
 # See http://www.realmsofwarcraft.com/bb for forums and information.
-- 
2.1.4

